[{"title":"UnCrackable-Level2分析","url":"/2025/05/18/UnCrackable-Level2%E5%88%86%E6%9E%90/","content":"UnCrackable-Level2.apk直接安装+打开，又是解密。\n\n\n搜索Nope，定位到this.m.a(s)。\n\n\n在类MainActivity中，有一个私有对象m，m属于类CodeCheck，调用了函数a，最后调用了native层函数bar。\n\n\nnative层需要ida进行静态分析，这里将apk进行解压，取出其中的arm64架构的so库放入ida中，可以看到两个导出函数。\nJava_包名_类名_函数名，可以看出bar就是我们要找的函数。\n\n一眼看出，v7对应的字符串就是正确的secret。\n\n\n再看看导出的init函数，这里ida并没有给出JNIEnv和jobect，应该是反编译失误——这俩参数没用到，可能被优化了。\n\n\n在sub_918中，可以发现：fork出子进程，然后子进程通过ptrace附加到父进程，使得父进程无法其它调试器被再次附加，一个反调试技术。\n\n\nFrida通过Interceptor模块，可以支持对Native层函数的hook。\n下面这个脚本，先通过Module.findBaseAddress找到so模块的基地址，然后通过导出表符号Java_sg_vantagepoint_uncrackable2_MainActivity_init，找到它的函数地址，然后根据在文件中计算的文件偏移量，计算出要hook的无符号函数的地址。\nJava.perform(() =&gt; &#123;    const LIB_NAME = &#x27;libfoo.so&#x27;;    const EXPORT_SYMBOL = &#x27;Java_sg_vantagepoint_uncrackable2_MainActivity_init&#x27;;    const OFFSET = ptr(-1140);    function tryHook() &#123;        // 获得模块基地址        const moduleBase = Module.findBaseAddress(LIB_NAME);        if (!moduleBase) &#123;            console.log(`[!] $&#123;LIB_NAME&#125; 未加载，等待...`);            setTimeout(tryHook, 1000); // 每秒检查一次            return;        &#125;        console.log(`[+] 模块基地址: $&#123;moduleBase&#125;`);        // 通过符号名获得函数实际地址        const exportAddress = Module.getExportByName(LIB_NAME, EXPORT_SYMBOL);        if (!exportAddress) &#123;            console.error(`[!] 未找到导出函数 $&#123;EXPORT_SYMBOL&#125;`);            return;        &#125;        console.log(`[+] 导出函数地址: $&#123;exportAddress&#125;`);\t\t        // 根据偏移计算目标地址        const targetAddress = exportAddress.add(OFFSET);        console.log(`[+] 目标函数地址: $&#123;targetAddress&#125;`);        // 打印目标地址的前5个字节        const bytes = Memory.readByteArray(targetAddress, 5);        const byteArray = new Uint8Array(bytes);        const hexBytes = Array.from(byteArray).map(b =&gt; b.toString(16).padStart(2, &#x27;0&#x27;)).join(&#x27; &#x27;);        console.log(`[+] 前5个字节: $&#123;hexBytes&#125;`);        Interceptor.attach(targetAddress, &#123;            onEnter: function(args) &#123;                console.log(`\\n=== 函数调用开始 ===`);                if (Process.arch === &#x27;arm64&#x27;) &#123;                    console.log(`X0: $&#123;args[0]&#125;, X1: $&#123;args[1]&#125;, X2: $&#123;args[2]&#125;`);                &#125; else &#123;                    console.log(`R0: $&#123;args[0]&#125;, R1: $&#123;args[1]&#125;, R2: $&#123;args[2]&#125;`);                &#125;            &#125;,            onLeave: function(retval) &#123;                console.log(`返回值: $&#123;retval&#125;`);                console.log(`=== 函数调用结束 ===\\n`);            &#125;        &#125;);        console.log(`[√] Hook 安装成功`);    &#125;    setTimeout(tryHook, 1000); // 延迟1秒开始检查&#125;);\n\n然而还不够，即便hook住了这个函数，但这个函数早已经在MainActivity.onCreate阶段执行了，hook了也没用，因为已经执行过了一遍。\n针对执行时机的问题，有以下解决方法：\n1.使用spawn模式，默认的frida -U -f是“fork-and-attach”模式，可能错过早期逻辑。使用“spawn”模式可以在应用进程创建时注入Frida。\n如：frida -U -l script.js –no-pause -f com.example.app –spawn\n–spawn: 在进程创建时注入，而不是附加到已有进程。\n2.hook系统类System，然后对loadLibrary做手脚，如果加载的是其它库，不做处理；如果加载的是foo.so，则立马进行覆盖。这个hook的时机发生在静态初始化块执行之前。\nJava.perform(() =&gt; &#123;    const LIB_NAME = &#x27;libfoo.so&#x27;;    const EXPORT_SYMBOL = &#x27;Java_sg_vantagepoint_uncrackable2_MainActivity_init&#x27;;    const OFFSET = ptr(-1140);    // Hook System.loadLibrary    Java.use(&#x27;java.lang.System&#x27;).loadLibrary.implementation = function(libName) &#123;        console.log(`[+] 加载库: $&#123;libName&#125;`);        this.loadLibrary(libName); // 调用原始方法        if (libName === &#x27;foo&#x27;) &#123;            const moduleBase = Module.findBaseAddress(LIB_NAME);            if (!moduleBase) return;            const exportAddress = Module.getExportByName(LIB_NAME, EXPORT_SYMBOL);            const targetAddress = exportAddress.add(OFFSET);            Interceptor.replace(targetAddress, new NativeCallback(function() &#123;                console.log(`sub_918 被调用并覆盖`);                return 42;            &#125;, &#x27;int64&#x27;, []));            console.log(`[√] sub_918 已替换`);        &#125;    &#125;;&#125;);\n\n3.Hook MainActivity.onCreat。\n所以接下来这段脚本执行时机如下，在静态初始化块执行后（System.loadLibrary导入libfoo.so），在onCreate执行前（调用Java_sg_vantagepoint_uncrackable2_MainActivity_init之前），hook了类MainActivity，然后在它执行前，将sub_918的内容做了替换。\nJava.perform(() =&gt; &#123;    const LIB_NAME = &#x27;libfoo.so&#x27;;    const EXPORT_SYMBOL = &#x27;Java_sg_vantagepoint_uncrackable2_MainActivity_init&#x27;;    const OFFSET = ptr(-1140);    const MainActivity = Java.use(&#x27;sg.vantagepoint.uncrackable2.MainActivity&#x27;);    MainActivity.onCreate.implementation = function(savedInstanceState) &#123;        console.log(&#x27;[+] MainActivity.onCreate 被调用&#x27;);        // 在 onCreate 执行前替换 sub_918        const moduleBase = Module.findBaseAddress(LIB_NAME);        if (moduleBase) &#123;            const exportAddress = Module.getExportByName(LIB_NAME, EXPORT_SYMBOL);            const targetAddress = exportAddress.add(OFFSET);            Interceptor.replace(targetAddress, new NativeCallback(function() &#123;                console.log(`sub_918 被调用并覆盖`);                return 42;            &#125;, &#x27;int64&#x27;, []));            console.log(`[√] sub_918 已替换`);        &#125;        // 调用原始 onCreate        this.onCreate(savedInstanceState);    &#125;;&#125;);\n\n下图是安卓的初始化过程以及注入时机。\n\n\n\n\n之后尝试一下hook是否执行成功，先将脚本断掉，直接通过jeb调试进程。\n\n\n再试试通过frida进行hook后，能否attach上去调试。\n\n\n确实是attach上去了，但是手机上显示被检测到了调试，根据字符串搜索，发现问题来自于下图。\n\n\n有一个持续检测的进程，阿这，这么防着咱。。。\n只需要hook Debug.isDebuggerConnected()即可，让它一直返回false，这里就不写了。\n"},{"title":"UnCrackable-Level1分析","url":"/2025/05/18/UnCrackable-Level1%E5%88%86%E6%9E%90/","content":"UnCrackable-Level1.apk下载并安装，打开；一上来就被检测出root权限了。\n\n\n将apk丢入jeb中查看，通过ctrl + f搜索字符串。\n\n\nc.a()、c.b()、c.c()的逻辑如下图，我发现，在我的&#x2F;system&#x2F;bin中，确实有一个su。\n\n\n方案1，粗暴的解决方案，修改dex文件并重新签名。在onCreate的第一个if处，将判断结果改成false；\nJava.perform(function()&#123;  const root = Java.use(&quot;sg.vantagepoint.util.RootDetection&quot;);\troot.checkRoot1.implementation = function()&#123;\t\treturn false;\t&#125;\troot.checkRoot2.implementation = function()&#123;\t\treturn false;\t&#125;\troot.checkRoot3.implementation = function()&#123;\t\treturn false;\t&#125;&#125;);\n\n方案2，hook掉exit函数或者hook掉相关函数；\n方案3，面具magisk里直接屏蔽掉UnCrackable-Level1.apk的root权限，让它检测不到root。\n这里介绍一下第二个方法，js脚本如下，执行方法也如下，然后就绕过去了。\n# frida -U -f owasp.mstg.uncrackable1 -l .\\uncrackable-level1.jsJava.perform(function()&#123;    var temp = Java.use(&quot;java.lang.System&quot;); # 获得System类    # exit是静态函数，不需要实例化后再调用    # overload指定具体的重载版本    temp.exit.overload(&#x27;int&#x27;).implementation = function(arg0)&#123;        console.log(&quot;Exit called with &quot; + arg0);    &#125;;&#125;);\n\n\n通过jeb，可以发现在类a中，函数a会根据输入的内容进行比较，随后得出是否正确的答案。\n\n下面是写的一个js脚本，直接return true，或者通过sg.vantagepoint.a.a.a得到解密的明文。\n# 直接改为trueJava.perform(function() &#123;    // 获取目标类    var targetClass = Java.use(&#x27;sg.vantagepoint.uncrackable1.a&#x27;);        // Hook 静态方法 a(String)    targetClass.a.overload(&#x27;java.lang.String&#x27;).implementation = function(s) &#123;        console.log(&quot;\\n[*] 拦截验证方法调用&quot;);                // 打印原始输入        console.log(&quot;原始输入: &quot; + s);                // 调用原始方法获取结果        var result = this.a(s); // [!code focus]                // 打印原始验证结果        console.log(&quot;原始验证结果: &quot; + result);                // 强制返回 true（绕过验证）        console.log(&quot;[+] 强制返回 true&quot;);        return true;                // 若需保留原始逻辑，直接返回 result        // return result;    &#125;;&#125;);# 观察正确的输入Java.perform(function() &#123;    // 获取加密工具类    var crypto = Java.use(&#x27;sg.vantagepoint.a.a&#x27;);        // 获取验证类    var checker = Java.use(&#x27;sg.vantagepoint.uncrackable1.a&#x27;);        // Hook a() 方法获取密钥和密文    checker.a.overload(&#x27;java.lang.String&#x27;).implementation = function(s) &#123;        // 原始密文（Base64）        var ciphertext_b64 = &quot;5UJiFctbmgbDoLXmpL12mkno8HT4Lv8dlat8FxR2GOc=&quot;;                // 硬编码密钥（处理负数为无符号字节）        var key_bytes = [0x8D, 0x12, 0x76, 0x84, 0xCB, 0xC3, 0x7C, 0x17,                          0x61, 0x6D, 0x80, 0x6C, 0xF5, 0x04, 0x73, 0xCC];                // 将密钥转换为 Java byte[]        var jKey = Java.array(&#x27;byte&#x27;, key_bytes);                // Base64 解码密文        var ciphertext = Java.use(&#x27;android.util.Base64&#x27;).decode(ciphertext_b64, 0);                try &#123;            // 调用解密方法            var decrypted_bytes = crypto.a(jKey, ciphertext);                        // 转换为字符串            var plaintext = Java.use(&#x27;java.lang.String&#x27;).$new(decrypted_bytes);            console.log(&quot;\\n[+] 解密成功！Secret String: &quot; + plaintext);        &#125; catch(e) &#123;            console.log(&quot;[-] 解密失败: &quot; + e);        &#125;                // 返回原始验证结果（或强制返回 true）        return this.a(s);    &#125;;&#125;);\n\n执行，得到结果。\n\n"},{"title":"r2pay-v0.9分析","url":"/2025/05/18/r2pay-v0-9%E5%88%86%E6%9E%90/","content":"r2pay-v0.9.apk安装完后，一打开就闪退。\n通过adb logcat查看日志，筛选中下面的日志记录。\n02-28 10:34:38.788 11795 11795 I Magisk  : zygisk64: [re.pwnme] is on the denylist02-28 10:34:38.823 11795 11795 I re.pwnme: Late-enabling -Xcheck:jni02-28 10:34:38.845  1187  1204 I adbd    : jdwp connection from 1179502-28 10:34:38.867 11795 11795 D ProcessState: Binder ioctl to enable oneway spam detection failed: Invalid argument02-28 10:34:38.785     0     0 I binder  : 11795:11795 ioctl 40046210 7fe5e224b4 returned -2202-28 10:34:38.881 11795 11795 D CompatibilityChangeReporter: Compat change id reported: 171979766; UID 10137; state: DISABLED02-28 10:34:38.887 11795 11795 D ApplicationLoaders: Returning zygote-cached class loader: /system/framework/android.test.base.jar02-28 10:34:38.909 11795 11795 V GraphicsEnvironment: ANGLE Developer option for &#x27;re.pwnme&#x27; set to: &#x27;default&#x27;02-28 10:34:38.909 11795 11795 V GraphicsEnvironment: ANGLE GameManagerService for re.pwnme: false02-28 10:34:38.909 11795 11795 V GraphicsEnvironment: Neither updatable production driver nor prerelease driver is supported.02-28 10:34:38.911 11795 11795 D NetworkSecurityConfig: No Network Security Config specified, using platform default02-28 10:34:38.912 11795 11795 D NetworkSecurityConfig: No Network Security Config specified, using platform default02-28 10:34:39.391  2400  3117 W FrameTracker: Missing HWUI jank callback for vsyncId: 8485502-28 10:34:39.612 11795 11795 W re.pwnme: type=1400 audit(0.0:371): avc: denied &#123; read &#125; for name=&quot;cache&quot; dev=&quot;sda14&quot; ino=16 scontext=u:r:untrusted_app_29:s0:c137,c256,c512,c768 tcontext=u:object_r:cache_file:s0 tclass=lnk_file permissive=0 app=re.pwnme02-28 10:34:39.612 11795 11795 W re.pwnme: type=1400 audit(0.0:372): avc: denied &#123; read &#125; for name=&quot;cache&quot; dev=&quot;sda14&quot; ino=16 scontext=u:r:untrusted_app_29:s0:c137,c256,c512,c768 tcontext=u:object_r:cache_file:s0 tclass=lnk_file permissive=0 app=re.pwnme02-28 10:34:39.612 11795 11795 W re.pwnme: type=1400 audit(0.0:373): avc: denied &#123; read &#125; for name=&quot;cache&quot; dev=&quot;sda14&quot; ino=16 scontext=u:r:untrusted_app_29:s0:c137,c256,c512,c768 tcontext=u:object_r:cache_file:s0 tclass=lnk_file permissive=0 app=re.pwnme02-28 10:34:39.678 11795 11795 W re.pwnme: Accessing hidden method Landroid/view/View;-&gt;computeFitSystemWindows(Landroid/graphics/Rect;Landroid/graphics/Rect;)Z (unsupported, reflection, allowed)02-28 10:34:39.678 11795 11795 W re.pwnme: Accessing hidden method Landroid/view/ViewGroup;-&gt;makeOptionalFitsSystemWindows()V (unsupported, reflection, allowed)02-28 10:34:39.725 11795 11795 E RootBeer: b: a() [249] - com.topjohnwu.magisk ROOT management app detected!02-28 10:34:39.725 11795 11795 E QLog    : b: a() [249] - com.topjohnwu.magisk ROOT management app detected!02-28 10:34:39.726 11795 11795 D AndroidRuntime: Shutting down VM02-28 10:34:39.727 11795 11795 E AndroidRuntime: FATAL EXCEPTION: main02-28 10:34:39.727 11795 11795 E AndroidRuntime: Process: re.pwnme, PID: 1179502-28 10:34:39.727 11795 11795 E AndroidRuntime: java.lang.RuntimeException: Unable to start activity ComponentInfo&#123;re.pwnme/re.pwnme.MainActivity&#125;: java.lang.ArithmeticException: divide by zero02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:3707)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:3864)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:103)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.app.servertransaction.TransactionExecutor.executeCallbacks(TransactionExecutor.java:135)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:95)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2253)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.os.Handler.dispatchMessage(Handler.java:106)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.os.Looper.loopOnce(Looper.java:201)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.os.Looper.loop(Looper.java:288)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.app.ActivityThread.main(ActivityThread.java:7870)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at java.lang.reflect.Method.invoke(Native Method)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:548)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1003)02-28 10:34:39.727 11795 11795 E AndroidRuntime: Caused by: java.lang.ArithmeticException: divide by zero02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at re.pwnme.MainActivity.onCreate(SourceFile:38)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.app.Activity.performCreate(Activity.java:8057)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.app.Activity.performCreate(Activity.java:8037)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1341)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:3688)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        ... 12 more02-28 10:34:39.730  1045 11817 I DropBoxManagerService: add tag=data_app_crash isTagEnabled=true flags=0x202-28 10:34:39.730  1045  5059 W ActivityTaskManager:   Force finishing activity re.pwnme/.MainActivity02-28 10:34:39.737 11795 11795 I Process : Sending signal. PID: 11795 SIG: 9\n\n我把日志丢给grok进行分析，似乎是调用了RootBeer库进行root检测，发现了magisk，因此退出了。\n\n\n尝试搜索字符串 ROOT management app detected，这里的try catch就是用来检测root的，如果读包错误，就说明这个包不存在，不做任何处理；如果读到“危险”包，就会继续执行b.a.a.c.a.a，并将result置为true。\n\n\n追踪b.a.a.c.a.a进去看一下，发现就写了一个Log.e。\n\n查看方法b.a.a.b.a(List )的调用。\n\n\nIndex为0的方法b.a.a.b.a(String[] )如下，属于重载，可以看到，这里只是将字符串加入到packages里，并调用b.a.a.b.a(List )。\n\n而Index为1的方法b.a.a.b.b(String[] )如下，它调用了b.a.a.b.a(String[] )。\n\n之后又一直查看引用，找到b.a.a.j()，这里做了一堆检查root的内容。\n\n\n不如直接将函数j给hook了，也省得hook其它这么多函数，我观察了一下众多this.X，发现其中的this.e不仅仅在j()被调用，还在其它地方被调用。\n总结了一下，需要hook的函数如下：\nb.a.a.a()&#x2F;b.a.a.j()&#x2F;b.a.a.e()。\n首先hook方法a，一般来说，可以根据参数列表不同hook特定的、存在同名的方法，但这里要hook的方法a属于无参方法，而且存在两个无参方法a。\n下面是我找ds-r1生成的，不知道行不行得通，看得挺靠谱的，根据返回值类型来判断。（事后发现下面的脚本用不了，别学，这里作为错误示范）\nJava.perform(function() &#123;    var targetClass = Java.use(&quot;b.a.a.b&quot;);    var methods = targetClass.class.getDeclaredMethods();        methods.forEach(function(method) &#123;        if (method.getName() === &quot;a&quot; &amp;&amp; method.getParameterTypes().length === 0) &#123;            var returnType = method.getReturnType().getName();                        // Hook返回boolean的a方法            if (returnType === &quot;boolean&quot;) &#123;                method.implementation = function() &#123;                    console.log(&quot;Hooked boolean a() method&quot;);                    return this.a.apply(this, arguments);                &#125;;            &#125;            // Hook返回String数组的a方法            else if (returnType === &quot;[Ljava.lang.String;&quot;) &#123;                method.implementation = function() &#123;                    console.log(&quot;Hooked String[] a() method&quot;);                    return this.a.apply(this, arguments);                &#125;;            &#125;        &#125;    &#125;);&#125;);\n\n不过既然要hook的方法都在b.a.a类中，不妨直接将hook的方法补充进上面这个脚本里，执行后，又闪退了，不过这回查看日志，并没看到之前的那几条记录了。\n02-28 15:10:41.848  4531  4531 I crash_dump64: obtaining output fd from tombstoned, type: kDebuggerdTombstoneProto02-28 15:10:41.849   655   655 I tombstoned: received crash request for pid 452802-28 15:10:41.850  4531  4531 I crash_dump64: performing dump of process 4498 (target tid = 4528)02-28 15:10:41.871  4531  4531 E DEBUG   : failed to read /proc/uptime: Permission denied02-28 15:10:42.485     0     0 I logd    : logdr: UID=10137 GID=10137 PID=4531 n tail=0 logMask=8 pid=4498 start=0ns deadline=0ns02-28 15:10:42.486     0     0 I logd    : logdr: UID=10137 GID=10137 PID=4531 n tail=0 logMask=1 pid=4498 start=0ns deadline=0ns02-28 15:10:42.498  4531  4531 F DEBUG   : *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***02-28 15:10:42.498  4531  4531 F DEBUG   : Build fingerprint: &#x27;OnePlus/OnePlus6/OnePlus6:8.1.0/OPM1.171019.011/06140300:user/release-keys&#x27;02-28 15:10:42.498  4531  4531 F DEBUG   : Revision: &#x27;0&#x27;02-28 15:10:42.498  4531  4531 F DEBUG   : ABI: &#x27;arm64&#x27;02-28 15:10:42.498  4531  4531 F DEBUG   : Timestamp: 2025-02-28 15:10:41.870217324+080002-28 15:10:42.498  4531  4531 F DEBUG   : Process uptime: 0s02-28 15:10:42.498  4531  4531 F DEBUG   : Cmdline: com.google.android.videos02-28 15:10:42.498  4531  4531 F DEBUG   : pid: 4498, tid: 4528, name: re.pwnme  &gt;&gt;&gt; com.google.android.videos &lt;&lt;&lt;02-28 15:10:42.498  4531  4531 F DEBUG   : uid: 1013702-28 15:10:42.498  4531  4531 F DEBUG   : signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0xfaba497502-28 15:10:42.498  4531  4531 F DEBUG   :     x0  0000006fe4986670  x1  000000730a2a77cc  x2  00000071ceef6220  x3  0000006fe498661802-28 15:10:42.498  4531  4531 F DEBUG   :     x4  00000000000010b0  x5  0000000000000001  x6  0000000000000000  x7  000000000000000002-28 15:10:42.498  4531  4531 F DEBUG   :     x8  00000000000035b2  x9  00000000faba4975  x10 000000008ef93fe9  x11 000000006df6246c02-28 15:10:42.498  4531  4531 F DEBUG   :     x12 0000000000000001  x13 00000000fffffff6  x14 00000000cf86a786  x15 000000000000000102-28 15:10:42.499  4531  4531 F DEBUG   :     x16 000000730a2911f8  x17 000000730a20db40  x18 0000000000000000  x19 0000006fe498667002-28 15:10:42.499  4531  4531 F DEBUG   :     x20 0000000000000000  x21 0000006fe498acb0  x22 0000000000001192  x23 000000000000119202-28 15:10:42.499  4531  4531 F DEBUG   :     x24 0000006fe498acb0  x25 0000006fe498acb0  x26 0000006fe498aff8  x27 00000000000fc00002-28 15:10:42.499  4531  4531 F DEBUG   :     x28 0000006fe4892000  x29 0000006fe498ac4002-28 15:10:42.499  4531  4531 F DEBUG   :     lr  0000006fdffa2668  sp  0000006fe4986670  pc  0000006fdfe77f7c  pst 000000006000000002-28 15:10:42.499  4531  4531 F DEBUG   : backtrace:02-28 15:10:42.499  4531  4531 F DEBUG   :       #00 pc 0000000000038f7c  /data/app/~~IG0Dzbwr_V__IsLZxDqnLA==/re.pwnme-5cCb3aQP1IrcfKWzdCWgYQ==/lib/arm64/libnative-lib.so (BuildId: f87b3bd9fcae36e63939958f412d03a42e0ce406)02-28 15:10:42.499  4531  4531 F DEBUG   :       #01 pc 00000000000b1810  /apex/com.android.runtime/lib64/bionic/libc.so!libc.so (__pthread_start(void*)+264) (BuildId: 6bfaf10f10e5ff343703efae2f1bdbdb)02-28 15:10:42.499  4531  4531 F DEBUG   :       #02 pc 00000000000512f0  /apex/com.android.runtime/lib64/bionic/libc.so!libc.so (__start_thread+64) (BuildId: 6bfaf10f10e5ff343703efae2f1bdbdb)\n\n查看调用栈，锁定在libnative-lib.so，偏移量是38f7c，用ida打开后，访问那块地址，结果说函数太大，无法进行f5，没辙了，没啥思绪了，看看博客。\nhttps://blog.csdn.net/qq_61253776/article/details/140026070\n看来我的第一步分析是正确的，将函数j a e进行了hook，避免了java层的检测，但so层好难。\n接下来找博客一步一步做了。\nSo层的检测针对了root权限和frida注入，下面主要写分析过程。\n在re.pwnme.MainActivity类中，静态初始化块加载了native-lib，\n\n\n然后声明了其中的一个native函数并用于MainActivity的页面代码中。\n\n\n通过ida观察libnative-lib.so的export表，导出函数和全局变量都被加密了。\n\n点开.datadiv_decodexxxxxx，大部分这类函数只写了一个RET，对应的字节码是C0 03 5F D6。\n\n根据观察，其中的函数datadiv_decode4432700155380705947，它存在函数体，并且大部分操作似乎在做解密。大部分资料显示，这里是在做全局字符串的解密操作。\n\n\n除此之外，在.init_array段中，存在两个拥有函数体的函数，它们无法f5，反编译成c。\n\n\n\n过了java层后，会在so层的某处断开，地址是38f7c。\n\n在ida中来到38f7c，一路跟踪交叉引用，最后判定，这段代码属于sub_83DC。\n由于静态无法分析，只能动态分析了，博客中，这里使用了工具QBDI，QBDI是一个动态二进制插桩的DBI框架，可以追踪函数细节，如果只用frida的话，只能看到函数调用前的参数和调用后的结果。\n但QBDI咋用啊，wtf，教程也太少了。\n\n时隔多天，在分析完豆瓣后，再次看看这个apk如何分析。\n在分析豆瓣的过程中，学会了找退出点的一些方法。\n比如：hook函数pthread_create，线程在跑起来后，如果是检测frida的线程，就会杀死frida，所以可以观察哪个线程跑起来后，导致frida退出了。因为libc.so是系统库，加载先于frida的spawn模式，无需担心过早hook。\n对应的检测线程脚本如下，不是直接复制就能用，这里放在这仅供参考：\nfunction hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;);    let offset = 0x51BA8; // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset);    let listener = Interceptor.attach(call_constructors, &#123;        onEnter: function(args) &#123;            console.log(&#x27;hook_linker_call_constructors onEnter&#x27;);            let libnative_module = Process.findModuleByName(&quot;libnative-lib.so&quot;);            // 打印模块信息            if (libnative_module) &#123;                console.log(&quot;Module name: &quot; + libnative_module.name);                console.log(&quot;Base address: 0x&quot; + libnative_module.base.toString(16));                console.log(&quot;Size: &quot; + libnative_module.size);                console.log(&quot;Path: &quot; + libnative_module.path);                                check_pthread_create(libnative_module.base);                //hook_20954();                //hook_7a660();                listener.detach();            &#125;        &#125;    &#125;);&#125;function check_pthread_create(baseaddr)&#123;    /* 找到函数pthread_create的地址 */    var pthread_create = Module.findExportByName(&quot;libc.so&quot;, &quot;pthread_create&quot;);    if(pthread_create)&#123;        console.log(&quot;pthread_create is exist&quot;);    &#125;else&#123;        console.log(&quot;pthread_create is not exist&quot;);    &#125;    /* hook */    Interceptor.attach(pthread_create, &#123;        onEnter: function(args)&#123;            console.log(&quot;pthread_create is called&quot;);            console.log(&quot;arg2: 0x&quot; + (args[2] - baseaddr).toString(16));        &#125;    &#125;);&#125;\n\n之后应该就会看到几个函数的地址，然后尝试hook它们。\nfunction hook_20954()&#123;    let libnative_module = Process.findModuleByName(&quot;libnative-lib.so&quot;);    Interceptor.replace(libnative_module.base.add(0x20954), new NativeCallback(function () &#123;        console.log(`hook_20954 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; replace`);    &#125;, &#x27;void&#x27;, []));&#125;function hook_7a660()&#123;    let libnative_module = Process.findModuleByName(&quot;libnative-lib.so&quot;);    Interceptor.replace(libnative_module.base.add(0x7a660), new NativeCallback(function () &#123;        console.log(`hook_7a660 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; replace`);    &#125;, &#x27;void&#x27;, []));&#125;\n\n然后再次跑frida脚本，发现提示除以0的报错，这个报错不是在之前的java层解决了吗？\n下面这个脚本是错的，是我早期通过deepseek生成的，我还以为能用。\nfunction hook_java() &#123;        var targetClass = Java.use(&quot;b.a.a.b&quot;);        var methods = targetClass.class.getDeclaredMethods();        console.log(&quot;Methods found in b.a.a.b:&quot;);        methods.forEach(function(method) &#123;            if (method.getName() === &quot;a&quot; &amp;&amp; method.getParameterTypes().length === 0) &#123;                var returnType = method.getReturnType().getName();                console.log(&quot;Return type: &quot; + typeof returnType + &quot;, value: &quot; + returnType);                if (returnType === &quot;boolean&quot;) &#123;                    method.implementation = function() &#123;                        console.log(&quot;b.a.a.b.a() is called, res = &quot;, this.a());                        console.log(&quot;Hooked boolean a() method&quot;);                        return false;                    &#125;;                &#125;            &#125;            if (method.getName() === &quot;j&quot; &amp;&amp; method.getParameterTypes().length === 0) &#123;                var returnType = method.getReturnType().getName();                if (returnType === &quot;boolean&quot;) &#123;                    method.implementation = function() &#123;                        console.log(&quot;b.a.a.b.j() is called, res = &quot;, this.j());                        console.log(&quot;Hooked boolean j() method&quot;);                        return false;                    &#125;;                &#125;            &#125;            if (method.getName() === &quot;e&quot; &amp;&amp; method.getParameterTypes().length === 0) &#123;                var returnType = method.getReturnType().getName();                if (returnType === &quot;boolean&quot;) &#123;                    method.implementation = function() &#123;                        console.log(&quot;b.a.a.b.e() is called, res = &quot;, this.e());                        console.log(&quot;Hooked boolean e() method&quot;);                        return false;                    &#125;;                &#125;            &#125;        &#125;);&#125;\n\n将它修改成正常的、简单的脚本。\nfunction hook_java() &#123;    Java.perform(function() &#123;              var targetClass = Java.use(&quot;b.a.a.b&quot;);         targetClass.a.overload().implementation = function() &#123;            console.log(&quot;Hooked b.a.a.b.a()&quot;);            return false; // 强制返回 false        &#125;;        targetClass.j.overload().implementation = function() &#123;            console.log(&quot;Hooked b.a.a.b.j()&quot;);            return false;        &#125;;        targetClass.e.overload().implementation = function() &#123;            console.log(&quot;Hooked b.a.a.b.e()&quot;);            return false;        &#125;;    &#125;);&#125;\n\n最后整理出来的脚本如下，执行完后能正常跑apk了。\nfunction hook_java() &#123;    Java.perform(function() &#123;              var targetClass = Java.use(&quot;b.a.a.b&quot;);         targetClass.a.overload().implementation = function() &#123;            console.log(&quot;Hooked b.a.a.b.a()&quot;);            return false; // 强制返回 false        &#125;;        targetClass.j.overload().implementation = function() &#123;            console.log(&quot;Hooked b.a.a.b.j()&quot;);            return false;        &#125;;        targetClass.e.overload().implementation = function() &#123;            console.log(&quot;Hooked b.a.a.b.e()&quot;);            return false;        &#125;;    &#125;);&#125;function hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;);    let offset = 0x51BA8; // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset);    let listener = Interceptor.attach(call_constructors, &#123;        onEnter: function(args) &#123;            console.log(&#x27;hook_linker_call_constructors onEnter&#x27;);            let libnative_module = Process.findModuleByName(&quot;libnative-lib.so&quot;);            // 打印模块信息            if (libnative_module) &#123;                console.log(&quot;Module name: &quot; + libnative_module.name);                console.log(&quot;Base address: 0x&quot; + libnative_module.base.toString(16));                console.log(&quot;Size: &quot; + libnative_module.size);                console.log(&quot;Path: &quot; + libnative_module.path);                                check_pthread_create(libnative_module.base);                hook_20954();                hook_7a660();                listener.detach();            &#125;        &#125;    &#125;);&#125;function check_pthread_create(baseaddr)&#123;    /* 找到函数pthread_create的地址 */    var pthread_create = Module.findExportByName(&quot;libc.so&quot;, &quot;pthread_create&quot;);    if(pthread_create)&#123;        console.log(&quot;pthread_create is exist&quot;);    &#125;else&#123;        console.log(&quot;pthread_create is not exist&quot;);    &#125;    /* hook */    Interceptor.attach(pthread_create, &#123;        onEnter: function(args)&#123;            console.log(&quot;pthread_create is called&quot;);            console.log(&quot;arg2: 0x&quot; + (args[2] - baseaddr).toString(16));        &#125;    &#125;);&#125;function hook_20954()&#123;    let libnative_module = Process.findModuleByName(&quot;libnative-lib.so&quot;);    Interceptor.replace(libnative_module.base.add(0x20954), new NativeCallback(function () &#123;        console.log(`hook_20954 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; replace`);    &#125;, &#x27;void&#x27;, []));&#125;function hook_7a660()&#123;    let libnative_module = Process.findModuleByName(&quot;libnative-lib.so&quot;);    Interceptor.replace(libnative_module.base.add(0x7a660), new NativeCallback(function () &#123;        console.log(`hook_7a660 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; replace`);    &#125;, &#x27;void&#x27;, []));&#125;function Avoid_divide_by_zero()&#123;    let b = Java.use(&quot;b.a.a.b&quot;);    b[&quot;j&quot;].implementation = function () &#123;        return false    &#125;;&#125;hook_linker_call_constructors();setImmediate(hook_java);\n\n成功在豆瓣进修，hhhhhh。\n"},{"title":"UnCrackable-Level3分析","url":"/2025/05/18/UnCrackable-Level3%E5%88%86%E6%9E%90/","content":"UnCrackable-Level3.apk照常，安装并打开，被检测到了root，通过magisk进行root权限的隐藏。\n之后还是输入正确的密码。\n\n\n在输入错误的Secret后，会提示Nope…That’s not it. Try again.\n在Jeb中搜索这个字符串，发现关键点在check_code上。\n\n\ncheck_code调用了native层函数bar。\n\n\n在ida中，检索函数bar，一个很明显的xor解密，密钥的长度为24。\n\n为了获得正确的secret，需要将v8和qword_15038进行xor运算，得到最终的结果。\n不难看出，v8的值来自于sub_10E0，这里考虑对sub_10E0进行hook，然后查看v8的值。\n结果hook的过程遇到了反frida的检测，可以根据报错的调用栈定位到goodbye函数。\n\n\n追溯到源头，发现在sub_30D0处，调用了goodbye()，检测的逻辑是，通过读取映射到内存的文件名，只要发现frida等字段就退出。\n\n\n为了能够正常使用frida进行hook，有以下几种hook的方式，绕过反frida。\n1.hook函数sub_30D0。\n2.hook函数strstr。\nⅠ.先讲hook sub_30D0：观察过函数sub_30D0，发现它被写在了.init_array节里，这个节里面的函数，会在库加载的时候依次被调用，因此，如果想要hook这个函数，必须在System.loadLibray执行过程中——因为执行完后，frida就hook不了了；而若是还没执行，libfoo.so还没加载，当然hook不了。\n查阅了相关博客，so层的.init_array节里的函数，都是被模块linker64中的call_array调用的，所以要hook函数call_array，当下的核心目标是获得call_array在模块linker64中的偏移量。（方法随意，可以直接在ida中进行查看）\n在hook后，流程变成：遇到加载的so是libfoo.so，在完成了内存映射后，call_array还没有执行，这个时候去修改内存中sub_30D0的内容，之后正常执行call_array。\n    // 获取linker64模块的基地址    var linker64_module = Module.getBaseAddress(&quot;linker64&quot;);    //使用拦截器附加linker64模块的偏移地址    // 7D68B58764 - 7D68B38000 = 0x20764    Interceptor.attach(linker64_module.add(0x20764),&#123;        // 进入函数，代码检查参数args[3]指向的字符串是否匹配libfoo.so        onEnter:function(args) &#123;           if(args[0].readCString().match(&quot;libfoo.so&quot;)) &#123;                // 获取libfoo.so的基地址                var libfoo_module  = Module.findBaseAddress(&#x27;libfoo.so&#x27;);                console.log(&quot;获取libfoo.so的基地址==&gt;&quot;+libfoo_module)                Interceptor.replace(libfoo_module.add(0x30D0),new NativeCallback(function()&#123;                    return;                &#125;,&#x27;void&#x27;,[]));           &#125;    &#125;,onLeave:function(result)&#123;&#125;&#125;)\n\nⅡ.hook strstr就比较简单，判断strstr的第1个参数里有没有frida字段，如果有，之后的返回值直接强制返回。\n// 反frida检测Interceptor.attach(Module.findExportByName(&quot;libc.so&quot;, &quot;strstr&quot;), &#123;    onEnter: function(args) &#123;        this.haystack = args[0];        this.needle = args[1];        this.frida = false;        // 方法 1：使用 readCString（自动处理 NULL 结尾）        try &#123;            const haystack = this.haystack.isNull() ? &quot;&quot; : this.haystack.readCString();            if (haystack &amp;&amp; (haystack.includes(&quot;frida&quot;) || haystack.includes(&quot;xposed&quot;))) &#123;                this.frida = true;            &#125;        &#125; catch (e) &#123;            console.log(&quot;读取字符串失败:&quot;, e);        &#125;    &#125;,    onLeave: function(retval) &#123;        if (this.frida) &#123;            retval.replace(0);        &#125;        return retval;    &#125;&#125;);\n\nok，在解决了反frida后，继续对之前提到的sub_10E0进行解密，由于这个函数没有返回值，可以判断：这个函数会在v8所指向的地址处，修改24个字节。\n   function hookXor()&#123;           // hook xor的其中一个key       Interceptor.attach((Module.findBaseAddress(&quot;libfoo.so&quot;)).add(&quot;0x010E0&quot;), &#123;           onEnter: function(args)&#123;               console.log(&quot;onEnter: hook xor key&quot;);               this.key = args[0];           &#125;,                   onLeave: function(retval)&#123;               var key_ = new NativePointer(this.key);               var arr = key_.readByteArray(24);               console.log(arr);           &#125;       &#125;);   &#125;setTimeout(hookXor, 1000);\n\n这里为了避免hookXor未执行，特意延迟了1000ms再进行注入（方法比较简单）。\n还有其它方法，在保证加载了libfoo.so后立马进行hook，而不用等待1000ms。（同样是在加载器上做文章，不过这里hook的是System.loadLibrary）\nJava.perform(function() &#123;    const System = Java.use(&quot;java.lang.System&quot;);    const Runtime = Java.use(&quot;java.lang.Runtime&quot;);    const SystemLoad_2 = System.loadLibrary.overload(&quot;java.lang.String&quot;);    const VMStack = Java.use(&quot;dalvik.system.VMStack&quot;);    SystemLoad_2.implementation = function(library) &#123;        console.log(&quot;Loading dynamic library =&gt; &quot; + library);        try &#123;          const loaded =     Runtime.getRuntime().loadLibrary0( VMStack.getCallingClassLoader(), library);          if(library.includes(&quot;foo&quot;)) &#123;            //function that gets the xored value             Interceptor.attach(Module.findBaseAddress(&quot;libfoo.so&quot;).add(&#x27;0x00000fa0&#x27;),&#123;              onEnter: function(args)&#123;                console.log(&quot;getting other_key value&quot;);                this.other_key_address = args[0];              &#125;,              onLeave: function(retval)&#123;                var other_key = new NativePointer(this.other_key_address);                var arr = other_key.readByteArray(24);                console.log(arr);              &#125;            &#125;);          &#125;          return loaded;        &#125; catch(ex) &#123;          console.log(ex);          console.log(ex.stack);        &#125;    &#125;;&#125;);\n\n最后得到的结果如下，即：1d 08 11 13…\n\n\n同时，另一个密钥key是qword_15038，追踪后，发现是通过init函数进行初始化的，这个函数是一个jni函数，根据代码，可以发现它的值由java层传递。\n\n因此，另一个key的值是pizzapizzapizzapizzapizz。\n\n\n将两者做异或运算。\ndef xor_bytes(str1, bytes2):    &quot;&quot;&quot;    对两个24字节的数据进行逐字节的异或运算。    参数:    str1: 长度为24字节的字符串    bytes2: 长度为24字节的字节数组    返回:    result: 异或运算后的字节数组    &quot;&quot;&quot;    # 确保输入长度为24字节    if len(str1) != 24 or len(bytes2) != 24:        raise ValueError(&quot;输入必须是24字节长&quot;)    # 将字符串转换为字节数组    bytes1 = str1.encode(&#x27;utf-8&#x27;)    # 进行逐字节的异或运算    result = bytearray()    for b1, b2 in zip(bytes1, bytes2):        result.append(b1 ^ b2)    return result# 示例用法if __name__ == &quot;__main__&quot;:    # 输入字符串和字节数组    str_input = &quot;pizzapizzapizzapizzapizz&quot;  # 24字节字符串    bytes_input = bytes([0x1d, 0x08, 0x11, 0x13, 0x0f, 0x17, 0x49, 0x15, 0x0d, 0x00, 0x03, 0x19, 0x5a, 0x1d, 0x13, 0x15, 0x08, 0x0e, 0x5a, 0x00, 0x17, 0x08, 0x13, 0x14])  # 24字节的字节数组 [0, 1, 2, ..., 23]    # 执行异或运算    result = xor_bytes(str_input, bytes_input)    # 输出结果    print(&quot;异或运算结果:&quot;, result)    print(&quot;十六进制表示:&quot;, result.hex())\n\n\n\n阿这，这个解密出来的结果有点6。\n\n"},{"title":"unidbg初识","url":"/2025/05/18/unidbg%E5%88%9D%E8%AF%86/","content":"Frida和Unidbg最大的区别是，Unidbg是模拟程序执行，所以可以绕过检测，而Frida面临众多检测，需要学会反检测。\n其实在理解了Unidbg的原理之后，它还蛮简单的。\n模拟层级Unicorn模拟了底层cpu指令模拟，相当于一台裸机。当native代码调用到系统调用的指令（如x86的syscall、arch64的svc等），会将这些触发转发给AndroidEmulator进行处理。\nAndroidEmulator主要负责模拟安卓环境和系统环境和JNI交互，除此之外，它还负责处理Unicorn转发而来的系统调用。\n补环境实例讲解可以观察下面的一个需要补环境的代码。\npackage com.example.luodst;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.LibraryResolver;import com.github.unidbg.Module;import com.github.unidbg.arm.backend.Unicorn2Factory;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.*;import com.github.unidbg.linux.android.dvm.array.ByteArray;import com.github.unidbg.memory.Memory;import com.github.unidbg.virtualmodule.android.AndroidModule;import java.io.File;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.sql.SQLOutput;import java.util.ArrayList;import java.util.Enumeration;import java.util.List;import java.util.zip.ZipEntry;import java.util.zip.ZipFile;public class MainActivity extends AbstractJni &#123;    public static void main(String[] args) &#123;        MainActivity mainActivity = new MainActivity();        mainActivity.getHash();    &#125;\t// 模拟器创建    private final AndroidEmulator emulator;    // 创建java虚拟机\tprivate final VM vm;    private final Module module;    private MainActivity() &#123;        //1.创建Android模拟器实例        emulator = AndroidEmulatorBuilder                .for32Bit() // 32位虚拟机                .addBackendFactory(new Unicorn2Factory(true)) // 选择指令集，相当于选择哪台裸机，默认是unicorn                .setRootDir(new File(&quot;unidbg-android/src/test/java/com/example/luodst/rootfs&quot;)) // 设置文件系统根目录                .build(); // 创建        //2.获取操作内存的接口        Memory memory = emulator.getMemory();        //3.设置Android SDK 版本        LibraryResolver resolver = new AndroidResolver(23);        memory.setLibraryResolver(resolver); // 加载sdk里的java类（可能会添加hook）        //4.创建java虚拟机，导入apk文件        vm = emulator.createDalvikVM(new File(&quot;unidbg-android/src/test/java/com/example/luodst/files/DogPro.apk&quot;));        //5.是否打印日志        vm.setVerbose(true);        //6.将自定义的JNI处理逻辑绑定到java虚拟机上        vm.setJni(this);        // 为java环境模拟器和java虚拟机注册内存        new AndroidModule(emulator, vm).register(memory);        //7.加载目标so文件，true主动执行init init_array        DalvikModule dm = vm.loadLibrary(&quot;dogpro&quot;, true);        //8.将so文件对应的Module存入成员变量        module = dm.getModule();        //9.主动调用JNI_OnLoad        dm.callJNI_OnLoad(emulator);    &#125;    private void getHash() &#123;        DvmObject&lt;?&gt; dvmObject = vm.resolveClass(&quot;com/example/dogpro/MainActivity&quot;).newObject(null);        System.out.println(&quot;dvmObject = &quot;+ dvmObject.toString());        String input = &quot;unidbg-android/src/test/java/com/example/luodst/files/DogPro.apk&quot;;        DvmObject&lt;?&gt; ret = dvmObject.callJniMethodObject(emulator, &quot;getHash(Ljava/lang/String;)Ljava/lang/String;&quot;, input);        System.out.println(&quot;result ==&gt; &quot;+ret.getValue());    &#125;&#125;\n\n可以这么理解Unidbg补环境的过程，so文件作为elf二进制代码，可以在unicorn上面跑，但一些JNI函数，他们的参数列表需要JNI类型的数据，有时候甚至要调用一些Java层的函数（java层给native层数据时，数据类型是JNI类型），而Unidbg就是负责处理JNI交互的。\nUnidbg有自己的一套JNI类型，其内置的Java虚拟机中还内置了很多自定义的基本类型、引用类型的数据结果，如：外部虚拟机中的String类型，在Unidbg中是StringObject类型；外部的int、boolean类型，是Unidbg中的DvmInteger和DvmBoolean；除此之外，大部分引用类型在Unidbg都视作DvmClass类型（继承于DvmObject&lt;?&gt;类型），这些引用类型的对象都属于DvmObject&lt;?&gt;类型。\nDvmObject&lt;?&gt;：这是 Unidbg 中所有 Java 对象的基类，类似于真实 JVM 中的 java.lang.Object。它是一个泛型类，DvmObject&lt;T&gt; 的 T 通常表示对应的真实 Java 类型。例如，DvmObject&lt;String&gt; 表示一个 String 类型的对象。DvmClass：表示 Java 中的类对象（java.lang.Class 的模拟）。在 Unidbg 中，DvmClass 继承自 DvmObject&lt;Class&lt;?&gt;&gt;，用来表示类的元信息（如类名、方法、字段等）。\n\n\n一般情况下，不需要补环境，是因为unidbg的虚拟机中内置了很多DvmClass（解析于SDK），也内置了很多自己的处理函数，操作这些DvmObject&lt;?&gt;，但遇到一些尚未解析的DvmClass或者无法解析的DvmClass的函数，就会抛出错误，这个时候就需要为它补环境了。\n补环境的过程如下，简单来说，就是内置的类与函数不够用了，转而使用外部java虚拟机的类与函数，只将结果转换成DvmObject&lt;?&gt;返回给内部虚拟机。\n\n\n举个例子，下面这个报错是无法处理ZipFile的构造函数。\n\n一直定位追踪到下面这个函数，会发现没有针对于ZipFile类型的构造函数。\n@Overridepublic DvmObject&lt;?&gt; newObjectV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) &#123;    switch (signature) &#123;        case &quot;java/io/ByteArrayInputStream-&gt;&lt;init&gt;([B)V&quot;: &#123;            ByteArray array = vaList.getObjectArg(0);            assert array != null;            return vm.resolveClass(&quot;java/io/ByteArrayInputStream&quot;).newObject(new ByteArrayInputStream(array.value));        &#125;        case &quot;java/lang/String-&gt;&lt;init&gt;([B)V&quot;: &#123;            ByteArray array = vaList.getObjectArg(0);            assert array != null;            return new StringObject(vm, new String(array.value));        &#125;        case &quot;java/lang/String-&gt;&lt;init&gt;([BLjava/lang/String;)V&quot;: &#123;            ByteArray array = vaList.getObjectArg(0);            assert array != null;            StringObject charsetName = vaList.getObjectArg(1);            assert charsetName != null;            try &#123;                return new StringObject(vm, new String(array.value, charsetName.value));            &#125; catch (UnsupportedEncodingException e) &#123;                throw new IllegalStateException(e);            &#125;        &#125;        case &quot;javax/crypto/spec/SecretKeySpec-&gt;&lt;init&gt;([BLjava/lang/String;)V&quot;:&#123;            byte[] key = (byte[]) vaList.getObjectArg(0).value;            StringObject algorithm = vaList.getObjectArg(1);            assert algorithm != null;            SecretKeySpec secretKeySpec = new SecretKeySpec(key, algorithm.value);            return dvmClass.newObject(secretKeySpec);        &#125;        case &quot;java/lang/Integer-&gt;&lt;init&gt;(I)V&quot;: &#123;            int i = vaList.getIntArg(0);            return DvmInteger.valueOf(vm, i);        &#125;        case &quot;java/lang/Boolean-&gt;&lt;init&gt;(Z)V&quot;:&#123;            boolean b;            b = vaList.getIntArg(0) != 0;            return DvmBoolean.valueOf(vm, b);        &#125;    &#125;    throw new UnsupportedOperationException(signature);&#125;\n\n这个时候就需要为它补环境了，如何补呢？这里的ZipFile并不是基本数据类型，在项目中也没有为它进行解析。\n\n\n因此需要将这个ZipFile类型解析到Unidbg的虚拟机中，再为它创建一个对象进行返回。\n下面的代码中，vm.resolveClass负责解析ZipFile类，此时ZipFile类光荣的加入了Unidbg的虚拟机中，并重新定义为DvmObject&lt;ZipFile&gt;类，newObject返回了一个Unidbg内置的DvmObject&lt;ZipFile&gt;类对象。\n这样便解解决了一个环境问题。\n@Override   public DvmObject&lt;?&gt; newObjectV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) &#123;       switch (signature) &#123;           case &quot;java/util/zip/ZipFile-&gt;&lt;init&gt;(Ljava/lang/String;)V&quot;: &#123;               // 正确提取 String 参数               StringObject pathObj = vaList.getObjectArg(0); // 内部虚拟机的String               assert pathObj != null;               String filePath = pathObj.getValue(); // 获取实际java类型的String               try &#123;                   // 创建虚拟的 ZipFile 对象（需提前在虚拟文件系统中补文件）                   ZipFile zipFile = new ZipFile(filePath);                   return vm.resolveClass(&quot;java/util/zip/ZipFile&quot;).newObject(zipFile);               &#125; catch (IOException e) &#123;                   throw new RuntimeException(e);               &#125;           &#125;       &#125;       return super.newObjectV(vm, dvmClass, signature, vaList);   &#125;\n\n还有一个补环境的例子，下面是报错，报错理由是缺少ZipFile的entries操作。\njava.lang.UnsupportedOperationException: java/util/zip/ZipFile-&gt;entries()Ljava/util/Enumeration;\tat com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417)\tat com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)\tat com.github.unidbg.linux.android.dvm.DvmMethod.callObjectMethodV(DvmMethod.java:89)\tat com.github.unidbg.linux.android.dvm.DalvikVM$32.handle(DalvikVM.java:553)\n\n一开始的补法是这样的。\npublic DvmObject&lt;?&gt; callObjectMethodV(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VaList vaList) &#123;    switch (signature) &#123;        case &quot;java/util/zip/ZipFile-&gt;entries()Ljava/util/Enumeration;&quot;: &#123;            //拿操作的对象            ZipFile zipFile = (ZipFile) dvmObject.getValue();            //通过对象来调用方法            Enumeration&lt;? extends ZipEntry&gt; entries =  zipFile.entries();            return vm.resolveClass(&quot;java/util/Enumeration&quot;).newObject(entries);        &#125;    &#125;    return super.callObjectMethodV(vm, dvmObject, signature, vaList);&#125;\n\n但之后仍会报错，提示无法将DvmObject转换为Enumeration，为什么会出现这个问题？其实DvmObject&lt;Enumeration&gt;是我们补的一个类，但Unidbg中内置了一个Enumeration类，这个类不应该补的，因为负责与与native层交互的内置虚拟机，它默认是转换内置的Enumeration &#x3D;&gt; JNI类型，而我们导入的这个类型会被忽视。\n虽然如此，但return的这个对象很重要，这是我们通过外部虚拟机，要返回给内部虚拟机的一个Enumeration对象，如果我们返回的是它内置的com.github.unidbg.linux.android.dvm.Enumeration就没任何事，因为这是它缺少的对象，但我们返回的是com.github.unidbg.linux.android.dvm.DvmObject&lt;Enumeration&gt;，对象不一致，就要强转了，然后失败了。\njava.lang.ClassCastException: class com.github.unidbg.linux.android.dvm.DvmObject cannot be cast to class com.github.unidbg.linux.android.dvm.Enumeration (com.github.unidbg.linux.android.dvm.DvmObject and com.github.unidbg.linux.android.dvm.Enumeration are in unnamed module of loader &#x27;app&#x27;)\tat com.github.unidbg.linux.android.dvm.AbstractJni.callBooleanMethodV(AbstractJni.java:610)\tat com.github.unidbg.linux.android.dvm.AbstractJni.callBooleanMethodV(AbstractJni.java:603)\tat com.github.unidbg.linux.android.dvm.DvmMethod.callBooleanMethodV(DvmMethod.java:119)\tat com.github.unidbg.linux.android.dvm.DalvikVM$35.handle(DalvikVM.java:630)\n\n我的分析得到了grok的认可，哈哈哈哈。\n\n既然这样补不对，就需要看内置的Enumeration是如何创建的，可以看到，内置的Enumeration实现的俩函数，不过这里不是重点，重点是如何创建一个Enumeration对象。\n通过构造函数，可以看到，需要输入一个外部java中的List对象，对象里的元素是DvmObject对象即可。\n因此，我们需要创建一个List，然后把ZipFile对象里元素的类型（即ZipEntry）转换成DvmObject&lt;ZipEntry&gt;，然后再放入List中。\n\n\n这样就算补好了。\npublic DvmObject&lt;?&gt; callObjectMethodV(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VaList vaList) &#123;    switch (signature) &#123;        case &quot;java/util/zip/ZipFile-&gt;entries()Ljava/util/Enumeration;&quot;: &#123;            ZipFile zipFile = (ZipFile) dvmObject.getValue();            Enumeration&lt;? extends ZipEntry&gt; entries =  zipFile.entries();            //return vm.resolveClass(&quot;java/util/Enumeration&quot;).newObject(entries);            List&lt;DvmObject&lt;?&gt;&gt; objs = new ArrayList&lt;&gt;();            while (entries.hasMoreElements())&#123;                ZipEntry zipEntry = entries.nextElement();                objs.add(vm.resolveClass(&quot;java/util/zip/ZipEntry&quot;).newObject(zipEntry));            &#125;            return new com.github.unidbg.linux.android.dvm.Enumeration(vm, objs);        &#125;    &#125;    return super.callObjectMethodV(vm, dvmObject, signature, vaList);&#125;\n\n追踪读写/* 监控读写 */emulator.traceRead(module.base, module.base + module.size);emulator.traceWrite(module.base, module.base + module.size);\n\n读取内存/* 读取内存 */long targetAddr = module.base + 0xE0320;UnidbgPointer ptr = UnidbgPointer.pointer(emulator, targetAddr);byte[] data = ptr.getByteArray(0, 0xC0);Inspector.inspect(data, &quot;Dumped Memory at 0x&quot; + Long.toHexString(targetAddr));\n"},{"title":"v380pro apk的分析","url":"/2025/05/18/v380pro-apk%E7%9A%84%E5%88%86%E6%9E%90/","content":"v380摄像头的apk某加密数据包分析先展示成果，原始数据内容通过了gzip压缩、AES（CBC模式）加密、base64编码，反过来就可以进行解密了。\n\n先通过r0capture查看函数调用栈，然后在几个关键函数处，hook下来，打印对象值，看看具体是哪一块进行加密。发现call到a的过程中有一个加密。\n\n由于call函数的过程，涉及很多对象的初始化，数据其实也在其中进行初始化了，很难分析。\n\n这里因为打印某些对象的值（gson包），发现了加密后data属于BodyRequest的成员变量j。\n\n追踪这个j。\n\n判断j的赋值在Api.c(api)。这里又可以看到j的值由api.k得到的。\n\n继续追踪k。\n\n\n\n搜索了一下，Kalle是一个开源sdk，body函数是用来填充负载部分的。\n\n\n这里很容易就知道AES_KEY和IV。\n\n直接用工具。\n\n\n如果要尝试使用分析libapk0000.so，我觉得可以解密字符串，然后进行dump下来查看，大概就可以判断加密模式了，如果是自定义的加密模式，那可能真要逆向了。\n"},{"title":"某瓣字段_sig的分析","url":"/2025/05/18/%E6%9F%90%E7%93%A3%E5%AD%97%E6%AE%B5-sig%E7%9A%84%E5%88%86%E6%9E%90/","content":"豆瓣抓包先了解如何抓包，这次尝试分析某个参数的加解密过程。\n工具是：Charles 4.6.3。\n抓包的配置方式如下：\n1.将pc和op放在同一局域网下，pc上打开Charles，设置Proxy-&gt;Proxy Settings，填写端口并勾选，如下图所示。\n\n\n2.之后在op上，设置网络的代理，将手机的流量转发到手机的9999端口。\n\n\n3.为pc和手机装Charles的root证书，用于CA自签名。\n\n由于手机端的证书对文件名有要求，这个文件名需要通过计算获得，计算可以通过openssl x509 -subject_hash_old -in &lt;证书&gt;获得，下图是网图，它最后得到的文件名就是5cba21f7，然后后缀固定为.0，所以就是5cba21f7.0。\n\n4.在安卓7以上的版本，app只接受系统证书，不接受用户证书，所以需要将证书移至&#x2F;system&#x2F;etc&#x2F;security&#x2F;cacerts，之后重启手机。\n5.之后如图所示，设置ssl代理。\n\n之后就可以抓到包了。——上面只考虑了单向认证，如果是双向认证，有些app的包还是会显示unknown，那就要将app的证书和密钥填写至Charles中了，不过豆瓣是单向认证。\n分析根据访问不同的域名，进行区别。\n\n\n其中，参数_sig是请求签名，用于验证请求的完整性和合法性，通常由参数和密钥计算得出。\n\n这次要分析的就是如何得到这个_sig。——抓几次包，会发现每次发包的header中，就_sig的值一直在变化，所以如果想要写脚本来发包，伪造客户端，就要解决_sig构造的问题。\n通过搜索&quot;_sig&quot;，似乎找到了为_sig赋值的地方，将pair0.first经过一些规则（HTTP的规范）后，作为值赋给_sig。\n\n在setQueryParameter中会检查s是否为空，如果已存在，还会把它移除，重新进行签名。\n\n之后，我想hook上面的函数，结果遇到了frida检测。\n这次frida检测，我学到了以下几点：\n1.frida用旧一些的版本，最新的可能不稳定；\n2.把握好hook的时机，Interceptor.attach和Interceptor.replace的执行方式不同。attach是设置监控，监控目标地址，当执行到目标地址，才会启动对应的脚本内容；而replace是对目标地址立马进行替换，如果目标地址所在的模块尚未加载，会执行失败。\n以下是grok的回答。\n什么是“Hook 陷阱”？“Hook 陷阱”并不是一个官方术语，而是形象地描述了 Frida 在特定时机设置 Hook 的工作方式。简单来说，它就像在目标函数的调用路径上“埋下一个陷阱”，等待程序运行到那个位置时触发，而不是立即执行 Hook 逻辑。在 Frida 中，Hook 的实现主要通过 Interceptor 模块完成：    Interceptor.attach：附加到目标函数的入口和出口，分别在函数调用前（onEnter）和调用后（onLeave）执行自定义逻辑。    Interceptor.replace：直接替换目标函数的实现，用你定义的函数逻辑覆盖原始函数。“陷阱”的关键在于时机：    Hook 的设置（比如调用 Interceptor.attach 或 Interceptor.replace）是在你的 Frida JS 脚本运行时完成的。    Hook 的触发（比如执行 onEnter 或替换后的函数逻辑）则是在目标函数被实际调用时发生的。举个例子：javascriptInterceptor.attach(Module.getExportByName(&#x27;libc.so&#x27;, &#x27;open&#x27;), &#123;    onEnter: function(args) &#123;        console.log(&#x27;open 被调用了！&#x27;);    &#125;&#125;);    脚本运行时，Interceptor.attach 会“设置陷阱”，告诉 Frida 监控 open 函数。    但 onEnter 里的 console.log 并不会立即执行，而是等到程序调用 open 时才打印日志。这种“等待触发”的机制就是“Hook 陷阱”的核心。替换函数的时机：脚本运行后会第一时间替换吗？你提到：“将脚本跑起来后，它难道不是第一时间将 Native 层函数替换掉吗？”答案是不完全是。让我们详细分析一下。Frida 替换函数的工作原理使用 Interceptor.replace 可以替换 Native 层函数的实现。例如：javascriptInterceptor.replace(ptr(&#x27;0x12345678&#x27;), new NativeCallback(function() &#123;    console.log(&#x27;函数被替换了！&#x27;);    return 0;&#125;, &#x27;int&#x27;, []));    当脚本执行到 Interceptor.replace 时，Frida 会尝试将目标函数的地址替换为你的自定义函数。    但这有一个前提：目标函数所在的模块必须已经加载到内存中。时机的影响因素    模块是否已加载        如果你在脚本运行时要替换的函数属于某个动态加载的 .so 文件（比如 libexample.so），而这个文件在脚本启动时尚未加载，Frida 无法立即替换。        因为 Frida 需要知道模块的基址和函数的偏移量。如果 Process.findModuleByName(&#x27;libexample.so&#x27;) 返回 null，你就无法计算目标函数的地址，替换自然无法生效。    动态加载的场景        在 Android 中，很多 .so 文件是通过 dlopen（或 android_dlopen_ext）动态加载的。        如果你的目标函数在某个动态加载的模块中，你需要在模块加载后再执行替换操作。实际例子：你的代码可能的样子假设你想替换 libmsaoaidsec.so 中的某个函数 sub_1b924，代码可能是这样的：javascriptfunction hook_sub_1b924() &#123;    let module = Process.findModuleByName(&#x27;libmsaoaidsec.so&#x27;);    if (module) &#123;        let sub_1b924 = module.base.add(0x1b924);        Interceptor.replace(sub_1b924, new NativeCallback(function() &#123;            console.log(&#x27;sub_1b924 被替换了！&#x27;);            return 0;        &#125;, &#x27;int&#x27;, []));    &#125; else &#123;        console.log(&#x27;模块尚未加载！&#x27;);    &#125;&#125;    如果脚本运行时 libmsaoaidsec.so 还没加载，module 会是 null，替换不会生效。    你需要等待模块加载完成后再调用 hook_sub_1b924()。为什么不直接在脚本运行时替换？你可能会疑惑：为什么不直接在脚本启动时就完成所有替换？原因有以下几点：    模块未加载的问题        如上所述，如果目标模块没加载，Frida 无法找到函数地址，替换会失败。        解决办法是监控模块加载过程（比如 Hook android_dlopen_ext），在模块加载后再执行替换。    初始化逻辑的依赖        有些 .so 文件在加载后会执行初始化逻辑（比如通过 soinfo::call_constructors() 调用 .init 或 .init_array）。        如果你在初始化前替换函数，可能会干扰模块的正常初始化（比如反调试、校验逻辑），导致程序崩溃或行为异常。        通过在初始化开始前（比如 call_constructors 的 onEnter）替换函数，你可以更安全地介入。例如，一个常见的策略是：javascriptInterceptor.attach(Module.getExportByName(&#x27;libdl.so&#x27;, &#x27;android_dlopen_ext&#x27;), &#123;    onEnter: function(args) &#123;        this.onLeave = function(retval) &#123;            hook_sub_1b924(); // 在模块加载后替换函数        &#125;;    &#125;&#125;);    这里在 android_dlopen_ext 调用后（模块加载完成时）再执行替换，确保时机正确。总结：如何理解“Hook 陷阱”和替换时机    “Hook 陷阱”的含义        它是指在脚本运行时设置 Hook，但实际逻辑在目标函数调用时触发，就像“埋下陷阱”等待猎物。        比如通过 Interceptor.attach 设置的 onEnter 和 onLeave，都是在目标函数执行时才生效。    替换函数的时机        Interceptor.replace 在脚本运行时设置替换，但实际生效取决于模块是否加载。        如果目标函数所在的 .so 文件是动态加载的，你需要在模块加载后（比如通过 Hook android_dlopen_ext 或 soinfo::call_constructors()）再执行替换。    你的疑问解答        脚本运行后不会“第一时间”替换 Native 层函数，除非目标模块已经加载且函数地址可访问。        对于动态加载的模块，Frida 需要你手动控制替换时机，确保在正确的时间点介入。\n\n之后写的脚本如下。\nfunction hook_dlopen() &#123;    Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;),        &#123;            onEnter: function (args) &#123;                this.fileName = args[0].readCString()                console.log(`dlopen onEnter: $&#123;this.fileName&#125;`)                if (this.fileName !== undefined &amp;&amp; this.fileName.indexOf(&quot;libmsaoaidsec.so&quot;) &gt;= 0) &#123;                    hook_linker_call_constructors()                &#125;            &#125;, onLeave: function (retval) &#123;                console.log(`dlopen onLeave fileName: $&#123;this.fileName&#125;`)                if (this.fileName != null &amp;&amp; this.fileName.indexOf(&quot;libmsaoaidsec.so&quot;) &gt;= 0) &#123;                    let JNI_OnLoad = Module.getExportByName(this.fileName, &#x27;JNI_OnLoad&#x27;)                    Interceptor.attach(JNI_OnLoad, &#123;                        onLeave: function (retval) &#123;                            console.log(`JNI_OnLoad onLeave: $&#123;retval&#125;`)                        &#125;                        &#125;);                    console.log(`dlopen onLeave JNI_OnLoad: $&#123;JNI_OnLoad - Module.getBaseAddress(this.fileName)&#125;`)                &#125;            &#125;        &#125;    );&#125;function hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;)    let offset = 0x51BA8    // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset)    let listener = Interceptor.attach(call_constructors,&#123;        onEnter:function(args)&#123;            console.log(&#x27;hook_linker_call_constructors onEnter&#x27;)            let secmodule = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;)            if (secmodule != null)&#123;                // hook_pthred_create()                hook_sub_1c544() // 含检测                hook_sub_1b8d4()                // hook_sub_26e5c()                listener.detach()            &#125;        &#125;    &#125;)&#125;function hook_pthred_create()&#123;    console.log(&quot;libmsaoaidsec.so --- &quot; + Process.findModuleByName(&quot;libmsaoaidsec.so&quot;).base)    Interceptor.attach(Module.findExportByName(&#x27;libc.so&#x27;,&#x27;pthread_create&#x27;),&#123;        onEnter(args)&#123;            let func_addr = args[2]            console.log(`The thread Called function address is: $&#123;func_addr&#125;`)        &#125;    &#125;)&#125;function hook_sub_1c544() &#123;    let secmodule = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;)    Interceptor.replace(secmodule.base.add(0x1c544), new NativeCallback(function () &#123;      console.log(`hook_sub_1c544 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; replace`)    &#125;, &#x27;void&#x27;, [&quot;int64&quot;]));&#125;function hook_sub_1b8d4() &#123;    let secmodule = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;)    Interceptor.replace(secmodule.base.add(0x1b8d4), new NativeCallback(function () &#123;      console.log(`hook_sub_1b8d4 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; replace`)    &#125;, &#x27;void&#x27;, []));&#125;function hook_sub_26e5c() &#123;    let secmodule = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;)    Interceptor.replace(secmodule.base.add(0x26e5c), new NativeCallback(function () &#123;      console.log(`hook_sub_26e5c &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; replace`)      return 1;    &#125;, &#x27;int64&#x27;, []));&#125;setImmediate(hook_dlopen)\n\n逻辑算比较清楚，之后还剩下对业务函数的hook、利用_sig构造包。\n接着分析方法e0.d.A(Request request0)。\n\n然后写了这个函数，每次我将这个函数放到hook_dlopen的末尾，就无法正确hook上之前的3个线程。之后我发现，可以通过cmd行输入。\nfunction hook_sig()&#123;    Java.perform(function()&#123;        const clazz_d = Java.use(&quot;e0.d&quot;);        clazz_d.A.implementation = function (request) &#123;            console.log(`request-header: $&#123;request.header(&quot;Authorization&quot;)&#125;`);            return this.A(request);        &#125;    &#125;)&#125;\n\n结果如下。\n\n这里就获得了Authorization的值：93f4c257daea24dfbbde470790be6e9d。\n在方法d.z中，将url、method、authorization进行加密\n\n这里就不进去追踪了，直接获取返回值。\n直接获取了_sig和_ts的值。\nfunction hook_sig()&#123;    Java.perform(function()&#123;        const clazz_d = Java.use(&quot;e0.d&quot;);        clazz_d.A.implementation = function (request) &#123;            console.log(`request-header: $&#123;request.header(&quot;Authorization&quot;)&#125;`);            let res = this.A(request);            console.log(`Pair-first: $&#123;new String(res.first)&#125;\\nPair-second: $&#123;new String(res.second)&#125;`);            return res;        &#125;    &#125;)&#125;\n\n\n之后要利用并构造包的话，只需要添加上自己生成的_sig参数，这里用js脚本，模仿jeb的代码构造_sig，最终，完整的代码如下。\nvar url;var method;var authorization;function hook_dlopen() &#123;    let listener = Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;),        &#123;            onEnter: function (args) &#123;                this.fileName = args[0].readCString()                console.log(`dlopen onEnter: $&#123;this.fileName&#125;`)                if (this.fileName !== undefined &amp;&amp; this.fileName.indexOf(&quot;libmsaoaidsec.so&quot;) &gt;= 0) &#123;                    hook_linker_call_constructors()                    listener.detach()                &#125;            &#125;        &#125;    );    // hook_sig()&#125;function hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;)    let offset = 0x51BA8    // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset)    let listener = Interceptor.attach(call_constructors,&#123;        onEnter:function(args)&#123;            console.log(&#x27;hook_linker_call_constructors onEnter&#x27;)            let secmodule = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;)            if (secmodule != null)&#123;                // hook_pthred_create()                hook_sub_1c544()                hook_sub_1b8d4()                hook_sub_26e5c()                listener.detach()            &#125;        &#125;    &#125;)&#125;function hook_pthred_create()&#123;    console.log(&quot;libmsaoaidsec.so --- &quot; + Process.findModuleByName(&quot;libmsaoaidsec.so&quot;).base)    Interceptor.attach(Module.findExportByName(&#x27;libc.so&#x27;,&#x27;pthread_create&#x27;),&#123;        onEnter(args)&#123;            let func_addr = args[2]            console.log(`The thread Called function address is: $&#123;func_addr&#125;`)        &#125;    &#125;)&#125;function hook_sub_1c544() &#123;    let secmodule = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;)    Interceptor.replace(secmodule.base.add(0x1c544), new NativeCallback(function () &#123;      console.log(`hook_sub_1c544 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; replace`)    &#125;, &#x27;void&#x27;, [&quot;int64&quot;]));&#125;function hook_sub_1b8d4() &#123;    let secmodule = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;)    Interceptor.replace(secmodule.base.add(0x1b8d4), new NativeCallback(function () &#123;      console.log(`hook_sub_1b8d4 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; replace`)    &#125;, &#x27;void&#x27;, []));&#125;function hook_sub_26e5c() &#123;    let secmodule = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;)    Interceptor.replace(secmodule.base.add(0x26e5c), new NativeCallback(function () &#123;      console.log(`hook_sub_26e5c &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; replace`)      return 1;    &#125;, &#x27;int64&#x27;, []));&#125;function hook_sig()&#123;    Java.perform(function()&#123;        const clazz_d = Java.use(&quot;e0.d&quot;);        clazz_d.A.implementation = function (request) &#123;            authorization = request.header(&quot;Authorization&quot;);            authorization = authorization.substring(7);            url = request.url().toString();            method = request.method();            console.log(`request-header: $&#123;authorization&#125;`); // 打印Authorization            let res = this.A(request);            console.log(`Pair-first: $&#123;new String(res.first.value)&#125;\\nPair-second: $&#123;new String(res.second.value)&#125;`); // 打印Pair            // MySig，自己模仿流程写一个            getMySig();            return res;        &#125;    &#125;)&#125;function getMySig() &#123;    const HttpUrl = Java.use(&quot;okhttp3.HttpUrl&quot;);    const StringBuilder = Java.use(&quot;java.lang.StringBuilder&quot;);    const clazz_a = Java.use(&quot;android.support.v4.media.a&quot;);    const Uri = Java.use(&quot;android.net.Uri&quot;);    // 临时硬编码 s3    var s3 = Java.use(&quot;java.lang.String&quot;).$new(&quot;bf7dddc7c9cfe6f7&quot;);    if (!url || !method || !authorization) &#123;        console.error(&quot;url, method, or authorization is undefined&quot;);        return;    &#125;    var stringBuilder0 = clazz_a.g(method);    if (!stringBuilder0) &#123;        console.error(&quot;clazz_a.g(method) returned null&quot;);        return;    &#125;    var s4 = HttpUrl.parse(url).encodedPath();    if (!s4) &#123;        console.error(&quot;HttpUrl.parse failed&quot;);        return;    &#125;    var s5 = Uri.decode(s4);    if (s5.endsWith(&quot;/&quot;)) &#123;        s5 = clazz_a.e(s5, -1, 0);    &#125;    stringBuilder0.append(&quot;&amp;&quot;).append(Uri.encode(s5)).append(&quot;&amp;&quot;).append(authorization);    var v = Java.use(&quot;java.lang.System&quot;).currentTimeMillis().toString();    v = v.substring(0, v.length - 3);    stringBuilder0.append(&quot;&amp;&quot;).append(v);    var mac0 = Java.use(&quot;javax.crypto.Mac&quot;).getInstance(&quot;HmacSHA1&quot;);    mac0.init(Java.use(&quot;javax.crypto.spec.SecretKeySpec&quot;).$new(s3.getBytes(), &quot;HmacSHA1&quot;));    const Base64 = Java.use(&quot;android.util.Base64&quot;);    stringBuilder0.toString()    let strrr = stringBuilder0.toString();    console.log(`typeof strrr: $&#123;typeof strrr&#125;`);    let bytes = Java.use(&quot;java.lang.String&quot;).$new(strrr).getBytes();    console.log(`typeof Java.use(&quot;java.lang.String&quot;).$new(strrr): $&#123;typeof Java.use(&quot;java.lang.String&quot;).$new(strrr)&#125;`);    var res = mac0.doFinal(bytes);    var s6 = Base64.encodeToString(res, 2);    // 确保 s6 和 v 是正确的 Java 字符串    var pair = Java.use(&quot;android.util.Pair&quot;).$new(        s6, v);    console.log(`MySig: $&#123;pair.first&#125;`);    return pair;&#125;setImmediate(hook_dlopen)\n\n其中，有一个问题，如下代码卡了我很久。在我眼中，这里的strrr一定是一个js代理java的String类型，是一个属于java的字符串，但被frida自动转换成了JavaScript字符串，而JS字符串没有getBytes函数。\nstringBuilder0.toString()let strrr = stringBuilder0.toString();let bytes = Java.use(&quot;java.lang.String&quot;).$new(strrr).getBytes();// 原本写的是strrr.getBytes()\n\nhttps://reverseengineering.stackexchange.com/questions/32790/convert-string-to-byte-array-in-frida-js-script\n通过js的函数，typeof去查看区别，可以发现stringBuilder0.toString()的类型是string，而Java.use(“java.lang.String”).$new(strrr)的类型是object。\n\n至此，脚本也算是跑出了_sig签名。\n"},{"title":"类加载与脱壳机","url":"/2025/05/18/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E8%84%B1%E5%A3%B3%E6%9C%BA/","content":"自制脱壳机，将公开了源码的Fart6移植到Fart10，同时去除一些Fart特征。\nloadClass的过程loadClass的过程可以总结成：1.判断是否是当前类加载器加载了此类；2.若不是，让父加载器加载此类；3.若父加载器加载失败，由当前加载器加载。\n一般实现类加载，同时使用ClassLoader的实例调用loadClass。\n\n可以看到，ClassLoader.loadClass(String className)间接调用重载函数，resolve在这里不起作用，在JVM中，如果resolve为true，表示加载类之后是否需要立即进行链接操作中的解析步骤。（链接包括：验证、准备（分配空间）、解析），而在安卓虚拟机中，这里忽略resolve。\n\n\n1 findLoadedClass（ClassLoader）——查询当前加载器是否加载了目标类findLoadedClass是用来检查缓存的，这个方法会检查当前ClassLoader实例是否已经加载过名为className的类，每个ClassLoader实例都有一个缓存区，用来存放已经加载过的类。\n如果当前实例是启动类加载器，则将局部变量 loader 设为 null。这是因为查询启动类加载器加载的类通常需要通过 VM 的特殊 native 接口，并使用 null 来代表它。\n如果当前实例不是启动类加载器（比如是 AppClassLoader 或 PathClassLoader 等），则将 loader 设置为 this，即当前 ClassLoader 实例本身。\n\nfindLoadedClass（VMClassaLoader、JNI函数）这里的VMClassLoader.findLoadedClass是一个static的JNI函数，具体实现在native层，目录为：&#x2F;art&#x2F;runtime&#x2F;native&#x2F;java_lang_VMClassLoader.cc。\n这个 C++ 函数 VMClassLoader_findLoadedClass 的核心目的是：接收一个 Java 层的 ClassLoader 对象和一个类名字符串，然后在 ART 虚拟机内部的数据结构中查找，判断这个特定的 ClassLoader 是否已经加载并解析了具有该名称的类。如果找到了并且类是可用状态（已解析），就返回对应的 Java Class 对象 (jclass)；否则返回 nullptr。\n现在来简单解释一下下图的函数VMClassLoader_findLoadedClass。\n第31行，env是标准的JNI的接口，提供java与native之间的交互。soa可以理解为ART对JNI交互的封装与简化，它的底层还是使用env来工作，但自动管理线程状态，更安全、方便。\n第32行，将Java层的jobject javaLoader解码成ART内部表示的mirror::ClassaLoader*指针loader，这里的mirror是ART中表示Java堆对象的类的命名空间。\n第33行，将javaName从java的jstring转换成c&#x2F;c++使用的UTF-8编码字符串。\n第37行，获取ClassLinker实例，ClassLinker实例要负责类的加载、链接（验证、准备、解析）、初始化。所有类查找、类定义、解析相关的操作，都要经过ClassLinker。\n第38行，将点分格式的类名转换成虚拟机内部使用的描述符，即斜杠格式。\n第39行，将类描述符转换成唯一的哈希值。\n第40行，根据哈希值、loader、类描述符、当前的线程（soa.Self()返回线程Thread指针），来去找*唯一的类。\n这里重点关注LookupClass。\n\n\nLookupClass在LookupClass中。\n第一阶段，查主表。（缓存查找）\n使用 ReaderMutexLock 获取对 ClassLinker 内部类表的读取锁，保证线程安全。\n调用 LookupClassFromTableLocked 在主要的类表（包括 Zygote 预加载表 pre_zygote_class_table_ 和运行时表 class_table_）中查找。\n如果在表中找到了匹配的类 (result != nullptr)，就立即返回结果。锁会自动释放。\n第二阶段，查启动镜像（启动类加载器）。\n仅当第一阶段失败、查找的是启动类加载器 (class_loader == nullptr)、且需要查找镜像时，才执行这里。\n调用 LookupClassFromImage(descriptor) 尝试在 dex_caches_ 中查找。\n如果找到了 (result != nullptr): 调用 InsertClass 将其加入主类表（可能是 class_table_），起到缓存作用，然后返回找到的 result。\n如果还没找到 (result == nullptr): 增加查找镜像失败的计数器。如果失败次数超过阈值 (kMaxFailedDexCacheLookups)，则触发一个优化操作 MoveImageClassesToClassTable()，将所有启动镜像中的类都添加到主类表中，以加速后续查找。最后返回 nullptr。\n\nLookupClassFromTableLocked在LookupClassFromTableLocked中，pre_zygote_class_table_记录着预加载的类（Zygote进程在创建时，初始化了虚拟机并加载了一系列预加载的动态链接库，这些动态链接库里的类记录在这个预加载类表里）。而class_table_则是动态类表，它存储了 Zygote 之后由各种 ClassLoader 加载的类，以及从启动镜像（image）查找到并缓存起来的类。\n\nLookupClassFromImage函数LookupClassFromImage是从启动类加载器的dex_cache中找目标类，DexCache类用于关联DexFile对象。\n\n\n\n2 parent.loadClass——委托父加载器加载上述流程已经把如何寻找一个类讲得很详细了，接下来讲委派双亲机制。\n下图中，在findLoadedClass找不到className后，就会尝试执行parent.loadClass，让父加载器去加载，父加载器的执行流程也是：findLoadedClass、parent.loadClass、findClass。\n所以，这里不细讲委派机制（双亲委派机制不难），直接讲如何加载一个未加载的类。\n\n\n3 findClass——自己加载这里分析的是BaseDexClassLoader的findClass，一般整体壳都绕不开BaseDexClassLoader，BaseDexClassLoader的父类是ClassLoader，我们之前分析的findLoadedClass和parent.loadClass都是ClassLoader类中，loadClass里出现的函数。BaseDexClassLoader并没有实现自己的loadClass，所以loadClass都是从ClassLoader继承过来的。\n但ClassLoader的findClass已经被BaseDexClassLoader覆写了，我们这里就需要分析findClass。\nfindClass 函数的核心职责就是：在当前 ClassLoader 管理的一系列 Dex 文件中，按顺序查找指定的类，如果找到，就加载并定义它。\n下图中，pathList是个老熟人了。\n\npathList——属于类DexPathListpathList是BaseDexClassLoader声明的一个DexPathList类型的私有成员变量。\n\n关于DexPathList，从字面上来看，它是存储Dex路径列表的一个变量，从功能上来说，它存储的路径包括：apk的路径、dex的路径、jar的路径、class的路径等。然而，类DexPathList存储路径的列表（成员变量）叫dexElements，这一度让我以为——“一个Element实例代表一个Dex文件路径”，这个概念其实是错的。\n通过注释，其实可以知道，这个成员变量应该叫pathElements，结果因为Facebook app改了名字，What can I say。\n纠正一下上面的概念，这里的dexElements是一个Element数组，每个Element实例存储的是一个路径，这个路径要是指向apk，可能包含不止一个Dex，所以一个Element实例代表一个Dex文件路径的概念是错误的。\n\n\n接着看看DexPathList的findClass。\n可以看到，这里取出了每个Element实例，并取出了element.dexFile赋给dex，然后调用了dex.loadClassBinaryName去找目标类是否在当前的文件（apk&#x2F;dex&#x2F;jar&#x2F;class）中。\n\ndexElements——属于类Element类Element是定义在DexPathList的静态内部类，从成员变量中可以看出，它存储的类型有apk&#x2F;zip&#x2F;dex等，还有一个很关键的成员变量dexFile。\n\n\nmCookie——属于类DexFileDexFile的mCookie很重要，在native层中，通过相关函数的调用，可以利用mCookie去获取DexFile（可以理解为PathFile）里存放的所有Dex文件。\n\n\n阅读DexFile.java中的代码，会发现mCookie的值由jni函数openDexFileNative获得。\n\n\n\njava层openDexFileNative对应着native层的DexFile_openDexFileNative。\n第154-161行，将输入的jstring转换成c&#x2F;c++的const char*来使用。\n第163行，获取ART运行时的ClassLinker实例，打开Dex文件和处理OAT文件是ClassLinker的职责之一。\n第164行，创建一个std::vector，用于存放成功打开的DexFile对象。\n第165行，创建error_msgs用于收集打开过程中可能出现的错误信息。\n第167行，可以理解为OpenDexFilesFromOat将已打开的Dex文件(们)的内部句柄打包成一个long[]数组，返回给dex_files。\n第170行，将这些句柄从native类型转换成JNI类型，赋值给array，array会通过return赋给Java层的mCookie。\n\n\n于是我们知道了，mCookie是已打开的Dex文件们的句柄数组指针。\nloadClassBinaryName——属于类DexFile回到这张图，讲DexFile的loadClassBinaryName。\n\n直接跳转到defineClass。\n\n再跳转到defineClassNative。\n\n\ndefineClassNative是一个静态JNI函数。\n第220行，眼熟吧，将cookie转换回了dex_files句柄数组。\n第234行，遍历每一个打开的Dex文件句柄。\n第235行，通过函数FindClassDef，去每个Dex文件里寻找目标Class是否存在。\n第236行，如果存在，则通过ClassLinker的实例class_linker，对这个Dex文件进行注册，加入dex_caches。\n\nFindClassDef——找到类定义这个函数的核心目的是：在当前的 DexFile 对象所代表的 Dex 文件内部，根据给定的类描述符 (descriptor) 字符串和其哈希值，查找并返回对应的 DexFile::ClassDef 结构体指针。\n其中，第481-485行，在解析一个Dex文件，获得Class的数量。\n第486-499行，遍历类定义表，根据类定义结构的class_idx_是指向type索引表，这里通过描述符descriptor获取到了type_idx，然后和每个类的class_idx_进行比较，以此找出类。\n\n\n下图是ClassDef的结构。\n\n\nRegisterDexFile——将DexFile加入缓存dex_cache会被加入ClassLinker中的dex_caches_中（通过dex_caches_.push_back），ClassLinker会通过这个列表跟踪所有已注册的Dex缓存，建立了dex_cache和dex_file之间的连接（dex_cache-&gt;SetDexFile(&amp;dex_file)）。\n这个过程确保了每个被 ART 管理的 Dex 文件都有一个对应的 DexCache，并且 ClassLinker 能够找到并管理这些缓存。\n\n\nDefineClass——类的加载、链接、初始化这个函数是实际定义一个新类的核心逻辑。它接收一个在 dex_file 中找到的类定义 dex_class_def，以及要使用的 class_loader，然后负责创建对应的运行时 mirror::Class 对象，并执行加载和链接的关键步骤。\n\n\n第1816行-1829行，处理特殊的类。\n第1831-1841行，分配内存创建Class对象。\n第1842行，将DexFile对应的DexCache设置到Class对象中。\n第1844行，用ClassDef和ClassLoader信息填充Class对象。\n第1847-1850行，为String类专门进设置标志。——没深入分析。\n第1853-1854行，获得这个类的锁，防止并发初始化，记录当前线程为类的初始化线程。\n\n第1857行，根据描述符、Class对象.Get()、类描述符的hash值插入一个新加载的类到类表class_table_中。\n第1858-1862行，插入失败，说明被其它线程插入了，使用已存在的Class对象并确保它已经被解析。\n第1868-1876行，加载类的成员（字段和方法信息），如果失败，标志Class状态为Error。\n第1878-1879行，此时类状态应该为Loaded（成员已经加载，但父类&#x2F;接口未连接）。\n第1880行，加载并链接父类和接口。\n第1894行，执行链接（验证、准备、解析字段&#x2F;方法、设置vtable&#x2F;iftable等）。\n\n最后返回的是一个定义并链接好的Class对象。\n\n\n整个逻辑如下图所示。\n\n\n（注：说明一下，Java的DexFile类和C&#x2F;C++的DexFile类不一样，Java的DexFile通常指向一个APK文件或JAR文件或Dex文件等等，所以一个DexFile类可能会存储着许多个Dex文件；而C&#x2F;C++的DexFile类指向一个Dex文件）\n一个 Java DexFile 对象虽然是基于一个单一的源文件路径 (APK&#x2F;JAR) 创建的，但它内部通过 mCookie (一个 long[] 数组) 可以管理从该源文件或其对应的 OAT 文件中加载出来的一个或多个底层的 C++ art::DexFile 实例。这对于支持 Android 的 MultiDex 机制至关重要。\nFart的逻辑Fart脱壳的步骤主要分为3步：\n1.找到合适的点，通过DexFile结构脱下完整的dex；\n2.主动调用类中的每一个方法，并实现对CodeItem的dump；\n3.修复Dex。\n整体壳下图是Fart的第1点的逻辑。\n一个类的初始化函数是不会被直接编译成OAT代码的，而一个Java的Method，除了走OAT代码模式，就必须走解释器模式，解释器模式必须经过函数Execute，因此，可以在Execute里针对进行dump，以完成整个dex的dump。\n\n抽取壳下图是Fart的第2点逻辑。\n\n之后，又有人写了一个FartExt，逻辑如下。\n\n","tags":["安卓逆向 类加载 Fart"]},{"title":"算法逆向分析初识","url":"/2025/05/18/%E7%AE%97%E6%B3%95%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%88%9D%E8%AF%86/","content":"hellojni_2.0.7.apk目标：还原signs的加密算法。\n点击SIGN2按钮后，下面这个签名会发生改变。\n\n\n通过定位，发现这个签名是由JNI函数Java_com_example_hellojni_HelloJni_sign2生成的。\n进一步，对其中的sub_1CFF0进行hook，发现其第3个参数（从1开始算）便是签名。\n\n\nhook的代码如下，将其中的addr赋值为1CFF0即可。\nfunction hook_find_target_address(addr)&#123;    var base = Module.findBaseAddress(&quot;libhello-jni.so&quot;);    console.log(&quot;\\r\\nlibhello-jni.so Baseaddr: &quot; + base);    var target_addr = base.add(addr);    console.log(&quot;\\r\\nTarget Address: &quot; + target_addr);    // hook并打印参数和返回值    Interceptor.attach(target_addr, &#123;        onEnter(args)&#123;            this.arg0 = args[0];            this.arg1 = args[1];            this.arg2 = args[2];            console.log(&quot;\\r\\nsub_&quot; + addr.toString(16) + &quot;args: &quot;);            console.log(&quot;\\r\\ninput_str: \\r\\n&quot; + hexdump(this.arg0));            console.log(&quot;\\r\\ninput_str_length: &quot; + this.arg1);        &#125;,        onLeave(retval)&#123;            console.log(&quot;\\r\\noutput_str: \\r\\n&quot; + hexdump(this.arg2));        &#125;    &#125;)&#125;\n\n打印的结果如下图所示。\n\n\n为了方便分析，这里需要将input_str和input_str_length进行固定。\n如图所示，我将输入字符串固定为”1234567890abcdefg”。\nfunction hook_find_target_address(addr)&#123;    var base = Module.findBaseAddress(&quot;libhello-jni.so&quot;);    console.log(&quot;\\r\\nlibhello-jni.so Baseaddr: &quot; + base);    var target_addr = base.add(addr);    console.log(&quot;\\r\\nTarget Address: &quot; + target_addr);        // hook并打印参数和返回值    Interceptor.attach(target_addr, &#123;        onEnter(args)&#123;            // 保存原始参数值以便打印            this.arg0 = args[0];            this.arg1 = args[1];            this.arg2 = args[2];                        console.log(&quot;\\r\\nsub_&quot; + addr.toString(16) + &quot; args: &quot;);            console.log(&quot;\\r\\n原始input_str: \\r\\n&quot; + hexdump(this.arg0, &#123; length: parseInt(this.arg1) &#125;));            console.log(&quot;\\r\\ninput_str_length: &quot; + this.arg1);                        // 新字符串            var new_str = &quot;1234567890abcdefg&quot;;                        // 方法1：直接写入内存            Memory.writeUtf8String(args[0], new_str);                        // 方法2：如果需要写入二进制数据而不是UTF8字符串            // var bytes = [0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x00]; // &quot;1234567890abcdef\\0&quot;            // Memory.writeByteArray(args[0], bytes);                        var length = new_str.length;            args[1] = ptr(length);            this.args1 = args[1];            console.log(&quot;\\r\\n修改后的长度: &quot; + this.args1);            console.log(&quot;\\r\\n修改后input_str: \\r\\n&quot; + hexdump(args[0], &#123; length: parseInt(this.args1) &#125;));        &#125;,        onLeave(retval)&#123;            console.log(&quot;\\r\\noutput_str: \\r\\n&quot; + hexdump(this.arg2, &#123; length: parseInt(this.args1) &#125;));        &#125;    &#125;);&#125;\n\n\n\n在确保了输入字符串不变后，尝试使用IDA的trace，追踪函数sub_1CFF0。\n先注入frida、再注入IDA server——似乎不按这个顺序，先注入IDA再注入Frida，Frida会注入失败。\n我决定先退出Frida的hook，再进行追踪，因为我发现Frida要是已经hook了sub_1CFF0，在sub_1CFF0的函数开始的地方，会存在inline hook，跳转到Frida的跳床函数。\n\n\n通过IDA trace，走过的汇编指令会变成黄色。\n\n追踪到的内容如下图所示，第一栏的36EE是线程id，第二栏是地址，第三栏开始就是汇编指令了，如果汇编指令修改了寄存器，则会在汇编指令后面，显示寄存器被修改后的值。\n\n之后，我重新生成了一个trace记录，并记录了一下签名值。\n\n\n之后进行算法逆向。\n已知算法的输入是input_str &#x2F; input_str_length &#x2F; output_str，分别代表着X0、X1、X2。\n\n因为X2代表着output_str的内存地址，所以追踪X2，判断有哪些指令对地址0x00000079E1720D90上的内容进行了修改。\n\n\n查找到了34个对0x00000079E1720D90进行读写的位置。\n对其中一些指令进行还原，可以猜到。\nX8代表：当前正在操作output的第X8个字节，也代表循环次数；\nX5代表output的内存地址；\nX29[var_64]是一个固定字节数组。\nX29[var_68]也是一个固定字节数组。\n至于var_6C，最后还是追踪到var_68上。\n\n做了一些补充。\n\n一直追踪[X29,#var_64]。\n\n而一直追踪[X29,#var_68]，会发现需要追踪X2，继而追踪X2和X3，继而追踪X3和X7……\n最后追踪到[X29,#var_88]。\n\n最后发现，var_88这个变量是一个指针，它将地址给了X2，由X2去获取全局变量，也就是图中的xmmword_79A31EE7B0。\n\n至此，可以将全局变量及涉及到的寄存器改写成c。\n(解密的时候前8个字节和后8个字节的处理方式不同，可能还得逆，这里我直接贴别人逆好的代码)\n#include &lt;iostream&gt;#include &lt;cstring&gt;void enc_function(const char* input_str, int input_len, char* result) &#123;    const char* table_key1 = &quot;9d9107e02f0f07984956767ab1ac87e5&quot;;    const unsigned char table_key2[] = &#123;0x37, 0x92, 0x44, 0x68, 0xA5, 0x3D, 0xCC, 0x7F, 0xBB, 0xF, 0xD9, 0x88, 0xEE, 0x9A, 0xE9, 0x5A&#125;;    for (int i = 0; i &lt; input_len; ++i) &#123;        unsigned char X2 = input_str[i];        unsigned char key2 = table_key2[(i &amp; 0xF) &amp; 0xFFFFFFFF];        unsigned char W8 = 0xDA;        unsigned char W30 = 0x25;        unsigned char W2 = X2;        unsigned char W7 = W8 &amp; (~W2);        W2 = W2 &amp; 0x25;        W2 = W7 | W2;        unsigned char W3 = key2;        W7 = W8 &amp; (~W3);        W3 = W3 &amp; W30;        W3 = W7 | W3;        W2 = W2 ^ W3;        W3 = W2;        unsigned char key1 = table_key1[(i ^ 0xFFFFFFF8) &amp; i ];        W2 = key1;        W7 = key2;        W30 = key2;        unsigned char W1 = W2 &amp; (~W3);        W3 = W3 &amp; (~W2);        unsigned char W5 = W30 &amp; (~W2);        W2 = W2 &amp; (~W30);        W1 = W1 | W3;        W2 = W5 | W2;        W1 = W1 + W7;        W3 = W1 &amp; (~W2);        W1 = W2 &amp; (~W1);        W1 = W3 | W1;        result[i] = W1;    &#125;&#125;bool test_eq(const char* buf1, const char* buf2, int buf_len) &#123;    for (int i = 0; i &lt; buf_len; ++i) &#123;        if (buf1[i] != buf2[i]) &#123;            return false;        &#125;    &#125;    return true;&#125;int main() &#123;    const char* input = &quot;0123456789abcdef0123456789abcdef&quot;;    int len = strlen(input);    char* result = (char*)malloc(len);    memset(result, 0, len);    enc_function(input, len, result);    for (int i = 0; i &lt; len; ++i) &#123;        printf(&quot;%02x&quot;, (unsigned char)result[i]);    &#125;    printf(&quot;\\r\\n%x&quot;, test_eq(result, result, len));    free(result);    return 0;&#125;\n"},{"title":"实现对目标函数行为分析的脚本（frida）","url":"/2025/05/19/%E5%AE%9E%E7%8E%B0%E5%AF%B9%E7%9B%AE%E6%A0%87%E5%87%BD%E6%95%B0%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90%E7%9A%84%E8%84%9A%E6%9C%AC%EF%BC%88frida%EF%BC%89/","content":"Frida_BehaviorTrace场景：在native层遇到一个特别复杂的函数时，比方说被vmp保护的函数，若是难以通过静态分析工具去分析它的逻辑，那可以尝试hook一些libc的函数、JNI的函数观察它的行为。ps：这个脚本就做了这么一个事情。\n使用方法1.根据自己的需求，修改hook时机，当前脚本的hook时机是：linker64的call_constructor执行前。\n2.选定完hook时机后，调用hook_main_target_function_for_tracing()。ps：我之所以选择在执行完sub_88060再执行，是因为sub_88060会对某些函数进行解密，请大家自行修改。\n3.修改目标so和目标函数————修改TARGET_MODULE_NAME和TARGET_FUNCTION_OFFSET。\n4.添加要关注的自定义函数的偏移————往CUSTOM_FUNCTION_OFFSETS添加想要关注的自定义函数。\n5.添加要关注的libc的函数，修改参数解析的代码————往LIBC_FUNCTIONS_TO_HOOK添加要关注的libc函数，同时修改参数解析。\n6.添加要关注的JNI函数，修改参数解析部分的代码———往函数hook_libart()中添加要关注的JNI函数，同样，注意修改参数解析。\n7.启动脚本————frida -U -f &lt;包名&gt; -l trace_behavior.js\n使用案例比方说，我要追踪libbaiduprotect.so的sub_409E0，追踪它的行为。\n\nsub_409E0调用了sub_29030、sub_290DC…还调用了一些JNI函数。\n在我根据使用方法修改了脚本后，执行的效果是这样的。\n\n缩进代表函数调用的层级关系，这样子可以清晰看见目标函数执行了哪些自定义函数、Libc、JNI函数。\n结语链接：https://github.com/X14Nuy/Frida_BehaviorTrace\n大模型真厉害，一下子把我的思路变成代码了，哈哈哈。\n"},{"title":"某咖啡app协议字段分析——sign、q","url":"/2025/05/21/%E6%9F%90%E5%92%96%E5%95%A1app%E5%8D%8F%E8%AE%AE%E5%AD%97%E6%AE%B5%E5%88%86%E6%9E%90%E2%80%94%E2%80%94sign%E3%80%81q/","content":"分析流程首先打开JEB观察分析结果，看到存在com.qihoo.util，说明是数字壳。\n从Manifest可以知道，包名是com.lucky.luckyclient。\n接下来先进行脱壳，我之前刷了一个aosp10的脱壳机，正好试试。\n脱壳将app装入脱壳机，在某个指定文件中输入该app的包名，等待脱壳完毕即可。\n\n将脱完后的内容放入jadx，已经可以看到很多java层的代码了。\n\n\n接下来尝试抓包，我抓包工具还挺多的，reqable或Charles都行，试试Charles好了。\n抓包先观察电脑ip。\n\n\n将手机连上同一个局域网，并将代理设置为主机的ip，端口则填Charles监听的端口。——因此，代理地址是192.168.1.188:9999。\n\n\n\n\n要分析的这个请求是为了获得AuthCode（授权码），根据网上的博客，接下来开始分析sign和q字段的加密流程。\n\n\n分析加密流程sign在jadx直接搜索sign，观察是否能直接找到关于字段sign的代码，事实证明，并不可以。\n\n一般在开发中，存储字段会使用到标准sdk的HashMap，因此，接下来可以hook HashMap的put，观察进程是否会调用HashMap.put将sign字段存储起来。\nfunction call_HashMap() &#123;    Java.perform(function () &#123;        var hashMap = Java.use(&quot;java.util.HashMap&quot;);        hashMap.put.implementation = function (a, b) &#123;            if (a != null &amp;&amp; a.equals(&quot;sign&quot;)) &#123; console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new()))                console.log(&quot;hashMap.put: &quot;, a, b);            &#125;            return this.put(a, b);        &#125;    &#125;)&#125;\n\n打印的结果如下。\n\n很自然地，通过调用方法栈，我们下一个分析的点就是 getRequestParams。\n将 com.lucky.lib.http2.AbstractLcRequest.getRequestParams 拿到jadx中搜一搜。\n\n\n结合我们之前打印的结果，StubApp.getString2 在把字符串解密后，返回值字符串。\nhook一下，查看返回值，代码如下。\nfunction get_str(num)&#123;    Java.perform(function()&#123;        const StubApp = Java.use(&quot;com.stub.StubApp&quot;);        console.log(&quot;[num] &quot;, num, &quot; -&gt; &quot;, &quot;[decrypt_str] &quot;, StubApp.getString2(num));    &#125;)&#125;\n\n打印的结果如下。\n\n\n在jadx中加点注释。\n\n我们的目标是 sign，它的值是这样得来的，也就是说，要先获得cid、uid、q的值。\nC9267r.m20563a(cid, uid, q2)\n\n直接写脚本获取cid、uid、q，我们的目标是分析 sign 的加密流程。\nJava.perform(function() &#123;    const R = Java.use(&quot;com.lucky.lib.http2.r&quot;);    R.a.implementation = function(cid, uid, q)&#123;        console.log(&quot;[cid] &quot;, cid);        console.log(&quot;[uid] &quot;, uid);        console.log(&quot;[q] &quot;, q);        var res = this.a(cid, uid, q);        return res;    &#125;&#125;);\n\n执行后报错了，说是找不到类 com.lucky.lib.http2.r，可能是因为Frida使用的类加载器不对？经过尝试，这个类并不是一开始就加载的类，类未加载的时候hook不上。\nfunction get_cid_uid_q()&#123;    Java.perform(function() &#123;        Java.enumerateClassLoaders(&#123;            onMatch: function(loader) &#123;                try &#123;                    // 尝试使用当前 loader 加载类，不要设置全局 loader                    const R = Java.use(&quot;com.lucky.lib.http2.r&quot;, &#123; classLoader: loader &#125;);                    // console.log(&quot;[SUCCESS] Found com.lucky.lib.http2.r with loader: &quot; + loader);                        R.a.overload(&#x27;java.lang.String&#x27;, &#x27;java.lang.String&#x27;, &#x27;java.lang.String&#x27;).implementation = function(cid, uid, q) &#123;                        console.log(&quot;[Hooked R.a] Reached!&quot;);                        console.log(&quot;[cid] &quot;, cid);                        console.log(&quot;[uid] &quot;, uid);                        console.log(&quot;[q] &quot;, q);                            // 暂时不要调用原始方法，先看hook本身是否稳定                        //console.log(&quot;Original method R.a will not be called for now to test stability.&quot;);                        var res = this.a(cid, uid, q);                        console.log(&quot;[res from &quot; + loader + &quot;] &quot;, res);                        return res;                            // 根据原始方法的返回类型返回一个默认值，如果是void则不需要返回                        // 如果不知道返回类型，可以暂时返回 null                        return null;                    &#125;;                    // 如果希望只hook一次，可以在这里添加逻辑停止枚举或标记已hook                &#125; catch (e) &#123;                    console.log(&quot;[FAIL] Could not find com.lucky.lib.http2.r with loader: &quot; + loader);                    // 如果错误不是 ClassNotFoundException，打印出来看看                    if (!e.message.includes(&quot;java.lang.ClassNotFoundException&quot;)) &#123;                        console.error(&quot;Error while trying to use class with loader &quot; + loader + &quot;: &quot; + e);                    &#125;                &#125;            &#125;,            onComplete: function() &#123;                console.log(&quot;Class loader enumeration complete.&quot;);            &#125;        &#125;);    &#125;);&#125;setImmediate(get_cid_uid_q);\n\n等待一段时间，等到类加载了再进行hook即可。\n\ncid、uid基本是不变的（除非换账号、删缓存），唯一会变的是q。\n\n之后分析的时候，需要将q固定，这里先不动它。\n点进 C9267r.m20563a(cid, uid, q2) 查看，大致逻辑可以总结成下面这个式子，key和value代入uid、cid、q即可。\nC9247c.f237976b.m20087a(&quot;&lt;key&gt;=&lt;value&gt;;&lt;key&gt;=&lt;value&gt;;&lt;key&gt;=&lt;value&gt;;&quot;);\n\n\n点进 C9247c.f237976b.m20087a 查看。\n\n观察 this.f237669e.mo15913a ，this代表对象，f237669e 是this对象的接口对象，通过这个接口对象调用接口中声明的方法。\n\n\n\n\n如果想hook一个接口或者抽象方法，需要找到实现的地方进行hook，这跟frida是如何hook java层方法的原理有关。——简单来说，一个Java方法对应一个ArtMethod，我们要找到实现Java方法的ArtMethod，抽象方法和接口都没有实际的CodeItem。\n因此，我们要找到实现了这个接口的类，但是，这又有一个问题，CryptoHelper似乎并没有继承其它的类，没有间接实现接口的可能；那还有两个可能：一是赋值的时候用匿名类，在赋值的时候，同时实现了接口；二是定义一个实现好了接口的类，然后作为参数传能够给赋值 f237669e 的方法。\n\n交叉引用这个接口对象 f237669e，可以注意到，只有构造函数和方法m20086a可能为接口对象赋值了。\n\n交叉引用方法m20086a，会发现：没有任何被Java层代码调用的地方，那这个函数可能是在native层被调用了（通过FindClass、CallStaticMethod等函数调用），所以在jadx中查不到。\n接着交叉引用构造函数，这回有收获了。\n\n分别去查看C8118a、C9123b等类，查看它们关于接口的实现方式，结果如下。\nC8118a的实现。\n\n\n可以注意到，有点像base64编码（但标准的base64没有_符号），去试试解码。——试了后发现，都是不可显示的字符，用Hex也没看出什么特征。\n\n\n之后发现，这里面的_需要换成&#x2F;，不过之后再说吧。\nC9123b的实现。\n\n\nC9234b的实现有点绕。\n继续追踪f237975a。\n\n\n根据交叉引用，它只会通过方法m20437c得到值，因此继续追踪方法m20437c。\n\n\n查看成员变量f238026j，进行交叉引用。\n\n\n发现它只会在方法m20538g进行调用，继续交叉引用。\n\n\n因此，C9234b的实现是这样的。\n\n\nC11110a的实现。\n\nC11112c的实现。\n\n回到方法 m20087a。\nmd5_crypt( str.getBytes(), num)，这里的num是0&#x2F;1&#x2F;2中的一个，大概率是1，因为根据上述解密，似乎其它的类似base64编码的字节码，在解码后是不可视的字节码？无法和coffee、tea进行比较。\n\n这里的md5_crypt是native函数，不妨hook一下，看看i2的值是什么。\n\n\n代码如下。\nfunction hook_md5_crypt()&#123;    Java.perform(function() &#123;        const CryptoHelper = Java.use(&quot;com.luckincoffee.safeboxlib.CryptoHelper&quot;);        CryptoHelper.md5_crypt.implementation = function(arr, i2)&#123;            console.log(`--- md5_crypt called ---`);            console.log(`[i2] $&#123;i2&#125;`);            console.log(`[bArr] byte array of length $&#123;arr.length&#125;`);            // 遍历字节数组，并尝试转换为ASCII字符            let hexString = &#x27;&#x27;;            let asciiString = &#x27;&#x27;;            const bytesPerLine = 16; // 每行显示的字节数，方便查看            for (let i = 0; i &lt; arr.length; i++) &#123;                const byte = arr[i];                // 将有符号字节转换为无符号整数 (0-255)                const unsignedByte = byte &amp; 0xff;                // 将字节值转换为十六进制字符串，方便对比                hexString += unsignedByte.toString(16).padStart(2, &#x27;0&#x27;) + &#x27; &#x27;;                // 判断是否为可打印的ASCII字符 (通常范围是 32 到 126)                if (unsignedByte &gt;= 32 &amp;&amp; unsignedByte &lt;= 126) &#123;                    asciiString += String.fromCharCode(unsignedByte);                &#125; else &#123;                    // 如果不是可打印字符，用点或其他符号代替                    asciiString += &#x27;.&#x27;;                &#125;                // 每隔 bytesPerLine 打印一行，或者在数组结束时打印剩余部分                if ((i + 1) % bytesPerLine === 0 || i === arr.length - 1) &#123;                    // 为了对齐，给较短的行添加空格填充                     while (hexString.length &lt; bytesPerLine * 3) &#123; // 2 chars + 1 space per byte                        hexString += &#x27; &#x27;;                    &#125;                    console.log(`  $&#123;hexString&#125; | $&#123;asciiString&#125;`);                    hexString = &#x27;&#x27;;                    asciiString = &#x27;&#x27;;                &#125;            &#125;            console.log(`--- Calling original md5_crypt ---`);            // 调用原始的 native 方法并返回结果            const result = this.md5_crypt(arr, i2);             console.log(`--- Original md5_crypt returned ---`);            return result;        &#125;;    &#125;);&#125;setImmediate(hook_md5_crypt);\n\n如果多截几张图，就会发现，i2基本恒为1，符合我们的猜测，bArr数组其实就是cid、q、uid放在一块。\n\n\n接下来进入native层分析md5_crypt对应的函数，将libcryptoDD.so放入IDA中。\n\n进来后，先来看看导出表，我们的目标大概率是android_native_md5。\n同时，发现存在很多.datadiv_decodexxxxxx的函数，应该是解密字符串用的。\n\n基本都在.init_array段上，先不着急分析了，先写个脚本，将解密后的so文件进行dump，这样便于之后的分析。\n\n最后一个datadiv函数的地址是0x1B61C。可以在hook这个函数的onLeave回调进行dump。\n我靠，我写好了脚本，尝试了好多遍为什么一dump就“非法指令”退出，突然想起来，”libcryptoDD.so”是32位的so，不仅要修改linker64 -&gt; linker，还需要修改call_constructor的偏移量。\n但似乎改了后，还是会崩溃，那就应该是有反调了，但我没注意反调在哪，跑了挺久，也没退出，可能是对某些关键函数的hook做了检测吧，之后再去找找看。\n\n既然这样，不在第一时间dump了，等so文件稳定了再dump。\nvar module_name = &quot;libcryptoDD.so&quot;; // 可选：目标库名称，用于过滤function hook_dlopen() &#123;    var dlopenPtr = Module.findExportByName(null, &quot;dlopen&quot;);    if (!dlopenPtr) &#123;        console.error(&quot;[!] dlopen not found.&quot;);        return;    &#125;    console.log(&quot;[+] Hooking dlopen at &quot; + dlopenPtr);    Interceptor.attach(dlopenPtr, &#123;        onEnter: function(args) &#123;            var libraryPath = Memory.readUtf8String(args[0]);            console.log(&quot;[dlopen] Loading library: &quot; + libraryPath);            if (libraryPath.includes(module_name)) &#123;                console.log(&quot;[!] Target library &quot; + module_name + &quot; loaded, exiting...&quot;);                Process.exit(0);            &#125;        &#125;    &#125;);&#125;function hook_android_dlopen_ext() &#123;    var androidDlopenExtPtr = Module.findExportByName(null, &quot;android_dlopen_ext&quot;);    if (!androidDlopenExtPtr) &#123;        console.error(&quot;[!] android_dlopen_ext not found.&quot;);        return;    &#125;    console.log(&quot;[+] Hooking android_dlopen_ext at &quot; + androidDlopenExtPtr);    Interceptor.attach(androidDlopenExtPtr, &#123;        onEnter: function(args) &#123;            var libraryPath = Memory.readUtf8String(args[0]);            var flags = args[1].toInt32();            console.log(&quot;[android_dlopen_ext] Loading library: &quot; + libraryPath + &quot;, flags: 0x&quot; + flags.toString(16));            if (libraryPath.includes(module_name)) &#123;                console.log(&quot;[!] Target library &quot; + module_name + &quot; loaded, exiting...&quot;);                Process.exit(0);            &#125;        &#125;    &#125;);&#125;function main() &#123;    Java.perform(function() &#123;        hook_dlopen();        hook_android_dlopen_ext();        console.log(&quot;[*] Hooking dlopen and android_dlopen_ext initialized.&quot;);    &#125;);&#125;function dump_so(so_name)&#123;    let secmodule = Process.findModuleByName(so_name);    console.log(&quot;[name] &quot;, so_name);    console.log(&quot;[base] &quot;, secmodule.base.toString(16));    console.log(&quot;[size] &quot;, secmodule.size.toString(16));    dump(secmodule.base, secmodule.size);&#125;function dump(begin_addr, dump_size)&#123;    // console.log(&quot;[name] &quot;, module_name);    // console.log(&quot;[base] &quot;, begin_addr);    // console.log(&quot;[size] &quot;, &quot;0x&quot; + dump_size.toString(16));    var file_path = &quot;/data/data/com.lucky.luckyclient/zzc_0x&quot; + begin_addr.toString(16) + &quot;_0x&quot; + dump_size.toString(16) + &quot;.so&quot;;    var file_handle = new File(file_path, &quot;wb&quot;);    if (file_handle &amp;&amp; file_handle != null) &#123;        Memory.protect(ptr(begin_addr), dump_size, &#x27;rwx&#x27;);        var libso_buffer = ptr(begin_addr).readByteArray(dump_size);        file_handle.write(libso_buffer);        file_handle.flush();        file_handle.close();        console.log(&quot;[dump] &quot;, file_path);    &#125;&#125;setImmediate(main);\n\n执行结果如下图所示。\n\n然后将它pull出来，用修复工具修复（别用soFixer，可能导入表是乱的），展示一下修复后两个so文件的区别，明显可以看到，有一些字符串已经解密了。\n\n继续分析这个so文件，写一个脚本hook上RegisterNatives，判断一下md5_crypt对应的native函数地址是哪个。\n还没打印到那一步，就已经退出了。\n我尝试hook了libc标准库的常见函数，如：open、openat、strstr等函数，没发现对frida检测。\n\n还有一个问题，无法实现对call_constructor的hook，根据调用栈，会发现报错源来自frida的agent，是frida版本的问题吗？\n\n之后再来分析，先去分析数字免费壳，再来分析这个付费壳。\n\n\n之后我发现，换了一个方式hook RegisterNatives就能打印md5_crypt的注册地址了？\n// 获取 RegisterNatives 函数的内存地址，并赋值给addrRegisterNatives。function main()&#123;    var addrRegisterNatives = null;    var symbols = Module.enumerateSymbolsSync(&quot;libart.so&quot;);    for (var i = 0; i &lt; symbols.length; i++) &#123;        var symbol = symbols[i];        if (symbol.name.indexOf(&quot;art&quot;) &gt;= 0 &amp;&amp;            symbol.name.indexOf(&quot;JNI&quot;) &gt;= 0 &amp;&amp;            symbol.name.indexOf(&quot;RegisterNatives&quot;) &gt;= 0 &amp;&amp;            symbol.name.indexOf(&quot;CheckJNI&quot;) &lt; 0) &#123;            addrRegisterNatives = symbol.address;            console.log(&quot;RegisterNatives is at &quot;, symbol.address, symbol.name);            break        &#125;    &#125;    if (addrRegisterNatives) &#123;        Interceptor.attach(addrRegisterNatives, &#123;            onEnter: function (args) &#123;                var env = args[0];        // jni对象                var java_class = args[1]; // 类                var class_name = Java.vm.tryGetEnv().getClassName(java_class);                var taget_class = &quot;com.luckincoffee.safeboxlib.CryptoHelper&quot;;   //111 某个类中动态注册的so                if (class_name === taget_class) &#123;                    console.log(&quot;\\n[RegisterNatives] method_count:&quot;, args[3]);                    var methods_ptr = ptr(args[2]);                    var method_count = parseInt(args[3]);                    for (var i = 0; i &lt; method_count; i++) &#123;                        // Java中函数名字的                        var name_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3));                        // 参数和返回值类型                        var sig_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize));                        // C中的函数内存地址                        var fnPtr_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize * 2));                        var name = Memory.readCString(name_ptr);                        var sig = Memory.readCString(sig_ptr);                        var find_module = Process.findModuleByAddress(fnPtr_ptr);                        // 地址、偏移量、基地址                        var offset = ptr(fnPtr_ptr).sub(find_module.base);                        console.log(&#x27;class_name:&#x27;,class_name,&quot;name:&quot;, name, &quot;sig:&quot;, sig,&#x27;module_name:&#x27;,find_module.name ,&quot;offset:&quot;, offset);                    &#125;                &#125;            &#125;        &#125;);    &#125;&#125;setImmediate(main)// 动态注册函数地址// frida -U -f com.lucky.luckyclient -l hook_so_register.js  \n\n原先的脚本如下，区别在于：上面这个脚本在RegiterNatives的地方加了个taget_class的限制，那问题应该是注册了太多函数，导致打印崩溃了（？），先不管，之后分析壳的时候再看。\nfunction find_RegisterNatives(params) &#123;    let symbols = Module.enumerateSymbolsSync(&quot;libart.so&quot;);    let addrRegisterNatives = null;    for (let i = 0; i &lt; symbols.length; i++) &#123;        let symbol = symbols[i];                //_ZN3art3JNI15RegisterNativesEP7_JNIEnvP7_jclassPK15JNINativeMethodi        if (symbol.name.indexOf(&quot;art&quot;) &gt;= 0 &amp;&amp;                symbol.name.indexOf(&quot;JNI&quot;) &gt;= 0 &amp;&amp;                 symbol.name.indexOf(&quot;RegisterNatives&quot;) &gt;= 0 &amp;&amp;                 symbol.name.indexOf(&quot;CheckJNI&quot;) &lt; 0) &#123;            addrRegisterNatives = symbol.address;            console.log(&quot;RegisterNatives is at &quot;, symbol.address, symbol.name);            hook_RegisterNatives(addrRegisterNatives)        &#125;    &#125;&#125;function hook_RegisterNatives(addrRegisterNatives) &#123;    if (addrRegisterNatives != null) &#123;        Interceptor.attach(addrRegisterNatives, &#123;            onEnter: function (args) &#123;                console.log(&quot;[RegisterNatives] method_count:&quot;, args[3]);                let java_class = args[1];                let class_name = Java.vm.tryGetEnv().getClassName(java_class);                //console.log(class_name);                let methods_ptr = ptr(args[2]);                let method_count = parseInt(args[3]);                for (let i = 0; i &lt; method_count; i++) &#123;                    let name_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3));                    let sig_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize));                    let fnPtr_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize * 2));                    let name = Memory.readCString(name_ptr);                    let sig = Memory.readCString(sig_ptr);                    let symbol = DebugSymbol.fromAddress(fnPtr_ptr)                    console.log(&quot;[RegisterNatives] java_class:&quot;, class_name, &quot;name:&quot;, name, &quot;sig:&quot;, sig, &quot;fnPtr:&quot;, fnPtr_ptr,  &quot; fnOffset:&quot;, symbol, &quot; callee:&quot;, DebugSymbol.fromAddress(this.returnAddress));                &#125;            &#125;        &#125;);    &#125;&#125;setImmediate(find_RegisterNatives);\n\n打印的结果如下，md5_crypt对应着的地址是sub_1a981。\n\n我开了两个IDA对照着看，因为dump下来的文件虽然恢复了某些代码，但IDA的反汇编的伪代码也变了，没原来的so好读。\n根据对sub_1a981的分析，发现输入数据和输入数据的长度在sub_13E3C进行调用，sub_13E3C的函数名是md5。\n\n\nv24很有可能就是md5的返回值，可以写个脚本试试。\nfunction hook_md5()&#123;    var module_base = Module.findBaseAddress(&quot;libcryptoDD.so&quot;);    Interceptor.attach(module_base.add(0x13E3c), &#123;        onEnter: function(args)&#123;            this.data = args[0];            this.data_len = args[1];            this.digest = args[2];            console.log(&quot;[data]:\\n&quot;, hexdump(args[0], &#123;length: args[1]&#125;));        &#125;, onLeave: function(retval)&#123;            console.log(&quot;[digest]:\\n&quot;, hexdump(args[2], &#123;length: 64&#125;));        &#125;    &#125;);&#125;\n\n肯定是有反调，不然这种程度的hook，不至于引起进程崩溃。\n\n接下来用unidbg模拟执行。\n代码如下，从这套代码中，可以学会如何下断点（甚至是动调），如何模拟一个native层函数的执行。下断点的方式有2种，一是Unidbg提供的接口断点，二是Unicorn提供的断点，代码里都有涉及。\npackage com.luckincoffee.safeboxlib;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.Emulator;import com.github.unidbg.Module;import com.github.unidbg.arm.backend.Unicorn2Factory;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.*;import com.github.unidbg.linux.android.dvm.array.ByteArray;import com.github.unidbg.linux.android.dvm.jni.ProxyClassFactory;import com.github.unidbg.memory.Memory;import com.github.unidbg.utils.Inspector;import com.github.unidbg.arm.context.RegisterContext;import com.github.unidbg.debugger.BreakPointCallback;import com.github.unidbg.debugger.Debugger;import com.sun.jna.Pointer;import unicorn.ArmConst;import java.io.*;import java.nio.charset.StandardCharsets;import java.util.ArrayList;import java.util.List;public class CryptoHelper extends AbstractJni &#123;    private final AndroidEmulator emulator;    private final DvmClass cCryptoHelper;    private final VM vm;    private final Module module;    public CryptoHelper() &#123;        emulator = AndroidEmulatorBuilder.for32Bit()                .addBackendFactory(new Unicorn2Factory(true))                .setProcessName(&quot;com.lucky.luckyclient&quot;)                .build();        Memory memory = emulator.getMemory();        memory.setLibraryResolver(new AndroidResolver(23));        vm = emulator.createDalvikVM(new File(&quot;../file/rx.apk&quot;));        vm.setJni(this);        vm.setDvmClassFactory(new ProxyClassFactory());        vm.setVerbose(true);        DalvikModule dm = vm.loadLibrary(new File(&quot;unidbg-android/src/test/resources/example_binaries/armeabi-v7a/libcryptoDD.so&quot;), true);        module = dm.getModule();        cCryptoHelper = vm.resolveClass(&quot;com/luckincoffee/safeboxlib/CryptoHelper&quot;);        dm.callJNI_OnLoad(emulator);    &#125;    private void md5_hook() &#123;        Debugger debugger = emulator.attach();        // Hook md5 function at 0x13E3C: md5(indata_jarray, initial_len, v25)        debugger.addBreakPoint(module.base + 0x14D6E, new BreakPointCallback() &#123;            @Override            public boolean onHit(Emulator&lt;?&gt; emulator, long address) &#123;//                System.out.println(&quot;Breakpoint hit: md5 at 0x&quot; + Long.toHexString(address));//                RegisterContext context = emulator.getContext();////                // Parameters: ARM32 registers R0-R2//                long jarray = context.getLongArg(0); // R0: indata_jarray (jbyteArray)//                long initial_len = context.getLongArg(1); // R1: initial_len (jint)//                long v25 = context.getLongArg(2); // R2: v25 (pointer, possibly jbyteArray)////                System.out.println(&quot;md5 Parameters: jarray=0x&quot; + Long.toHexString(jarray) +//                        &quot;, initial_len=&quot; + initial_len +//                        &quot;, v25=0x&quot; + Long.toHexString(v25));////                // Parse input jbyteArray//                if (jarray != 0) &#123;//                    ByteArray byteArray = (ByteArray) vm.getObject((int) jarray);//                    if (byteArray != null) &#123;//                        Inspector.inspect(byteArray.getValue(), &quot;Input jbyteArray&quot;);//                    &#125;//                &#125;////                // Parse v25 (assuming it&#x27;s a pointer to output buffer)//                if (v25 != 0) &#123;//                    Pointer cipherText = context.getPointerArg(2);//                    Inspector.inspect(cipherText.getByteArray(0, 32), &quot;cipherText&quot;);//                &#125;////                // Continue execution, return false to stop at breakpoint for manual debugging                return false;            &#125;        &#125;);//        debugger.addBreakPoint(module.base + 0x1AB92, new BreakPointCallback() &#123;//            @Override//            public boolean onHit(Emulator&lt;?&gt; emulator, long address) &#123;//                System.out.println(&quot;Breakpoint hit: END at 0x&quot; + Long.toHexString(address));//                return true;//            &#125;//        &#125;);////        // Hook doMD5sign function at 0x14D54: doMD5sign(v41, initial_len + 20, &amp;v53)//        debugger.addBreakPoint(module.base + 0x14D54, new BreakPointCallback() &#123;//            @Override//            public boolean onHit(Emulator&lt;?&gt; emulator, long address) &#123;//                System.out.println(&quot;Breakpoint hit: doMD5sign at 0x&quot; + Long.toHexString(address));//                RegisterContext context = emulator.getContext();////                // Parameters: ARM32 registers R0-R2//                long v41 = context.getLongArg(0); // R0: v41 (possibly jbyteArray)//                long len = context.getLongArg(1); // R1: initial_len + 20 (jint)//                long v53 = context.getLongArg(2); // R2: &amp;v53 (pointer to output buffer)////                System.out.println(&quot;doMD5sign Parameters: v41=0x&quot; + Long.toHexString(v41) +//                        &quot;, len=&quot; + len +//                        &quot;, v53=0x&quot; + Long.toHexString(v53));////                // Parse v41 (assuming it&#x27;s a jbyteArray)//                if (v41 != 0) &#123;//                    ByteArray byteArray = (ByteArray) vm.getObject((int) v41);//                    if (byteArray != null) &#123;//                        Inspector.inspect(byteArray.getValue(), &quot;Input v41 (jbyteArray)&quot;);//                    &#125;//                &#125;////                // Parse v53 (output buffer)//                if (v53 != 0) &#123;//                    Pointer cipherText = context.getPointerArg(2);//                    Inspector.inspect(cipherText.getByteArray(0, 32), &quot;cipherText&quot;);//                &#125;////                // Continue execution//                return true;//            &#125;//        &#125;);//        // Add return hook using CodeHook to capture return value//        emulator.getBackend().hook_add_new(new com.github.unidbg.hook.HookListener() &#123;//            @Override//            public void hook(unicorn.Unicorn u, long address, int size, Object user) &#123;//                // Not used for entry hook in this case//            &#125;////            @Override//            public void onReturn(unicorn.Unicorn u, long address, int size, Object user) &#123;//                if (address == module.base + 0x13E3C) &#123;//                    long retValue = u.reg_read(ArmConst.UC_ARM_REG_R0).longValue();//                    System.out.println(&quot;md5 returned: 0x&quot; + Long.toHexString(retValue));//                    if (retValue != 0) &#123;//                        ByteArray retByteArray = (ByteArray) vm.getObject((int) retValue);//                        if (retByteArray != null) &#123;//                            Inspector.inspect(retByteArray.getValue(), &quot;md5 return jbyteArray&quot;);//                        &#125;//                    &#125;//                &#125; else if (address == module.base + 0x14D54) &#123;//                    long retValue = u.reg_read(ArmConst.UC_ARM_REG_R0).longValue();//                    System.out.println(&quot;doMD5sign returned: 0x&quot; + Long.toHexString(retValue));//                    if (retValue != 0) &#123;//                        ByteArray retByteArray = (ByteArray) vm.getObject((int) retValue);//                        if (retByteArray != null) &#123;//                            Inspector.inspect(retByteArray.getValue(), &quot;doMD5sign return jbyteArray&quot;);//                        &#125;//                    &#125;//                &#125;//            &#125;//        &#125;, module.base + 0x13E3C, module.base + 0x14D54, null);    &#125;    private void call_md5() &#123;        List&lt;Object&gt; args = new ArrayList&lt;&gt;(10);        args.add(vm.getJNIEnv());        args.add(0);        String my_bytes = &quot;cid=1;uid=1;q=1;&quot;;        args.add(vm.addLocalObject(new ByteArray(vm, my_bytes.getBytes())));        args.add(1);        Number retNum = module.callFunction(emulator, 0x1a981, args.toArray());        ByteArray retByteArr = (ByteArray) vm.getObject(retNum.intValue());        String md5result = new String(retByteArr.getValue(), StandardCharsets.UTF_8);        System.out.println(&quot;md5 result = &quot; + md5result);    &#125;    private void call_hooked_function() &#123;        List&lt;Object&gt; args = new ArrayList&lt;&gt;(10);        args.add(vm.addLocalObject(new ByteArray(vm, &quot;test_hook&quot;.getBytes())));        args.add(16); // initial_len        args.add(vm.addLocalObject(new ByteArray(vm, new byte[32]))); // v25: empty buffer        Number retNum = module.callFunction(emulator, 0x13E3C, args.toArray());        ByteArray retByteArr = (ByteArray) vm.getObject(retNum.intValue());        if (retByteArr != null) &#123;            String result = new String(retByteArr.getValue(), StandardCharsets.UTF_8);            System.out.println(&quot;md5 function result = &quot; + result);        &#125;    &#125;//    private void call_doMD5sign() &#123;//        List&lt;Object&gt; args = new ArrayList&lt;&gt;(10);//        args.add(vm.addLocalObject(new ByteArray(vm, &quot;test_doMD5sign&quot;.getBytes())));//        args.add(34); // initial_len + 20//        args.add(vm.addLocalObject(new ByteArray(vm, new byte[32]))); // v53: empty buffer//        Number retNum = module.callFunction(emulator, 0x14D54, args.toArray());//        ByteArray retByteArr = (ByteArray) vm.getObject(retNum.intValue());//        if (retByteArr != null) &#123;//            String result = new String(retByteArr.getValue(), StandardCharsets.UTF_8);//            System.out.println(&quot;doMD5sign function result = &quot; + result);//        &#125;//    &#125;    public void destroy() throws IOException &#123;        emulator.close();    &#125;    public static void main(String[] args) &#123;        CryptoHelper cryptoHelper = new CryptoHelper();        cryptoHelper.md5_hook();        cryptoHelper.call_md5();//        cryptoHelper.call_hooked_function();//        cryptoHelper.call_doMD5sign();        try &#123;            cryptoHelper.destroy();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n注意，上述关于断点处的代码，return true（或者是false）代表着是否要动调，false代表着要动调，Unidbg会模拟程序执行到那，然后停住（有点类似于gdb），等待用户输入指令。\n根据之前的分析，我们知道，md5_crypt对应的native层函数是 android_native_md5。\n根据对这个函数的分析，会发现传入的“cid&#x3D;1;uid&#x3D;1;q&#x3D;1”（unidbg中固定了输入值）最终会传入函数 doMD5sign。\n\n根据动调，比较java层得到的返回值和doMD5sign在函数退出时，digest指向的值，两者是一样的，因此这里的digest就是我们要的 android_native_md5 最后的返回值。不过注意，我们固定输入的initial_msg后，标准的md5返回值和digest里面的值是不一样的，这说明魔改了。\n在doMD5sign中，可以发现还有个函数叫md5，对这个函数进行hook（frida用不了，用unidbg的hook），在函数执行前，打印寄存器r0、r1、r2的值（r2指向一块buf），然后在md5执行完后，查看buf的内容。\n会发现，这个buf的内容是标准的md5结果。\n操作如下——\n固定输入。\n\n下断点。\n\n\nr0 &#x3D; 0x12248000，r1 &#x3D; 36，r2 &#x3D; 0xe4fff5d8。\n\n查看r0指向的字符串，会发现除了固定的输入，还加了IV，因此r1是36，而非我们固定输入的长度。\n\n\n当前的mr2。\n\n给0x12014d72下断点，然后按c执行，继续跑。\n\n此时程序跑完了md5，再来看看buf里的内容。\n\n\n这里的9eed….正是标准的md5结果。\n\n\n接下来就是看doMD5sign是如何魔改的，魔改的主要逻辑在 bytesToInt。按顺序，每次操作md5结果的4个字节，将每个字节都放大了好多，然后最终通过或操作，组成一个很大的数字，由于是signed int类型，有可能是负数，一旦是负数，就取绝对值。\n\n然后将取过绝对值的这个很大的数字化作字符串，存入缓冲区。——这里的byte_E0021指向字符串%d，可以在解密后的so文件看出来。\n\n\n\n既然知道算法了，接下来就写个python脚本复现一下，这里踩了个坑，python的整型是很大的，因此一般不会出现负数，而c&#x2F;c++中，32位的数若是很大，可能会溢出成负数，所以这里需要根据0x8000 0000判断当前得到的整型若是化成32位，是否是负数，若是，则转成正数，即减去0x1 0000 0000。\nimport hashlibdef bytesToInt(src, offset):    if len(src) &lt; offset + 4:        raise ValueError(f&quot;Source array too short for offset &#123;offset&#125;&quot;)    if v9_unsigned &gt;= 0x80000000: # 检查是否是负数（在C语言中）        v9_signed = v9_unsigned - 0x100000000 # 转换为正确的补码负值    else:        v9_signed = v9_unsigned    return v9_signeddef doMD5sign(initial_msg):    # Calculate MD5 hash (16 bytes)    md5_hash = hashlib.md5(initial_msg).digest()    # Process 4 blocks (offsets 0, 4, 8, 12)    offsets = [0, 4, 8, 12]    strings = []    for offset in offsets:        raw_int_value = bytesToInt(md5_hash, offset) # 获取有符号的整数值                # 按照IDA伪代码的逻辑，在转为字符串前取绝对值        # 对应IDA伪代码中的 &#x27;if ( vX &lt; 0 ) vY = -vX;&#x27;        abs_value = abs(raw_int_value)                 # 将绝对值转换为字符串        strings.append(str(abs_value))        print(f&quot;Offset &#123;offset&#125;: raw_int_value = &#123;raw_int_value&#125;, abs_value = &#123;abs_value&#125;&quot;)        # Concatenate strings    result = &quot;&quot;.join(strings)        # Simulate malloc and qmemcpy    digest = result    length = len(digest)        print(f&quot;Final digest: &#123;digest&#125;&quot;)    print(f&quot;Length: &#123;length&#125;&quot;)        return length, digestif __name__ == &quot;__main__&quot;:    initial_msg = b&quot;cid=1;uid=1;q=1;dJLdCJiVnDvM9JUpsom9&quot;        try:        length, digest = doMD5sign(initial_msg)    except ValueError as e:        print(f&quot;Error: &#123;e&#125;&quot;)\n\n脚本跑完的结果如下。\n\n\n而Unidbg模拟的结果如下。\n\n\n至此，sign分析结束了。\nps：unidbg之前没怎么用过，这个动调、断点还挺好用的，之后整理一套使用手册。\nq用之前写的hook HashMap的脚本，试试能不能找到q的加密点。\nfunction call_HashMap() &#123;    Java.perform(function () &#123;        var hashMap = Java.use(&quot;java.util.HashMap&quot;);        hashMap.put.implementation = function (a, b) &#123;            if (a != null &amp;&amp; a.equals(&quot;q&quot;)) &#123; console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new()))                console.log(&quot;hashMap.put: &quot;, a, b);            &#125;            return this.put(a, b);        &#125;    &#125;)&#125;\n\n看来跟sign一样，都是这么存储字段的。\n注意到，字段q的最后一个字节是&#x3D;，那很有可能是base64（猜测，base64没有_和-）。\n\n先从com.lucky.lib.http2.r.a看起，又是这个函数，需要追踪str3的值从何而来。\n\n\n写个脚本hook getRequestParams，并且hook AbstractC3710a.toJSONString，打印一下这个q2字符串的内容。\n\n\n这个类是之后加载的，需要加载之后再hook。\n\n打印的内容有些多。\n\n然后将内容传入方法 C9247c.m20436b，再传入 f237976b.m20089c。\n\n\n在 f237976b.m20089c 中，走localAESWork4Api(str.getBytes(), 0)。\n\nlocalAESWork4Api是CryptoHelper中的JNI函数，也注册在libcryptoDD.so。\n根据符号名，可以看出来是aes白盒加密。\n\n在 android_native_wbaes_jni 中，可以找到函数 wbaes_decrypt_ecb，说明是aes的ecb模式加密，ecb模式没有IV。\n\n\n虚假控制流有点多，要不直接trace算了？再等等好了。\n本次逆向的主要目标，就是掌握AES加密及白盒AES的破解方法之一——DFA。\n先根据这篇博客回顾一下，AES加密的流程。\nhttps://xiaoeeyu.github.io/2024/02/29/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-AES/\n以AES128为例，原理简单来说，如下。\n​\t输入：128位明文 + 128位密钥。\n​\t密钥扩展：生成11个128位（4x4字节）轮密钥。\n​\t初始轮：明文与第一个轮密钥异或。\n​\t普通轮：执行9轮（SubBytes（查表替换） → ShiftRows（字节循环左移） → MixColumns（列混合，矩阵乘法） → AddRoundKey（密钥异或））。\n​\t最终轮：执行1轮（SubBytes（查表替换） → ShiftRows（字节循环左移） → AddRoundKey（密钥异或））。\n​\t输出：128位密文。\n其中，查表替换的S盒是固定的，而且只有一个，通过脚本，搜索S盒的特征就可以找到了。\n交叉引用SBox。\n\n有2个函数调用了SBox。\nsub_63A0，很明显的SubBytes特征。\n*result &#x3D; *((_BYTE *)RijnDael_AES_LONG_SBox + (*result &amp; 0xF0) + (*result &amp; 0xF))\n等同于：result[i] &#x3D; SBox[result[i]]。\n\n还有一处是sub_5C58，这个特征不太明显阿。有点像SubBytes，又有点像移位操作。\n这毕竟不是标准AES，属于白盒AE，拿到了代码也不知道密钥在哪。\nint __fastcall sub_5C58(unsigned int a1)&#123;  return (*((unsigned __int8 *)&amp;RijnDael_AES_LONG_SBox[4 * ((a1 &gt;&gt; 4) &amp; 0xF000000F)] + (a1 &amp; 0xF)) | (*((unsigned __int8 *)RijnDael_AES_LONG_SBox + ((a1 &gt;&gt; 8) &amp; 0xF0) + ((a1 &gt;&gt; 8) &amp; 0xFF00000F)) &lt;&lt; 8) | (*((unsigned __int8 *)&amp;RijnDael_AES_LONG_SBox[4 * ((a1 &gt;&gt; 20) &amp; 0xFFFFF00F)] + (HIWORD(a1) &amp; 0xFFFF000F)) &lt;&lt; 16)) ^ (*((unsigned __int8 *)RijnDael_AES_LONG_SBox + (HIBYTE(a1) &amp; 0xF0) + (HIBYTE(a1) &amp; 0xF)) &lt;&lt; 24);&#125;\n\n接下来，学习其它的博客，试试如何获得白盒AES的密钥，下面这个文章把DFA原理讲得很明白。\nhttps://blog.quarkslab.com/differential-fault-analysis-on-white-box-aes-implementations.html\n总结一下我的理解：\n找到第8轮列混淆之后、第9轮列混淆之前（第十轮没有列混淆），然后修改1个字节（比特翻转，或者多修改点），这个修改的影响会被第9轮列混淆进行扩大，扩大到最终影响了输出的4个字节。\n根据数学关系，可以列4个等式。\nO和O’都是已知的，Z代表S-盒输入的差（A+X，即A异或X），根据对Y的假设，可以找到可能满足4个等式的Y0、Y1、Y2、Y3的候选者。\n\n\n再通过Y的候选者和已知的O，去获得可能的K（轮密钥的某个字节）的候选者。\n\n\n搞清楚DFA的原理以后，第一步，找到第8轮列混淆之后、第9轮列混淆之前进行故障注入。\n回到 android_native_wbaes，看看有没有什么特征函数。——找到了一个行位移的函数。为了确保它是我们要找的行位移函数，试试它有没有执行10次，并且打印v42的内容，判断是否每次都有行位移的操作。\n通过Unidbg完成上述的操作。\n\n\n下述是代码片段，num是我添加的成员变量。\nprivate void call_aes() &#123;        List&lt;Object&gt; args = new ArrayList&lt;&gt;(10);        // JNIEnv*        args.add(vm.getJNIEnv());        // jclass        args.add(0);        // 固定输入        String my_bytes = &quot;&#123;\\&quot;type\\&quot;:1&#125;&quot;;        args.add(vm.addLocalObject(new ByteArray(vm, my_bytes.getBytes())));        // 模式        args.add(0);        // 函数android_native_wbaes的偏移量0x1b1cd        Number retNum = module.callFunction(emulator, 0x1b1cd, args.toArray());        ByteArray retByteArr = (ByteArray) vm.getObject(retNum.intValue());        // 打印        byte[] resultBytes = retByteArr.getValue();        StringBuilder hexString = new StringBuilder();        for (byte b : resultBytes) &#123;            hexString.append(String.format(&quot;%02X&quot;, b &amp; 0xFF));        &#125;        System.out.println(&quot;q result (hex) = &quot; + hexString.toString());    &#125;    private void q_hook() &#123;        Debugger debugger = emulator.attach();        // Hook wbShiftRows function at 0x14F98        debugger.addBreakPoint(module.base + 0x14F98, new BreakPointCallback() &#123;            @Override            public boolean onHit(Emulator&lt;?&gt; emulator, long address) &#123;                num += 1;                System.out.println(&quot;wbShiftRows has been called: &quot; + num);                return true;            &#125;        &#125;);    &#125;\n\n可以看到，打印了10次，符合我们的预期。\n\n\n尝试打印每一次执行行位移之前的状态矩阵。\nprivate void q_hook() &#123;        Debugger debugger = emulator.attach();        // Hook wbShiftRows function at 0x14F98        debugger.addBreakPoint(module.base + 0x14F98, new BreakPointCallback() &#123;            @Override            public boolean onHit(Emulator&lt;?&gt; emulator, long address) &#123;                num += 1;                System.out.println(&quot;wbShiftRows has been called: &quot; + num);                // 获取寄存器上下文                RegisterContext context = emulator.getContext();                // R0 通常是第一个参数（状态矩阵的指针）                Pointer stateMatrix = context.getPointerArg(0);                if (stateMatrix != null) &#123;                    // 读取 16 字节状态矩阵                    byte[] stateBytes = stateMatrix.getByteArray(0, 16);                    // 转为十六进制                    StringBuilder hexString = new StringBuilder();                    for (byte b : stateBytes) &#123;                        hexString.append(String.format(&quot;%02X &quot;, b &amp; 0xFF));                    &#125;                    System.out.println(&quot;wbShiftRows state matrix (hex): &quot; + hexString.toString());                &#125;                return true; // 继续执行            &#125;        &#125;);    &#125;\n\n\n\n下面是q正常情况下的结果。——2FF0E1B44B413D51A083E55259E2179F\n\n\n修改第9次行位移的某个字节，收集10次差分故障攻击的结果。\n\n收集了16个错误的结果。\n2F1BE1B4E6413D51A083E56059E21A9F\n2FF0E1A84B41C451A0B1E55215E2179F\nE7F0E1B44B413DE3A0837A525924179F\n2FF0A8B44B2F3D511A83E55259E217C6\nDCF0E1B44B413DBEA08316525911179F\n2F68E1B436413D51A083E5CF59E2769F\n96F0E1B44B413DACA083AB5259EA179F\n89F0E1B44B413DE7A0831C525944179F\n42F0E1B44B413D1CA083D9525974179F\n2FF07FB44B6E3D514683E55259E21747\n17F0E1B44B413D6CA0838A5259F3179F\n2FF069B44BAA3D510283E55259E21754\nD8F0E1B44B413D36A0834452590B179F\n8AF0E1B44B413D27A0839752591E179F\n24F0E1B44B413DB1A0839C5259E9179F\n2FF0E16A4B414151A0A4E55293E2179F\n接下来使用大佬写的攻击，通过差分结果、正常结果，还原轮密钥，项目地址：\nhttps://github.com/SideChannelMarvels/JeanGrey/tree/master/phoenixAES\n编写脚本得到第10轮子密钥。\n#!/usr/bin/env python3import phoenixAESwith open(&#x27;tracefile&#x27;, &#x27;wb&#x27;) as t:    t.write(&quot;&quot;&quot;    2FF0E1B44B413D51A083E55259E2179F    2F1BE1B4E6413D51A083E56059E21A9F    2FF0E1A84B41C451A0B1E55215E2179F    E7F0E1B44B413DE3A0837A525924179F    2FF0A8B44B2F3D511A83E55259E217C6    DCF0E1B44B413DBEA08316525911179F    2F68E1B436413D51A083E5CF59E2769F    96F0E1B44B413DACA083AB5259EA179F    89F0E1B44B413DE7A0831C525944179F    42F0E1B44B413D1CA083D9525974179F    2FF07FB44B6E3D514683E55259E21747    17F0E1B44B413D6CA0838A5259F3179F    2FF069B44BAA3D510283E55259E21754    D8F0E1B44B413D36A0834452590B179F    8AF0E1B44B413D27A0839752591E179F    24F0E1B44B413DB1A0839C5259E9179F    2FF0E16A4B414151A0A4E55293E2179F&quot;&quot;&quot;.encode(&#x27;utf8&#x27;))phoenixAES.crack_file(&#x27;tracefile&#x27;)\n\n结果是：869D92BBB700D0D25BD9FD3E224B5DF2。\n\n\n再用另一个大佬，从轮密钥还原原密钥。\nhttps://github.com/SideChannelMarvels/Stark\n需要自己编译源代码，编译完后，还原原密钥！\n\n\n至此，成功把密钥DFA出来了，下面这个结果和Unidbg模拟的一模一样。\n\n\n心得体会以下是我从这次分析中，认为自己需要加强的点：\n1.学习绕过反调；（分析壳）\n2.学习Unidbg的用法，包括hook、补环境、补系统调用等操作；（读相关博客等）\n3.利用符号执行，去除控制流平坦化；\n4.学习Binary ninja。\n"},{"title":"360免费壳分析复现","url":"/2025/05/27/360%E5%85%8D%E8%B4%B9%E5%A3%B3%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0/","content":"数字免费壳用的是大佬 oacia 加固的apk，需要的可以去大佬的博客中下载~\n将apk丢入jeb中，查看AndroidManifest.xml。\n\n\n从整体壳开始看起，一般整体壳会在App类中重写方法attachBaseContext和onCreate，在这两个方法中，实现自脱壳。\n先看attachBaseContext。\n分析\n通过反射，访问类**”android.content.pm.PackageParser$Package”**，设置构造方法为可访问。\n\n\n通过反射，获取当前线程的ActivityThread实例，然后设置mHiddenApiWarningShown字段为true，避免了日志中出现使用隐藏api时的警告信息。\n\nStubApp是一个静态类，存储加固相关的全局状态。\nStubApp.a保存上下文，供加固逻辑使用；StubApp.c保存当前对象实例（App类实例），确保只初始化一次。\n\n在函数com.qihoo.util.a.a()中，通过下述3种方式判断当前的架构，若是x86架构，则返回true，然后加载X86Bridge；反之相反。\n\n检查 Build.SUPPORTED_32_BIT_ABIS 系统属性。\n\n读取 &#x2F;system&#x2F;build.prop 文件中的 ro.product.cpu.abi 属性。\n\n检查 &#x2F;system&#x2F;bin&#x2F;ls 的 ELF 文件头，判断其架构。\n\n\n\ncom.qihoo.util.a.a(…)会检测…&#x2F;assets&#x2F;libjiagu.so和…&#x2F;.jiagu&#x2F;libjiagu.so是否完全一样，如果不一样，以assets的so为主，会把assets的so覆写.jiagu的so，假如之后我们patch了…&#x2F;.jiagu的so文件进行重打包，将不会有效果；libjiagu_64.so同等”待遇”。\n\n随后来到方法interface5，跳转到native层执行。\n\n\n不必多说，这个interface5肯定是在libjiaguxxx.so中注册的。\n使用下面这个脚本跑一下试试。\nfunction find_RegisterNatives(params) &#123;    let symbols = Module.enumerateSymbolsSync(&quot;libart.so&quot;);    let addrRegisterNatives = null;    for (let i = 0; i &lt; symbols.length; i++) &#123;        let symbol = symbols[i];                //_ZN3art3JNI15RegisterNativesEP7_JNIEnvP7_jclassPK15JNINativeMethodi        if (symbol.name.indexOf(&quot;art&quot;) &gt;= 0 &amp;&amp;                symbol.name.indexOf(&quot;JNI&quot;) &gt;= 0 &amp;&amp;                 symbol.name.indexOf(&quot;RegisterNatives&quot;) &gt;= 0 &amp;&amp;                 symbol.name.indexOf(&quot;CheckJNI&quot;) &lt; 0) &#123;            addrRegisterNatives = symbol.address;            console.log(&quot;RegisterNatives is at &quot;, symbol.address, symbol.name);            hook_RegisterNatives(addrRegisterNatives)        &#125;    &#125;&#125;function hook_RegisterNatives(addrRegisterNatives) &#123;    if (addrRegisterNatives != null) &#123;        Interceptor.attach(addrRegisterNatives, &#123;            onEnter: function (args) &#123;                console.log(&quot;[RegisterNatives] method_count:&quot;, args[3]);                let java_class = args[1];                let class_name = Java.vm.tryGetEnv().getClassName(java_class);                //console.log(class_name);                let methods_ptr = ptr(args[2]);                let method_count = parseInt(args[3]);                for (let i = 0; i &lt; method_count; i++) &#123;                    let name_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3));                    let sig_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize));                    let fnPtr_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize * 2));                    let name = Memory.readCString(name_ptr);                    let sig = Memory.readCString(sig_ptr);                    let symbol = DebugSymbol.fromAddress(fnPtr_ptr)                    console.log(&quot;[RegisterNatives] java_class:&quot;, class_name, &quot;name:&quot;, name, &quot;sig:&quot;, sig, &quot;fnPtr:&quot;, fnPtr_ptr,  &quot; fnOffset:&quot;, symbol, &quot; callee:&quot;, DebugSymbol.fromAddress(this.returnAddress), &quot;\\n&quot;);                &#125;            &#125;        &#125;);    &#125;&#125;setImmediate(find_RegisterNatives);\n\n结果如图，暂时忽视那个Bad access….目标函数在libjiagu_64.so offset为0x11be00的位置。\n\n先不着急分析interface5，先走完libjiagu_64.so的初始化，用IDA打开assets下的libjiagu_a64.so。\n打开一看，天塌了，导入表、导出表全是空的。\n使用System.loadLibray加载一个so文件的流程是这样的（大致操作应该没问题，如果细节有误，就是我学术不精）。\n\n动态链接器会映射这个so文件的PT_LOAD段到内存中；\n\n解析so文件，映射所有其他依赖的共享库；\n\n完成符号解析、动态重定位等操作；\n\n动态库初始化：init_proc -&gt; .init_array(函数指针) -&gt; JNI_OnLoad；\n\n完成加载，等待调用。\n\n\n一般来说，一个普通的so文件是没有start的（注意，_start和_dl_start不是一个函数），只有可执行文件有，而libjiagu_64.so的导出表有start，而且只有一个start，甚至被标记为了main_entry。但对于so文件来说，main_entry应该是用不着的。\n\n上述种种特征说明，它不是一个普通的so文件，而是一个类似于自加载器的so文件，壳so负责将加固后的so文件解密，解析并加载，然后链接重定位。\n那么问题来了，何时进行加载、何时重定位呢？\n得先找到壳的程序入口点。\n按照我们的常规思路，先去看看有没有函数叫init_proc（旧版本的才有的函数，一般情况下已经见不到这个函数）、再看init_array上有没有函数指针列表、最后找JNI_OnLoad。\n结果，在IDA中看不到init_proc、init_array节、JNI_OnLoad。\n后来，我通过readelf -a读到了INIT_ARRAY的偏移。\n\n跳转到0x2d760，没有看到函数指针。\n\n\n360壳对so文件的结构字段做了很多修改，有一些字段是用来观察so文件结构的，他们属于对动态链接器加载流程不构成影响的字段，这些字段要么给删了，要么给加密了。\n事实上，完全可以从内存中dump一个已经加载好的so文件，但我想看看一般这种情况要如何进行下一步分析。\n重新理一下思路——360壳对ELF文件做了手脚，通过工具无法查看某些字段的信息，但对于动态链接器来说，它依旧可以正确调用init_array上的函数和JNI_OnLoad。\n因此，下一个切入点是：动态链接器是如何获得到init_array和JNI_OnLoad地址的。\n动态链接器找init_array节地址的流程是这样的：\n\n查找.dynamic节的位置，.dynamic节是一个由Elf_Dyn结构体组成的数组，每个Elf_Dyn包含2个主要成员。\n\nd_tag：一个标记（tag），表示这个条目的类型，比如，当前这个条目指向符号表或重定位表等。\nd_un：一个联合体，根据d_tag的不同，它可以是一个值，或者指向一个虚拟地址。\n\n\n查找特定的d_tag，对于.init_array来说，有2个相关的d_tag标记。\n\nd_tag &#x3D;&#x3D; DT_INIT_ARRAY，此时d_un包含了.init_array节的偏移地址。\nd_tag &#x3D;&#x3D; DT_INIT_ARRAYSZ，此时d_un包含了.init_array节的总大小。（以字节为单位）\n\n\n动态链接器会找到.init_array的位置，并根据.init_array的大小，得到函数指针的数目，执行上面的函数指针。\n\n\n实操如下。\n通过010editor，找到节头表，然后根据节头表找到.dynamic节的偏移。\n\n\n下面这个网址，给出了d_tag的值与含义。\nhttps://docs.oracle.com/cd/E23824_01/html/819-0690/chapter6-42444.html\n\n一个Elf_Dyn元素占16个字节，前8个字节是d_tag，后8个字节是d_un。\n接下来，在010editor中，从0x1DAD0开始，搜索d_tag &#x3D;&#x3D; 25（0x19）或27（0x1B）的地方。\n翻译一下，.init_array的地址是0x2D760，和之前readelf看到的一样；而.init_array的大小是0x10字节，可以存放2个函数指针。\n\n我们之前跳转到了0x2D760，发现.init_array上没有任何内容，这2个函数指针是哪里来的？突然想起来，在一个so文件加载的流程中，会先进行动态重定位，那大概率是在重定位的过程，为.init_array赋了2个函数指针。\n重定位表（RELA类型）相关的d_tag如下：\n\nDT_RELA：此时d_un指向了重定位表的地址。\nDT_RELASZ：此时d_un指定了重定位表的总大小。\nDT_RELAENT：此时d_un指定了每个重定位条目的大小（一般24字节）。\n\n而重定位表（RELA类型）中的每个元素的结构（Elf_Rela）是这样的：\n\nr_offset：需要修改的、需要重定位的地址偏移量。（字节）\nr_info：这个成员变量包含2个信息——高4字节表示符号表索引，指向动态符号表（.dynsym）中的符号条目，该符号的地址将用于重定位计算；低4字节表示修正规则，用于判断执行哪种类型的地址修正操作。\nr_addend：一个显式的加数，一个有符号的常量，它会参与重定位的计算中，比如说：写入r_offset的位置的值可能是符号地址 + r_addend。\n\n而如果是REL类型的重定位表，相关的d_tag则是少了一个A，比如说，DT_REL、DT_RELSZ、DT_RELENT。\n而REL类型重定位表每个元素的的结构只有：r_offset和r_info。\n接下来是实操。\n通过 readelf -r libjiagu_a64.so –use-dynamic，可以获得重定位表表项的信息。\n第一条表项，是不是很眼熟？正是我们.init_array的地址，（除此之外，没找到0x2d768），由于r_info的低32位是0403，代表修正操作是R_AARCH64_RELATIV，这个修正规则的符号索引通常是0（指向空符号），因为这种重定位规则是相对于模块自身的加载基址，不依赖于其他特定符号。\n因此，.init_array的第一个函数指针是sub_98a0。\n\n别着急找JNI_OnLoad，还没完，突然注意到RELA表中，第二项的Type也是R_AARCH64_RELATIV，并且r_addend是0x2e20，这不正是我们之前看到的start函数的地址吗？\n它被存放到了0x2d770的位置，这个地址离.init_array就差16个字节。\n\n还记得我们之前使用readelf -a读到了.init_array的地址，其实当时还读到了.fini_array的地址。\n\n也就是说，这个start是.fini_array上的函数指针，很有迷惑性，.fini_array上的函数指针，是当程序退出的时候执行的，却取名叫了start。\n至此，我们找到了.init_array上的函数指针：sub_98a0。\n下一步，动态链接器是如何找到JNI_OnLoad的呢？\n动态链接器在执行完.init_array上函数指针的函数后，会调用dlsym(handle, “JNI_OnLoad”)，用于在库中查找一个名为”JNI_OnLoad”的导出符号，具体来说，dlsym()回到库的动态符号表(.dynsym)中搜索这个名称，如果找到了这个符号，就会返回这个符号的内存地址，由Dalvik&#x2F;ART虚拟机传递JavaVM*指针和一个保留参数并执行这个指向JNI_OnLoad的函数。\n实操如下。\n通过.dynamic的节表找到.dynamic节在文件中的偏移。\n通过010editor，找到节头表（动态链接器会根据PHT来找，节表在装载过程可有可无），然后根据节头表找到.dynamic节的偏移。\n\n\n然后从0x1DAD0的位置，寻找d_tag &#x3D;&#x3D; DT_SYMTAB（0x6）的表项。\n\n可以从d_un知道，动态符号表的偏移是0x4E8。\n\n**动态符号表（.dynsym）**每个元素的结构（Elf64_Sym）是这样的。\n\n一共24个字节。\nst_name：4个字节，表示相对于动态字符串表起始地址（.dynstr）中的偏移，如果该值为0，表示该符号没有名称。\nst_info：1个字节，表示符号的类型和绑定属性（根据这1个字节的不同位区分），类型：函数还是对象；绑定属性：全局还是局部。\nst_other：1个字节，定义符号的可见性。\nst_shndx：2个字节，符号相关的节头表索引，指明了该符号定义在哪个节区（特殊值有：未定义符号-SHN_UNDEF、绝对符号-SHN_ABS）。\nst_value：8个字节，符号的值，通常是符号的虚拟地址。\nst_size：8个字节，符号关联的数据的大小，以字节为单位，例如：函数体的大小或者数据对象的大小。\n\n而动态字符串表（.dynstr）里面，全部放着字符串，动态符号表的st_name的索引，对应着动态字符串表首地址的偏移量。\n在动态符号表中，每个数据对象占24（0x18）个字节，我们假设JNI_OnLoad这个字符串一定存在于.dynstr里，先去计算它相对于.dynstr的首地址的偏移量。\n找动态字符串表有个快捷的方式，直接在IDA中shift + f12，起始地址是0xFB0。\n\n\n然后搜索”JNI_OnLoad”，先考虑第1个JNI_OnLoad的偏移吧，如果根据第1个的偏移找不到，再考虑第2个。（仅仅根据字符串，无法通过交叉引用追踪到JNI_OnLoad的函数地址）\n\n计算偏移，得出0x230。\n\n接下来，从动态符号表（从0x4E8开始找）中，每次查看24字节的前4个字节，寻找0x230，然后根据st_value，找到符号的虚拟地址。——由于是小端排序，可以直接在010editor搜索，30 02。\n\n\n根据st_value在结构体中的偏移量，st_value &#x3D; 0x8AFC。\n\n接下来我们去看看0x8AFC符不符合JNI_OnLoad的特征。\n\n\n其中，sub_8C74里面有关于JNI_OnLoad字符串的出现。\nsub_4c70像不像dlsym？dlsym根据动态链接库操作句柄(pHandle)与符号(symbol)，返回符号对应的地址，也就是一个函数指针，为什么有2个JNI_OnLoad呢？我猜测是壳so加载了一个so（暂且叫做主so），而这个主so负责JNI动态注册，简单来说，壳so的JNI_OnLoad调用了主so的JNI_OnLoad。\n\n至此，做个小总结，.init_array节上有函数指针sub_98a0，而壳so的JNI_OnLoad地址是0x8AFC，为了验证猜想，我们可以dump一个内存中加载好的libjiagu_64.so进行验证。\n通过frida进行dump。\nfunction my_hook_dlopen(soName = &#x27;&#x27;) &#123;    Interceptor.attach(Module.getExportByName(null, &quot;android_dlopen_ext&quot;),        &#123;            onEnter: function (args) &#123;                var pathptr = args[0];                if (pathptr !== undefined &amp;&amp; pathptr != null) &#123;                    var path = ptr(pathptr).readCString();                    if (path.indexOf(soName) &gt;= 0) &#123;                        console.log(&quot;准备加载&quot;)                        this.is_can_hook = true;                    &#125;                &#125;            &#125;,            onLeave: function (retval) &#123;                if (this.is_can_hook) &#123;                    dump_so(&quot;libjiagu_64.so&quot;);                &#125;            &#125;        &#125;    );&#125;function dump_so(so_name) &#123;    console.log(so_name)    var libso = Process.getModuleByName(so_name);    console.log(&quot;[name]:&quot;, libso.name);    console.log(&quot;[base]:&quot;, libso.base);    console.log(&quot;[size]:&quot;, ptr(libso.size));    console.log(&quot;[path]:&quot;, libso.path);    var file_path = &quot;/data/data/com.oacia.apk_protect/&quot; + libso.name + &quot;_&quot; + libso.base + &quot;_&quot; + ptr(libso.size) + &quot;.so&quot;;    var file_handle = new File(file_path, &quot;wb&quot;);    if (file_handle &amp;&amp; file_handle != null) &#123;        Memory.protect(ptr(libso.base), libso.size, &#x27;rwx&#x27;);        var libso_buffer = ptr(libso.base).readByteArray(libso.size);        file_handle.write(libso_buffer);        file_handle.flush();        file_handle.close();        console.log(&quot;[dump]:&quot;, file_path);    &#125;&#125;setImmediate(my_hook_dlopen(&quot;libjiagu_64.so&quot;));\n\n然后使用elf修复工具进行修复，再用ida打开，这回导入、导出表的内容恢复了。\n\n\n来查看.init_array和JNI_OnLoad的地址。\n\n\n\n下图是壳so的JNI_OnLoad。\n\n下图是主so的JNI_OnLoad。\n\n\n暂且就不去分析sub_98a0和壳so的JNI_OnLoad的代码了，应该是修复导入、导出表，执行JNI_OnLoad、反调等操作。接下来会使用frida对这一块内容进行分析。\n\n注意到，在frida注入代码，dump了so文件之后，进程会立即退出。\n\n\nhook了android_dlopen_ext，发现进程在加载了libjiagu_64.so后就退出了，说明检测frida的代码大概率在这个so文件里。\n\n通过hook发现，libjiagu_64.so的某段代码一直在检测maps文件，应该是这里在检测调试器。\n解决办法：可以hook函数open，每当要执行函数open时，判断目标文件是否为maps文件，如果是，重定位到一个不存在的文件。\n\n\nhook的脚本如下。\nfunction my_hook_dlopen(soName = &#x27;&#x27;) &#123;    Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;),        &#123;            onEnter: function (args) &#123;                var pathptr = args[0];                if (pathptr !== undefined &amp;&amp; pathptr != null) &#123;                    var path = ptr(pathptr).readCString();                    if (path.indexOf(soName) &gt;= 0) &#123;                        this.is_can_hook = true;                    &#125;                &#125;            &#125;,            onLeave: function (retval) &#123;                if (this.is_can_hook) &#123;                    hook_proc_self_maps();                &#125;            &#125;        &#125;    );&#125;function hook_proc_self_maps() &#123;    const openPtr = Module.getExportByName(null, &#x27;open&#x27;);    const open = new NativeFunction(openPtr, &#x27;int&#x27;, [&#x27;pointer&#x27;, &#x27;int&#x27;]);    var fakePath = &quot;/data/data/com.oacia.apk_protect/maps&quot;;    Interceptor.replace(openPtr, new NativeCallback(function (pathnameptr, flag) &#123;        var pathname = Memory.readUtf8String(pathnameptr);        console.log(&quot;open&quot;, pathname);        if (pathname.indexOf(&quot;maps&quot;) &gt;= 0) &#123;            console.log(&quot;find&quot;,pathname,&quot;,redirect to&quot;,fakePath);            var filename = Memory.allocUtf8String(fakePath);            return open(filename, flag);        &#125;        var fd = open(pathnameptr, flag);        return fd;    &#125;, &#x27;int&#x27;, [&#x27;pointer&#x27;, &#x27;int&#x27;]));&#125;setImmediate(my_hook_dlopen,&quot;libjiagu&quot;);\n\n虽然还是退出了，但这次有了新的收获，可以看到打开了3个dex文件。\n\n\n用010editor打开，发现第一个dex处于加密状态，而其它的dex是空的。\n\n为了判断是哪里的代码open了dex文件，可以打印一下堆栈，常规的打印堆栈的方式是加下面这句代码，但我们前面将maps文件重定位了，所以不能使用DebugSymbol.fromAddress（用到了maps文件）了，得自己实现一个函数。\nconsole.log(&#x27;RegisterNatives called from:\\\\n&#x27; + Thread.backtrace(this.context, Backtracer.FUZZY).map(DebugSymbol.fromAddress).join(&#x27;\\\\n&#x27;) + &#x27;\\\\n&#x27;);\n\n修改后的完整代码如下。\nfunction addr_in_so(addr)&#123;    var process_Obj_Module_Arr = Process.enumerateModules();    for(var i = 0; i &lt; process_Obj_Module_Arr.length; i++) &#123;        if(addr&gt;process_Obj_Module_Arr[i].base &amp;&amp; addr&lt;process_Obj_Module_Arr[i].base.add(process_Obj_Module_Arr[i].size))&#123;            console.log(addr.toString(16),&quot;is in&quot;,process_Obj_Module_Arr[i].name,&quot;offset: 0x&quot;+(addr-process_Obj_Module_Arr[i].base).toString(16));        &#125;    &#125;&#125;function hook_proc_self_maps() &#123;    const openPtr = Module.getExportByName(null, &#x27;open&#x27;);    const open = new NativeFunction(openPtr, &#x27;int&#x27;, [&#x27;pointer&#x27;, &#x27;int&#x27;]);    var fakePath = &quot;/data/data/com.oacia.apk_protect/maps_nonexistent&quot;;    Interceptor.replace(openPtr, new NativeCallback(function (pathnameptr, flag) &#123;        var pathname = Memory.readUtf8String(pathnameptr);        console.log(&quot;open&quot;,pathname);//,Process.getCurrentThreadId()        if (pathname.indexOf(&quot;maps&quot;) &gt;= 0) &#123;            console.log(&quot;find&quot;,pathname+&quot;, redirect to&quot;,fakePath);            var filename = Memory.allocUtf8String(fakePath);            return open(filename, flag);        &#125;        if (pathname.indexOf(&quot;dex&quot;) &gt;= 0) &#123;            Thread.backtrace(this.context, Backtracer.FUZZY).map(addr_in_so);        &#125;        var fd = open(pathnameptr, flag);        return fd;    &#125;, &#x27;int&#x27;, [&#x27;pointer&#x27;, &#x27;int&#x27;]));&#125;function my_hook_dlopen(soName=&#x27;&#x27;) &#123;    Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;),        &#123;            onEnter: function (args) &#123;                var pathptr = args[0];                if (pathptr !== undefined &amp;&amp; pathptr != null) &#123;                    var path = ptr(pathptr).readCString();                    //console.log(path);                    if (path.indexOf(soName) &gt;= 0) &#123;                        this.is_can_hook = true;                    &#125;                &#125;            &#125;,            onLeave: function (retval) &#123;                if (this.is_can_hook) &#123;                    hook_proc_self_maps();                &#125;            &#125;        &#125;    );&#125;setImmediate(my_hook_dlopen,&#x27;libjiagu&#x27;);\n\n可以看到3个dex文件被打开时的调用栈了，鉴于3个dex文件的调用栈基本一样，大概率是在一个循环中依次加载的。\n\n\n\n\n来到0x19b780，发现都是0，应该是在加载完dex文件后，将这块空间清空了。\n\n\n为了分析这块代码的逻辑，需要在open dex文件的时候，将so文件dump下来。\nvar hook_once = 0;function my_hook_dlopen(soName = &#x27;&#x27;) &#123;    Interceptor.attach(Module.getExportByName(null, &quot;android_dlopen_ext&quot;),        &#123;            onEnter: function (args) &#123;                var pathptr = args[0];                if (pathptr !== undefined &amp;&amp; pathptr != null) &#123;                    var path = ptr(pathptr).readCString();                    if (path.indexOf(soName) &gt;= 0) &#123;                        console.log(&quot;准备加载&quot;)                        this.is_can_hook = true;                    &#125;                &#125;            &#125;,            onLeave: function (retval) &#123;                if (this.is_can_hook) &#123;                    // 获得open的地址                    const openPtr = Module.getExportByName(null, &#x27;open&#x27;);                    // 准备替换的open                    const open = new NativeFunction(openPtr, &#x27;int&#x27;, [&#x27;pointer&#x27;, &#x27;int&#x27;]);                    // hook                    Interceptor.replace(openPtr, new NativeCallback(function (pathnameptr, flag) &#123;                        var pathname = Memory.readUtf8String(pathnameptr);                        console.log(&quot;open&quot;, pathname);//,Process.getCurrentThreadId()                        if (pathname.indexOf(&quot;maps&quot;) &gt;= 0) &#123;                            var fakePath = &quot;/data/data/com.oacia.apk_protect/maps_nonexistent&quot;;                            console.log(&quot;find&quot;,pathname+&quot;, redirect to&quot;,fakePath);                            var filename = Memory.allocUtf8String(fakePath);                            return open(filename, flag);                        &#125;                        if (pathname.indexOf(&quot;/data/data/com.oacia.apk_protect/.jiagu/classes&quot;) &gt;= 0) &#123;                            if(hook_once == 0)&#123;                                dump_so(&quot;libjiagu_64.so&quot;);                                hook_once = 1;                            &#125;                        &#125;                        var fd = open(pathnameptr, flag);                        return fd;                    &#125;, &#x27;int&#x27;, [&#x27;pointer&#x27;, &#x27;int&#x27;]));                &#125;            &#125;        &#125;    );&#125;function dump_so(so_name) &#123;    console.log(so_name)    var libso = Process.getModuleByName(so_name);    console.log(&quot;[name]:&quot;, libso.name);    console.log(&quot;[base]:&quot;, libso.base);    console.log(&quot;[size]:&quot;, ptr(libso.size));    console.log(&quot;[path]:&quot;, libso.path);    var file_path = &quot;/data/data/com.oacia.apk_protect/&quot; + libso.name + &quot;_&quot; + libso.base + &quot;_&quot; + ptr(libso.size) + &quot;.so&quot;;    var file_handle = new File(file_path, &quot;wb&quot;);    if (file_handle &amp;&amp; file_handle != null) &#123;        Memory.protect(ptr(libso.base), libso.size, &#x27;rwx&#x27;);        var libso_buffer = ptr(libso.base).readByteArray(libso.size);        file_handle.write(libso_buffer);        file_handle.flush();        file_handle.close();        console.log(&quot;[dump]:&quot;, file_path);    &#125;&#125;setImmediate(my_hook_dlopen(&quot;libjiagu_64.so&quot;));\n\n脚本执行结果。\n\n\n 修复之后，用IDA打开，定位到0x19b780。\n\n\n可以使用winmerge查看两个文件的区别。分析被抽空的数据，是从哪里开始抽空的\n\n往上滚动，直到0xe7000，两边的文件才基本一模一样。\n\n注意到，0xe7000存放的是.ELF，这是ELF文件的魔数。也就是说，壳so里面藏了一个so（主so）。\n使用下面这个脚本，将壳so里的ELF文件读出来，放入010editor查看。\nwith open(&#x27;libjiagu_64.so_0x6f71613000_0x274000.so&#x27;,&#x27;rb&#x27;) as f:    s=f.read()with open(&#x27;libjiagu_0xe7000.so&#x27;,&#x27;wb&#x27;) as f:    f.write(s[0xe7000::])\n\n除了ELF头，段头表和节表都被加密了。\n\n因此，IDA无法对这个ELF文件进行正常的分析。\n根据前人的分析，壳ELF会对加密的主ELF进行解密，并且自己实现了linker，对主ELF进行解析，再将解析结果赋值到soinfo结构体中，然后调用dlopen进行手动加载。\n先简单介绍一下什么是dlopen、dlsym和soinfo。\ndlopen (Dynamic Load Open)\n\n是什么：dlopen 是一个标准 C 库函数（定义在 dlfcn.h 中，通常由 libdl.so 提供）。它允许程序在运行时（而不是在程序启动时）显式地加载指定的共享对象（SO文件）到其地址空间。\n作用：当程序调用 dlopen(&quot;path/to/your_library.so&quot;, flags) 时，它会请求动态链接器加载这个库。如果加载成功，dlopen 会返回一个“句柄 (handle)”，后续可以使用这个句柄通过 dlsym 查找库中的符号（函数或变量），或者通过 dlclose卸载该库。\n谁调用它：应用程序代码可以直接调用 dlopen 来实现插件系统、按需加载功能模块等。在Java&#x2F;Kotlin层面，System.loadLibrary() 或 System.load() 在底层通常也是通过调用 dlopen 来加载JNI库的。\n\nsoinfo (Shared Object Information)\n\n是什么：soinfo 是Android动态链接器内部使用的一个非常重要的数据结构。对于加载到进程中的每一个SO文件，动态链接器都会在内部创建一个对应的 soinfo 实例来管理它。其他类Unix系统的动态链接器也会有类似的内部结构来跟踪已加载的库，但 soinfo 这个名称特指Android的实现（源于Bionic C库的链接器）。\n作用：soinfo结构体存储了关于一个已加载SO文件的所有关键运行时信息，例如：\n库的名称和完整路径。\n库在内存中的加载基地址 (base address) 和大小。\n指向其ELF动态段 (.dynamic section) 的指针。\n指向其动态符号表 (.dynsym)、字符串表 (.dynstr)、哈希表 (.hash 或 .gnu.hash) 的指针。\n重定位表的信息。\n依赖的其他 soinfo 实例的列表。\n库的句柄 (handle)、引用计数。\n初始化状态（例如，构造函数&#x2F;.init_array 是否已运行）。\n标志位（例如，是否是主可执行程序、是否是PIE等）。\n\n\n\n应用程序通过dlopen函数请求加载一个so文件，dlopen会将这个请求传递给动态链接器linker，动态链接器linker负责实际执行加载so文件的所有底层工作（查找文件、映射内存、解析依赖、重定位符号、运行初始化代码等）。在加载so文件的过程中，动态链接器会为这个新加载的so文件创建一个soinfo结构体实例，这个soinfo包含了管理该so所需的所有元数据和状态信息。\n而当后续调用dlsym查找该库某个符号时，链接器会查阅对应soinfo中记录的符号表等信息——dlopen获得的handle，实际上就是soinfo结构体实例的指针。\n因此，可以理解壳ELF的行为：对主ELF文件进行解析、映射、重定位…创建soinfo结构实例，然后供dlsym使用，获得符号的地址。\n主so是壳so加载起来的，但要是连依赖项也由壳处理，就过于麻烦了，所以前人分析会用到dlopen，于是进行交叉引用追踪。\n在函数sub_3C94中，用到了dlopen，同时会发现，这里的代码和aosp源码的预链接十分相似，下图是sub_3C94的代码。\n\n下图是AOSP源码中的预链接（直接用oacia大佬的图）。\n\n\n添加前人准备好的关于soinfo的结构体，然后将参数a1类型改成soinfo *。\n// ELF64 启用该宏#define __LP64__ 1// ELF32 启用该宏//#define __work_around_b_24465209__ 1/* https://android.googlesource.com/platform/bionic/+/master/linker/Android.bp架构为 32 位 定义__work_around_b_24465209__宏arch: &#123;    arm: &#123;cflags: [&quot; D__work_around_b_24465209__&quot;],&#125;,    x86: &#123;cflags: [&quot; D__work_around_b_24465209__&quot;],&#125;,&#125;*/// 定义 ELF 文件的基本类型，根据架构决定使用 ELF32 或 ELF64 类型#if defined(__LP64__)    #define ElfW(type) Elf64_ ## type#else    #define ElfW(type) Elf32_ ## type#endif// 32 位和 64 位重定位和符号表数据结构// Elf32 和 Elf64 基本类型typedef signed char __s8;typedef unsigned char __u8;typedef signed short __s16;typedef unsigned short __u16;typedef signed int __s32;typedef unsigned int __u32;typedef signed long long __s64;typedef unsigned long long __u64;// 32 位 ELF 基本类型typedef __u32 Elf32_Addr;typedef __u16 Elf32_Half;typedef __u32 Elf32_Off;typedef __s32 Elf32_Sword;typedef __u32 Elf32_Word;// 64 位 ELF 基本类型typedef __u64 Elf64_Addr;typedef __u16 Elf64_Half;typedef __s16 Elf64_SHalf;typedef __u64 Elf64_Off;typedef __s32 Elf64_Sword;typedef __u32 Elf64_Word;typedef __u64 Elf64_Xword;typedef __s64 Elf64_Sxword;// 动态段数据结构（Elf32 和 Elf64）typedef struct dynamic &#123;    Elf32_Sword d_tag;    union &#123;        Elf32_Sword d_val;        Elf32_Addr d_ptr;    &#125; d_un;&#125; Elf32_Dyn;typedef struct &#123;    Elf64_Sxword d_tag; /* entry tag value */    union &#123;        Elf64_Xword d_val;        Elf64_Addr d_ptr;    &#125; d_un;&#125; Elf64_Dyn;// 重定位数据结构（Elf32 和 Elf64）typedef struct elf32_rel &#123;    Elf32_Addr r_offset;    Elf32_Word r_info;&#125; Elf32_Rel;typedef struct elf64_rel &#123;    Elf64_Addr r_offset; /* Location at which to apply the action */    Elf64_Xword r_info;  /* index and type of relocation */&#125; Elf64_Rel;typedef struct elf32_rela &#123;    Elf32_Addr r_offset;    Elf32_Word r_info;    Elf32_Sword r_addend;&#125; Elf32_Rela;typedef struct elf64_rela &#123;    Elf64_Addr r_offset;  /* Location at which to apply the action */    Elf64_Xword r_info;   /* index and type of relocation */    Elf64_Sxword r_addend; /* Constant addend used to compute value */&#125; Elf64_Rela;// 符号表数据结构（Elf32 和 Elf64）typedef struct elf32_sym &#123;    Elf32_Word st_name;    Elf32_Addr st_value;    Elf32_Word st_size;    unsigned char st_info;    unsigned char st_other;    Elf32_Half st_shndx;&#125; Elf32_Sym;typedef struct elf64_sym &#123;    Elf64_Word st_name;     /* Symbol name, index in string tbl */    unsigned char st_info;  /* Type and binding attributes */    unsigned char st_other; /* No defined meaning, 0 */    Elf64_Half st_shndx;    /* Associated section index */    Elf64_Addr st_value;    /* Value of the symbol */    Elf64_Xword st_size;    /* Associated symbol size */&#125; Elf64_Sym;// ELF 文件头数据结构（Elf32 和 Elf64）#define EI_NIDENT 16typedef struct elf32_hdr &#123;    unsigned char e_ident[EI_NIDENT];    Elf32_Half e_type;    Elf32_Half e_machine;    Elf32_Word e_version;    Elf32_Addr e_entry; /* Entry point */    Elf32_Off e_phoff;    Elf32_Off e_shoff;    Elf32_Word e_flags;    Elf32_Half e_ehsize;    Elf32_Half e_phentsize;    Elf32_Half e_phnum;    Elf32_Half e_shentsize;    Elf32_Half e_shnum;    Elf32_Half e_shstrndx;&#125; Elf32_Ehdr;typedef struct elf64_hdr &#123;    unsigned char e_ident[EI_NIDENT]; /* ELF &quot;magic number&quot; */    Elf64_Half e_type;    Elf64_Half e_machine;    Elf64_Word e_version;    Elf64_Addr e_entry;  /* Entry point virtual address */    Elf64_Off e_phoff;   /* Program header table file offset */    Elf64_Off e_shoff;   /* Section header table file offset */    Elf64_Word e_flags;    Elf64_Half e_ehsize;    Elf64_Half e_phentsize;    Elf64_Half e_phnum;    Elf64_Half e_shentsize;    Elf64_Half e_shnum;    Elf64_Half e_shstrndx;&#125; Elf64_Ehdr;// 程序头数据结构（Elf32 和 Elf64）typedef struct elf32_phdr &#123;    Elf32_Word p_type;    Elf32_Off p_offset;    Elf32_Addr p_vaddr;    Elf32_Addr p_paddr;    Elf32_Word p_filesz;    Elf32_Word p_memsz;    Elf32_Word p_flags;    Elf32_Word p_align;&#125; Elf32_Phdr;typedef struct elf64_phdr &#123;    Elf64_Word p_type;    Elf64_Word p_flags;    Elf64_Off p_offset;  /* Segment file offset */    Elf64_Addr p_vaddr;  /* Segment virtual address */    Elf64_Addr p_paddr;  /* Segment physical address */    Elf64_Xword p_filesz; /* Segment size in file */    Elf64_Xword p_memsz;  /* Segment size in memory */    Elf64_Xword p_align;  /* Segment alignment, file &amp; memory */&#125; Elf64_Phdr;// 节头数据结构（Elf32 和 Elf64）typedef struct elf32_shdr &#123;    Elf32_Word sh_name;    Elf32_Word sh_type;    Elf32_Word sh_flags;    Elf32_Addr sh_addr;    Elf32_Off sh_offset;    Elf32_Word sh_size;    Elf32_Word sh_link;    Elf32_Word sh_info;    Elf32_Word sh_addralign;    Elf32_Word sh_entsize;&#125; Elf32_Shdr;typedef struct elf64_shdr &#123;    Elf64_Word sh_name;       /* Section name, index in string tbl */    Elf64_Word sh_type;       /* Type of section */    Elf64_Xword sh_flags;     /* Miscellaneous section attributes */    Elf64_Addr sh_addr;       /* Section virtual addr at execution */    Elf64_Off sh_offset;      /* Section file offset */    Elf64_Xword sh_size;      /* Size of section in bytes */    Elf64_Word sh_link;       /* Index of another section */    Elf64_Word sh_info;       /* Additional section information */    Elf64_Xword sh_addralign; /* Section alignment */    Elf64_Xword sh_entsize;   /* Entry size if section holds table */&#125; Elf64_Shdr;// 动态链接信息结构（Android 特有）typedef void (*linker_dtor_function_t)();typedef void (*linker_ctor_function_t)(int, char**, char**);#if defined(__work_around_b_24465209__)#define SOINFO_NAME_LEN 128#endif// Android 中的 soinfo 结构体，用于表示动态链接库信息struct soinfo &#123;    #if defined(__work_around_b_24465209__)    char old_name_[SOINFO_NAME_LEN];    #endif    const ElfW(Phdr)* phdr;    size_t phnum;    ElfW(Addr) base;    size_t size;    ElfW(Dyn)* dynamic;    soinfo* next;    uint32_t flags_;    const char* strtab_;    ElfW(Sym)* symtab_;    size_t nbucket_;    size_t nchain_;    uint32_t* bucket_;    uint32_t* chain_;    #if !defined(__LP64__)    ElfW(Addr)** unused4; // DO NOT USE, maintained for compatibility    #endif    #if defined(USE_RELA)    ElfW(Rela)* plt_rela_;    size_t plt_rela_count_;    ElfW(Rela)* rela_;    size_t rela_count_;    #else    ElfW(Rel)* plt_rel_;    size_t plt_rel_count_;    ElfW(Rel)* rel_;    size_t rel_count_;    #endif    linker_ctor_function_t* preinit_array_;    size_t preinit_array_count_;    linker_ctor_function_t* init_array_;    size_t init_array_count_;    linker_dtor_function_t* fini_array_;    size_t fini_array_count_;    linker_ctor_function_t init_func_;    linker_dtor_function_t fini_func_;    size_t ref_count_;    link_map link_map_head;    bool constructors_called;    ElfW(Addr) load_bias;    bool has_text_relocations;    bool has_DT_SYMBOLIC;&#125;;\n\n如果是一个标准的soinfo结构，不会出现a1[1]，只能说壳ELF的soinfo魔改了。\n\n简单分析一下sub_3C94做了什么：\n\n构建soinfo实例，从一些硬编码的信息中，将soinfo实例进行初始化；\n加载主so的依赖库；\n\n这些硬编码信息的偏移量是从a1获得的。\n\n\nsub_49F0调用了sub_3C94。\n\n\nv5的值与v1有关，v1的值与a1有关，a1的值来自sub_49f0的调用者——sub_4B54。\n\n\na1的值与a2有关，但在函数sub_6128中，a2的值是由a1得来的，因此，还得继续追踪sub_4B54的调用者。\n\nsub_4B54有2个调用者，其中，sub_8c74很眼熟。\n\n0x8AFC是JNI_OnLoad的函数地址，其实之前交叉引用sub_8C74的时候，发现没有函数引用sub_8C74，但JNI_OnLoad的伪代码里突然发现了sub_8c74。\n\n\n通过汇编代码，可以看到，BL指令的下一条指令就是sub_8C74，这种方式的调用可能让IDA无法正常分析了。\n\n\n言归正传，也就是说，当壳so被加载起来后，会通过JNI_OnLoad，最终将主so进行解析并加载。\n回到sub_3C94的调用者——sub_49F0。\n只有当sub_3C94的返回值是奇数，才能进一步执行sub_4918，而sub_3C94的作用我们前面分析过了（将主so的元数据填到soinfo实例，然后加载主so的依赖），这里的sub_4918大概率是进一步完成主so的加载。\n\n\n看到关于dynamic的字眼，大概率是重定位阶段。\n\n点进sub_4000。\n\n看到0x403，有点眼熟，搜了一下之前的内容，果然，v8是r_info的低32位，代表重定位过程，地址的修正规则，进一步说明当前函数是在进行重定位了。\n\n一般情况下，动态链接器会先对处理通用重定位（.rela.dyn或.rel.dyn），再处理 PLT 重定位（.rela.plt或.rel.plt）。\n\n再进入sub_5e6c观察。\n\n观察到0x38（56个字节），刚好是一个段表的大小。\n\n调用了mprotect。\n\n\n基本可以确定，大概率是在处理各个LOAD段。\n将begin_addr_pht_1类型改成elf64_phdr，IDA的伪代码将会更加清晰，下图是我分析后的sub_5E6C。\n\n0x6474E552换成十进制是1685382482，可以通过010Editor知道其含义是PT_GNU_RELRO。\n\n\nsub_5E6C 函数在处理 PT_GNU_RELRO 段。它的作用就是在“主SO”的重定位完成后，找到所有标记为 PT_GNU_RELRO 的程序段，并将这些段在内存中的对应区域设置为只读。这是ELF动态链接中的一个标准安全步骤，称为RELRO (Relocation Read-Only)，目的是保护那些在重定位后不应再被修改的数据段（如部分GOT表、.data.rel.ro段）免遭篡改。\n既然，这里将RELRO的段设置成了只读，说明这个时候，所有的PHT都应该处于解密状态，尝试在这个时候读取PHT，将它们dump下来。\n第1个参数代表程序头表（们）的起始地址，第2个参数代表数量，第3个参数还没分析。\n\n使用frida脚本进行dump，需要注意，sub_5E6C是在壳so的JNI_OnLoad调用的，如果hook android_dlopen_ext，在onLeave回调时，hook sub_5E6C，那时就太晚了，JNI_OnLoad都执行完了，不会触发Interceptor.attach的trap。\n因此，得hook call_constructors，在onEnter时进一步hook sub_5E6C，这个hook的时机是：壳so的内容映射到了内存中，但尚未执行init_proc、.init_array上的函数、JNI_OnLoad，这个时机就很完美。\n// 针对 call_constructors 进行 Hookfunction hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;);    let offset_call = 0x51BA8; // 你手机的 linker64 中 call_constructors 的偏移量    let call_constructors = linker64_base_addr.add(offset_call);    let listener = Interceptor.attach(call_constructors, &#123;        onEnter: function(args) &#123;            let secmodule = Process.findModuleByName(&quot;libjiagu_64.so&quot;); // 目标 SO 文件            if (secmodule != null) &#123;                // Hook 目标函数 sub_5E6C                console.log(&quot;[+] &quot;, &quot;Module libjiagu_64.so base_addr: &quot;, secmodule.base.toString(16));                hook_target_func(secmodule.base);                listener.detach(); // Hook 完成后解除            &#125;        &#125;    &#125;);&#125;// Hook 目标函数 sub_5E6Cfunction hook_target_func(baseaddr) &#123;    // sub_5E6C 的偏移    let target_offset = 0x5E6C;    let target_func = baseaddr.add(target_offset);    Interceptor.attach(target_func, &#123;        onEnter: function(args) &#123;            console.log(&#x27;[+] Hooking sub_5E6C at:&#x27;, target_func);            // 获取参数            let begin_addr_pht = args[0]; // 第一个 PHT 条目的地址            let nums_pht = args[1]; // PHT 条目数量            console.log(&#x27;[+] PHT Parameters:&#x27;);            console.log(&#x27;  - begin_addr_pht:&#x27;, begin_addr_pht);            console.log(&#x27;  - nums_pht:&#x27;, nums_pht);            console.log(&#x27;  - a3: 0x&#x27; + args[2].toString(16))            // 验证 PHT 条目数量            if (nums_pht &lt; 1) &#123;                console.log(&#x27;[-] Invalid PHT count:&#x27;, nums_pht);                return;            &#125;            // 计算 PHT 结束地址            let pht_size_per_entry = 56; // Elf64_Phdr 的大小为 56 字节            let end_addr_pht = begin_addr_pht.add(nums_pht * pht_size_per_entry);            // 准备保存 PHT 数据            let pht_data = Memory.alloc(nums_pht * pht_size_per_entry);            Memory.copy(pht_data, begin_addr_pht, nums_pht * pht_size_per_entry);            // 保存到文件            let file_path = &#x27;/data/data/com.oacia.apk_protect/pht_decrypt.bin&#x27;;            let file = new File(file_path, &#x27;wb&#x27;);            if (file &amp;&amp; file !== null) &#123;                file.write(pht_data.readByteArray(nums_pht * pht_size_per_entry));                file.flush();                file.close();                console.log(&#x27;[+] PHT dumped to:&#x27;, file_path);            &#125; else &#123;                console.log(&#x27;[-] Failed to open file:&#x27;, file_path);            &#125;        &#125;,        onLeave: function(retval) &#123;            console.log(&#x27;[+] sub_5E6C returned:&#x27;, retval);        &#125;    &#125;);&#125;// 启动 HooksetImmediate(hook_linker_call_constructors);\n\n结果如下（忽视掉进程终止^_^）。\n可以发现：0x70089b4000 - 0x70088cd000 &#x3D; 0xe7000，而之前我们的分析中，偏移量0xe7000处是主so的起始地址，所以这里的a3是主so在内存中的基址。\n同时，也可以看出来解密后的PHT的存放地址，和主so的ELF头并不在内存上相连（在之后的操作后就明白了，这里PHT的地址是堆的地址，主so的PHT是垃圾数据），与ELF头相连的PHT是垃圾数据填充的，或者说是加密的。\n\n将文件pull出来观察，看样子确实解密了。\n\n\n修改到之前脱掉的主so里去，现在可以清晰看到段表的内容了。\n\n至此，拿到了解密后的PHT，也知道了sub_5E6C的参数意义。\n问题又来了，既然参数的意义分别是：第1个参数代表程序头表（们）的起始地址，第2个参数代表数量，第3个参数代表主so的基址。\n\n而soinfo的结构体是这样的。\n\n\n按理来说，soinfo偏移量为0的地方就是PHT的地址，而这里的a1-&gt;link_map_head.l_next实则指向了((byte*) a1) + 232，这说明在成员变量const Elf64_Phdr *phdr的前面，还有232字节，这232字节应该是360壳自定义的。\n\n添加后，第1个参数的位置对了，但第2个参数和第3个参数还是错的，说明还需要插入一些字节。\n\n正常情况应该是这样。\nsub_5E6C(a1-&gt;phdr, a1-&gt;phnum, a1-&gt;base)\n\n为了知道壳ELF是怎么解密出来的，大佬oacia写了一个IDA插件：stalker_trace_so，这个脚本可以追踪native函数的执行顺序，但似乎不分线程，而且也没有调用关系，下图是截的大佬oacia博客的图。\n\n\n我对这个脚本进行了二开，让打印更美观一点，而且要展示调用关系。\n修改后，打印的内容好看了很多，能清晰地看到调用链。\n[ONEPLUS A6003::com.oacia.apk_protect ]-&gt; start Stalker on thread 11793Stalker started![180 ms] [TID:11793] ENTER: JNI_OnLoad  [180 ms] [TID:11793] ENTER: .interpreter_wrap_int64_t    [180 ms] [TID:11793] ENTER: interpreter_wrap_int64_t      [181 ms] [TID:11793] ENTER: ._Znwm      [181 ms] [TID:11793] EXIT: ._Znwm    [181 ms] [TID:11793] EXIT: interpreter_wrap_int64_t    [182 ms] [TID:11793] ENTER: sub_13908      [182 ms] [TID:11793] ENTER: ._Znam      [182 ms] [TID:11793] EXIT: ._Znam      [184 ms] [TID:11793] ENTER: sub_11220        [184 ms] [TID:11793] ENTER: .memset        [185 ms] [TID:11793] EXIT: .memset        [186 ms] [TID:11793] ENTER: sub_9DD8        [186 ms] [TID:11793] EXIT: sub_9DD8      [187 ms] [TID:11793] EXIT: sub_11220      [190 ms] [TID:11793] ENTER: sub_E3E0      [190 ms] [TID:11793] EXIT: sub_E3E0      [190 ms] [TID:11793] ENTER: .calloc      [191 ms] [TID:11793] EXIT: .calloc    [191 ms] [TID:11793] EXIT: sub_13908  [191 ms] [TID:11793] EXIT: .interpreter_wrap_int64_t[193 ms] [TID:11793] EXIT: JNI_OnLoad[204 ms] [TID:11793] ENTER: .malloc  [204 ms] [TID:11793] ENTER: .free  [204 ms] [TID:11793] EXIT: .free[207 ms] [TID:11793] EXIT: .malloc[208 ms] [TID:11793] ENTER: sub_E648[209 ms] [TID:11793] EXIT: sub_E648[209 ms] [TID:11793] ENTER: ._ZdaPv[213 ms] [TID:11793] EXIT: ._ZdaPv[213 ms] [TID:11793] ENTER: sub_C918[213 ms] [TID:11793] EXIT: sub_C918[214 ms] [TID:11793] ENTER: sub_9988[214 ms] [TID:11793] EXIT: sub_9988[214 ms] [TID:11793] ENTER: sub_9964[214 ms] [TID:11793] EXIT: sub_9964[215 ms] [TID:11793] ENTER: sub_9AC4[216 ms] [TID:11793] EXIT: sub_9AC4[216 ms] [TID:11793] ENTER: .ffi_prep_cif  [216 ms] [TID:11793] ENTER: ffi_prep_cif    [217 ms] [TID:11793] ENTER: .ffi_prep_cif_machdep      [217 ms] [TID:11793] ENTER: ffi_prep_cif_machdep      [218 ms] [TID:11793] EXIT: ffi_prep_cif_machdep      [218 ms] [TID:11793] ENTER: .ffi_call        [218 ms] [TID:11793] ENTER: ffi_call          [218 ms] [TID:11793] ENTER: sub_1674C          [219 ms] [TID:11793] EXIT: sub_1674C          [219 ms] [TID:11793] ENTER: .ffi_call_SYSV            [219 ms] [TID:11793] ENTER: ffi_call_SYSV              [219 ms] [TID:11793] ENTER: sub_167BC                [220 ms] [TID:11793] ENTER: sub_1647C                [220 ms] [TID:11793] EXIT: sub_1647C                [220 ms] [TID:11793] ENTER: sub_163DC                [220 ms] [TID:11793] EXIT: sub_163DC              [221 ms] [TID:11793] EXIT: sub_167BC            [221 ms] [TID:11793] EXIT: ffi_call_SYSV            [221 ms] [TID:11793] ENTER: sub_9900            [222 ms] [TID:11793] EXIT: sub_9900          [222 ms] [TID:11793] EXIT: .ffi_call_SYSV        [222 ms] [TID:11793] EXIT: ffi_call      [222 ms] [TID:11793] EXIT: .ffi_call    [223 ms] [TID:11793] EXIT: .ffi_prep_cif_machdep    [224 ms] [TID:11793] ENTER: sub_94BC      [224 ms] [TID:11793] ENTER: .dladdr      [226 ms] [TID:11793] EXIT: .dladdr    [226 ms] [TID:11793] EXIT: sub_94BC  [226 ms] [TID:11793] EXIT: ffi_prep_cif[226 ms] [TID:11793] EXIT: .ffi_prep_cif[226 ms] [TID:11793] ENTER: .strstr[227 ms] [TID:11793] EXIT: .strstr[231 ms] [TID:11793] ENTER: .setenv[232 ms] [TID:11793] EXIT: .setenv[235 ms] [TID:11793] ENTER: _Z9__arm_a_1P7_JavaVMP7_JNIEnvPvRi[239 ms] [TID:11793] EXIT: _Z9__arm_a_1P7_JavaVMP7_JNIEnvPvRi[241 ms] [TID:11793] ENTER: sub_9E58  [242 ms] [TID:11793] ENTER: sub_999C  [242 ms] [TID:11793] EXIT: sub_999C[242 ms] [TID:11793] EXIT: sub_9E58[242 ms] [TID:11793] ENTER: sub_10964  [243 ms] [TID:11793] ENTER: j_._ZdlPv_1    [243 ms] [TID:11793] ENTER: ._ZdlPv      [245 ms] [TID:11793] ENTER: sub_96E0      [246 ms] [TID:11793] EXIT: sub_96E0    [246 ms] [TID:11793] EXIT: ._ZdlPv    [246 ms] [TID:11793] ENTER: sub_8000      [246 ms] [TID:11793] ENTER: .strncpy      [247 ms] [TID:11793] EXIT: .strncpy      [247 ms] [TID:11793] ENTER: sub_60E0      [247 ms] [TID:11793] EXIT: sub_60E0      [247 ms] [TID:11793] ENTER: sub_6544      [248 ms] [TID:11793] EXIT: sub_6544      [248 ms] [TID:11793] ENTER: sub_4B54        [248 ms] [TID:11793] ENTER: sub_6128        [248 ms] [TID:11793] EXIT: sub_6128        [248 ms] [TID:11793] ENTER: _ZN9__arm_c_19__arm_c_0Ev        [250 ms] [TID:11793] EXIT: _ZN9__arm_c_19__arm_c_0Ev        [250 ms] [TID:11793] ENTER: sub_A3EC          [250 ms] [TID:11793] ENTER: sub_99CC            [250 ms] [TID:11793] ENTER: sub_9944            [250 ms] [TID:11793] EXIT: sub_9944          [251 ms] [TID:11793] EXIT: sub_99CC        [251 ms] [TID:11793] EXIT: sub_A3EC      [252 ms] [TID:11793] EXIT: sub_4B54    [254 ms] [TID:11793] EXIT: sub_8000  [254 ms] [TID:11793] EXIT: j_._ZdlPv_1[254 ms] [TID:11793] EXIT: sub_10964[257 ms] [TID:11793] ENTER: sub_6484  [257 ms] [TID:11793] ENTER: sub_6590    [257 ms] [TID:11793] ENTER: .memcpy    [258 ms] [TID:11793] EXIT: .memcpy    [258 ms] [TID:11793] ENTER: sub_6698      [260 ms] [TID:11793] ENTER: sub_9FFC      [261 ms] [TID:11793] EXIT: sub_9FFC    [268 ms] [TID:11793] EXIT: sub_6698    [268 ms] [TID:11793] ENTER: j_._ZdlPv_3      [268 ms] [TID:11793] ENTER: j_._ZdlPv_2        [269 ms] [TID:11793] ENTER: j_._ZdlPv_0          [269 ms] [TID:11793] ENTER: sub_A3A0            [269 ms] [TID:11793] ENTER: sub_9A90            [269 ms] [TID:11793] EXIT: sub_9A90          [269 ms] [TID:11793] EXIT: sub_A3A0        [270 ms] [TID:11793] EXIT: j_._ZdlPv_0      [270 ms] [TID:11793] EXIT: j_._ZdlPv_2      [270 ms] [TID:11793] ENTER: sub_5F20      [271 ms] [TID:11793] EXIT: sub_5F20    [271 ms] [TID:11793] EXIT: j_._ZdlPv_3    [271 ms] [TID:11793] ENTER: sub_6044    [276 ms] [TID:11793] EXIT: sub_6044  [276 ms] [TID:11793] EXIT: sub_6590  [276 ms] [TID:11793] ENTER: sub_3574    [276 ms] [TID:11793] ENTER: .uncompress    [279 ms] [TID:11793] EXIT: .uncompress  [279 ms] [TID:11793] EXIT: sub_3574[281 ms] [TID:11793] EXIT: sub_6484[316 ms] [TID:11793] ENTER: sub_49F0  [316 ms] [TID:11793] ENTER: sub_5400  [316 ms] [TID:11793] EXIT: sub_5400  [316 ms] [TID:11793] ENTER: sub_5478    [316 ms] [TID:11793] ENTER: sub_5B08    [318 ms] [TID:11793] EXIT: sub_5B08  [320 ms] [TID:11793] EXIT: sub_5478  [320 ms] [TID:11793] ENTER: sub_5650  [321 ms] [TID:11793] EXIT: sub_5650  [321 ms] [TID:11793] ENTER: sub_580C    [322 ms] [TID:11793] ENTER: .mprotect    [322 ms] [TID:11793] EXIT: .mprotect  [324 ms] [TID:11793] EXIT: sub_580C[324 ms] [TID:11793] EXIT: sub_49F0[325 ms] [TID:11793] ENTER: .strlen[325 ms] [TID:11793] EXIT: .strlen[325 ms] [TID:11793] ENTER: sub_3C94  [327 ms] [TID:11793] ENTER: .dlopen  [328 ms] [TID:11793] EXIT: .dlopen[330 ms] [TID:11793] EXIT: sub_3C94[352 ms] [TID:11793] ENTER: sub_4918  [353 ms] [TID:11793] ENTER: sub_4000    [353 ms] [TID:11793] ENTER: sub_41B4      [354 ms] [TID:11793] ENTER: sub_35AC      [355 ms] [TID:11793] EXIT: sub_35AC    [355 ms] [TID:11793] EXIT: sub_41B4    [356 ms] [TID:11793] ENTER: .dlsym    [357 ms] [TID:11793] EXIT: .dlsym  [358 ms] [TID:11793] EXIT: sub_4000[359 ms] [TID:11793] EXIT: sub_4918[369 ms] [TID:11793] ENTER: sub_5E6C[370 ms] [TID:11793] EXIT: sub_5E6C[370 ms] [TID:11793] ENTER: sub_5444[370 ms] [TID:11793] EXIT: sub_5444[386 ms] [TID:11793] ENTER: sub_633C[386 ms] [TID:11793] EXIT: sub_633C[386 ms] [TID:11793] ENTER: sub_8130  [387 ms] [TID:11793] ENTER: sub_4C70  [387 ms] [TID:11793] EXIT: sub_4C70[388 ms] [TID:11793] EXIT: sub_8130[388 ms] [TID:11793] ENTER: sub_825C[389 ms] [TID:11793] EXIT: sub_825C[389 ms] [TID:11793] ENTER: sub_8B50[390 ms] [TID:11793] EXIT: sub_8B50[390 ms] [TID:11793] ENTER: sub_8ED4[391 ms] [TID:11793] EXIT: sub_8ED4[391 ms] [TID:11793] ENTER: sub_8430[394 ms] [TID:11793] EXIT: sub_8430[395 ms] [TID:11793] ENTER: interpreter_wrap_int64_t_bridge  [397 ms] [TID:11793] ENTER: sub_9D60  [398 ms] [TID:11793] EXIT: sub_9D60[398 ms] [TID:11793] EXIT: interpreter_wrap_int64_t_bridge[780 ms] [TID:11793] ENTER: sub_166C4[781 ms] [TID:11793] EXIT: sub_166C4[782 ms] [TID:11793] ENTER: .puts[787 ms] [TID:11793] EXIT: .puts[1642 ms] [TID:11793] ENTER: sub_115AA0[1643 ms] [TID:11793] EXIT: sub_115AA0[1781 ms] [TID:11793] ENTER: _Z9__arm_a_2PcmS_Rii[1790 ms] [TID:11793] EXIT: _Z9__arm_a_2PcmS_Rii[2069 ms] [TID:11793] ENTER: .ffi_prep_cif_var  [2070 ms] [TID:11793] ENTER: ffi_prep_cif_var  [2070 ms] [TID:11793] EXIT: ffi_prep_cif_var[2070 ms] [TID:11793] EXIT: .ffi_prep_cif_var\n\n脚本链接：Call_Trace，如果觉得好用，麻烦点个星星，┭┮﹏┭┮这对我找工作真的很重要。——脚本是有局限的，在github里写了，如果只想要观察调用顺序而不需要调用关系，可以把打印内容的EXIT全部去掉，再把缩进也去掉，这样就恢复成原来oacia大佬的脚本了。由于这是360壳，有些调用不是标准的RET退栈，所以调用关系可能会有问题。\n继续分析。\n\n\n在解压缩操作附近的函数进行查看，发现存在RC4加密。\n下面这个是标准RC4的KSA步骤。\n\n\n修改一下变量名，简单明了，和标准RC4一模一样，如果想得到密钥的值，hook sub_5F20，然后得到第1个参数的值即可。\n\nhook rc4的密钥脚本如下。\n// 针对 call_constructors 进行 Hookfunction hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;);    let offset_call = 0x51BA8; // 你手机的 linker64 中 call_constructors 的偏移量    let call_constructors = linker64_base_addr.add(offset_call);    let listener = Interceptor.attach(call_constructors, &#123;        onEnter: function(args) &#123;            let secmodule = Process.findModuleByName(&quot;libjiagu_64.so&quot;); // 目标 SO 文件            if (secmodule != null) &#123;                // Hook 目标函数 sub_5E6C                console.log(&quot;[+] &quot;, &quot;Module libjiagu_64.so base_addr: &quot;, secmodule.base.toString(16));                hook_target_func(secmodule.base);                listener.detach(); // Hook 完成后解除            &#125;        &#125;    &#125;);&#125;// Hook 目标函数 sub_5f20function hook_target_func(baseaddr) &#123;    // sub_5E6C 的偏移    let target_offset = 0x5f20;    let target_func = baseaddr.add(target_offset);    Interceptor.attach(target_func, &#123;        onEnter: function(args) &#123;            console.log(&#x27;[+] Hooking sub_5f20 at:&#x27;, target_func);            console.log(&quot;rc4 key:&quot;);            console.log(hexdump(args[0], &#123;length: 64&#125;));        &#125;,        onLeave: function(retval) &#123;            console.log(&#x27;[+] sub_5f20 returned:&#x27;, retval);        &#125;    &#125;);&#125;// 启动 HooksetImmediate(hook_linker_call_constructors);\n\n结果如下图所示，提取密钥，如果之后要用就方便了。0x76,0x55,0x56,0x34,0x23,0x91,0x23,0x53,0x56,0x74。\n\n\n按理来说，在ksa之后，应该会调用rc4的PRGA算法，然后进行rc4解密，再进行压缩，所以这里继续追踪sub_6044和sub_3574进行查看。\n\n先看sub_3574，这里直接调用了uncompress，那大概率sub_6044就是rc4_PRGA算法。\n\n\n标准的RC4_PRGA算法是这样的。\n\n\n而sub_6044是这样的。\n\n修改变量名后，如下图所示。\n\n在进行rc4解密后，主so的内容仍然是不可用的，还需要进行解压缩。sub_6044的下一个函数调用是sub_3574，而sub_3574直接调用uncompress，然后发现uncompress位于导入表，那大概率就是zlib库的uncompress了。\n下面是uncompress的函数签名。\nint uncompress(Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen);\n根据这个函数签名，我们可以hook它，得到解压缩后的内容。\n但在hook uncompress之前，先hook rc4_prga，通过它，可以获得加密主so的地址和内容的大小。\n脚本如下。\n// 针对 call_constructors 进行 Hookfunction hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;);    let offset_call = 0x51BA8; // 手机的 linker64 中 call_constructors 的偏移量    let call_constructors = linker64_base_addr.add(offset_call);    let listener = Interceptor.attach(call_constructors, &#123;        onEnter: function(args) &#123;            let secmodule = Process.findModuleByName(&quot;libjiagu_64.so&quot;); // 目标 SO 文件            if (secmodule != null) &#123;                // Hook 目标函数 sub_6044                console.log(&quot;[+] &quot;, &quot;Module libjiagu_64.so base_addr: &quot;, secmodule.base.toString(16));                hook_target_func(secmodule.base);                listener.detach(); // Hook 完成后解除            &#125;        &#125;    &#125;);&#125;// Hook 目标函数 sub_6044function hook_target_func(baseaddr) &#123;    // sub_6044 的偏移    let target_offset = 0x6044;    let target_func = baseaddr.add(target_offset);    Interceptor.attach(target_func, &#123;        onEnter: function(args) &#123;            console.log(&#x27;[+] Hooking sub_6044 at:&#x27;, target_func);            console.log(&quot;encrypt 主elf addr:&quot;, &quot;0x&quot; + (args[0] - baseaddr).toString(16));            console.log(&quot;encrypt 主elf size:&quot;, &quot;0x&quot; + args[1].toString(16));            console.log(&quot;解密前:&quot;);            this.arg0 = args[0];            console.log(hexdump(args[0], &#123;length: 64&#125;));        &#125;,        onLeave: function(retval) &#123;            console.log(&quot;解密后:&quot;);            console.log(hexdump(this.arg0, &#123;length: 64&#125;))        &#125;    &#125;);&#125;// 启动 HooksetImmediate(hook_linker_call_constructors);\n\n打印结果如下。\n\n0x74783ff0肯定不是一个正常的偏移量，估计做过转移（比如malloc申请空间，存到别的地方去了），真正的主so加密数据应该是在壳so的某个偏移。\n尝试在壳so文件搜索加密前的内容——用010editor在文件中在搜索 01 18 25 e7…\n可以发现，加密数据存放于libjiagu_64_after_open_fixed.so的0x2e270的位置，这是我之前趁着open(“…&#x2F;xxx.dex”)的时候dump下来的libjiagu_a64.so。\n\n\n而在assets目录下的libjiagu_a64.so中，这段加密内容位于0x1E270的位置。\n\n\n估计是加载过程中对齐的缘故，又或者是360壳把把主so的基址设在了64K位置（0x10000）。\n如果之后我们想直接从壳so中获得主so，用的是0x1E270，但分析的时候，继续用0x2e270。\n\n对这个变量名交叉引用，只有函数sub_8000引用了它。\n可以发现，0xB8010正是sub_6044第2个参数的值，代表着RC4加密后主so的大小。\n\n\n接着hook uncompress，由于uncompress是系统库的函数，不需要考虑360壳做手脚，直接hook。\n// 针对 call_constructors 进行 Hookfunction hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;);    let offset_call = 0x51BA8; // 手机的 linker64 中 call_constructors 的偏移量    let call_constructors = linker64_base_addr.add(offset_call);    let listener = Interceptor.attach(call_constructors, &#123;        onEnter: function(args) &#123;            let secmodule = Process.findModuleByName(&quot;libjiagu_64.so&quot;); // 目标 SO 文件            if (secmodule != null) &#123;                // Hook 目标函数 sub_6044                console.log(&quot;[+] &quot;, &quot;Module libjiagu_64.so base_addr: &quot;, secmodule.base.toString(16));                hook_target_func(secmodule.base);                listener.detach(); // Hook 完成后解除            &#125;        &#125;    &#125;);&#125;// Hook 目标函数 sub_6044function hook_target_func(baseaddr) &#123;    // sub_6044 的偏移    let target_offset = 0x6044;    let target_func = baseaddr.add(target_offset);    Interceptor.attach(target_func, &#123;        onEnter: function(args) &#123;            console.log(&#x27;[+] Hooking sub_6044 at:&#x27;, target_func);            console.log(&quot;encrypt 主elf在内存中的实际位置:&quot;, &quot;0x&quot; + args[0].toString(16));            console.log(&quot;encrypt 主elf在rc4加密后的大小:&quot;, &quot;0x&quot; + args[1].toString(16));            console.log(&quot;解密前:&quot;);            this.arg0 = args[0];            console.log(hexdump(args[0], &#123;length: 64&#125;));        &#125;,        onLeave: function(retval) &#123;            console.log(&quot;解密后:&quot;);            console.log(hexdump(this.arg0, &#123;length: 64&#125;))        &#125;    &#125;);&#125;function hook_uncompress_res()&#123;    Interceptor.attach(Module.findExportByName(null, &quot;uncompress&quot;), &#123;        onEnter: function (args) &#123;            console.log(&quot;hook uncompress&quot;)            console.log(&quot;解压缩前:&quot;)            console.log(hexdump(args[2], &#123;              offset: 0,// 相对偏移              length: 64,//dump 的大小              header: true,              ansi: true            &#125;));            console.log(&quot;解压缩前的大小:&quot;,args[3])        &#125;,        onLeave: function (ret) &#123;        &#125;    &#125;);&#125;// 启动 HooksetImmediate(function()&#123;    hook_linker_call_constructors();    hook_uncompress_res();&#125;);\n\n打印的结果如下。\n很容易猜到，rc4解密后的数据的前4个字节用来表示解压后的主so的大小（0x1a0eb9）。\n\n现在我们已经知道了主so的位置（0x1e270）、加密的算法与密钥（rc4和”0x76,0x55,0x56,0x34,0x23,0x91,0x23,0x53,0x56,0x74”）、解压用的函数及解压后的大小（zlib的uncompress和0x1a0eb9），现在可以很轻易地从壳so中直接得到主so解密的内容。\n写脚本脱下来看看——这边直接抄了oacia大佬的。\nimport zlibimport structdef RC4(data, key):    S = list(range(256))    j = 0    out = []    # KSA Phase    for i in range(256):        j = (j + S[i] + key[i % len(key)]) % 256        S[i], S[j] = S[j], S[i]    # PRGA Phase    i = j = 0    for ch in data:        i = (i + 1) % 256        j = (j + S[i]) % 256        S[i], S[j] = S[j], S[i]        out.append(ch ^ S[(S[i] + S[j]) % 256])    return outdef RC4decrypt(ciphertext, key):    return RC4(ciphertext, key)wrap_elf_start = 0x1e270wrap_elf_size = 0xb8010key = b&quot;vUV4#\\x91#SVt&quot;with open(&#x27;com.oacia.apk_protect/assets/libjiagu_a64.so&#x27;,&#x27;rb&#x27;) as f:    wrap_elf = f.read()# 对密文进行解密dec_compress_elf = RC4decrypt(wrap_elf[wrap_elf_start:wrap_elf_start+wrap_elf_size], key)dec_elf = zlib.decompress(bytes(dec_compress_elf[4::]))with open(&#x27;wrap_elf&#x27;,&#x27;wb&#x27;) as f:    f.write(dec_elf)\n\n将得到的wrap_elf放到010editor查看，一大堆D3。\n\n\n往下面看，发现存在ELF文件的特征，而ELF文件之前导出都是D3。\n\n\n可以将这里理解为2段数据，part1为D3相关的加密，part2为ELF文件头（可能还有其它内容）。\n这里对wrap_elf进行切割。\nwith open(&#x27;wrap_elf&#x27;, &#x27;rb&#x27;) as f:    wrap_elf = f.read()ELF_magic = bytes([0x7F, 0x45, 0x4C, 0x46])for i in range(len(wrap_elf) - len(ELF_magic) + 1):    if wrap_elf[i:i + len(ELF_magic)] == ELF_magic:        print(hex(i))        with open(&#x27;wrap_elf_part1&#x27;, &#x27;wb&#x27;) as f:            f.write(wrap_elf[0:i])        with open(&#x27;wrap_elf_part2&#x27;, &#x27;wb&#x27;) as f:            f.write(wrap_elf[i::])        break\n\n打开wrap_elf_part2，发现PHT填充了一堆垃圾数据（可能是加密数据，但我更倾向于PHT放在了别的地方）。\n\n往下分析，要进行重定位的话，要么是part2的PHT解密了，要么是PHT放在了其它地方。\n\n对其中的函数进行分析。\n\n一般加载一个so的时候，申请mmap空间之前需要有PHT，先读取PHT上写着的LOAD加载地址、大小、对齐方式等，再调用mmap进行申请。\n因此，sub_5B08大概率在获得正确的PHT，点进来一看，发现存在常量0x38，刚好是一个PHT的大小，更说明猜测是对的了。\n\n\npht_buffer与xor_key进行异或，异或的xor_key来自于a2+16。\n\n\nhook一下，查看xor_key的内容是多少。\n// 针对 call_constructors 进行 Hookfunction hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;);    let offset_call = 0x51BA8; // 手机的 linker64 中 call_constructors 的偏移量    let call_constructors = linker64_base_addr.add(offset_call);    let listener = Interceptor.attach(call_constructors, &#123;        onEnter: function(args) &#123;            let secmodule = Process.findModuleByName(&quot;libjiagu_64.so&quot;); // 目标 SO 文件            if (secmodule != null) &#123;                console.log(&quot;[+] &quot;, &quot;Module libjiagu_64.so base_addr: &quot;, secmodule.base.toString(16));                hook_target_func(secmodule.base);                listener.detach(); // Hook 完成后解除            &#125;        &#125;    &#125;);&#125;function hook_target_func(baseaddr) &#123;    let target_offset = 0x5B08;    let target_func = baseaddr.add(target_offset);    Interceptor.attach(target_func, &#123;        onEnter: function(args) &#123;            console.log(&quot;[xor_key]:&quot;, &quot;0x&quot;+args[1].add(16).readPointer().readU8().toString(16));        &#125;    &#125;);&#125;// 启动 HooksetImmediate(function()&#123;    hook_linker_call_constructors();&#125;);\n\n脚本执行结果是0xd3，说明真正的PHT很可能就是part1解密后的内容。\n\n除了异或，解密的循环还有arm64的neon运算。\nNEON 是 ARM 架构的 SIMD 扩展，提供一组专用的寄存器和指令，用于并行处理多个数据元素。\n下面两个链接介绍了sub_5B08中出现的vdupq_n_s8和veorq_s8。\nhttps://developer.arm.com/architectures/instruction-sets/intrinsics/#q=vdupq_n_s8\nhttps://developer.arm.com/architectures/instruction-sets/intrinsics/#q=veorq_s8\n简单来说，一个字节一个字节的异或效率太低，而neon可以一次性异或16个字节。——根本不影响阅读。\n\n\n分析了一下，突然意识到v2似乎指向part2。\n\n打印一下看看。（脚本就不提供了，跟查看xor_key的脚本差不多）\n下面这内容不就是part1的内容？\n\n也就是说，part1的第1个字节是xor_key，接下来的4个字节是长度（0x150），再接下来的0x150个字节是待异或的内容，注意到，我们之前分析的主so有6个pht，每个pht大小是0x38，加起来不就是0x150个字节吗？所以说，part1的前0x155字节与pht相关。\n\n整理了一下，假如每次要处理的数据量都很小，那每次的处理数据的方式都是逐字节异或，然后goto到下一块要处理的数据，整个sub_5B08有4个这样子的结构，因此有4块数据。\n数据的分布结构是这样的：xor_key（1个字节）、data1_len（4个字节）、data1、data2_len（4个字节）、data2、data3_len（4个字节）、data3、data4_len、data4。\n之前提过，soinfo中存在一些360壳的字段，而在sub_5B08可以推测一些字段了。\n关于data1的相关字段。\n\n\n关于data2的相关字段。\n\n\n关于data3的相关字段。\n\n\n关于data4的相关字段。\n\n\n最后还有elf的相关字段，这里的v16、v27、v38、pht_total_size有3个是数据的大小，还有有一个是基址；17是1个字节的xor_key和4个4字节的data_len。\n想想wrap_elf，part1基本都是0xD3，而part2是ELF文件，不难想出，a1的第152个字节指向elf起始地址。\n\n原先的soinfo是这样的。前232字节由于不知道是什么，直接当成一个char数组，暂时没做处理。\n\n\n根据分析，可以这么设置。\n\n\n但是想了想，似乎不太合适，这样子先入为主地认为之前的那个数据结构是soinfo了，虽然的确很像，如果如上图这么设置，pht_buffer和phdr是同一个意思，应该不会这么设计。\n依照其它人的博客的意思，老老实实创建当前这个结构体即可，不要往soinfo去想，因为一开始的soinfo也是猜测。\n因此，这里的Four_Section不需要凑232个字节了，只需要满足偏移量在对应的地方即可，结构体应该如下。\n\n\n既然sub_5B08的第1个参数是Four_Section，查看它的引用函数，传参的那个变量的类型也应该是Four_Section。\n\n继续查看引用sub_5478函数，将v14变量的类型改成Four_Section*，然后发现不对，存在2个问题。\n\nv14的类型是Four_Section*，为什么还要取地址再转成(Four_Section*)？\nv7_1[29] &#x3D; v9，v9 &#x3D; v16，但v16的值呢？\n\n\n针对上述两个问题，其实说明v14的类型取错了。\n\n这里的v15-v23找不到赋值的地方，它们很有可能是和v14作为一个完整的结构体对象，一起作为参数赋值的，而我们这边将v14设置成指针类型，导致将v14与v15-v23进行了切割。只需要把v14的指针符号去掉即可。\n\n\n再根据下图的逻辑，定义新的结构体。v7_1申请了0x1E0个空间，因此，我们需要创建的结构体大小应该也是0x1E0。\n\n创建的结构体是这样的，注：168个字节中，可能有好几个成员变量类型。\n\n其实到这一步，也能看出之前想的soinfo是错误的，因此要回到用到了soinfo的地方，把类型改成FourSection_t，然后观察section2&#x2F;3&#x2F;4到底是什么。\nsub_3c94是设置重定位表、符号表等内容的函数，可以看出来section4存放的是.dynamic节（一般DT_DYNAMIC只含一个.dynamic节）。\n\n\n\n而在函数sub_4918中，我们判断第1次调用sub_4000是进行常规重定位（对数据和指令的重定位），第2次调用sub_4000是进行plt重定位（大部分情况是对符号的重定位）。\n\n快有点模糊d_tag和r_info的区别了…这里的0x402和0x403分别是R_AARCH64_JUMP_SLOT、R_AARCH64_RELATIVE，是一种计算修正地址的规则，而这种规则分别常用于.rela.plt和.rela.dyn，因此认为这里的section3和2分别指向.rela.dyn和.rela.plt。\n区分.rela.plt和.rela.dyn的方式是d_tag，d_tag &#x3D;&#x3D; DT_RELA是后者，d_tag &#x3D;&#x3D; DT_JMPREL是前者。\n\n至此，重命名一下。\n\n\n总结一下释放主so的流程：\n\nwrap_elf位于assets&#x2F;libjiagu_a64.so的0x1e270的位置。\n\nwrap_elf经过rc4解密（密钥：b”vUV4#\\x91#SVt”）后，是一个长度为0xb8010的压缩数据A，真正参与解压的数据是A[4:]，也就是说，参与解压的数据的大小是0xb800C，前4个字节描述了解压后数据的大小。\n\n解压后的数据视作wrap_elf，而wrap_elf里分为part1和part2两部分，part1被0xD3异或加密，part2指向一个ELF文件，但PHT、.dynamic节的等内容均被垃圾数据占满。\n\npart1里有4组数据，它的数据结构是这样：xor_key（1个字节）、data1_len（4个字节）、data1、data2_len（4个字节）、data2、data3_len（4个字节）、data3、data4_len、data4；\n\ndata1-data4分别是被0xD3异或加密的PHT、.rela.plt、.rela.dyn、.dynamic。\n\n\n需要注意，0x1e270是在壳so文件里wrap_elf的偏移，而在内存中，wrap_elf的偏移来到了0x2e270，原0x1e270被清空了；之后的主so加载的基址是0xe7000。\n通过下面这个脚本，可以从壳so里直接获得4个解密后的section。\nimport copyimport zlibdef RC4(data, key):    S = list(range(256))    j = 0    out = []    # KSA Phase    for i in range(256):        j = (j + S[i] + key[i % len(key)]) % 256        S[i], S[j] = S[j], S[i]    # PRGA Phase    i = j = 0    for ch in data:        i = (i + 1) % 256        j = (j + S[i]) % 256        S[i], S[j] = S[j], S[i]        out.append(ch ^ S[(S[i] + S[j]) % 256])    return outdef RC4decrypt(ciphertext, key):    return RC4(ciphertext, key)wrap_elf_start = 0x1e270wrap_elf_size = 0xb8010key = b&quot;vUV4#\\x91#SVt&quot;with open(&#x27;com.oacia.apk_protect/assets/libjiagu_a64.so&#x27;, &#x27;rb&#x27;) as f:    wrap_elf = f.read()# 对密文进行解密dec_compress_elf = RC4decrypt(wrap_elf[wrap_elf_start:wrap_elf_start + wrap_elf_size], key)dec_elf = zlib.decompress(bytes(dec_compress_elf[4::]))with open(&#x27;wrap_elf&#x27;, &#x27;wb&#x27;) as f:    f.write(dec_elf)class part:    def __init__(self):        self.name = &quot;&quot;        self.value = b&#x27;&#x27;        self.offset = 0        self.size = 0index = 1extra_part = [part() for _ in range(7)]seg = [&quot;phdr&quot;, &quot;.rela.plt&quot;, &quot;.rela.dyn&quot;, &quot;.dynamic&quot;]v_xor = dec_elf[0]for i in range(4):    size = int.from_bytes(dec_elf[index:index + 4], &#x27;little&#x27;)    index += 4    extra_part[i + 1].name = seg[i]    extra_part[i + 1].value = bytes(map(lambda x: x ^ v_xor, dec_elf[index:index + size]))    extra_part[i + 1].size = size    index += sizefor p in extra_part:    if p.value!=b&#x27;&#x27;:        filename = f&quot;libjiagu.so_&#123;hex(p.size)&#125;_&#123;p.name&#125;&quot;        print(f&quot;[&#123;p.name&#125;] get &#123;filename&#125;, size: &#123;hex(p.size)&#125;&quot;)        with open(filename,&#x27;wb&#x27;) as f:            f.write(p.value)\n\n至于修复，很简单，把part2的主so放到010editor，用得到的4个section进行覆盖就行。\n\n覆盖pht，其它的覆盖方法，需要找.dynamic节，然后得到.rela.plt和.rela.dyn节的偏移是多少，这里不过多赘述。\n\n\n在修复之后，基址设为0xe7000。\n\n\n在获得主so文件之后，下一个主线任务就是找到主dex是如何加载并被解密的，然后获取主dex。\n之前我们在hook函数open的时候，发现open会打开dex文件，通过打印调用函数栈，我们发现主so位于偏移量为0xE7000的位置，现在回顾一下在打开dex文件时的函数调用栈。\n\n\n这里看到的调用栈其实只是部分，因为主so的函数列表并没有添加到壳so生成的脚本里，我之前写的脚本并没有测试过，所以这里还是用大佬oacia的吧。\n在IDA中打开主so，然后使用插件stalker_trace_so，然后将主so的函数列表插回壳so的脚本里，这是佬oacia的截图。\n\n这里我将名字改成keke了hhhhh。\n\n然后插入1个判断即可。\n\n前面在大量地执行壳so的函数，后面基本都在调用主so的函数。\n\n\n在主so中搜索0x19b780，发现这个指令位于函数sub_19B760中，然后在trace.log中，发现没找到sub_19B760，应该是因为没hook maps文件，进程检测到frida，提前退出了。\n在hook了maps文件后，发现获得的日志信息反而变少了。\n[ONEPLUS A6003::com.oacia.apk_protect ]-&gt; start Stalker!Stalker end![keke] call1:JNI_OnLoad[keke] call2:.interpreter_wrap_int64_t[keke] call3:interpreter_wrap_int64_t[keke] call4:._Znwm[keke] call5:sub_13908[keke] call6:._Znam[keke] call7:sub_11220[keke] call8:.memset[keke] call9:sub_9DD8[keke] call10:sub_E3E0[keke] call11:.calloc[keke] call12:.malloc[keke] call13:.free[keke] call14:sub_E648[keke] call15:._ZdaPv[keke] call16:sub_C918[keke] call17:sub_9988[keke] call18:sub_9964[keke] call19:sub_9AC4[keke] call20:.ffi_prep_cif[keke] call21:ffi_prep_cif[keke] call22:.ffi_prep_cif_machdep[keke] call23:ffi_prep_cif_machdep[keke] call24:.ffi_call[keke] call25:ffi_call[keke] call26:sub_1674C[keke] call27:.ffi_call_SYSV[keke] call28:ffi_call_SYSV[keke] call29:sub_167BC[keke] call30:sub_1647C[keke] call31:sub_163DC[keke] call32:sub_9900[keke] call33:sub_94BC[keke] call34:.dladdr[keke] call35:.strstr[keke] call36:.setenv[keke] call37:_Z9__arm_a_1P7_JavaVMP7_JNIEnvPvRi[keke] call38:sub_9E58[keke] call39:sub_999C[keke] call40:sub_10964[keke] call41:j_._ZdlPv_1[keke] call42:._ZdlPv[keke] call43:sub_96E0[keke] call44:sub_8000[keke] call45:.strncpy[keke] call46:sub_60E0[keke] call47:sub_6544[keke] call48:sub_4B54[keke] call49:sub_6128[keke] call50:_ZN9__arm_c_19__arm_c_0Ev[keke] call51:sub_A3EC[keke] call52:sub_99CC[keke] call53:sub_9944[keke] call54:sub_6484[keke] call55:sub_6590[keke] call56:.memcpy[keke] call57:sub_6698[keke] call58:sub_9FFC[keke] call59:j_._ZdlPv_3[keke] call60:j_._ZdlPv_2[keke] call61:j_._ZdlPv_0[keke] call62:sub_A3A0[keke] call63:sub_9A90[keke] call64:sub_5F20[keke] call65:sub_6044[keke] call66:sub_3574[keke] call67:.uncompress[keke] call68:sub_49F0[keke] call69:sub_5400[keke] call70:sub_5478[keke] call71:sub_5B08[keke] call72:sub_5650[keke] call73:sub_580C[keke] call74:.mprotect[keke] call75:.strlen[keke] call76:sub_3C94[keke] call77:.dlopen[keke] call78:sub_4918[keke] call79:sub_4000[keke] call80:sub_41B4[keke] call81:sub_35AC[keke] call82:.dlsym[keke] call83:sub_5E6C[keke] call84:sub_5444[main] call85:sub_11603C[main] call86:j__Znwm[main] call87:_Znwm[main] call88:malloc[main] call89:__cxa_atexit[main] call90:sub_1160B4[main] call91:sub_1160C4[main] call92:strlen[main] call93:memcpy[main] call94:sub_1161FC[main] call95:sub_1164AC[main] call96:sub_1164D8[main] call97:sub_116528[main] call98:sub_1165C8[main] call99:sub_1A32C0[main] call100:sub_1A3150[main] call101:sub_1A3204[main] call102:sub_1166FC[main] call103:sub_116728[main] call104:sub_116750[main] call105:sub_116830[main] call106:sub_116BA0[keke] call107:sub_633C[keke] call108:sub_8130[keke] call109:sub_4C70[keke] call110:sub_825C[keke] call111:sub_8B50[keke] call112:sub_8ED4[keke] call113:sub_8430[main] call114:JNI_OnLoad[main] call115:j_interpreter_wrap_int64_t[main] call116:interpreter_wrap_int64_t[keke] call117:interpreter_wrap_int64_t_bridge[keke] call118:sub_9D60[main] call119:sub_1B3F0C[main] call120:gettimeofday[main] call121:sub_11BD9C[main] call122:sub_1182D8[main] call123:sub_123970[main] call124:sub_1B6448[main] call125:getenv[main] call126:sub_11F130[main] call127:sub_12047C[main] call128:j__ZdlPv[main] call129:_ZdlPv[main] call130:free[main] call131:sub_1427E8[main] call132:dlopen[main] call133:sub_11BDA8[main] call134:sub_11BE58[main] call135:sub_11F69C[main] call136:sub_117BE0[main] call137:sub_117CA0[main] call138:fopenopen /proc/self/mapsfind /proc/self/maps, redirect to /data/data/com.oacia.apk_protect/maps_nonexistent[main] call139:sub_117E90[main] call140:sub_14285C[main] call141:sub_1429CC[main] call142:sub_11C1AC[main] call143:sub_11C1B4[main] call144:sub_11C210[keke] call145:sub_166C4[keke] call146:.puts[main] call147:sub_123324[main] call148:sub_1205A0[main] call149:sub_11F768[main] call150:memcmp[main] call151:opendir[main] call152:closedir[main] call153:sub_11859C[main] call154:sub_11C268[main] call155:sub_11C300[main] call156:sub_117B68[main] call157:sub_1186B8[main] call158:sub_143964[main] call159:sub_1B66A8[main] call160:pthread_mutex_lock[main] call161:sub_142EA0[main] call162:sub_143A38[main] call163:sub_11CF8C[main] call164:sub_131D58[main] call165:sub_1B66D0[main] call166:pthread_mutex_unlock[main] call167:sub_1178E8[main] call168:sub_13D70C[main] call169:sub_19F984[main] call170:sub_11F1C8[main] call171:atoi[main] call172:sub_12D2F8[main] call173:sub_17ABE8[main] call174:sub_172660[main] call175:sub_13BFF0[main] call176:sub_172AA4[main] call177:sub_13BD80[main] call178:sub_13BE2C[main] call179:sub_13BE4C[main] call180:memmove[main] call181:sub_13BE64[main] call182:sub_172D78[main] call183:sub_13E510[main] call184:sub_1926F0[main] call185:sub_13DB7C[main] call186:sub_1B7A08[main] call187:sub_1B7ABC[main] call188:pthread_cond_broadcastopen /proc/self/mapsfind /proc/self/maps, redirect to /data/data/com.oacia.apk_protect/maps_nonexistentopen /proc/self/mapsfind /proc/self/maps, redirect to /data/data/com.oacia.apk_protect/maps_nonexistent[main] call189:sub_12FA34[main] call190:sub_120664[main] call191:sub_1332B8[main] call192:sub_13E0F8open /proc/self/mapsfind /proc/self/maps, redirect to /data/data/com.oacia.apk_protect/maps_nonexistent[main] call193:sub_12743C[main] call194:sub_124C68[main] call195:sub_125DC4[main] call196:sub_124510[main] call197:sub_126888[main] call198:strdup[main] call199:sub_126920[main] call200:sub_122180[main] call201:sub_11BC1C[main] call202:sub_13DF34[main] call203:getpid[main] call204:memset[main] call205:snprintfopen /proc/25453/mapsfind /proc/25453/maps, redirect to /data/data/com.oacia.apk_protect/maps_nonexistent[main] call206:sub_124FA0[main] call207:sub_1B6498[main] call208:sub_1A0C88[main] call209:sub_217444[main] call210:sub_2175E0[main] call211:read[main] call212:strncmp[main] call213:close[main] call214:sub_1B578C[main] call215:j___self_lseek[main] call216:__self_lseek[main] call217:sub_1B586C[main] call218:j_j___read_self[main] call219:j___read_self[main] call220:__read_self[main] call221:sub_1B6528[main] call222:sub_1B6578[main] call223:mmap[main] call224:sub_1B5B50[main] call225:calloc[main] call226:memchr[main] call227:sub_1B5D04[main] call228:sub_1B5EC4[main] call229:sub_1B6270[main] call230:sub_1B6180[main] call231:sub_1B6678[main] call232:inflateInit2_[main] call233:inflate[main] call234:inflateEnd[main] call235:sub_1B6540[main] call236:munmap[main] call237:sub_1B56F8[main] call238:sub_19BC9C[main] call239:sub_19CCD4open /proc/self/mapsfind /proc/self/maps, redirect to /data/data/com.oacia.apk_protect/maps_nonexistent[main] call240:sub_12D470[main] call241:sub_142FE0[main] call242:sub_143008[main] call243:sub_142ABC[main] call244:sub_143848[main] call245:sub_143B48[main] call246:sub_143088[main] call247:sub_1222D0[main] call248:sub_14316C[main] call249:sub_142954[keke] call250:_Z9__arm_a_2PcmS_Rii[main] call251:sub_142894[main] call252:sub_1428BC[main] call253:sub_127DCC[main] call254:sub_14292C[main] call255:sub_121B78[main] call256:sub_121BE0[main] call257:sub_123CE8[main] call258:sub_123BC0[main] call259:sub_11959C[main] call260:sub_1AC170[main] call261:pthread_create[main] call262:sub_1AC210[main] call263:sub_1B5DE4[main] call264:sub_1B60E8[main] call265:sub_19F7C4[main] call266:sub_1B2DC8[main] call267:sub_1B1CE8open /proc/self/mapsfind /proc/self/maps, redirect to /data/data/com.oacia.apk_protect/maps_nonexistent[main] call268:sub_1B0974[main] call269:sub_1AFE6C[main] call270:sub_126ED8[main] call271:sub_1AFE8C[main] call272:sub_1AFE90[main] call273:sub_1AB87C[main] call274:sub_1B26D4[main] call275:sub_1B26F4[main] call276:sub_1B27C8[keke] call277:.ffi_prep_cif_var[keke] call278:ffi_prep_cif_var[main] call279:sub_1AAF48[main] call280:sub_1AAF54[main] call281:sub_2162D4[main] call282:sub_1B2898[main] call283:sub_1B2918[main] call284:sub_1ABE90[main] call285:sub_13E0ECProcess terminated\n\n根据对日志的分析，发现有3个函数是zlib库中用来解压缩的函数——inflateInit2_、inflate、inflateEnd，大概率是用来解压dex文件的。\n对inflateInit2_进行交叉引用，发现2个引用。\n\n根据日志，先查看sub_1B6270。\n\n\n注意到，inflate的参数是s和4。\n\n根据函数签名，可以知道s是z_streamp类型，需要在IDA中添加相应的结构体。\n\n结构体如下，Bytef可以改成Byte*，指针都是8个字节，感觉不用太担心具体类型。\n#  define z_const consttypedef unsigned char  Byte;  /* 8 bits */typedef unsigned int   uInt;  /* 16 bits or more */typedef unsigned long  uLong; /* 32 bits or more */typedef struct z_stream_s &#123;    z_const Bytef *next_in;     /* next input byte */    uInt     avail_in;  /* number of bytes available at next_in */    uLong    total_in;  /* total number of input bytes read so far */    Bytef    *next_out; /* next output byte will go here */    uInt     avail_out; /* remaining free space at next_out */    uLong    total_out; /* total number of bytes output so far */&#125; z_stream;\n\n接下来hook inflate，看看解压缩后的数据是什么，这里有个问题，在主so还没解密时是hook不了的，大佬oacia给了一个思路：哦统计inflate调用的次数，壳ELF在调用uncompress的时候会执行1次inflate，而解压dex的时候就是第2次。\n大佬的思路很好，学习到了，但是不知道为什么大佬的脚本hook的是汇编层指令的地址（可能会报错），而非函数序言地址，直接在onLeave回调时不一样可以dump和打印吗，还可以少定义一个函数。\n下面是从佬博客标注的代码，不全。\nfunction dump_memory(start,size,filename) &#123;    var file_path = &quot;/data/data/com.oacia.apk_protect/&quot; + filename;    var file_handle = new File(file_path, &quot;wb&quot;);    if (file_handle &amp;&amp; file_handle != null) &#123;        var libso_buffer = start.readByteArray(size.toUInt32());        file_handle.write(libso_buffer);        file_handle.flush();        file_handle.close();        console.log(&quot;[dump]:&quot;, file_path);    &#125;&#125;function hook_zlib_result()&#123;    var module = Process.findModuleByName(&quot;libjiagu_64.so&quot;);    Interceptor.attach(module.base.add(0x1B63F0), &#123;        // fd, buff, len        onEnter: function (args) &#123;            console.log(&quot;inflate result&quot;)            console.log(hexdump(next_in, &#123;              offset: 0,// 相对偏移              length: 0x50,//dump 的大小              header: true,              ansi: true            &#125;));            console.log(hexdump(next_out, &#123;              offset: 0,// 相对偏移              length: 0x50,//dump 的大小              header: true,              ansi: true            &#125;));            dump_memory(next_out,avail_out,&quot;dex001&quot;)        &#125;,        onLeave: function (ret) &#123;        &#125;    &#125;);&#125;var zlib_count=0;var next_in,avail_in,next_out,avail_out;function hook_zlib()&#123;    Interceptor.attach(Module.findExportByName(null, &quot;inflate&quot;), &#123;        // fd, buff, len        onEnter: function (args) &#123;            zlib_count+=1            if(zlib_count&gt;1)&#123;                hook_zlib_result();            &#125;            next_in=ptr(args[0].add(0x0).readS64());            avail_in=ptr(args[0].add(0x8).readS64());            next_out=ptr(args[0].add(0x18).readS64());            avail_out=ptr(args[0].add(0x20).readS64());            console.log(hexdump(next_in, &#123;              offset: 0,// 相对偏移              length: 0x50,//dump 的大小              header: true,              ansi: true            &#125;));            console.log(args[1]);        &#125;,        onLeave: function (ret) &#123;        &#125;    &#125;);&#125;\n\n下面是我对佬代码做的删减及必要的补充。\nfunction dump_memory(start,size,filename) &#123;    var file_path = &quot;/data/data/com.oacia.apk_protect/&quot; + filename;    var file_handle = new File(file_path, &quot;wb&quot;);    if (file_handle &amp;&amp; file_handle != null) &#123;        var libso_buffer = start.readByteArray(size.toUInt32());        file_handle.write(libso_buffer);        file_handle.flush();        file_handle.close();        console.log(&quot;[dump]:&quot;, file_path);    &#125;&#125;var zlib_count=0;var next_in,avail_in,next_out,avail_out;function hook_zlib()&#123;    Interceptor.attach(Module.findExportByName(null, &quot;inflate&quot;), &#123;        // fd, buff, len        onEnter: function (args) &#123;            zlib_count+=1            console.log(&quot;[inflate calls]&quot;, zlib_count);            next_in=ptr(args[0].add(0x0).readS64());            avail_in=ptr(args[0].add(0x8).readS64());            next_out=ptr(args[0].add(0x18).readS64());            avail_out=ptr(args[0].add(0x20).readS64());            console.log(hexdump(next_in, &#123;              offset: 0,// 相对偏移              length: 0x64,//dump 的大小              header: true,              ansi: true            &#125;));        &#125;,        onLeave: function (ret) &#123;            if(zlib_count&gt;1)&#123;                console.log(&quot;inflate result&quot;)                console.log(hexdump(next_out, &#123;                  offset: 0,// 相对偏移                  length: 0x50,//dump 的大小                  header: true,                  ansi: true                &#125;));                dump_memory(next_out,avail_out,&quot;dex001&quot;)            &#125;        &#125;    &#125;);&#125;function my_hook_dlopen(soName=&#x27;&#x27;) &#123;    Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;),        &#123;            onEnter: function (args) &#123;                var pathptr = args[0];                if (pathptr !== undefined &amp;&amp; pathptr != null) &#123;                    var path = ptr(pathptr).readCString();                    //console.log(path);                    if (path.indexOf(soName) &gt;= 0) &#123;                        this.is_can_hook = true;                    &#125;                &#125;            &#125;,            onLeave: function (retval) &#123;                if (this.is_can_hook) &#123;                    hook_proc_self_maps();                    hook_zlib();                &#125;            &#125;        &#125;    );&#125;function hook_proc_self_maps() &#123;    const openPtr = Module.getExportByName(null, &#x27;open&#x27;);    const open = new NativeFunction(openPtr, &#x27;int&#x27;, [&#x27;pointer&#x27;, &#x27;int&#x27;]);    var fakePath = &quot;/data/data/com.oacia.apk_protect/maps_nonexistent&quot;;    Interceptor.replace(openPtr, new NativeCallback(function (pathnameptr, flag) &#123;        var pathname = Memory.readUtf8String(pathnameptr);        console.log(&quot;open&quot;,pathname);//,Process.getCurrentThreadId()                if (pathname.indexOf(&quot;maps&quot;) &gt;= 0) &#123;            console.log(&quot;find&quot;,pathname+&quot;, redirect to&quot;,fakePath);            var filename = Memory.allocUtf8String(fakePath);            return open(filename, flag);        &#125;        var fd = open(pathnameptr, flag);        return fd;    &#125;, &#x27;int&#x27;, [&#x27;pointer&#x27;, &#x27;int&#x27;]));&#125;setImmediate(function()&#123;    my_hook_dlopen(&#x27;libjiagu&#x27;);&#125;);\n\n执行效果如下，解压后的数据似乎是一个dex文件？\n\n\n难蚌，为什么解压后的数据与原dex完全相同。\n\n博主根据原apk、加固后的apk，通过比较大小，发现壳dex的末尾附带了一大串加密数据，既然当前的sub_1B6270解压出了和原dex一样的数据A，说明接下来该对这个数据A的末尾进行解密了。\n观察sub_1B6270，会发现，return是用来判断函数sub_1B6270是否执行成功的。\n\n\na3将缓冲区的地址传给了s.next_out，解压后的数据在a3，缓冲区的长度为v19。\n\n\n追踪sub_1B6270，判断a3是在哪申请的缓冲区，根据日志，选择sub_1A0C88。\n\nv10拿到了装有原dex的缓冲区，然后赋给了a3。\n\n根据日志，这里选择追踪函数sub_124FA0。\n\n这里返回值用来判断是否执行成功，s1获得了原dex。\n\ns1会给v27传递一些信息，此后s1没出现过了。\n\n对sub_19BC9C进行分析。\n\n内部状态初始化：对 a1 指向的内存区域进行清零和内部指针设置。\n\nDEX文件处理：解析传入的 s1（壳dex文件），识别其具体类型（DEX, ODEX, CDEX），并调整 a1 中的指针以指向有效的DEX数据区域。这使得后续代码可以通过 a1 方便地访问DEX内容。\n\n构建JNI类型映射：在 a1 结构的某个区域（从偏移 0x138 开始）构建一个从JNI短类型签名到完整Java类名的映射表。这个映射表是执行JNI操作（如方法调用、字段访问）时进行类型匹配和转换的基础。\n\n\n 看来也没有壳dex末尾的加密数据进行解密，继续交叉引用sub_124FA0，结合日志，下一个追踪的函数是sub_1332B8。\n\n\n\n调用链应该是这样的，除此之外，暂时没什么成果。\nsub_1332B8-&gt;sub_124FA0-&gt;sub_1A0C88-&gt;sub_1B6270-&gt;inflate\n\n回到函数open打开classes.dex时的函数调用栈，如下图。\n\n\n\n\n查看函数0x19b780的引用，发现有2次引用来自sub_1332b8，根据上面2个图，结合0x134680 &#x3D;&#x3D; 0x1332b8 + 0x13c4 + 0x4和0x134598 &#x3D;&#x3D; 0x1332b8 + 0x12dC + 0x4。\n\n所以classes.dex对应的sub_19b760，在sub_1332B8+12DC处被调用。\n而classes2.dex和classes3.dex对应的sub_19b760，在subsub_1332B8+13C4处被调用。\n\n注意到，壳dex的中注入的加密数据位于0x3198h处，而大小是0x41FD18。\n\n尝试hook一下sub_19b760，观察buffer和buffer_size是否有符合壳dex末尾加密数据的特征。\n大佬没给脚本，自己写一个脚本吧。\n考虑到sub_19b760是主so中的函数，如果hook得太早，主so还没有加载，这样hook不上，甚至可能会有报错；如果hook太晚，sub_19b70可能执行完了。\n所以需要找一个时机，主so已经加载完，并且sub_19b70还没清空的时机——其实拿inflate第2次执行的时机就行。\nfunction my_hook_dlopen(soName=&#x27;&#x27;) &#123;    Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;),        &#123;            onEnter: function (args) &#123;                var pathptr = args[0];                if (pathptr !== undefined &amp;&amp; pathptr != null) &#123;                    var path = ptr(pathptr).readCString();                    //console.log(path);                    if (path.indexOf(soName) &gt;= 0) &#123;                        this.is_can_hook = true;                    &#125;                &#125;            &#125;,            onLeave: function (retval) &#123;                if (this.is_can_hook) &#123;                    hook_proc_self_maps();                    hook_zlib();                &#125;            &#125;        &#125;    );&#125;function hook_proc_self_maps() &#123;    const openPtr = Module.getExportByName(null, &#x27;open&#x27;);    const open = new NativeFunction(openPtr, &#x27;int&#x27;, [&#x27;pointer&#x27;, &#x27;int&#x27;]);    var fakePath = &quot;/data/data/com.oacia.apk_protect/maps_nonexistent&quot;;    Interceptor.replace(openPtr, new NativeCallback(function (pathnameptr, flag) &#123;        var pathname = Memory.readUtf8String(pathnameptr);        console.log(&quot;open&quot;,pathname);//,Process.getCurrentThreadId()                if (pathname.indexOf(&quot;maps&quot;) &gt;= 0) &#123;            console.log(&quot;find&quot;,pathname+&quot;, redirect to&quot;,fakePath);            var filename = Memory.allocUtf8String(fakePath);            return open(filename, flag);        &#125;        var fd = open(pathnameptr, flag);        return fd;    &#125;, &#x27;int&#x27;, [&#x27;pointer&#x27;, &#x27;int&#x27;]));&#125;var zlib_count = 0;function hook_zlib()&#123;    Interceptor.attach(Module.findExportByName(null, &quot;inflate&quot;), &#123;        // fd, buff, len        onEnter: function (args) &#123;            zlib_count = zlib_count + 1;        &#125;,        onLeave: function (ret) &#123;            // 此时的sub_19b760已经解密完成，而且没有被清空            if(zlib_count == 2)&#123;                hook_sub_19b760();            &#125;        &#125;    &#125;);&#125;function hook_sub_19b760()&#123;    const module = Process.findModuleByName(&quot;libjiagu_64.so&quot;);    console.log(&quot;[so base]&quot;, &quot;0x&quot; + module.base.toString(16))    Interceptor.attach(module.base.add(0x19b760), &#123;        onEnter: function(args)&#123;            console.log(&quot;[path]&quot;, args[0].readCString());            console.log(&quot;[buffer] size =&quot;, &quot;0x&quot;+args[2].toString(16));            console.log(hexdump(args[1], &#123;length: 64&#125;));        &#125;    &#125;)&#125;setImmediate(function()&#123;    my_hook_dlopen(&#x27;libjiagu&#x27;);&#125;);\n\n执行结果如下，可以看到，打开的classes.dex正是壳dex末尾的注入数据，连大小都是0x41fd18。\n\n在sub_1332B8中，打开了classes.dex，已经确定了sub_19B760的3个参数的内容是什么，追踪dex_buffer。\n\ndex_buffer会作为参数传递给sub_128D44。\n\n\n转到汇编层，可以看到j_interpreter_wrap_int64_t的参数不应该是0。\n\n根据寄存器的大小，修改成下面这样。\n\n接着，通过stalker_trace_so的日志可以发现，函数sub_128D44没执行。博主在这个问题上的解决办法是：在调用sub_128D44的位置，再调用一次trace_so()。\n\n博主给出了脚本的片段，如下图所示。\n\n我试验了一下，进程还是退出了，可能是我hook的时机不对，干脆先把反调过了，然后再执行stalker_trace_so，使用下面这个脚本可以找到哪里调用了pthread_create。\nfunction check_pthread_create() &#123;    var pthread_create_addr = Module.findExportByName(null, &#x27;pthread_create&#x27;);    var pthread_create = new NativeFunction(pthread_create_addr, &quot;int&quot;, [&quot;pointer&quot;, &quot;pointer&quot;, &quot;pointer&quot;, &quot;pointer&quot;]);    Interceptor.replace(pthread_create_addr, new NativeCallback(function (parg0, parg1, parg2, parg3) &#123;        var so_name = Process.findModuleByAddress(parg2).name;        var so_path = Process.findModuleByAddress(parg2).path;        var so_base = Module.getBaseAddress(so_name);        var offset = parg2 - so_base;        var PC = 0;        if ((so_name.indexOf(&quot;jiagu&quot;) &gt; -1)) &#123;            console.log(&quot;======&quot;)            console.log(&quot;find thread func offset&quot;, so_name, offset.toString(16));            Thread.backtrace(this.context, Backtracer.ACCURATE).map(addr_in_so);            var check_list = []//1769036,1771844            if (check_list.indexOf(offset)!==-1) &#123;                console.log(&quot;check bypass&quot;)            &#125; else &#123;                PC = pthread_create(parg0, parg1, parg2, parg3);            &#125;        &#125; else &#123;            PC = pthread_create(parg0, parg1, parg2, parg3);        &#125;        return PC;    &#125;, &quot;int&quot;, [&quot;pointer&quot;, &quot;pointer&quot;, &quot;pointer&quot;, &quot;pointer&quot;]))&#125;function addr_in_so(addr)&#123;    var process_Obj_Module_Arr = Process.enumerateModules();    for(var i = 0; i &lt; process_Obj_Module_Arr.length; i++) &#123;        if(addr&gt;process_Obj_Module_Arr[i].base &amp;&amp; addr&lt;process_Obj_Module_Arr[i].base.add(process_Obj_Module_Arr[i].size))&#123;            console.log(addr.toString(16),&quot;is in&quot;,process_Obj_Module_Arr[i].name,&quot;offset: 0x&quot;+(addr-process_Obj_Module_Arr[i].base).toString(16));        &#125;    &#125;&#125;setImmediate(function()&#123;    check_pthread_create();&#125;);\n\n\n\n由于无法判断是哪个线程检测了frida，这里并不方便把目标线程函数替换为空。\n先来0x17710看看，并没有看到pthread_create，这里的X24里面应该存放了pthread_create的地址。\n\n\n大佬oacia在这里写得有些模糊。这里X24不一定是pthread_create，还有可能是其它的函数，通过这种动态跳转的方式，避免在静态调试工具中暴露易被检测的函数。\n大佬在这里一个一个改x0-x6，emmm，先判断X24跳转的函数是什么，然后查看对应的寄存器会更好吧。\n这里借着大佬已经分析出的解决方案——修改x6指向的字符串，去思考为什么是修改x6。\n之前我们hook maps文件，是因为存在读maps文件的操作，但要如何逐行检测frida呢？是靠strstr吗？这里的x6说明了参数的数目之多，strstr可没那么多参数。\n我写了个脚本，hook x6寄存器，并根据x24跳转的地址，根据它的偏移量，计算跳转的目标函数是什么。\nfunction anti_frida_check() &#123;    var module = Process.findModuleByName(&quot;libjiagu_64.so&quot;);    if (!module) &#123;        // console.log(&quot;[anti_frida_check] libjiagu_64.so not found.&quot;);        return;    &#125;    Interceptor.attach(module.base.add(0x1770C), &#123;        onEnter: function (args) &#123;            try &#123;                // 确保 X6 是一个有效的指针再尝试读取                if (this.context.x6 &amp;&amp; !this.context.x6.isNull()) &#123;                    var s = null;                    try &#123;                        s = this.context.x6.readCString();                    &#125; catch (readError) &#123;                        // console.log(&quot;[anti_frida_check] Error reading string from X6: &quot; + readError.message);                        return; // 如果无法读取字符串，则不继续                    &#125;                    if (s &amp;&amp; (s.indexOf(&#x27;frida&#x27;) !== -1 ||                              s.indexOf(&#x27;gum-js-loop&#x27;) !== -1 ||                              s.indexOf(&#x27;gmain&#x27;) !== -1 ||                              s.indexOf(&#x27;linjector&#x27;) !== -1 ||                              s.indexOf(&#x27;/proc/&#x27;) !== -1)) &#123;                                                console.log(&quot;\\n==================================================&quot;);                        console.log(&quot;[+] Frida-related string detected in X6!&quot;);                        console.log(&quot;    Original string (s) from X6: \\&quot;&quot; + s + &quot;\\&quot;&quot;);                                                console.log(&quot;--- Register Dump (X0-X6) ---&quot;);                        console.log(&quot;    X0: &quot; + this.context.x0);                        console.log(&quot;    X1: &quot; + this.context.x1);                        console.log(&quot;    X2: &quot; + this.context.x2);                        console.log(&quot;    X3: &quot; + this.context.x3);                        console.log(&quot;    X4: &quot; + this.context.x4);                        console.log(&quot;    X5: &quot; + this.context.x5);                        console.log(&quot;    X6: &quot; + this.context.x6 + &quot; (Pointer value)&quot;);                        console.log(&quot;--- X24 Analysis ---&quot;);                        var x24_val = this.context.x24;                        console.log(&quot;    X24 points to address: &quot; + x24_val);                        if (x24_val &amp;&amp; !x24_val.isNull()) &#123;                            var symbolInfo = DebugSymbol.fromAddress(x24_val);                            if (symbolInfo &amp;&amp; symbolInfo.name) &#123;                                var moduleName = symbolInfo.moduleName || &quot;unknown module&quot;;                                var moduleBase = Module.findBaseAddress(moduleName) || ptr(0);                                var symbolOffset = symbolInfo.address.sub(moduleBase); // Offset of symbol from module base                                var pcOffsetFromSymbolStart = x24_val.sub(symbolInfo.address); // Offset of PC from symbol start                                console.log(&quot;    -&gt; Resolved Symbol: &quot; + symbolInfo.name);                                console.log(&quot;       Module: &quot; + moduleName + &quot; (Base: &quot; + moduleBase + &quot;)&quot;);                                console.log(&quot;       Symbol Address: &quot; + symbolInfo.address + &quot; (Offset in module: 0x&quot; + symbolOffset.toString(16) + &quot;)&quot;);                                console.log(&quot;       X24 is +0x&quot; + pcOffsetFromSymbolStart.toString(16) + &quot; bytes from symbol start.&quot;);                            &#125; else &#123;                                // 如果 DebugSymbol 未直接找到名称，尝试通过 ModuleMap 查找模块                                var moduleDetails = Process.findModuleByAddress(x24_val);                                if (moduleDetails) &#123;                                    console.log(&quot;    -&gt; Address is within module: &quot; + moduleDetails.name);                                    console.log(&quot;       Module Base: &quot; + moduleDetails.base);                                    console.log(&quot;       Offset from module base: 0x&quot; + x24_val.sub(moduleDetails.base).toString(16));                                &#125; else &#123;                                    console.log(&quot;    -&gt; Could not resolve X24 to a specific function or module.&quot;);                                &#125;                            &#125;                        &#125; else &#123;                            console.log(&quot;    -&gt; X24 is null or its value is invalid.&quot;);                        &#125;                        console.log(&quot;==================================================\\n&quot;);                    &#125;                &#125;            &#125; catch (e) &#123;                // 捕获外部 try-catch 的错误，例如 this.context 访问问题（虽然不太可能）                // console.log(&quot;[anti_frida_check] General error in onEnter: &quot; + e.message);            &#125;        &#125;,        onLeave: function (ret) &#123;        &#125;    &#125;);&#125;function my_hook_dlopen(soName = &#x27;&#x27;) &#123;    Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;),        &#123;            onEnter: function (args) &#123;                var pathptr = args[0];                if (pathptr !== undefined &amp;&amp; pathptr != null &amp;&amp; !pathptr.isNull()) &#123; // 添加 !pathptr.isNull() 检查                    var path = &quot;&quot;;                    try &#123;                        path = ptr(pathptr).readCString();                    &#125; catch (e) &#123;                        // console.log(&quot;Error reading SO path: &quot; + e.message);                        return;                    &#125;                                        if (path &amp;&amp; soName &amp;&amp; path.indexOf(soName) &gt;= 0) &#123; // 确保 soName 也有效                        this.is_can_hook = true;                    &#125;                &#125;            &#125;,            onLeave: function (retval) &#123;                if (this.is_can_hook) &#123;                    // console.log(&quot;[my_hook_dlopen] Detected &quot; + (soName || &quot;target SO&quot;) + &quot;. Attaching anti_frida_check.&quot;);                    anti_frida_check();                    this.is_can_hook = false; // 重置标志，避免重复附加                &#125;            &#125;        &#125;    );&#125;setImmediate(function() &#123;    // 你可以在这里指定要监控的 soName，例如 &#x27;libjiagu_64.so&#x27;    // 如果不指定，或者指定空字符串，my_hook_dlopen 默认的 soName=&#x27;&#x27;    // path.indexOf(&#x27;&#x27;) 总是返回0（为真），这会导致对每个dlopen都尝试设置anti_frida_check    // 建议明确指定 soName 来提高目标性，例如：    // my_hook_dlopen(&#x27;libjiagu_64.so&#x27;);     // 如果你希望保持原样，对所有SO加载（dlopen）后都调用 anti_frida_check（如果 libjiagu_64.so 已加载）    // 那么下面的调用是正确的，但请注意 anti_frida_check 内部会找 libjiagu_64.so    my_hook_dlopen(&#x27;libjiagu_64.so&#x27;); // 修改此处，明确指定目标SO，使anti_frida_check只在该SO加载后执行一次&#125;);\n\n执行结果如下，那应该很好猜了，sscanf是用来逐行解析maps文件的，然后比较对应的字段，判断是否有frida的痕迹。\n\n\n接下来，只要将x6替换掉即可，博主给出了代码，添加一下执行时机即可使用，在这里就不写了。\nfunction anti_frida_check()&#123;    var module = Process.findModuleByName(&quot;libjiagu_64.so&quot;);    Interceptor.attach(module.base.add(0x1770C), &#123;        onEnter: function (args) &#123;            try&#123;                var s = this.context.x6.readCString();                if (s.indexOf(&#x27;frida&#x27;)!==-1 ||                    s.indexOf(&#x27;gum-js-loop&#x27;)!==-1 ||                    s.indexOf(&#x27;gmain&#x27;)!==-1 ||                    s.indexOf(&#x27;linjector&#x27;)!==-1 ||                    s.indexOf(&#x27;/proc/&#x27;)!==-1)&#123;                    //console.log(s)                    Memory.protect(this.context.x0, Process.pointerSize, &#x27;rwx&#x27;);                    var replace_str=&quot;&quot;                    for(var i=0;i&lt;s.length;i++)&#123;                        replace_str+=&quot;0&quot;                    &#125;                    this.context.x0.writeUtf8String(replace_str);                &#125;            &#125;            catch (e)&#123;            &#125;        &#125;,        onLeave: function (ret) &#123;        &#125;    &#125;);&#125;\n\n\n现在再试试能不能使用stalker_trace_so追踪所有函数了。\n成功了，这回能够一直trace下去了，哈哈哈哈哈哈哈: &#x2F;\n\n顺着stalker_trace_so，沿着0x128D44继续往下分析，直到分析sub_18FEA8，这个函数内部存在大量的字符。\n先hook这个函数的参数看看。\n\n\n打印了3次，有理由去怀疑它与3个dex文件相关，感觉a1是数字、a2是地址、a3是大小，a4是地址，a5又是大小，a6暂时不知道。\n\n\n修改一下，a2和a3分别代表着解密后的dex文件和文件大小。\n\n根据oacia大佬的说明，函数sub_18FEA8里的字符串解密后，与dex文件的加载有关，这里就不深入了，主要还是关心dex文件是如何解密的。\n我还是觉得sub_128d44很可疑，只输入一个加密的dex，加密的dex又不能提取什么信息，除了解密，还能干嘛？如果要解密，必须读取加密dex，所以可以在加密dex设置读写断点。\n让gemini帮我写一个，脚本过于丑陋，就不外露了。\n下面是打印结果。\n\n注意到，打印出来的内容基都是read的操作，而没有写的操作，说明解密后的dex放到了内存的另一个地方。——20250526-20:51，明天再看，看了一天了有点累了。\n——早上好~现在是20250527-09:04，继续分析。\n通过上图的hook，可以知道libjiagu_64.so偏移0xd364的位置访问了加密dex，而且这个偏移一眼是壳代码，偏移为0xd364的指令位于函数sub_C918内。\n然而查看stalker_trace_so，发现sub_128D44后面没有跟着sub_C918，为什么？我的猜测如下：脚本hook的时机不对，frida_stalker_so hook的时机是当android_dlopen_ext检测到库libjiagu_64.so时，在onLeave回调时调用trace_so，对所有在func_addr列表上的地址进行追踪，然而，主so在没加载的时候，主so某些函数尚未解密，此时frida-stalker插的桩似乎并不有效，总之，可能会引起问题。\n尝试验证一下：在第二次inflate的时候开始执行trace_so，第二次inflate的时候，主so应该是解密完成的。\n下图是打印结果，看来猜对了。\n\n\nhook一下sub_c918，根据观察，a1总为0，a2和a3应该是地址，a4不知道是什么；而且我明明写了onLeave回调，但这里没触发，说明函数sub_C918内访问了加密dex并调用了解密函数。\n\n\nhook一下，查看执行到0xd364时，X19和X24的值。\n也就是说x19 + x24 &#x3D;&#x3D; 0x7009ee4ce4，而[0x7009ee4ce4]的值为0x707aa982e0，0x707aa982e0刚好是0x707aa872d8 + 8的位置，因此访问了加密dex的缓冲区，触发了断点。\n\n\n\n把脚本改了一下，验证一下，结果如下。\n\n和在010editor中加密dex的第2个8字节一样，说明思路是对的——但是注意，这里的汇编指令是STR W0，也就是传了4个字节，而非8个字节。\n\n光看sub_c918，没发现解密内容。\n\n\n而且似乎只访问了上图的内容，然后做了一个内存移动的操作，从将dex加密的第3个4字节从[x19, x24]移到[x19, x21]。\n\n根据stalker_frida_so，继续往下分析其它的函数，寻找加密点。\n在sub_143008发现了加解密的代码。\nvaddq_s8，批量进行加法；veorq_s8，批量进行异或。\n\n\nhook sub_143008的形参。\n\n结果如下。\n\narg1不知道是什么。\narg2指向着压缩的dex的第12个字节开始的地址。\n\narg2 &#x3D;&#x3D; 0x41e，这不正是偏移0xD364处的指令，所读取那4个字节吗？\n\n解密一下，发现是配置信息。\n\n\n解密算法是：（加密字节 + 0x70）^0x36，但这仅仅针对0x41E个字节，并不足以解密整个dex文件。\n接下来，大佬的思路是：在调用链中，发现用到了pthread_mutex_lock函数，说明有多个线程，当前的frida-stalker追踪的是某一线程，有可能是其它的线程完成了对dex的解密。\n\n\n查看sub_143848、sub_1B66A8，看看是哪个函数调用了锁。\n\n\n既然函数sub_143848涉及到锁，说明会有多个线程调用sub_143848，因此对函数sub_143848进行hook。\n照着博客的代码，改了一下脚本，追踪非主线程的线程，只trace一次。\n\n\n打印结果如下，和大佬博客的一模一样。\n\n\n然后大佬发现sub_1A1D84是一个解密函数。\n但是！其实我在主线程的trace.log中也看到了这个函数，可能是大佬没注意吧？\nsub_1A1D84是一个典型的RC4算法函数，一眼a2是密钥，a3是长度。\n\n\nhook一下，获得密钥的内容。长16字节，内容是：0x68,0x76,0x99,0x72,0x96,0x60,0x9f,0x63,0x96,0x2c,0x98,0x30,0xc2,0x36,0x51,0x42\n\n与sub_1A1D84的下一个函数调用是sub_1A1E74，明显的rc4解密。\nhook一下，查看函数sub_1A1E74在对什么进行解密。\n第一个加密内容如下所示。\n\n将f7 4f e8 0e 62 19作为搜索关键词，在壳dex中进行搜索。\n蓝色部分是不知道什么作用的8个字节，蓝色与红色直接是加密内容的长度，也就是0x10949f，红色部分是加密内容，因此，可以判断sub_1A1E74在对壳dex尾部的加密数据进行逐段解密。\n\n同时注意到，先前先加0x70，再异或0x36的加密内容，同样源于壳dex的末尾，同样前8个字节不知道是什么，然后4个字节代表加密内容大小，0x31A4 + 0x41E &#x3D;&#x3D; 0x35C2，正好是上面那段加密内容的起始部分。\n\n因此，可以猜测壳dex有多个段被加密，数据结构是这样的：不知道什么作用的8个字节 + 加密内容长度（4个字节） + 加密内容 + 不知道什么作用的8个字节…….\n计算一下下一段加密内容的起始地址：0x10949F + 0x35CE &#x3D;&#x3D; 0x10CA6D，下一个加密内容的长度是0x31a3028，这个长度明显不肯，说明关于壳dex的数据结构猜测有问题，说明存在其它的加密方式。\n\n观察我们的打印日志，只有f7 4f e8 0e 62开头encrypt_data在壳dex中，其它的加密内容，并没有出现在壳dex中。统计一下，有3个f7 4f e8 0e 62开头encrypt_data，还有3个长度为0x6400的encrypt_data，会不会代表着3个dex文件及其加密组件呢？\n\n\n把这3个内容解密看看，然而并没有出现dex的魔术。\n\n\n总结一下，这3个rc加密的内容，分别在偏移0x35CE , 0x3A93AD , 0x417064的位置。\n看了一眼博主的分析，好像确实是这样！\n所以，加密dex的数据结构应该是这个样子：未知8个字节、配置信息长度（4字节）、配置信息、加密内容个数（4个字节）、加密内容1的总长度（4个字节）、加密内容1需要rc4解密的长度（4个字节）、加密内容1、加密内容2的总长度（4个字节）、加密内容2需要rc4解密的长度（4个字节）、加密内容2、加密内容3的总长度（4个字节）、加密内容3需要rc4解密的长度（4个字节）、加密内容3。\n\n如此，便可写一个脚本，尝试把加密内容脱下来并解密，如下图所示，下图是dex1的内容，仍然是加密内容。\n\n\n跟着博主（函数调用链）继续分析，函数sub_18F6AC似乎在做解密。\n其中，a3是加密内容被rc4解密后，从0xC开始的数据地址。\n\n\n具体如下图所示。\n\n还有11个字节，在函数sub_18DCC0进行处理。以5、4、4字节的大小进行读取。\n\n以dex1.dex为例，按照这种方式进行读取的话，内容在破折号后面，记作a1、a2、a3——0x 01 00 00 00 5D、0x 00 40 00 00、0x 00 10 94 92。\na2：\n之前将加密内容分成了：1.rc4解密数据，2.未加密数据；而在更早之前，我们在hook maps文件的时候，曾获得了一个解密的dex文件，经过搜索未加密数据，发现未加密数据在dex的偏移量刚好是a2。\n以dex1.dex为例，dex1的a2是0x400000，那未加密数据的内容，在dex1.dex中需要移动到偏移量为0x400000的地方。\n下图是dex1.dex。\n\n下图是未加密数据。\n\n而a3，代表着第2次解密的长度（尚未知道是什么算法）。\n\n随后，发现了一个很关键的信息——sub_128D44的返回值是一个3级指针，指向着解密之后的dex。\n\n而且，这个dex数据的首地址是0x6ffeae3000，一般mmap申请空间才会这么规整，按照0x1000对齐来给空间。\n发现，sub_19b73c调用了mmap。\n那咱可以尝试在mmap调用完后，获得申请的空间地址，然后对这部分空间下读写断点，同时打印调用栈。\nfunction hook_mmap()&#123;    var module = Process.findModuleByName(&quot;libjiagu_64.so&quot;);    Interceptor.attach(module.base.add(0x19B81C), &#123;        // fd, buff, len        onEnter: function (args) &#123;            console.log(&quot;mmap!&quot;)            console.log(this.context.x0);            MemoryAccessMonitor.enable(                &#123;                    base:this.context.x0,                    size:30                &#125;,&#123;                    onAccess: function (details) &#123;                        console.log(details.operation)                        console.log(get_addr_in_so(details.from));                    &#125;                &#125;            )        &#125;,        onLeave: function (ret) &#123;        &#125;    &#125;);&#125;function get_addr_in_so(addr)&#123;    var process_Obj_Module_Arr = Process.enumerateModules();    for(var i = 0; i &lt; process_Obj_Module_Arr.length; i++) &#123;        if(addr&gt;process_Obj_Module_Arr[i].base &amp;&amp; addr&lt;process_Obj_Module_Arr[i].base.add(process_Obj_Module_Arr[i].size))&#123;            return addr.toString(16)+&quot; is in &quot;+process_Obj_Module_Arr[i].name+&quot; offset: 0x&quot;+(addr-process_Obj_Module_Arr[i].base).toString(16);        &#125;    &#125;    return addr.toString(16);&#125;\n\n脚本执行结果如下，可以发现调用了3次mmap，对应3个dex的映射，同时通过写断点，找到了是哪里在给这块内容进行写操作——0x18ebd4。\n\n\n定位过来，在函数sub_18E8D0内部，这个函数十分大，第2次解密算法是自定义的算法，一般自定义算法，我会通过trace，通过汇编指令逐步还原解密法。——实习还没着落，不太想花时间在这，暂时先搁置吧。\n可以猜到v15是基址，v4是游标，v28是解密后的内容。\n\n\n最后写一个脚本，判断一下这里的v28是不是解密后的dex。\n\n\n还不是dex的魔数？但发现：a1 a0 bd cf f5 f6 fd c5与c5进行异或后。\n\n原来还有一步异或。\n感想很感谢有这样的大佬愿意分享技术博客，光是复现就学到很多了，谢谢！\n从我自己的角度来说，这一次分析360免费壳真是学到了很多，不仅对动态链接的流程更加深刻了，同时开阔了眼界——还能这么玩？\n在复现的时候，对于主so的还原，我还有些思路，就算没思路了还可以看看大佬的博客；但在主dex的还原时，明显感觉到，我的分析缺乏目的性，虽然看了大佬的博客会有思路，但很多时候还是踩在巨人的肩膀上，我很难想象要是从头自己分析，要分析得有多崩溃（可能我太菜了吧）。\n总结\n数字壳的加固方案：壳DEX-&gt;壳ELF-&gt;主ELF-&gt;主DEX——具体的加固方式在上面的内容中。\n反调使用了sscanf解读maps文件，读取相应字段对frida进行检测，这算是常规操作了。\n\n不足之处1.学习如何写JEB脚本，oacia师傅写了一个JEB解密脚本，可以简单学习一下。\n# coding=utf-8from com.pnfsoftware.jeb.client.api import IScript, IconType, ButtonGroupTypefrom com.pnfsoftware.jeb.core import RuntimeProjectUtilfrom com.pnfsoftware.jeb.core.units.code.java import IJavaSourceUnitfrom com.pnfsoftware.jeb.core.units.code import ICodeUnit, ICodeItemfrom com.pnfsoftware.jeb.core.output.text import ITextDocumentfrom com.pnfsoftware.jeb.core.units.code.java import IJavaSourceUnit, IJavaStaticField, IJavaNewArray, IJavaConstant, IJavaCall, IJavaField, IJavaMethod, IJavaClassfrom com.pnfsoftware.jeb.core.events import JebEvent, Jfrom com.pnfsoftware.jeb.core.util import DecompilerHelper# 解密字符串函数的类名以及方法名methodName = [&#x27;Lcom/qihoo/util/a;&#x27;, &#x27;a&#x27;]class dec_str_360jiagu(IScript):    def run(self, ctx):        print(&#x27;start deal with strings&#x27;)        self.ctx = ctx        engctx = ctx.getEnginesContext()        if not engctx:            print(&#x27;Back-end engines not initialized&#x27;)            return        projects = engctx.getProjects()        if not projects:            print(&#x27;There is no opened project&#x27;)            return        units = RuntimeProjectUtil.findUnitsByType(projects[0], IJavaSourceUnit, False)        for unit in units:            javaClass = unit.getClassElement()            print(&#x27;[+] decrypt:&#x27; + javaClass.getName())            self.cstbuilder = unit.getFactories().getConstantFactory()            self.processClass(javaClass)            unit.notifyListeners(JebEvent(J.UnitChange))        print(&#x27;Done.&#x27;)    def processClass(self, javaClass):        if javaClass.getName() == methodName[0]:            return        for method in javaClass.getMethods():            block = method.getBody()            i = 0            while i &lt; block.size():                stm = block.get(i)                self.checkElement(block, stm)                i += 1    def checkElement(self, parent, e):        try:            if isinstance(e, IJavaCall):                mmethod = e.getMethod()                mname = mmethod.getName()                msig = mmethod.getSignature()                if mname == methodName[1] and methodName[0] in msig:                    v = []                    for arg in e.getArguments():                        if isinstance(arg, IJavaConstant):                            v.append(arg.getString())                    if len(v) == 1:                        decstr = self.decryptstring(v[0])                        parent.replaceSubElement(e, self.cstbuilder.createString(decstr))            for subelt in e.getSubElements():                if isinstance(subelt, IJavaClass) or isinstance(subelt, IJavaField) or isinstance(subelt, IJavaMethod):                    continue                self.checkElement(e, subelt)        except:            print(&#x27;error&#x27;)    def decryptstring(self, string):        src = []        for index, char in enumerate(string):            src.append(chr(ord(char) ^ 16))        return &#x27;&#x27;.join(src).decode(&#x27;unicode_escape&#x27;)\n\n2.根据大佬的博客，在attachBaseContexr中会加载DtcLoader类，jeb中没显示出来，而在jadx中显示了，这是如何做到的？这个DtcLoader做了什么？\n3.onCreate的vmp没分析。\n参考链接https://oacia.dev/360-jiagu/\n","tags":["收获颇多hhh"]},{"title":"baidu免费壳分析复现","url":"/2025/05/27/baidu%E5%85%8D%E8%B4%B9%E5%A3%B3%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0/","content":"libbaiduprotect.so加载分析通过Manifest可以看到包名和第一个加载的app类。——“com.example.test”和“com.baidu.protect.StubApplication”。\n\n在原来的lib下，多出了一个libbaiduprotect.so，而在assets下面也多了几个文件。\n\n猜测是libbaiduprotect.so将assets下的文件解密出了dex，然后进行加载。\n下面开始分析。\n根据app类的名称，找到app类，一般整体壳，app类会对attachBaseContext和onCreate进行覆写。\n先看attachBaseContext。\n\n\n其中，StubApplication.loadLibrary实际上是加载了libbaiduprotect.so，因此，接下来用ida查看libbaiduprotect.so。\n\n搜索函数“init_proc”并没有搜到，接下来查看.init_array节，存在以下在加载so阶段会执行的函数。\n\n\n先来看sub_88060，一眼混淆，本来靠着NOP，去掉了几个虚假控制流和不透明谓词，但还是太多了，直接使用d810进行处理。\n\n处理完后，算上default的话，有32个case选项，看样子是在做解密操作。\n\n再来看JNI_OnLoad，会发现被加密了，可以猜到是sub_88060对它进行了加密。\n\n下面是一个frida脚本，用于在sub_88060解完密后，第一时间dump整个so。\n// 要hook的函数offsetvar offset = 0x88060;// so文件的大小var module_size = 0;// 要hook的so的名字var module_name = &quot;libbaiduprotect.so&quot;;function hook_linker_call_constructors() &#123;    // 获得linker64的地址    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;)    let offset_call = 0x51BA8    // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset_call)    let listener = Interceptor.attach(call_constructors,&#123;        onEnter:function(args)&#123;            // 判断是否可以通过findModuleByName查找到目标so文件            console.log(&#x27;[linker] Call_Constructors onEnter&#x27;)            let secmodule = Process.findModuleByName(module_name);            if (secmodule != null)&#123;                module_size = secmodule.size;                // 第一时间hook                hook_target_func(secmodule.base);                listener.detach();            &#125;        &#125;    &#125;)&#125;function hook_target_func(baseaddr)&#123;    let listener = Interceptor.attach(baseaddr.add(offset), &#123;        onEnter:function(args)&#123;        &#125;,        onLeave:function(retval)&#123;            // 在执行完某个函数后，立马进行dump            dump(baseaddr, module_size);            listener.detach();        &#125;    &#125;);&#125;function dump(begin_addr, dump_size)&#123;    console.log(&quot;[name] &quot;, module_name);    console.log(&quot;[base] &quot;, begin_addr);    console.log(&quot;[size] &quot;, &quot;0x&quot; + dump_size.toString(16));    var file_path = &quot;/data/data/com.example.test/zzc_&quot; + begin_addr + &quot;_0x&quot; + dump_size.toString(16) + &quot;.so&quot;;    var file_handle = new File(file_path, &quot;wb&quot;);    if (file_handle &amp;&amp; file_handle != null) &#123;        Memory.protect(ptr(begin_addr), dump_size, &#x27;rwx&#x27;);        var libso_buffer = ptr(begin_addr).readByteArray(dump_size);        file_handle.write(libso_buffer);        file_handle.flush();        file_handle.close();        console.log(&quot;[dump] &quot;, file_path);    &#125;&#125;setImmediate(hook_linker_call_constructors)\n\n将dump下来的so文件，通过soFixer进行修复。\nSoFixer-Windows-64.exe -s .\\zzc_0x6f7471a000_0xc1000.so -o .\\zzc_0x6f7471a000_0xc1000.sofixer.so -m 0x6f7471a000 -d\n\n可以看到，JNI_OnLoad已经恢复正常了。\n\n接下来看其它的在.init_array上的函数（在加密so的中查看）。\n查看sub_6FC4。\n\n可以看出来，qword_28c28s是一个函数指针，它在解密后面那一串内容。\n\n点开地址28c28的位置，发现存在加密的内容。\n\n\n这说明这个函数也需要得到解密，那就只能是在sub_88060里了，去另一个解密的so文件看一眼，发现果然解密了。\n\n\n通过hook解密后的sub_28c28，可以得到解密字符串，脚本如下。\n// 要hook的函数offsetvar offset = 0x88060;// so文件的大小var module_size = 0;// 要hook的so的名字var module_name = &quot;libbaiduprotect.so&quot;;function hook_linker_call_constructors() &#123;    // 获得linker64的地址    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;)    let offset_call = 0x51BA8    // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset_call)    let listener = Interceptor.attach(call_constructors,&#123;        onEnter:function(args)&#123;            // 判断是否可以通过findModuleByName查找到目标so文件            console.log(&#x27;[linker] Call_Constructors onEnter&#x27;)            let secmodule = Process.findModuleByName(module_name);            if (secmodule != null)&#123;                module_size = secmodule.size;                // 第一时间hook                hook_target_func(secmodule.base);                listener.detach();            &#125;        &#125;    &#125;)&#125;function hook_target_func(baseaddr)&#123;    let listener = Interceptor.attach(baseaddr.add(offset), &#123;        onEnter:function(args)&#123;        &#125;,        onLeave:function(retval)&#123;            // 第一个函数解密完后，才能hook sub_28c28            decrypt_28c28(baseaddr);            listener.detach();        &#125;    &#125;);&#125;function decrypt_28c28(baseaddr)&#123;        Interceptor.attach(baseaddr.add(0x28c28), &#123;            onEnter:function(args)&#123;                console.log(&quot;[sub_28c28] &quot;, &quot;arg = &quot;, ptr(args[0]).readCString());            &#125;, onLeave:function(retval)&#123;                console.log(&quot;[sub_28c28] &quot;, &quot;retval = &quot;, ptr(retval).readCString());            &#125;        &#125;)&#125;setImmediate(hook_linker_call_constructors)\n\n执行的结果如下。\n\n\n写了一个ida脚本，给这些字符串的地方添加注释。\nimport idaapiimport idautils# 加密/明文映射mappings = &#123;    &quot;710E34DFB3D273975E0936FBB4CF62BE541F3CC4A8&quot;: &quot;FeatureLibcProtection&quot;,    &quot;530A39DDAFCB39A84E1821CEAB8F52BE4F3B34DFAEEC7FA843&quot;: &quot;dalvik/system/DexPathList&quot;&#125;# 函数列表（地址或函数名）func_list = [    0x28c28]def find_string_addr(search_str):    &quot;&quot;&quot;查找字符串的地址&quot;&quot;&quot;    for addr in idautils.Strings():        if str(addr) == search_str:            return addr.ea    return Nonedef resolve_func_addr(func_entry):    &quot;&quot;&quot;将函数名或地址转换为地址&quot;&quot;&quot;    if isinstance(func_entry, int):        return func_entry    elif isinstance(func_entry, str):        func_addr = idaapi.get_name_ea_simple(func_entry)        if func_addr == idaapi.BADADDR:            print(f&quot;Function not found: &#123;func_entry&#125;&quot;)            return None        return func_addr    else:        print(f&quot;Invalid function entry: &#123;func_entry&#125;&quot;)        return Nonedef add_comments_to_strings():    &quot;&quot;&quot;为 .rodata 中的字符串添加解密注释和重命名&quot;&quot;&quot;    for encrypted, decrypted in mappings.items():        str_addr = find_string_addr(encrypted)        if str_addr:            idaapi.set_cmt(str_addr, f&quot;Decrypted: &#123;decrypted&#125;&quot;, 0)            # 重命名字符串，替换特殊字符以符合命名规则            safe_name = f&quot;str_&#123;decrypted.replace(&#x27;/&#x27;, &#x27;_&#x27;).replace(&#x27; &#x27;, &#x27;_&#x27;)&#125;&quot;            idaapi.set_name(str_addr, safe_name, idaapi.SN_FORCE)            print(f&quot;Added comment at 0x&#123;str_addr:x&#125;: &#123;encrypted&#125; -&gt; &#123;decrypted&#125;&quot;)        else:            print(f&quot;String not found in .rodata: &#123;encrypted&#125;&quot;)def add_comments_to_function(func_addr):    &quot;&quot;&quot;为指定函数添加注释，扫描加载字符串的指令&quot;&quot;&quot;    func = idaapi.get_func(func_addr)    if not func:        print(f&quot;Function at 0x&#123;func_addr:x&#125; not found or invalid&quot;)        return    # 添加函数注释    func_name = idaapi.get_func_name(func_addr)    idaapi.set_func_cmt(func_addr, f&quot;Decrypts strings (e.g., &#123;&#x27;, &#x27;.join(f&#x27;&#123;k&#125;-&gt;&#123;v&#125;&#x27; for k, v in mappings.items())&#125;)&quot;, 1)    print(f&quot;Processing function: &#123;func_name&#125; at 0x&#123;func_addr:x&#125;&quot;)    # 扫描函数指令，查找加载字符串的指令    for ea in idautils.FuncItems(func.start_ea):        disasm = idaapi.generate_disasm_line(ea, 0)        if &quot;LDR&quot; in disasm:  # 检查加载指令            for enc, dec in mappings.items():                if enc in disasm:                    idaapi.set_cmt(ea, f&quot;Loads &#123;enc&#125; -&gt; &#123;dec&#125;&quot;, 0)                    print(f&quot;Added comment at 0x&#123;ea:x&#125;: &#123;enc&#125; -&gt; &#123;dec&#125;&quot;)def main():    &quot;&quot;&quot;主函数：处理字符串和函数列表&quot;&quot;&quot;    # 处理 .rodata 中的字符串    print(&quot;Processing strings in .rodata...&quot;)    add_comments_to_strings()    # 处理函数列表    print(&quot;\\nProcessing functions...&quot;)    for func_entry in func_list:        func_addr = resolve_func_addr(func_entry)        if func_addr is not None:            add_comments_to_function(func_addr)        else:            print(f&quot;Skipping invalid function: &#123;func_entry&#125;&quot;)# 执行脚本if __name__ == &quot;__main__&quot;:    main()\n\nida脚本的执行情况如下，自动添加注释并对字符串重命名。\n\n回到sub_6FC4的位置，710….代表FeatureLibcProtection。\n\n函数sub_3E590也被加密了，通过解密的so文件查看，它似乎是在赋值？a1是一个全局变量，a2是解密后的字符串，a3是1，似乎是一个索引。\n\n\nBB9B0是一个函数指针，存放着的内容是sub_811B8的地址（也就是811B8）。\n\n这里创建一个结构体，由于函数指针和字符串指针都是指针，这里定义为__int64*。\n\n结构就比较容易懂了。\n\n因此，sub_6FC4可以理解为在做函数注册。\n\n会根据index，在对应的槽位注册。\n\n\n根据分析，注册了8个函数。\n\n\n整理一下，注册关系大致如下。\nsub_B3B4 -&gt; 索引1 -&gt; global_func_list[1]。\nsub_3E29C -&gt; 索引3 -&gt; global_func_list[3]。\nsub_40CF8 -&gt; 索引6 -&gt; global_func_list[6]。\nsub_3DFC4 -&gt; 索引7 -&gt; global_func_list[7]。\nsub_11F5C -&gt; 索引8 -&gt; global_func_list[8]。\nsub_45964 -&gt; 索引9 -&gt; global_func_list[9]。\nsub_3E96C -&gt; 索引10 -&gt; global_func_list[10]。\nsub_42388 -&gt; 索引13 -&gt; global_func_list[13]。\n之后开始分析JNI_onLoad，由于加密的so中，JNI_onLoad没有解密，所以这里根据解密的so的JNI_onLoad进行分析。\n\n\n上来就看到一大堆混淆，用d810处理一下。\n可能是由于从内存中dump出来的缘故，反汇编伪代码的效果不是很好，连vm都看不到在哪里使用了。\n\n\n先看sub_91D8，十分眼熟，+48，基本可以确认a1是JNIEnv*的类型了。\n\n\n\n\n之后再看sub_7BC4，槽位0是经过初始化的，但没存前面的函数（应该被sub_82254初始化了），如果0号元素的内容为空，则调用sub_3E5A8进行清空。\n\n\n\n\n所以，可以把函数sub_7BC4理解为，判断函数是否注册完毕。\n接着看函数sub_3E628，没搞明白v11、v12在做什么，但能看得出来，是在调用函数列表里的函数，第一个参数是自己的地址，第二个参数是1（JNI_OnLoad传入的a2）。\n\n先来观察函数列表的index为1的函数sub_B3B4。\n\n\n如果a2不为1，直接返回，说明sub_B3B4只接受a2&#x3D;&#x3D;1的情况。\n\nsub_B3B4对很多字符串进行了解密，同时连接了很多字符串。\n\n\n配合着脚本，实现了对这些字符串的解密。\n// 要hook的函数offsetvar offset = 0x88060;// so文件的大小var module_size = 0;// 要hook的so的名字var module_name = &quot;libbaiduprotect.so&quot;;// 解密函数的偏移列表（从 sub_28AD0 到 sub_28A24）var decrypt_offsets = [    0x28AD0, 0x25E78, 0x25F24, 0x25FD0, 0x2607C, 0x26128, 0x261D4, 0x26280,    0x2632C, 0x263D8, 0x26484, 0x26530, 0x265DC, 0x26688, 0x26734, 0x267E0,    0x2688C, 0x26938, 0x269E4, 0x26A90, 0x26B3C, 0x26BE8, 0x26C94, 0x26D40,    0x26DEC, 0x26E98, 0x26F44, 0x26FF0, 0x2709C, 0x27148, 0x271F4, 0x272A0,    0x2734C, 0x273F8, 0x274A4, 0x27550, 0x275FC, 0x276A8, 0x27754, 0x27800,    0x278AC, 0x27958, 0x27A04, 0x27AB0, 0x27B5C, 0x27C08, 0x27CB4, 0x27D60,    0x27E0C, 0x27EB8, 0x27F64, 0x28010, 0x280BC, 0x28168, 0x28214, 0x282C0,    0x2836C, 0x28418, 0x284C4, 0x28570, 0x2861C, 0x286C8, 0x28774, 0x28820,    0x288CC, 0x28A24];function hook_linker_call_constructors() &#123;    // 获得linker64的地址    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;);    let offset_call = 0x51BA8;    // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset_call);    let listener = Interceptor.attach(call_constructors, &#123;        onEnter: function(args) &#123;            // 判断是否可以通过findModuleByName查找到目标so文件            console.log(&#x27;[linker] Call_Constructors onEnter&#x27;);            let secmodule = Process.findModuleByName(module_name);            if (secmodule != null) &#123;                module_size = secmodule.size;                // 第一时间hook                hook_target_func(secmodule.base);                listener.detach();            &#125;        &#125;    &#125;);&#125;function hook_target_func(baseaddr) &#123;    let listener = Interceptor.attach(baseaddr.add(offset), &#123;        onEnter: function(args) &#123;            console.log(&quot;[target_func] onEnter, offset:&quot;, offset.toString(16));        &#125;,        onLeave: function(retval) &#123;            console.log(&quot;[target_func] onLeave, retval:&quot;, retval);            // 第一个函数解密完后，Hook 所有解密函数            hook_decrypt_funcs(baseaddr);            listener.detach();        &#125;    &#125;);&#125;function hook_decrypt_funcs(baseaddr) &#123;    // Hook sub_28C28（保持原有逻辑）    Interceptor.attach(baseaddr.add(0x28C28), &#123;        onEnter: function(args) &#123;            console.log(&quot;[sub_28C28] arg =&quot;, ptr(args[0]).readCString());        &#125;,        onLeave: function(retval) &#123;            console.log(&quot;[sub_28C28] retval =&quot;, ptr(retval).readCString());        &#125;    &#125;);    // 循环 Hook 所有解密函数    decrypt_offsets.forEach(function(offset) &#123;        let func_name = &quot;sub_&quot; + offset.toString(16).toUpperCase();        Interceptor.attach(baseaddr.add(offset), &#123;            onEnter: function(args) &#123;                console.log(&quot;[&quot; + func_name + &quot;] arg =&quot;, ptr(args[0]).readCString());            &#125;,            onLeave: function(retval) &#123;                console.log(&quot;[&quot; + func_name + &quot;] retval =&quot;, ptr(retval).readCString());            &#125;        &#125;);    &#125;);&#125;setImmediate(hook_linker_call_constructors);\n\n用ida进行修改并添加注释。\nimport idaapiimport idautils# 加密/明文映射（从 Frida 输出中提取）mappings = &#123;    &quot;710E34DFB3D273975E0936FBB4CF62BE541F3CC4A8&quot;: &quot;FeatureLibcProtection&quot;,    &quot;530A39DDAFCB39A84E1821CEAB8F52BE4F3B34DFAEEC7FA843&quot;: &quot;dalvik/system/DexPathList&quot;,    &quot;3D7CDAABED5340D60976CFBAFB5560E80D70C9B0F64C40E80F&quot;: &quot;FeatureProtectEnvironment&quot;,    &quot;5227DBB22926DA554467C6EF2433D6524567F7&quot;: &quot;com/baidu/protect/A&quot;,    &quot;14D64606364E3C6D&quot;: &quot;unknown&quot;,    &quot;5A483597E76FC0D170423682FE54CBF073&quot;: &quot;FeatureGlobalInfo&quot;,    &quot;47986CBE0A46F6EE6F8968AD0D5DE7DE429568A914&quot;: &quot;FeatureIntegrityCheck&quot;,    &quot;5227DBB22926DA554467C6EF2433D6524567F5EF2A34DB795026D2F12E35&quot;: &quot;com/baidu/protect/CrashHandler&quot;,    &quot;02D740473B583B0914975D1A364D370E15976F&quot;: &quot;com/baidu/protect/B&quot;,    &quot;0406D0C873B03D581246CD957EA5315F1346FC9761983A5A08&quot;: &quot;com/baidu/protect/AppInfo&quot;,    &quot;C7D432A325E854F696D43CFF27BF03F7&quot;: &quot;c07954f5209e7c14&quot;,    &quot;67C538FE4857A6C4309F39AB4B06A5C5&quot;: &quot;f8547c5c1b4a426b&quot;,    &quot;260714BFA582481D715D15EAA6D34B1C785B43B8F385444A705E15EAF3D54C4B&quot;: &quot;f8547c5c1b4a426b8db3ad940a4aa415&quot;,    &quot;57585C810030ABC6530C06D65363FF9C545A5CD60367A9CD545400D45430A8C9&quot;: &quot;359b71797ac5dbcc07954f5209e7c146&quot;,    &quot;7E6EA364435927F7&quot;: &quot;.suuid&quot;,    &quot;3148B69D4B47B331&quot;: &quot;&quot;,    &quot;61B82D685939526D&quot;: &quot;&quot;,    &quot;065A40FFE793182D255C54F9FB95042D0474&quot;: &quot;FeatureSecuritySDK&quot;,    &quot;1901FAF72A31D21E5D29D8FA6408D15B542BC2A6100BD950472999F12A29D41E7E2ADCF82833881867&quot;: &quot;(ILjava/lang/Object;[Ljava/lang/Object;)V&quot;,    &quot;49F16102384F33420DD9430F7676300704DB59530275380C17D90204385735422EDA470D3A4D69443B&quot;: &quot;(ILjava/lang/Object;[Ljava/lang/Object;)Z&quot;,    &quot;4F20F18D70A735130B08D3803E9E3656020AC9DC4A9D3E5D1108928B70BF3313280BD78272A56F1525&quot;: &quot;(ILjava/lang/Object;[Ljava/lang/Object;)B&quot;,    &quot;8CAD49F071AA53ECC8856BFD3F9350A9C18771A14B9058A2D2852AF671B255ECEB866FFF73A809EAE7&quot;: &quot;(ILjava/lang/Object;[Ljava/lang/Object;)C&quot;,    &quot;29B441A01E42F2886D9C63AD507BF1CD649E79F12478F9C6779C22A61E5AF4884E9F67AF1C40A88E52&quot;: &quot;(ILjava/lang/Object;[Ljava/lang/Object;)S&quot;,    &quot;68766DE1F3971C512C5E4FECBDAE1F14255C55B0C9AD171F365E0EE7F38F1A510F5D4BEEF195465709&quot;: &quot;(ILjava/lang/Object;[Ljava/lang/Object;)I&quot;,    &quot;4C2429895677FDD0080C0B84184EFE95010E11D86C4DF69E120C4A8F566FFBD02B0F0F865475A7D62E&quot;: &quot;(ILjava/lang/Object;[Ljava/lang/Object;)J&quot;,    &quot;78549A7B4B4B46D83C7CB8760572459D357EA22A71714D96267CF97D4B5340D81F7FBC7449491CDE16&quot;: &quot;(ILjava/lang/Object;[Ljava/lang/Object;)F&quot;,    &quot;8F4502F0DDCDC5C2CB6D20FD93F4C687C26F3AA1E7F7CE8CD16D61F6DDD5C3C2E86E24FFDFCF9FC4E3&quot;: &quot;(ILjava/lang/Object;[Ljava/lang/Object;)D&quot;,    &quot;A34B5090CFED8214E763729D81D48151EE6168C1F5D7895AFD633396CFF58414C460769FCDEFD812C7687D8CCFB48F5AE56533B5CCF18658FF39&quot;: &quot;(ILjava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;&quot;,    &quot;2E68C02CC53A063D255DD337C42D001F0162CF&quot;: &quot;FeatureVMProtection&quot;,    &quot;F48398ED31542B0E&quot;: &quot;libc.so&quot;,    &quot;6E2DCEF43F47B331&quot;: &quot;_exit&quot;,    &quot;04C0441C5939526D&quot;: &quot;exit&quot;,    &quot;171DD59574B03063041BD88665B4&quot;: &quot;pthread_create&quot;,    &quot;D4906DE875BD569CCE8B6CF4&quot;: &quot;pthread_join&quot;,    &quot;6C9860A90F4D93A7&quot;: &quot;memcpy&quot;,    &quot;2D5E4DE7FD827D7E&quot;: &quot;malloc&quot;,    &quot;070C098F58629CFF&quot;: &quot;calloc&quot;,    &quot;3D78BB624F4927F7&quot;: &quot;memset&quot;,    &quot;C1633EFFD2BBA4ED&quot;: &quot;fopen&quot;,    &quot;ED617095DDFEE33B&quot;: &quot;fclose&quot;,    &quot;E24E68C72ED3BB4E&quot;: &quot;fgets&quot;,    &quot;4EFE6FC425A325B6&quot;: &quot;strtoul&quot;,    &quot;30640DB4A5A47CCE&quot;: &quot;strtoull&quot;,    &quot;59CA0B1C240EE666&quot;: &quot;strstr&quot;,    &quot;B3783A25593967C1&quot;: &quot;ptrace&quot;,    &quot;715D268CE678C6E2&quot;: &quot;mprotect&quot;,    &quot;678568CC1272D9F4&quot;: &quot;strlen&quot;,    &quot;4333E40A59E92B6B&quot;: &quot;sscanf&quot;,    &quot;20C396763EB607CE&quot;: &quot;free&quot;,    &quot;59EFF51F63070DB8&quot;: &quot;strdup&quot;,    &quot;1B79D33BDD38636B&quot;: &quot;strcmp&quot;,    &quot;11EDA0D862CA71BA0FE9&quot;: &quot;strcasecmp&quot;,    &quot;AD1C8CA1863C3CF3&quot;: &quot;utime&quot;,    &quot;7F7567B6D496D9AC&quot;: &quot;mkdir&quot;,    &quot;3F4E6764B2499D86&quot;: &quot;open&quot;,    &quot;7838B71CCAAF75C6&quot;: &quot;close&quot;,    &quot;04B2CD050F9C47EE&quot;: &quot;unlink&quot;,    &quot;086DDAAB98212586&quot;: &quot;stat&quot;,    &quot;E2292D97D01141B6&quot;: &quot;time&quot;,    &quot;6E4AC4CB291788D4&quot;: &quot;snprintf&quot;,    &quot;302FD3054ECECD91&quot;: &quot;strchr&quot;,    &quot;C65AB9D5625867A8&quot;: &quot;strncmp&quot;,    &quot;0C8A9ABA3559D876189B86A93350&quot;: &quot;pthread_detach&quot;,    &quot;B4D5455E4F6B8C3BB7C4414A&quot;: &quot;pthread_self&quot;,    &quot;A832C433D41105B4&quot;: &quot;opendir&quot;,    &quot;63C7D8A1855BE1D1&quot;: &quot;readdir&quot;,    &quot;DD596595BC74408E&quot;: &quot;closedir&quot;,    &quot;711BD780E966683E&quot;: &quot;mmap&quot;,    &quot;3B70EDB05642EDB6&quot;: &quot;munmap&quot;,    &quot;31F4B35BA15DF8D9&quot;: &quot;lseek&quot;,    &quot;3A7B1DDB8EAEEB3C&quot;: &quot;fstat&quot;,    &quot;2DC5B93C51DE4E8C&quot;: &quot;read&quot;,    &quot;CD3E5AC4CE4EB523&quot;: &quot;select&quot;,    &quot;9C6E379605B933C39F71&quot;: &quot;bsd_signal&quot;,    &quot;C489B09443666A3D&quot;: &quot;fork&quot;,    &quot;266DF31562D26748&quot;: &quot;prctl&quot;,    &quot;176E4794FD670E8110&quot;: &quot;setrlimit&quot;,    &quot;50660A65A953F202&quot;: &quot;getppid&quot;,    &quot;9B333E341D4B67D8&quot;: &quot;getpid&quot;,    &quot;68D77BE990FA40DB&quot;: &quot;waitpid&quot;,    &quot;03B093571B66B5A9&quot;: &quot;kill&quot;,    &quot;75F6DC484BF43E44&quot;: &quot;flock&quot;,    &quot;795BD9475A856CF3&quot;: &quot;write&quot;,    &quot;BE66196673ACF758&quot;: &quot;execve&quot;,    &quot;296C25084100FFA8&quot;: &quot;execv&quot;,    &quot;164C148245E50A35&quot;: &quot;execl&quot;,    &quot;FEF19D484641B9EC&quot;: &quot;sysconf&quot;,    &quot;E215844F2E808FC7E23A85592D9198DEC415905329&quot;: &quot;__system_property_get&quot;,    &quot;C033AAA8B3EE1BBFC3&quot;: &quot;ftruncate&quot;,    &quot;D818528B9AD01DD0&quot;: &quot;gettid&quot;,    &quot;2E1331FA88B61B58&quot;: &quot;pread64&quot;,    &quot;8F6EB5FBB011CE0A&quot;: &quot;pwrite64&quot;,    &quot;3DFBFF6E535AF038&quot;: &quot;pread&quot;,    &quot;B2D06CEC09B428DF&quot;: &quot;pwrite&quot;,    &quot;326FA0A56FCADBAB&quot;: &quot;statvfs&quot;,    &quot;09598DD611D1543C&quot;: &quot;n001&quot;,    &quot;8CA86FFB66BD1DAFC58A62B543A840AACA833ED67ABD44A28B8864F477F361B7D68D6BFD2B9058A2D2852AF671B255ECF79077F37EBB098FCE8573FB3FB053ADC3CB56EE62B55CA49FAD5FB346&quot;: &quot;(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;IZ)V&quot;,    &quot;6FCD3DF87F3493A7&quot;: &quot;n002&quot;,    &quot;687340E5F6931217241042E4FC951810341062E4FC951806340408DD&quot;: &quot;(Landroid/content/Context;)V&quot;,    &quot;0A5D55D037019CFF&quot;: &quot;n003&quot;,    &quot;783480112A3D27F7&quot;: &quot;()V&quot;,    &quot;226212F6FEFC669A22&quot;: &quot;arm64-v8a&quot;,    &quot;4819CF8872FE27590B0F928A70A127&quot;: &quot;/proc/self/maps&quot;,    &quot;D6E4059A10DC32C3&quot;: &quot;r&quot;,    &quot;6D946FAE0959BDD46E&quot;: &quot;libdvm.so&quot;,    &quot;2C5643EAE095530D2F&quot;: &quot;libart.so&quot;,    &quot;080407955A6AF59B3B01008E4273B28C0B&quot;: &quot;libvmkid_lemur.so&quot;,    &quot;3C74B470455E09843F&quot;: &quot;libaoc.so&quot;,    &quot;54AFA16C61F747EE&quot;: &quot;%s&quot;,    &quot;44CB02463B5D3E0202D3&quot;: &quot;%s/.bdlock&quot;,    &quot;050301915868F8D007020B97526FE8D014004AB05E66F29E10181786&quot;: &quot;android/content/pm/Signature&quot;,    &quot;3173B263455443D83372B8654F5353D82070F9414B5E4C9637789F7F4C52&quot;: &quot;android/content/pm/PackageInfo&quot;,    &quot;C6622AE8D3D2C0C2C46320EED9D5D0C2D76161CADDD8CF8CC06903FBD2DAC388D5&quot;: &quot;android/content/pm/PackageManager&quot;,    &quot;EA6C7888C1F28714EA726CD5EFF89752FD6B6883FAF3915EEA66&quot;: &quot;android/app/ActivityThread&quot;,    &quot;E54769C132BADF61E5597D9C1EBCD53AE15179FA30A3D7&quot;: &quot;android/app/ContextImpl&quot;,    &quot;5AEF69E333A53DD350C972DE3EB331C2&quot;: &quot;getSystemContext&quot;,    &quot;6B3933A1A4B562CD2A7450A1BAA13FE12C7E0BA5B2A559CF337C44&quot;: &quot;()Landroid/app/ContextImpl;&quot;,    &quot;49CB0B1D3512922749CA101939089F3242CC1C0E34&quot;: &quot;currentActivityThread&quot;,    &quot;EB250425543815AEAA6867254A2C4880A078213253281E95AB7E2D255E67&quot;: &quot;()Landroid/app/ActivityThread;&quot;,    &quot;7B4820B3F37ECEF77B481982FC7CC2F36E&quot;: &quot;getPackageManager&quot;,    &quot;3CD856C11978AB9B7D9535C31872AD917A8535D01A338995779A7BC71251B89A75967FD24C&quot;: &quot;()Landroid/content/pm/PackageManager;&quot;,    &quot;5725F33B56EC400A5725CE0551E0&quot;: &quot;getPackageInfo&quot;,    &quot;6EFD997248D728A227DF943C6DC275A728D6C85A17FA66A022C39C7A5A9964A128C5967D4A9977A369E1927055D760AB0FDF957C05&quot;: &quot;(Ljava/lang/String;I)Landroid/content/pm/PackageInfo;&quot;,    &quot;59F2E015770378CA4FE8&quot;: &quot;signatures&quot;,    &quot;3341C036D43A0C020C22C237DE3C06051C22D1359F1B0A0C066CD52DC22D58&quot;: &quot;[Landroid/content/pm/Signature;&quot;,    &quot;16F690C277DC55AB10F8AB&quot;: &quot;toByteArray&quot;,    &quot;F041BE8EE33C3CF3&quot;: &quot;()[B&quot;,    &quot;376D2CF19796D9AC&quot;: &quot;%s/.1&quot;,    &quot;754D2D248366B8F5&quot;: &quot;%s/.1/%s&quot;,    &quot;EA6C7888C1F28714E47133B8DBF28F5F&quot;: &quot;android/os/Build&quot;,    &quot;C96649F611D3BB4E&quot;: &quot;MODEL&quot;,    &quot;71E07CC62BF925D753ED32E33EA420D85AB1&quot;: &quot;Ljava/lang/String;&quot;,    &quot;E67F6728533E67C1&quot;: &quot;%s/lib&quot;,    &quot;395E7BCDB779A596&quot;: &quot;%s/.%d&quot;,    &quot;758269C5036FF69675987ED5076EB68071926E851332B39566&quot;: &quot;assets/baiduprotect%d.jar&quot;,    &quot;1F71A90156FD2B6B&quot;: &quot;/1.jar&quot;,    &quot;69D29F724DC562BD68DB9261&quot;: &quot;/classes.jar&quot;,    &quot;05F8EB1A650468CB04FFE203&quot;: &quot;/classes.dex&quot;,    &quot;4769C02CD167070A1C6C8E7DC3674D4E0C22C234D13B100E1B23CB39C2&quot;: &quot;/data/data/%s/.%d/classes.jar&quot;,    &quot;4DFDB3CF629670B816F8FD9E70963AFC06B6B1D762CA67BC11B7B6DE7B&quot;: &quot;/data/data/%s/.%d/classes.dex&quot;,    &quot;0DD14F092B4D300C12DD031B36&quot;: &quot;libartbase.so&quot;,    &quot;1E38C4F22868C0545D2E99F02A37C0&quot;: &quot;/proc/self/maps&quot;,    &quot;13B82D685939526D&quot;: &quot;r&quot;,    &quot;1544909711D1543C&quot;: &quot;r--p&quot;,    &quot;819725BF63FC17E9D7C420B063FC17E9D7C420E9&quot;: &quot;%s %s %*s %*s %*s %s&quot;,    &quot;73D075BA7F3493A7&quot;: &quot;r-xp&quot;,    &quot;FBBB64F474AE5DAAC0BB69F5778342B1CD8A71&quot;: &quot;__android_log_print&quot;,    &quot;2D5240FB92E17D7E&quot;: &quot;mmap&quot;,    &quot;503BC5F83F349C535021D2E83B35DC45542BC2B82F69D95043&quot;: &quot;assets/baiduprotect%d.jar&quot;,    &quot;0900049337019CFF&quot;: &quot;mmap&quot;,    &quot;D2290DB35DD3BB4E&quot;: &quot;V&quot;,    &quot;678A1DB04AD649B6&quot;: &quot;Z&quot;,    &quot;01107FC0CAD110A2&quot;: &quot;B&quot;,    &quot;69BE796F507CE666&quot;: &quot;C&quot;,    &quot;900C48443A5C67C1&quot;: &quot;S&quot;,    &quot;552D54E3921DA596&quot;: &quot;I&quot;,    &quot;5EF11AA0771CD9F4&quot;: &quot;J&quot;,    &quot;7640876B378F2B6B&quot;: &quot;F&quot;,    &quot;02B1F3133EB607CE&quot;: &quot;D&quot;,    &quot;669B877B16770DB8&quot;: &quot;L&quot;,    &quot;6A0EB69D4B47B331&quot;: &quot;[F&quot;,    &quot;3AFC2D685939526D&quot;: &quot;[D&quot;,    &quot;0D08CB863EBD35520046FF887EBD315D09&quot;: &quot;java/lang/Boolean&quot;,    &quot;CE8573FB3FB053ADC3CB47E364B9&quot;: &quot;java/lang/Byte&quot;,    &quot;6B9C7BAB5058F2C966D24EA21E46F2C475987F&quot;: &quot;java/lang/Character&quot;,    &quot;2A5E57EABD8D1C10271072E3FD9309&quot;: &quot;java/lang/Short&quot;,    &quot;0E0C1382186DFD9103422C8D4364FB9A16&quot;: &quot;java/lang/Integer&quot;,    &quot;3A7CA0700551469937329A7E445A&quot;: &quot;java/lang/Long&quot;,    &quot;CD6D38FB93D7C583C02308F6D3DAD0&quot;: &quot;java/lang/Float&quot;,    &quot;E1636A9B81F78255EC2D5895DBF98F5E&quot;: &quot;java/lang/Double&quot;,    &quot;EE487BD272BFDA20E30642D137B6D83A&quot;: &quot;java/lang/Object&quot;,    &quot;01E373D93EE849B6&quot;: &quot;&lt;init&gt;&quot;,    &quot;6B4A5696CAD110A2&quot;: &quot;(Z)V&quot;,    &quot;16D717062442E666&quot;: &quot;&lt;init&gt;&quot;,    &quot;EB4E61123A5C67C1&quot;: &quot;(B)V&quot;,    &quot;20443A8AE623A596&quot;: &quot;&lt;init&gt;&quot;,    &quot;3CB233F6771CD9F4&quot;: &quot;(C)V&quot;,    &quot;0C29E90243B12B6B&quot;: &quot;&lt;init&gt;&quot;,    &quot;6EE2DA453EB607CE&quot;: &quot;(S)V&quot;,    &quot;16F2E91262490DB8&quot;: &quot;&lt;init&gt;&quot;,    &quot;4044880EB048636B&quot;: &quot;(I)V&quot;,    &quot;5EF0BCD2778714D9&quot;: &quot;&lt;init&gt;&quot;,    &quot;F022CC9AE33C3CF3&quot;: &quot;(J)V&quot;,    &quot;2E776DB6D2A8D9AC&quot;: &quot;&lt;init&gt;&quot;,    &quot;78782B5CB2499D86&quot;: &quot;(F)V&quot;,    &quot;273DB606DB9175C6&quot;: &quot;&lt;init&gt;&quot;,    &quot;5998883A61F747EE&quot;: &quot;(D)V&quot;,    &quot;1976D4B3FD404BD01A75CEBA&quot;: &quot;booleanValue&quot;,    &quot;BE691AF2D01141B6&quot;: &quot;()Z&quot;,    &quot;7F5DC0DC161890C778&quot;: &quot;byteValue&quot;,    &quot;6B72E36626BCCD91&quot;: &quot;()B&quot;,    &quot;D646AAC957547BDDD0&quot;: &quot;charValue&quot;,    &quot;54D7B1C85038BC29&quot;: &quot;()C&quot;,    &quot;B7C9425E5E5C8908B1C4&quot;: &quot;shortValue&quot;,    &quot;EF6BF25DB07877B4&quot;: &quot;()S&quot;,    &quot;78CCCD93805EE6B4&quot;: &quot;intValue&quot;,    &quot;961C43E6D91029FC&quot;: &quot;()I&quot;,    &quot;7019D897BF07044B79&quot;: &quot;longValue&quot;,    &quot;7E2CC9DD3732EDB6&quot;: &quot;()J&quot;,    &quot;3BEBB95FBE0B99B528E2&quot;: &quot;floatValue&quot;,    &quot;74212FBAFAAEEB3C&quot;: &quot;()F&quot;,    &quot;3BCFAD3A3DBB18ED33D5BD&quot;: &quot;doubleValue&quot;,    &quot;967272A1AD3AB523&quot;: &quot;()D&quot;,    &quot;947C25A859BC35C3993200BD04B93ACA&quot;: &quot;java/lang/String&quot;,    &quot;CB88B69A31086A3D&quot;: &quot;intern&quot;,    &quot;7E36DC0B6FA406673A7EFE062181133A3F71F75A&quot;: &quot;()Ljava/lang/String;&quot;,    &quot;0406D0C873B03D581246C59479B831500346DC843E891C&quot;: &quot;com/baidu/xshield/ac/XH&quot;,    &quot;8CA864F474AE5DAAC0CB66F57EA857ADD0CB46F57EA857BBD0DF49F071AA53ECC8856BFD3F8F46B1CD8A62A15CB653B5C5CB69FB7EBB1D90D0966CF477E7698A8DB2&quot;: &quot;(Landroid/content/Context;Ljava/lang/String;Ljava/lang/String;[I)V&quot;,    &quot;689364BE7F3493A7&quot;: &quot;init&quot;,    &quot;503BC5F83F349C535021D2E83B35DC45542BC2B326&quot;: &quot;assets/baiduprotect.m&quot;,    &quot;44CB2D685939526D&quot;: &quot;%s&quot;,    &quot;3E27F603C0CC1EC6&quot;: &quot;%s.lock&quot;&#125;# 函数列表（从 Frida 输出中提取涉及的函数地址）func_list = [    0x28C28,  # sub_28C28    0x2709C,  # sub_2709C    0x25E78,  # sub_25E78    0x25F24,  # sub_25F24    0x25FD0,  # sub_25FD0    0x2607C,  # sub_2607C    0x26128,  # sub_26128    0x261D4,  # sub_261D4    0x26280,  # sub_26280    0x2632C,  # sub_2632C    0x263D8,  # sub_263D8    0x26484,  # sub_26484    0x26BE8,  # sub_26BE8    0x28AD0   # sub_28AD0]def find_string_addr(search_str):    &quot;&quot;&quot;查找字符串的地址&quot;&quot;&quot;    for addr in idautils.Strings():        if str(addr) == search_str:            return addr.ea    return Nonedef resolve_func_addr(func_entry):    &quot;&quot;&quot;将函数名或地址转换为地址&quot;&quot;&quot;    if isinstance(func_entry, int):        return func_entry    elif isinstance(func_entry, str):        func_addr = idaapi.get_name_ea_simple(func_entry)        if func_addr == idaapi.BADADDR:            print(f&quot;Function not found: &#123;func_entry&#125;&quot;)            return None        return func_addr    else:        print(f&quot;Invalid function entry: &#123;func_entry&#125;&quot;)        return Nonedef add_comments_to_strings():    &quot;&quot;&quot;为 .rodata 中的字符串添加解密注释和重命名&quot;&quot;&quot;    for encrypted, decrypted in mappings.items():        str_addr = find_string_addr(encrypted)        if str_addr:            idaapi.set_cmt(str_addr, f&quot;Decrypted: &#123;decrypted&#125;&quot;, 0)            # 重命名字符串，替换特殊字符以符合命名规则            safe_name = f&quot;str_&#123;decrypted.replace(&#x27;/&#x27;, &#x27;_&#x27;).replace(&#x27; &#x27;, &#x27;_&#x27;).replace(&#x27;(&#x27;, &#x27;_&#x27;).replace(&#x27;)&#x27;, &#x27;_&#x27;).replace(&#x27;;&#x27;, &#x27;_&#x27;).replace(&#x27;[&#x27;, &#x27;_&#x27;).replace(&#x27;]&#x27;, &#x27;_&#x27;)&#125;&quot;            idaapi.set_name(str_addr, safe_name, idaapi.SN_FORCE)            print(f&quot;Added comment at 0x&#123;str_addr:x&#125;: &#123;encrypted&#125; -&gt; &#123;decrypted&#125;&quot;)        else:            print(f&quot;String not found in .rodata: &#123;encrypted&#125;&quot;)def add_comments_to_function(func_addr):    &quot;&quot;&quot;为指定函数添加注释，扫描加载字符串的指令&quot;&quot;&quot;    func = idaapi.get_func(func_addr)    if not func:        print(f&quot;Function at 0x&#123;func_addr:x&#125; not found or invalid&quot;)        return    # 添加函数注释    func_name = idaapi.get_func_name(func_addr)    idaapi.set_func_cmt(func_addr, f&quot;Decrypts strings (e.g., &#123;&#x27;, &#x27;.join(f&#x27;&#123;k&#125;-&gt;&#123;v&#125;&#x27; for k, v in list(mappings.items())[:5])&#125;...)&quot;, 1)    print(f&quot;Processing function: &#123;func_name&#125; at 0x&#123;func_addr:x&#125;&quot;)    # 扫描函数指令，查找加载字符串的指令    for ea in idautils.FuncItems(func.start_ea):        disasm = idaapi.generate_disasm_line(ea, 0)        if &quot;LDR&quot; in disasm:  # 检查加载指令            for enc, dec in mappings.items():                if enc in disasm:                    idaapi.set_cmt(ea, f&quot;Loads &#123;enc&#125; -&gt; &#123;dec&#125;&quot;, 0)                    print(f&quot;Added comment at 0x&#123;ea:x&#125;: &#123;enc&#125; -&gt; &#123;dec&#125;&quot;)def main():    &quot;&quot;&quot;主函数：处理字符串和函数列表&quot;&quot;&quot;    # 处理 .rodata 中的字符串    print(&quot;Processing strings in .rodata...&quot;)    add_comments_to_strings()    # 处理函数列表    print(&quot;\\nProcessing functions...&quot;)    for func_entry in func_list:        func_addr = resolve_func_addr(func_entry)        if func_addr is not None:            add_comments_to_function(func_addr)        else:            print(f&quot;Skipping invalid function: &#123;func_entry&#125;&quot;)# 执行脚本if __name__ == &quot;__main__&quot;:    main()\n\n效果如下。\n\n由于解密我在hook的脚本里，设置第一个参数是字符串，而在sub_b3b4中，有些解密函数的参数是字节码，因此还需要补充5个解密函数的hook。\n// 要 hook 的 so 文件名字var module_name = &quot;libbaiduprotect.so&quot;;// so 文件的大小var module_size = 0;// 默认的目标函数偏移var target_offset = 0x88060;// 需要 hook 的字节码解密函数偏移列表var bytecode_decrypt_offsets = [    0x267e0, 0x26A90, 0x27550, 0x27800, 0x28418];// Hook linker64 的 call_constructors，检测目标 so 文件加载function hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;);    let offset_call = 0x51BA8; // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset_call);    let listener = Interceptor.attach(call_constructors, &#123;        onEnter: function(args) &#123;            console.log(&#x27;[linker] Call_Constructors onEnter&#x27;);            let secmodule = Process.findModuleByName(module_name);            if (secmodule != null) &#123;                module_size = secmodule.size;                // 第一时间 hook 目标函数                hook_target_func(secmodule.base);                listener.detach();            &#125;        &#125;    &#125;);&#125;// Hook 目标函数（触发后续字节码解密函数的 hook）function hook_target_func(baseaddr) &#123;    let listener = Interceptor.attach(baseaddr.add(target_offset), &#123;        onEnter: function(args) &#123;            console.log(&quot;[target_func] onEnter, offset: 0x&quot; + target_offset.toString(16));        &#125;,        onLeave: function(retval) &#123;            console.log(&quot;[target_func] onLeave, retval: &quot; + retval);            // 在目标函数退出时，hook 所有字节码解密函数            hook_bytecode_decrypt_funcs(baseaddr);            listener.detach();        &#125;    &#125;);&#125;// Hook 指定的字节码解密函数function hook_bytecode_decrypt_funcs(baseaddr) &#123;    bytecode_decrypt_offsets.forEach(function(offset) &#123;        let func_name = &quot;sub_&quot; + offset.toString(16).toUpperCase();        Interceptor.attach(baseaddr.add(offset), &#123;            onEnter: function(args) &#123;                let input_ptr = args[0]; // 捕获输入指针（指向字节数组）                console.log(&quot;[&quot; + func_name + &quot;] Input pointer: &quot; + input_ptr);                                // 读取以 0x00 结尾的字节数组                let bytes = [];                let i = 0;                while (true) &#123;                    let byte = Memory.readU8(input_ptr.add(i));                    if (byte === 0x00) break; // 遇到 0x00 停止                    bytes.push(byte.toString(16));                    i++;                &#125;                console.log(&quot;[&quot; + func_name + &quot;] Input bytes: &quot; + bytes.join(&quot;, &quot;));            &#125;,            onLeave: function(retval) &#123;                // 捕获返回值（解密后的字符串）                let output_str = retval.readCString();                console.log(&quot;[&quot; + func_name + &quot;] Output string: &quot; + output_str);            &#125;        &#125;);    &#125;);&#125;// 主逻辑：启动 hooksetImmediate(hook_linker_call_constructors);\n\n看得出来，sub_b3b4负责解密字符串，因此改名成这个。\n\n接下来看其它的函数，根据分析，当a2&#x3D;&#x3D;1时，只执行sub_B3B4。\n\n\n回到JNI_OnLoad，继续分析sub_91E4。\n\n\n可以看出来，在进行JNI动态注册，所以给它改了些函数名及变量名。\n\n回到JNI_OnLoad，我一直很好奇剩下的fread是什么东西？下图是别人对同样的so文件的分析，它这里伪代码是gettimeofday，那就很好理解了，在计算时间差，一般计算时间差是为了反调试，博主说这里只是收集信息。\n\n接下来可以分析第a2&#x3D;&#x3D;2的时候，会调用什么内容。\n\n已知B3B4只当a2&#x3D;&#x3D;1时才调用，这里从3E29C开始分析。\n\n\n直接分析3E36C。\n\n\n再进入3E3F0。\n\n\n3E3F0这两个函数很奇怪，似乎是我dump出现了点bug？\n\n和博主dump下来的so不太一样呢。\n\n用博主的图来讲函数3E3F0，大概是通过&#x2F;proc&#x2F;self&#x2F;maps获取进程虚拟机类型。\n\n这样子分析下去有点难受，我重新dump了一个，还是这样子，难道是壳做了什么手脚？——保留疑惑。看了一下修复的soFixer，它github写着。——阿这。\n\n之后换了一个so修复的程序，需要自己编译。\n链接：https://github.com/maiyao1988/elf-dump-fix\n再次查看3e3f0，这回终于没问题了。\n\n\n继续看函数列表，发现当a2&#x3D;&#x3D;2时，只执行了3E29C。\n\n\n总结至此，libbaiduprotect.so加载完了，总结一下：\n\n在.init_array的sub_88060进行解密，对so里的一些关键函数进行恢复。\n下述这些函数，统统在全局函数列表处进行注册添加，等待调用。\n\n\n\n\n在JNI_OnLoad处。\nsub_B3B4（a2&#x3D;&#x3D;1）解密了一些libc常用的函数地址，存在全局变量中。\n\n\nsub_91E4处，进行JNI动态注册，注册了n001、n002、n003共3个JNI函数。\n\nsub_3E29C（a2&#x3D;&#x3D;2）执行了下面的内容，获取最大IO向量数量并获得虚拟机类型。\n\n\n\nJNI函数分析（attachBaseContext&#x2F;onCreate）n001Java层的n001，对应于sub_91E4注册的3个函数的第1个函数。\n通过分析，得知n001属于类com.baidu.protect.A。\n\n\n然后在com.baidu.protect.StubApplication类的attachBaseContext中进行调用。\n\n接下来进入native层进行分析。\n首先简单的改了一下名字和类型。\n\n\n下图中，还原了一些函数名。\n\n\n先来分析sub_95B4。\n下面两个图中，可以看到函数sub_968C的参数列表不一样。\n\n\n\n\n在sub_95B4调用sub_968C的地方，进入汇编层分析。\n可以看到，前sub_968C的前两个参数是sub_9584的前两个参数，而X2 &#x3D; X19 + X1 &#x3D; strlen(X1) + X1，因此，sub_968C的参数列表应该是3个参数，第3个参数是a2字符串的结束地址。\n\n\n修改后是这样。\n\n\n进入sub_968C进行分析，修改了一些变量名后，如下图所示。\n它大致是一个管理缓冲区的函数，将字符串复制到目标缓冲区，并防止缓冲区溢出，重命名为buffer_manager。\n\n回到n001的JNI函数，继续往下分析，尝试hook decrypt_str2，观察返回值。\n\nhook的脚本如下。\n// 要 hook 的 so 文件名字var module_name = &quot;libbaiduprotect.so&quot;;// so 文件的大小var module_size = 0;// 默认的目标函数偏移var target_offset = 0x88060;// 需要 hook 的字节码解密函数偏移列表var bytecode_decrypt_offsets = [    0x95F4];// Hook linker64 的 call_constructors，检测目标 so 文件加载function hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;);    let offset_call = 0x51BA8; // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset_call);    let listener = Interceptor.attach(call_constructors, &#123;        onEnter: function(args) &#123;            console.log(&#x27;[linker] Call_Constructors onEnter&#x27;);            let secmodule = Process.findModuleByName(module_name);            if (secmodule != null) &#123;                module_size = secmodule.size;                // 第一时间 hook 目标函数                hook_target_func(secmodule.base);                listener.detach();            &#125;        &#125;    &#125;);&#125;// Hook 目标函数（触发后续字节码解密函数的 hook）function hook_target_func(baseaddr) &#123;    let listener = Interceptor.attach(baseaddr.add(target_offset), &#123;        onEnter: function(args) &#123;            console.log(&quot;[target_func] onEnter, offset: 0x&quot; + target_offset.toString(16));        &#125;,        onLeave: function(retval) &#123;            console.log(&quot;[target_func] onLeave, retval: &quot; + retval);            // 在目标函数退出时，hook 所有字节码解密函数            hook_bytecode_decrypt_funcs(baseaddr);            listener.detach();        &#125;    &#125;);&#125;// Hook 指定的字节码解密函数function hook_bytecode_decrypt_funcs(baseaddr) &#123;    bytecode_decrypt_offsets.forEach(function(offset) &#123;        let func_name = &quot;sub_&quot; + offset.toString(16).toUpperCase();        Interceptor.attach(baseaddr.add(offset), &#123;            onEnter: function(args) &#123;                let input_ptr = args[0]; // 捕获输入指针（指向字节数组）                console.log(&quot;[&quot; + func_name + &quot;] Input pointer: &quot; + input_ptr);                                // 读取以 0x00 结尾的字节数组                let bytes = [];                let i = 0;                while (true) &#123;                    let byte = Memory.readU8(input_ptr.add(i));                    if (byte === 0x00) break; // 遇到 0x00 停止                    bytes.push(byte.toString(16));                    i++;                &#125;                console.log(&quot;[&quot; + func_name + &quot;] Input bytes: &quot; + bytes.join(&quot;, &quot;));            &#125;,            onLeave: function(retval) &#123;                // 捕获返回值（解密后的字符串）                let output_str = retval.readCString();                console.log(&quot;[&quot; + func_name + &quot;] Output string: &quot; + output_str);            &#125;        &#125;);    &#125;);&#125;// 主逻辑：启动 hooksetImmediate(hook_linker_call_constructors);\n\n打印的结果如下。\n\n打印了几个字符串，BCDB0[0]的值是BE660，因此可以确定，&#x2F;data&#x2F;user&#x2F;0&#x2F;com.example.test是我们要找的解密字符串。\n\n\n之后又调用函数sub_95FC。\n\n在这个函数中，创建了文件&#x2F;data&#x2F;user&#x2F;0&#x2F;com.example.test&#x2F;.bdlock，然后通过flock函数上锁（文件锁）。更名为open_and_lock。\n\n之后再分析sub_781C，又有混淆，通过d810去一下混淆，又调用函数列表，这回调用a2&#x3D;&#x3D;3的情况。\n\n\n观察函数列表的函数，先整理出有哪些函数当a2&#x3D;&#x3D;3的时候执行。\n\n\n经过整理，会执行3E29C、40CF8（与java层传入的arg5有关）、3DFC4、11F5C、45964。\nsub_3E29C(a2&#x3D;&#x3D;3)先分析3E29C。\n查看call_funcs_list，传入的参数为：a1是函数列表，a2是3，a3是env。\n\n\n进入sub_13880进行查看。\n\n解密了很多系统库中的函数名，通过JNI进行调用。\n这一块代码有点怪，v29应该传入getPackageInfo的函数参数里的，可以从汇编看看。\n\n如下图所示，应该有5个参数。（arm64支持X0-X7传递参数）\n\n但这里不能修改一下callxxxxx的函数签名，因为他是一个不定长的函数调用。但我们知道，a2是一个字符串（包名，稍微追踪一下，发现是在JNI_OnLoad赋值的，当时没改名字，现在苦苦分析）。\n\n\nflags的值是0x40，代表返回PackageInfo的PackageInfo对象，包含签名信息。（如果不填0x40，返回的PackageInfo对象中的signatures字段将会是null）\n继续分析，为他们修改注释和变量名。\n\n进入sub_3AE58，直接返回16字节，有点像md5的初始化常量。\n\n借助大模型的力量，我成功识别了md5的相关函数，不过也说明了算法是我的薄弱点，得找时间好好看看。\n\n\n分析完了，sub_13880的行为：根据签名数组的第0个签名生成md5，赋值给a3并返回。\n\n接着看sub_66064。\n在sub_65E94中，会根据md5的值，在result地址+8的为止，根据md5，累积异或产生了16个新字节（假如记作buf1）。\n在sub_64A50中，result将指向ptr_result+1的位置，也就是result &#x3D; buf1，然后在sub_64A50中，根据buf1的最后4个字节，又生成了160个字节，也就是说，result指向的字节数组大小为176。\n因此，将sub_66064命名为md5_extend_176。\n\n整理一下，sub_3E29C得到了一个md5和一个基于md5的176字节。\nsub_40cf8(a2&#x3D;&#x3D;3)继续看，下一个看40CF8——3E29C、40CF8（与java层传入的arg5有关）、3DFC4、11F5C、45964。\n\n这里的BCE28，和n001传入的arg5有关。\n\n\n为了确定这个值，尝试hook一下Java层的n001，脚本如下。\nfunction hook_n001()&#123;    Java.perform(function()&#123;        var clazz_A = Java.use(&quot;com.baidu.protect.A&quot;);        clazz_A.n001.implementation = function(arg0, arg1, arg2, arg3, arg4, arg5)&#123;            console.log(&quot;[arg0] &quot;, arg0);            console.log(&quot;[arg1] &quot;, arg1);            console.log(&quot;[arg2] &quot;, arg2);            console.log(&quot;[arg3] &quot;, arg3);            console.log(&quot;[arg4] &quot;, arg4);            console.log(&quot;[arg5] &quot;, arg5);            var result = this.n001(arg0,arg1,arg2,arg3,arg4,arg5);            return result;        &#125;    &#125;)&#125;setImmediate(hook_n001);\n\n结果如下。\n\n从调用的地方可以猜到含义，分别代表着：包名、app名、apk路径、数据路径、sdk版本、是否报崩溃的错误。\n\n回到40CF8，这回知道了off_BCE28的含义了，用来判断是否上报crash信息的，那40CF8的这段代码，应该是用来处理崩溃信息上传的？\n在调用call_funcs_list这个函数中，调用函数列表每个函数的传参方式是：函数地址、a2、env、a4、a5、a6。（a3就是env）\n\n因此，在40CF8中，sub_409E0和sub_40F38的传参就好懂了。\n\n\n先进入409E0，修改a2的类型，看样子是注册了两个函数。\n\n\n交叉引用qword_BE808，找到它赋值的位置，发现它是一个之前的解密字符串，“com&#x2F;baidu&#x2F;protect&#x2F;CrashHandler”。\n\n鉴于sub_7398、sub_409E0等函数还存在字符串未解密，这里先把它们的解密字符串收集起来，就不提供脚本了，脚本都大差不差。\n回到409e0。\n有些搞不明白这里的v10与v11的关系，v11按理来说应该是异常的回调函数，但这里的写法我确实没看懂。\n总之，sub_409E0动态注册了com.baidu.protect.CrashHandler.a()和com.baidu.protect.CrashHandler.b(Ljava&#x2F;lang&#x2F;String)。\n同时，注册了一个统一的自定义处理函数sub_40bd0，负责处理异常。\n综上所述，直接将这个函数改名成处理异常。\n\n回到40cf8，这个函数在a2&#x3D;&#x3D;3时，做了下面的操作，接着看下一个函数列表的函数。\n\nsub_3DFC4(a2&#x3D;&#x3D;3)该看3DFC4了——3E29C、40CF8（与java层传入的arg5有关）、3DFC4、11F5C、45964。\n先将a3的类型改为JNIEnv*，然后尝试阅读一下代码。\n\n这一个函数的难度，比我想象中难很多啊，博客说，3D6AC是3DFC4的关键函数…点进去一看，不知道3D6AC在做什么，ptr_buf的大小是0x13E80，不妨hook sub_3d6ac，观察结束后，ptr_buf的内容是多少。\n\n脚本如下。\n// Frida脚本：hexdump sub_3D6AC的第一个参数ptr_buf// 1. 请将 &quot;libyourtarget.so&quot; 替换为目标SO文件的实际名称const TARGET_MODULE_NAME = &quot;libbaiduprotect.so&quot;;// 2. 这是 sub_3D6AC 函数在SO文件中的偏移地址//    如果 &quot;sub_3D6AC&quot; 是一个导出的函数名，你可以尝试使用 Module.findExportByName()//    但通常这种 &quot;sub_XXXXX&quot; 格式的名称是IDA反编译后基于地址命名的，所以使用偏移量更可靠。const FUNCTION_OFFSET = 0x3D6AC; // 函数 sub_3D6AC 的偏移地址// 3. ptr_buf 指向的内存区域大小const BUFFER_SIZE = 0x13e80;// (可选) 你想在hexdump中实际打印的最大字节数，以防BUFFER_SIZE过大导致控制台输出混乱// 如果你想打印全部内容，可以将MAX_DUMP_SIZE设置为BUFFER_SIZEconst MAX_DUMP_SIZE = Math.min(BUFFER_SIZE); // 例如，最多打印1024字节function hook_linker_call_constructors() &#123;    // 获得linker64的地址    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;);    let offset_call = 0x51BA8;    // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset_call);    let listener = Interceptor.attach(call_constructors, &#123;        onEnter: function(args) &#123;            // 判断是否可以通过findModuleByName查找到目标so文件            console.log(&#x27;[linker] Call_Constructors onEnter&#x27;);            let secmodule = Process.findModuleByName(TARGET_MODULE_NAME);            if (secmodule != null) &#123;                // 第一时间hook                hook_target_func(secmodule.base);                listener.detach();            &#125;        &#125;    &#125;);&#125;function hook_target_func(baseaddr)&#123;    let listener = Interceptor.attach(baseaddr.add(0x88060), &#123;        onEnter:function(args)&#123;        &#125;,        onLeave:function(retval)&#123;            // 第一个函数解密完后，才能hook sub_28c28            main(baseaddr);            listener.detach();        &#125;    &#125;);&#125;function main(base) &#123;    const moduleBase = base;    if (!moduleBase) &#123;        console.error(&quot;[-] 模块 &quot; + TARGET_MODULE_NAME + &quot; 未找到。请确保模块名正确且已加载。&quot;);        return;    &#125;    const targetFunctionAddr = moduleBase.add(FUNCTION_OFFSET);    console.log(&quot;[+] 目标函数 sub_3D6AC 地址: &quot; + targetFunctionAddr);    console.log(&quot;[+] ptr_buf 大小: 0x&quot; + BUFFER_SIZE.toString(16) + &quot; (&quot; + BUFFER_SIZE + &quot; bytes)&quot;);    console.log(&quot;[+] hexdump 将显示最多: 0x&quot; + MAX_DUMP_SIZE.toString(16) + &quot; (&quot; + MAX_DUMP_SIZE + &quot; bytes)&quot;);    Interceptor.attach(targetFunctionAddr, &#123;        onEnter: function(args) &#123;            // args[0] 是第一个参数 (__int64 a1, 即 ptr_buf)            // args[1] 是第二个参数 (JNIEnv *env)            this.ptr_buf = args[0]; // 保存 ptr_buf 的指针以在 onLeave 中使用            this.jniEnv = args[1];  // 保存 JNIEnv 指针            console.log(&quot;\\n[*] 进入 sub_3D6AC:&quot;);            console.log(&quot;    ptr_buf (a1): &quot; + this.ptr_buf);            console.log(&quot;    JNIEnv* (a2): &quot; + this.jniEnv);        &#125;,        onLeave: function(retval) &#123;            console.log(&quot;[*] 离开 sub_3D6AC. 返回值: &quot; + retval);            if (this.ptr_buf &amp;&amp; !this.ptr_buf.isNull()) &#123;                console.log(&quot;[+] ptr_buf (&quot; + this.ptr_buf + &quot;) 内容 (前 &quot; + MAX_DUMP_SIZE + &quot; 字节):&quot;);                try &#123;                    // Memory.readByteArray(pointer, length) 返回一个 ArrayBuffer                    const bufferContent = Memory.readByteArray(this.ptr_buf, Math.min(BUFFER_SIZE, MAX_DUMP_SIZE));                    console.log(hexdump(bufferContent, &#123;                        offset: 0,                        length: Math.min(BUFFER_SIZE, MAX_DUMP_SIZE), // 确保hexdump长度与读取长度一致                        header: true,                        ansi: true // 如果你的控制台支持，可以开启颜色高亮                    &#125;));                    // 如果你想保存整个缓冲区到文件（这部分比较复杂，通常建议在PC端Python脚本中处理）                    // 你可以在这里发送 bufferContent (或者 this.ptr_buf 和 BUFFER_SIZE) 到你的Python脚本                    // 例如: send(&#123; ptr: this.ptr_buf.toString(), size: BUFFER_SIZE &#125;);                    // 然后在Python端接收并保存：                    // def on_message(message, data):                    //     if message[&#x27;type&#x27;] == &#x27;send&#x27;:                    //         payload = message[&#x27;payload&#x27;]                    //         ptr = int(payload[&#x27;ptr&#x27;], 16)                    //         size = payload[&#x27;size&#x27;]                    //         print(f&quot;Receiving buffer from &#123;hex(ptr)&#125; with size &#123;size&#125;&quot;)                    //         buffer_data = process.read_bytes(ptr, size)                    //         with open(f&quot;ptr_buf_dump_&#123;hex(ptr)&#125;.bin&quot;, &quot;wb&quot;) as f_out:                    //             f_out.write(buffer_data)                    //         print(f&quot;Buffer dumped to ptr_buf_dump_&#123;hex(ptr)&#125;.bin&quot;)                    // script.on(&#x27;message&#x27;, on_message)                &#125; catch (e) &#123;                    console.error(&quot;[-] 读取或hexdump ptr_buf 时发生错误: &quot; + e);                    console.error(&quot;    错误详情: &quot; + e.stack);                &#125;            &#125; else &#123;                console.warn(&quot;[-] ptr_buf 在 onLeave 时为 null 或无效。&quot;);            &#125;            console.log(&quot;--- 结束 sub_3D6AC 打印 ---&quot;);        &#125;    &#125;);&#125;// 确保在Java环境准备好后执行main函数，尤其是在attach模式下早期hook时// 对于 Android SO 文件中的函数，通常直接调用 main() 即可，// 或者使用 setImmediate(main) 来确保主循环已准备好setImmediate(hook_linker_call_constructors);// 或者对于某些情况，特别是应用启动非常早期的hook，可能需要等待Java VM加载完毕// Java.perform(function() &#123;//     console.log(&quot;[+] Java VM 已加载，开始执行 main()&quot;);//     main();// &#125;);\n\n打印的结果如下图所示，文件还挺大的。\n\n回到3DFC4，验证一下我们之前的分析，第0x721个元素存放了目录路径的个数。0x721 x 4 &#x3D; 0x1C84，因此到0x1C84去读取个数。\n\n读4个字节，02 00 00 00，即为2。因此会创建2个文件夹，再来到第0x744个元素（也就是0x744 x 4 &#x3D; 0x1D10），去读取目录字符串。\n\n也就是说，第一个目录字符串的地址存放再0x7969adfcc0处，下一个地址则是0x7969adfd20。\n\n要获取这2个字符串，即去读取ptr_buf + 0x1D10和ptr_buf + 0x1D40，修改一下脚本。\nconst TARGET_MODULE_NAME = &quot;libbaiduprotect.so&quot;;const FUNCTION_OFFSET = 0x3D6AC;const BUFFER_SIZE = 0x13e80;const MAX_DUMP_SIZE = Math.min(BUFFER_SIZE);function hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;);    let offset_call = 0x51BA8; // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset_call);    let listener = Interceptor.attach(call_constructors, &#123;        onEnter: function(args) &#123;            console.log(&#x27;[linker] Call_Constructors onEnter&#x27;);            let secmodule = Process.findModuleByName(TARGET_MODULE_NAME);            if (secmodule != null) &#123;                hook_target_func(secmodule.base);                listener.detach();            &#125;        &#125;    &#125;);&#125;function hook_target_func(baseaddr) &#123;    let listener = Interceptor.attach(baseaddr.add(0x88060), &#123;        onEnter: function(args) &#123;&#125;,        onLeave: function(retval) &#123;            main(baseaddr);            listener.detach();        &#125;    &#125;);&#125;function main(base) &#123;    const moduleBase = base;    if (!moduleBase) &#123;        console.error(&quot;[-] 模块 &quot; + TARGET_MODULE_NAME + &quot; 未找到。请确保模块名正确且已加载。&quot;);        return;    &#125;    const targetFunctionAddr = moduleBase.add(FUNCTION_OFFSET);    console.log(&quot;[+] 目标函数 sub_3D6AC 地址: &quot; + targetFunctionAddr);    console.log(&quot;[+] ptr_buf 大小: 0x&quot; + BUFFER_SIZE.toString(16) + &quot; (&quot; + BUFFER_SIZE + &quot; bytes)&quot;);    console.log(&quot;[+] hexdump 将显示最多: 0x&quot; + MAX_DUMP_SIZE.toString(16) + &quot; (&quot; + MAX_DUMP_SIZE + &quot; bytes)&quot;);    Interceptor.attach(targetFunctionAddr, &#123;        onEnter: function(args) &#123;            this.ptr_buf = args[0]; // 保存 ptr_buf 的指针            this.jniEnv = args[1];  // 保存 JNIEnv 指针            console.log(&quot;\\n[*] 进入 sub_3D6AC:&quot;);            console.log(&quot;    ptr_buf (a1): &quot; + this.ptr_buf);            console.log(&quot;    JNIEnv* (a2): &quot; + this.jniEnv);        &#125;,        onLeave: function(retval) &#123;            console.log(&quot;[*] 离开 sub_3D6AC. 返回值: &quot; + retval);            if (this.ptr_buf &amp;&amp; !this.ptr_buf.isNull()) &#123;                console.log(&quot;[+] ptr_buf (&quot; + this.ptr_buf + &quot;) 内容:&quot;);                try &#123;                    // 读取目录个数 (ptr_buf[0x721])                    const dirCount = this.ptr_buf.add(0x721 * 4).readU32();                    console.log(&quot;[+] 目录个数 (ptr_buf[0x721]): &quot; + dirCount);                    // 从 0x744 开始遍历目录结构                    let dirOffset = 0x744 * 4; // 字节偏移                    for (let i = 0; i &lt; dirCount; i++) &#123;                        const dirEntry = this.ptr_buf.add(dirOffset);                        const dirPathPtr = dirEntry.readPointer(); // 读取目录路径指针                        try &#123;                            const dirPath = dirPathPtr.readCString();                            console.log(`[Dir $&#123;i&#125;] $&#123;dirPathPtr&#125;: $&#123;dirPath&#125;`);                        &#125; catch (e) &#123;                            console.log(`[Dir $&#123;i&#125;] $&#123;dirPathPtr&#125;: (无法读取字符串: $&#123;e&#125;)`);                        &#125;                        dirOffset += 48; // 每个目录结构 48 字节                    &#125;                    // 可选：打印整个缓冲区 (注释掉，避免输出过多)                    /*                    const bufferContent = Memory.readByteArray(this.ptr_buf, Math.min(BUFFER_SIZE, MAX_DUMP_SIZE));                    console.log(hexdump(bufferContent, Math.min(BUFFER_SIZE, MAX_DUMP_SIZE)));                    */                &#125; catch (e) &#123;                    console.error(&quot;[-] 读取 ptr_buf 时发生错误: &quot; + e);                    console.error(&quot;    错误详情: &quot; + e.stack);                &#125;            &#125; else &#123;                console.warn(&quot;[-] ptr_buf 在 onLeave 时为 null 或无效。&quot;);            &#125;            console.log(&quot;--- 结束 sub_3D6AC 打印 ---&quot;);        &#125;    &#125;);&#125;setImmediate(hook_linker_call_constructors);\n\n打印的结果如下图所示，创建了2个目录。\n\n至于sub_3DFC4d剩下的内容就不分析了，因为sdk版本之前打印好像是32。\n\nsub_11F5C(a2&#x3D;&#x3D;3)接着看11F5C。——3E29C、40CF8（与java层传入的arg5有关）、3DFC4、11F5C、45964。\n直接调用sub_BC60。\n\n\n在sub_BC60中，根据sdk版本，执行不同的代码块，我记得之前打印过，sdk_version是32，因此这里只关注需要执行的函数。\n\n\n来看看sub_188AC，用d810去一下混淆。\n\n\nhook这些字符串，打印看看什么含义，似乎没打印出来，说明没执行到。v0是一个指针，存储着BCEB8。我猜测，这里是在根据sdk，选择对应的so。\n\n\n我知道libart.so，但libartbase.so是什么呢？\n\n\n接着看sub_4029c，进行一定分析，修改变量名，写注释，如下图所示。\n看上去，sub_4029C是一个处理内存映射的函数。\n\n整理一下：\n\n读取 &#x2F;proc&#x2F;self&#x2F;maps：\n\n\n打开 &#x2F;proc&#x2F;self&#x2F;maps 文件，获取当前进程的内存映射信息。\n\n\n查找目标模块（str）：\n\n\n在内存映射中查找包含 str（例如 “libartbase.so”）的条目。\n\n\n修改内存权限：\n\n\n对于目标模块的内存段，修改其权限（mprotect）：\n如果段权限是 r–p（只读），改为 r-x（可读可执行）。\n如果段权限是 r-xp（可读可执行），改为 rwx（可读可写可执行）。\n\n\n\n\n存储基地址：\n\n\n将目标模块的基地址存储到 a1 中。\n\n回到sub_188AC，继续分析，将sub_4029C改名成get_so_baseaddr_AND_change_flags。\n我之前hook过sub_25E78，但这里似乎并没有对6A6DC5A……进行解密，大概率是没执行，这里分析else分支，继续分析sub_3FF9C。\n\nbaseaddr是libartbase.so的基址，这里看上去是在解析ELF文件。\n\n\n随便打开一个普通的so文件看看，寻找第0x38个字节和0x20个字节的含义。——先取指针，后进行运算，所以这里用0x38*8。\n第0x38字节的含义：e_phnum_NUMBER_OF_PROGRAM_HEADER_ENTRIES，代表PHT的个数。\n\n第0x20字节的含义：e_phoff_PROGRAM_HEADER_OFFSET_IN_FILE，代表PHT在文件中的偏移量。\n\n除此之外，还有访问pht + 16位置的代码段…这里就不贴图了，直接修改变量名。\n这个函数手动解析了ELF动态信息，这种方式可以绕过一些针对标准dlsym的Hook，或者在某些特殊环境中加载和解析符号。\n那么，sub_3FF9C看似是在解析动态链接库，并找到对应的符号。——当然不是这样，继续往下看。\n\n可以注意到，函数3FAE0和3F924出现在了switch-case结构中，这里简单介绍这俩函数的作用。\n函数sub_3FAE0负责处理标准的ELF重定位表（如 .rela.dyn 用于数据重定位，.rela.plt 用于过程链接表PLT的函数调用重定位）。它查找对目标符号的引用，并将这些引用重定向到a3（调用时提供的“空函数”地址，伏笔）。\n函数sub_3FAE0负责处理一个自定义的、以”APS2”开头的特殊数据结构。这个结构中也包含了对某些符号的引用信息（可能是为了处理更复杂的场景，如与符号版本控制相关的重定位，或者是一些内部模块间的链接）。它同样查找对目标符号的引用，并将这些引用重定向到提供的“空函数”地址。\n这里的空函数，指的是sub_1B044，这是一个空函数，点进去只有一个return。（这里的redirect_func_to_a3是sub_3FF9C，被我改名了）。\n\n\n\n在sub_188AC中，除了将__android_log_print进行hook，重定位到一个空函数，还将mmap进行了hook，重定位到了sub_1B070，博主说，这里在加载Dex的时候有用。那就待会再来看sub_1B070吧。\n\n回到sub_BC60，总结一下sub_188AC，它将__android_log_print和mmap进行了hook。\n因为我们的sdk是32，再继续分析sub_11AB0。\n\n\n还有好多未解密的字符串，写个脚本打印一下。\n\n\n打印的结果如下，涉及动态加载。\n\n有个很奇怪的现象，可能是我没分析到？当把未解密的so文件放入ida中，跳转到11ab0，是可以看到循环的（和博客一致）。而解密后的so文件在查看时，没有for循环，不知道是什么导致的。麻了，因为这个so文件我没添加注释，没改变量名，有些东西乍一看看不出来。\n\n\n直接拿博客的图来用一下吧，好糊。\n简单说一下思路，将jar文件转换成dex文件，然后通过InMemoryDexClassLoader进行加载，然后将两个加载器的Element数组合并，重新设置成原加载器的Element数组（为了之后加载的类，可以被原始类加载器加载，热更新），随后将Dex文件的信息，在baidu设置的0x13E80个字节的缓冲区里进行更新——也不知道更新什么东西？费这么大信息，hook上mmap函数，最后只是为了拿到mmap分配的地址，给到函数update_dex_info_to_baidu_struct。\n\n\n回到sub_bc60，再次总结一下，在hook mmap之后，会加载jar文件（目标dex文件），然后去除mmap的hook。\n\n\n至此，sub_bc60分析完了——我没特意分析具体是如何解密出dex文件的，感觉很复杂——之前的签名扩展的176字节，会被用来当密钥，也就是说，如果这个apk被修改后重新签名，是无法打开的，因为Dex文件解不开。\n要想得到这个Dex文件，可以通过hook sub_3BA90，在onLeave时dump第3个参数，而dump的大小是第4个参数。\n\n\nsub_45964(a2&#x3D;&#x3D;3)最后，分析sub_45964。——3E29C、40CF8（与java层传入的arg5有关）、3DFC4、11F5C、45964。\n做了一下简单的分析。\n在RegisterNative_10item的函数中，注册了10个JNI函数，10个JNI函数全部注册到了1个Native地址上。\n\n10个函数全部注册到1个地址，说明是vmp。\n\n下图来自未解密的so文件，又有do-while没被检测出来。在函数sub_42D8C中，会对每个Dex文件去解析附加数据3。\n\n下图是每个Jar文件的内容。sub_42D8C负责处理其中的附加数据3。\n\n这里直接引用博主的分析，如下图所示。\n\n如何分析出来的呢？过几天来看看。\n总结至此，n001分析完了，总结一下。\nsub_3E29C取出了签名数组，取了数组的第0个元素，通过md5得到了16个字节，再把这16字节扩展成了176字节。\nsub_40cf8注册的函数异常处理有关，大致是负责异常处理。\nsub_3DFC4创建了两个目录，分别是&#x2F;data&#x2F;user&#x2F;0&#x2F;com.example.test&#x2F;.1和&#x2F;data&#x2F;user&#x2F;0&#x2F;com.example.test&#x2F;.2，这两个目录应该是与dex、jar相关，为sub_11f5c服务的。——我发现了一些字符串，&#x2F;data&#x2F;data&#x2F;包名&#x2F; &#x3D;&#x3D; &#x2F;data&#x2F;user&#x2F;0&#x2F;包名。\n\nsub_11f5C hook了两个函数，一个是__android_log_print，一个是mmap，然后解密加载了业务dex文件（需要用到sub_3E29C签名扩展的176字节进行解密），加载完后，删除了mmap的hook。\nsub_4596c注册了10个JNI函数，解析了vmp的方法数组和指令替换表。\nn002n002函数是在onCreate函数中调用的，也是启动app的流程必经的函数之一。\n在n002中，又是调用函数列表上的函数，这回的a2&#x3D;&#x3D;4。\n通过分析，会有sub_ 40CF8、sub_ 3E96C、sub_ 42388这3个函数执行。\nsub_ 40CF8调用CrashHandler.asynRun方法，向https://apkprotect.baidu.com/apklog发送统计信息。\nsub_ 3E96C assets&#x2F;baiduprotect.m检查dex的完整性，该文件中存有加密的dex MD5，如果修改dex进行重新签名，会导致app打不开。——应该还有对调试器的检测，因为使用frida和IDA的时候会异常退出。\nsub_ 42388注册com.baidu.xshield.jni.Asc和com.baidu.xshield.utility.KeyUtil的本地函数，调用com.baidu.xshield.ac.XH.init方法。\n至此，app启动流程涉及到的n001和n002分析完了。\nvmp分析先把dex dump下来，下面是脚本，hook sub_3BA90，在onLeave时进行dump。\n脚本如下。\nconst TARGET_MODULE_NAME = &quot;libbaiduprotect.so&quot;;function hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;);    let offset_call = 0x51BA8; // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset_call);    let listener = Interceptor.attach(call_constructors, &#123;        onEnter: function(args) &#123;            console.log(&#x27;[linker] Call_Constructors onEnter&#x27;);            let secmodule = Process.findModuleByName(TARGET_MODULE_NAME);            if (secmodule != null) &#123;                hook_target_func(secmodule.base);                listener.detach();            &#125;        &#125;    &#125;);&#125;function hook_target_func(baseaddr) &#123;    let listener = Interceptor.attach(baseaddr.add(0x88060), &#123;        onEnter: function(args) &#123;&#125;,        onLeave: function(retval) &#123;            // hook sub_3BA90            hook_3BA90(baseaddr);            listener.detach();        &#125;    &#125;);&#125;function hook_3BA90(baseaddr) &#123;    Interceptor.attach(baseaddr.add(0x3BA90), &#123;        onEnter: function(args) &#123;            // 保存指针地址            this.dexPtr = args[2]; // &amp;dex_ 的地址            this.sizePtr = args[3]; // &amp;v6 的地址            console.log(&quot;[+] sub_3BA90 - dexPtr:&quot;, this.dexPtr, &quot;sizePtr:&quot;, this.sizePtr);            console.log(&quot;[+] Call stack:\\n&quot;, Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join(&quot;\\n&quot;));        &#125;,        onLeave: function(retval) &#123;                // 读取 dex_ 和 v6 的值                this.ptr = this.dexPtr.readPointer(); // *dexPtr, 即 dex_ 的值                this.size = this.sizePtr.readU64().toNumber(); // *sizePtr, 即 v6 的值                console.log(&quot;[+] DEX dump - ptr:&quot;, this.ptr, &quot;size:&quot;, this.size);                if (this.ptr &amp;&amp; !this.ptr.isNull() &amp;&amp; this.size &gt; 0 &amp;&amp; this.size &lt; 0x10000000) &#123; // 限制最大 256MB                    // 修改内存权限                    Memory.protect(this.ptr, this.size, &#x27;rwx&#x27;);                    console.log(&quot;[+] 内存权限已修改为 rwx&quot;);                    // 读取 DEX 文件内容                    const dexData = Memory.readByteArray(this.ptr, this.size);                    console.log(&quot;[+] 成功读取 DEX 数据&quot;);                    // 生成唯一的文件名                    const filename = `/data/data/com.example.test/dex_dump_$&#123;this.ptr.toString(16)&#125;_$&#123;Date.now()&#125;.dex`;                    // 写入文件                    const file = new File(filename, &quot;wb&quot;);                    if (file) &#123;                        file.write(dexData);                        file.flush();                        file.close();                        console.log(&quot;[+] DEX 文件成功保存到:&quot;, filename);                    &#125; else &#123;                        console.error(&quot;[-] 无法打开文件:&quot;, filename);                    &#125;                &#125; else &#123;                    console.warn(&quot;[-] 无效的 ptr 或 size:&quot;, this.ptr, this.size);                &#125;        &#125;    &#125;);&#125;setImmediate(hook_linker_call_constructors);\n\n打印的结果如下。\n\n\n这里图方便，分析onCreate函数（vmp化），需要判断它在哪个dex文件里。\n通过这个指令：grep -r “MainActivity” .&#x2F;dex_dump 可以找到。\n\n算了，直接将2个dex都pull出来，丢进行jadx里看看。\n成功找到了类MainActivity，onCreate明显被vmp动过。\n\n\n-1426063360即为0xAB00 0000。\n\n\n来到之前注册V的函数的地方，函数列表很怪，按理来说，应该有5个参数，前2个是JNIEnv和jclass，然后是A.V传的3个参数。\n\n把签名改成我期待的样子。\n\n再看这个sub_4A458，很不正常，连传了3个BYTE(a3)，还是看汇编吧。\n\n通过汇编的还原，调用的参数列表应该是这样子的。\n\n\n接下来，进入sub_4a458。看一眼就累了，很多函数的参数都是瞎传递的，ida没正确识别。\n\n试试用ida的trace，由于vmp这一块代码是加密的，要等到解密后才方便下断点。因此，还是使用frida进行trace吧。\n但是frida trace受挫了，似乎有反调？我之前尝试使用jnitrace也是执行到特定时候就会退出。\n之后尝试绕过。——hook pthread_create的线程函数，置为空，然后重新使用hook_libart.js来查看调用的JNI函数，看看会不会退出。\n好消息，成功了，脚本如下。\nvar offset = 0x88060;var module_size = 0;var module_name = &quot;libbaiduprotect.so&quot;;var base_addr = null; // To store the base address of libbaiduprotect.so// Create an empty functionvar empty_func = new NativeCallback(function() &#123;    return 0;&#125;, &#x27;int&#x27;, [&#x27;pointer&#x27;]);function hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;);    let offset_call = 0x51BA8; // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset_call);    let listener = Interceptor.attach(call_constructors, &#123;        onEnter: function(args) &#123;            console.log(&#x27;[linker] Call_Constructors onEnter&#x27;);            let secmodule = Process.findModuleByName(module_name);            if (secmodule != null) &#123;                module_size = secmodule.size;                base_addr = secmodule.base; // Save the base address                console.log(&quot;libbaiduprotect.so base: &quot; + base_addr + &quot;, size: &quot; + module_size);                hook_target_func(base_addr);                listener.detach();            &#125;        &#125;    &#125;);&#125;function hook_target_func(baseaddr) &#123;    let target_addr = baseaddr.add(offset);    let listener = Interceptor.attach(target_addr, &#123;        onEnter: function(args) &#123;            console.log(&quot;Target function at &quot; + target_addr + &quot; entered&quot;);        &#125;,        onLeave: function(retval) &#123;            console.log(&quot;libbaiduprotect.so base address: &quot; + baseaddr);            hook_pthread_create();            listener.detach();        &#125;    &#125;);&#125;function hook_pthread_create() &#123;    let pthread_create_addr = Module.getExportByName(&quot;libc.so&quot;, &quot;pthread_create&quot;);    Interceptor.attach(pthread_create_addr, &#123;        onEnter: function(args) &#123;            let func_addr = args[2];            let target_func_addr = base_addr.add(0x3E9F0); // Calculate the target function address            if (func_addr.equals(target_func_addr)) &#123;                console.log(&quot;Replacing func_addr &quot; + func_addr + &quot; with empty function&quot;);                args[2] = empty_func; // Replace with the empty function                hook_libart(); // Execute hook_libart            &#125; else &#123;                let module = Process.findModuleByAddress(func_addr);                if (module &amp;&amp; module.name === module_name) &#123;                    console.log(&quot;pthread_create called in libbaiduprotect.so, function address: &quot; + func_addr);                &#125;            &#125;        &#125;,        onLeave: function(retval) &#123;            // Optionally log return value        &#125;    &#125;);&#125;const STD_STRING_SIZE = 3 * Process.pointerSize;class StdString &#123;    constructor() &#123;        this.handle = Memory.alloc(STD_STRING_SIZE);    &#125;    dispose() &#123;        const [data, isTiny] = this._getData();        if (!isTiny) &#123;            Java.api.$delete(data);        &#125;    &#125;    disposeToString() &#123;        const result = this.toString();        this.dispose();        return result;    &#125;    toString() &#123;        const [data] = this._getData();        return data.readUtf8String();    &#125;    _getData() &#123;        const str = this.handle;        const isTiny = (str.readU8() &amp; 1) === 0;        const data = isTiny ? str.add(1) : str.add(2 * Process.pointerSize).readPointer();        return [data, isTiny];    &#125;&#125;function prettyMethod(method_id, withSignature) &#123;    const result = new StdString();    Java.api[&#x27;art::ArtMethod::PrettyMethod&#x27;](result, method_id, withSignature ? 1 : 0);    return result.disposeToString();&#125;function hook_libart() &#123;    var symbols = Module.enumerateSymbolsSync(&quot;libart.so&quot;);    var addrGetStringUTFChars = null;    var addrNewStringUTF = null;    var addrFindClass = null;    var addrGetMethodID = null;    var addrGetStaticMethodID = null;    var addrGetFieldID = null;    var addrGetStaticFieldID = null;    var addrRegisterNatives = null;    var so_name = &quot;lib&quot;;      // TODO: Specify the SO to filter    for (var i = 0; i &lt; symbols.length; i++) &#123;        var symbol = symbols[i];        if (symbol.name.indexOf(&quot;art&quot;) &gt;= 0 &amp;&amp;            symbol.name.indexOf(&quot;JNI&quot;) &gt;= 0 &amp;&amp;            symbol.name.indexOf(&quot;CheckJNI&quot;) &lt; 0 &amp;&amp;            symbol.name.indexOf(&quot;_ZN3art3JNIILb0&quot;) &gt;= 0        ) &#123;            if (symbol.name.indexOf(&quot;GetStringUTFChars&quot;) &gt;= 0) &#123;                addrGetStringUTFChars = symbol.address;                console.log(&quot;GetStringUTFChars is at &quot;, symbol.address, symbol.name);            &#125; else if (symbol.name.indexOf(&quot;NewStringUTF&quot;) &gt;= 0) &#123;                addrNewStringUTF = symbol.address;                console.log(&quot;NewStringUTF is at &quot;, symbol.address, symbol.name);            &#125; else if (symbol.name.indexOf(&quot;FindClass&quot;) &gt;= 0) &#123;                addrFindClass = symbol.address;                console.log(&quot;FindClass is at &quot;, symbol.address, symbol.name);            &#125; else if (symbol.name.indexOf(&quot;GetMethodID&quot;) &gt;= 0) &#123;                addrGetMethodID = symbol.address;                console.log(&quot;GetMethodID is at &quot;, symbol.address, symbol.name);            &#125; else if (symbol.name.indexOf(&quot;GetStaticMethodID&quot;) &gt;= 0) &#123;                addrGetStaticMethodID = symbol.address;                console.log(&quot;GetStaticMethodID is at &quot;, symbol.address, symbol.name);            &#125; else if (symbol.name.indexOf(&quot;GetFieldID&quot;) &gt;= 0) &#123;                addrGetFieldID = symbol.address;                console.log(&quot;GetFieldID is at &quot;, symbol.address, symbol.name);            &#125; else if (symbol.name.indexOf(&quot;GetStaticFieldID&quot;) &gt;= 0) &#123;                addrGetStaticFieldID = symbol.address;                console.log(&quot;GetStaticFieldID is at &quot;, symbol.address, symbol.name);            &#125; else if (symbol.name.indexOf(&quot;RegisterNatives&quot;) &gt;= 0) &#123;                addrRegisterNatives = symbol.address;                console.log(&quot;RegisterNatives is at &quot;, symbol.address, symbol.name);            &#125; else if (symbol.name.indexOf(&quot;CallStatic&quot;) &gt;= 0) &#123;                console.log(&quot;CallStatic is at &quot;, symbol.address, symbol.name);                Interceptor.attach(symbol.address, &#123;                    onEnter: function (args) &#123;                        var module = Process.findModuleByAddress(this.returnAddress);                        if (module != null &amp;&amp; module.name.indexOf(so_name) == 0) &#123;                            var java_class = args[1];                            var mid = args[2];                            var class_name = Java.vm.tryGetEnv().getClassName(java_class);                            if (class_name.indexOf(&quot;java.&quot;) == -1 &amp;&amp; class_name.indexOf(&quot;android.&quot;) == -1) &#123;                                var method_name = prettyMethod(mid, 1);                                console.log(&quot;&lt;&gt;CallStatic:&quot;, DebugSymbol.fromAddress(this.returnAddress), class_name, method_name);                            &#125;                        &#125;                    &#125;,                    onLeave: function (retval) &#123; &#125;                &#125;);            &#125; else if (symbol.name.indexOf(&quot;CallNonvirtual&quot;) &gt;= 0) &#123;                console.log(&quot;CallNonvirtual is at &quot;, symbol.address, symbol.name);                Interceptor.attach(symbol.address, &#123;                    onEnter: function (args) &#123;                        var module = Process.findModuleByAddress(this.returnAddress);                        if (module != null &amp;&amp; module.name.indexOf(so_name) == 0) &#123;                            var jobject = args[1];                            var jclass = args[2];                            var jmethodID = args[3];                            var obj_class_name = Java.vm.tryGetEnv().getObjectClassName(jobject);                            var class_name = Java.vm.tryGetEnv().getClassName(jclass);                            if (class_name.indexOf(&quot;java.&quot;) == -1 &amp;&amp; class_name.indexOf(&quot;android.&quot;) == -1) &#123;                                var method_name = prettyMethod(jmethodID, 1);                                console.log(&quot;&lt;&gt;CallNonvirtual:&quot;, DebugSymbol.fromAddress(this.returnAddress), class_name, obj_class_name, method_name);                            &#125;                        &#125;                    &#125;,                    onLeave: function (retval) &#123; &#125;                &#125;);            &#125; else if (symbol.name.indexOf(&quot;Call&quot;) &gt;= 0 &amp;&amp; symbol.name.indexOf(&quot;Method&quot;) &gt;= 0) &#123;                console.log(&quot;Call&lt;&gt;Method is at &quot;, symbol.address, symbol.name);                Interceptor.attach(symbol.address, &#123;                    onEnter: function (args) &#123;                        var module = Process.findModuleByAddress(this.returnAddress);                        if (module != null &amp;&amp; module.name.indexOf(so_name) == 0) &#123;                            var java_class = args[1];                            var mid = args[2];                            var class_name = Java.vm.tryGetEnv().getObjectClassName(java_class);                            if (class_name.indexOf(&quot;java.&quot;) == -1 &amp;&amp; class_name.indexOf(&quot;android.&quot;) == -1) &#123;                                var method_name = prettyMethod(mid, 1);                                console.log(&quot;&lt;&gt;Call&lt;&gt;Method:&quot;, DebugSymbol.fromAddress(this.returnAddress), class_name, method_name);                            &#125;                        &#125;                    &#125;,                    onLeave: function (retval) &#123; &#125;                &#125;);            &#125;        &#125;    &#125;    if (addrGetStringUTFChars != null) &#123;        Interceptor.attach(addrGetStringUTFChars, &#123;            onEnter: function (args) &#123;            &#125;,            onLeave: function (retval) &#123;                if (retval != null) &#123;                    var module = Process.findModuleByAddress(this.returnAddress);                    if (module != null &amp;&amp; module.name.indexOf(so_name) == 0) &#123;                        var bytes = Memory.readCString(retval);                        console.log(&quot;[GetStringUTFChars] result:&quot; + bytes, DebugSymbol.fromAddress(this.returnAddress));                    &#125;                &#125;            &#125;        &#125;);    &#125;    if (addrNewStringUTF != null) &#123;        Interceptor.attach(addrNewStringUTF, &#123;            onEnter: function (args) &#123;                if (args[1] != null) &#123;                    var module = Process.findModuleByAddress(this.returnAddress);                    if (module != null &amp;&amp; module.name.indexOf(so_name) == 0) &#123;                        var string = Memory.readCString(args[1]);                        console.log(&quot;[NewStringUTF] bytes:&quot; + string, DebugSymbol.fromAddress(this.returnAddress));                    &#125;                &#125;            &#125;,            onLeave: function (retval) &#123; &#125;        &#125;);    &#125;    if (addrFindClass != null) &#123;        Interceptor.attach(addrFindClass, &#123;            onEnter: function (args) &#123;                if (args[1] != null) &#123;                    var module = Process.findModuleByAddress(this.returnAddress);                    if (module != null &amp;&amp; module.name.indexOf(so_name) == 0) &#123;                        var name = Memory.readCString(args[1]);                        console.log(&quot;[FindClass] name:&quot; + name, DebugSymbol.fromAddress(this.returnAddress));                    &#125;                &#125;            &#125;,            onLeave: function (retval) &#123; &#125;        &#125;);    &#125;    if (addrGetMethodID != null) &#123;        Interceptor.attach(addrGetMethodID, &#123;            onEnter: function (args) &#123;                if (args[2] != null) &#123;                    var clazz = args[1];                    var class_name = Java.vm.tryGetEnv().getClassName(clazz);                    var module = Process.findModuleByAddress(this.returnAddress);                    if (module != null &amp;&amp; module.name.indexOf(so_name) == 0) &#123;                        var name = Memory.readCString(args[2]);                        if (args[3] != null) &#123;                            var sig = Memory.readCString(args[3]);                            console.log(&quot;[GetMethodID] class_name:&quot; + class_name + &quot; name:&quot; + name + &quot;, sig:&quot; + sig, DebugSymbol.fromAddress(this.returnAddress));                        &#125; else &#123;                            console.log(&quot;[GetMethodID] class_name:&quot; + class_name + &quot; name:&quot; + name, DebugSymbol.fromAddress(this.returnAddress));                        &#125;                    &#125;                &#125;            &#125;,            onLeave: function (retval) &#123; &#125;        &#125;);    &#125;    if (addrGetStaticMethodID != null) &#123;        Interceptor.attach(addrGetStaticMethodID, &#123;            onEnter: function (args) &#123;                if (args[2] != null) &#123;                    var clazz = args[1];                    var class_name = Java.vm.tryGetEnv().getClassName(clazz);                    var module = Process.findModuleByAddress(this.returnAddress);                    if (module != null &amp;&amp; module.name.indexOf(so_name) == 0) &#123;                        var name = Memory.readCString(args[2]);                        if (args[3] != null) &#123;                            var sig = Memory.readCString(args[3]);                            console.log(&quot;[GetStaticMethodID] class_name:&quot; + class_name + &quot; name:&quot; + name + &quot;, sig:&quot; + sig, DebugSymbol.fromAddress(this.returnAddress));                        &#125; else &#123;                            console.log(&quot;[GetStaticMethodID] class_name:&quot; + class_name + &quot; name:&quot; + name, DebugSymbol.fromAddress(this.returnAddress));                        &#125;                    &#125;                &#125;            &#125;,            onLeave: function (retval) &#123; &#125;        &#125;);    &#125;    if (addrGetFieldID != null) &#123;        Interceptor.attach(addrGetFieldID, &#123;            onEnter: function (args) &#123;                if (args[2] != null) &#123;                    var module = Process.findModuleByAddress(this.returnAddress);                    if (module != null &amp;&amp; module.name.indexOf(so_name) == 0) &#123;                        var name = Memory.readCString(args[2]);                        if (args[3] != null) &#123;                            var sig = Memory.readCString(args[3]);                            console.log(&quot;[GetFieldID] name:&quot; + name + &quot;, sig:&quot; + sig, DebugSymbol.fromAddress(this.returnAddress));                        &#125; else &#123;                            console.log(&quot;[GetFieldID] name:&quot; + name, DebugSymbol.fromAddress(this.returnAddress));                        &#125;                    &#125;                &#125;            &#125;,            onLeave: function (retval) &#123; &#125;        &#125;);    &#125;    if (addrGetStaticFieldID != null) &#123;        Interceptor.attach(addrGetStaticFieldID, &#123;            onEnter: function (args) &#123;                if (args[2] != null) &#123;                    var module = Process.findModuleByAddress(this.returnAddress);                    if (module != null &amp;&amp; module.name.indexOf(so_name) == 0) &#123;                        var name = Memory.readCString(args[2]);                        if (args[3] != null) &#123;                            var sig = Memory.readCString(args[3]);                            console.log(&quot;[GetStaticFieldID] name:&quot; + name + &quot;, sig:&quot; + sig, DebugSymbol.fromAddress(this.returnAddress));                        &#125; else &#123;                            console.log(&quot;[GetStaticFieldID] name:&quot; + name, DebugSymbol.fromAddress(this.returnAddress));                        &#125;                    &#125;                &#125;            &#125;,            onLeave: function (retval) &#123; &#125;        &#125;);    &#125;    if (addrRegisterNatives != null) &#123;        Interceptor.attach(addrRegisterNatives, &#123;            onEnter: function (args) &#123;                console.log(&quot;[RegisterNatives] method_count:&quot;, args[3], DebugSymbol.fromAddress(this.returnAddress));                var env = args[0];                var java_class = args[1];                var class_name = Java.vm.tryGetEnv().getClassName(java_class);                var methods_ptr = ptr(args[2]);                var method_count = parseInt(args[3]);                for (var i = 0; i &lt; method_count; i++) &#123;                    var name_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3));                    var sig_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize));                    var fnPtr_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize * 2));                    var name = Memory.readCString(name_ptr);                    var sig = Memory.readCString(sig_ptr);                    var find_module = Process.findModuleByAddress(fnPtr_ptr);                    console.log(&quot;[RegisterNatives] java_class:&quot;, class_name, &quot;name:&quot;, name, &quot;sig:&quot;, sig, &quot;fnPtr:&quot;, fnPtr_ptr, &quot;module_name:&quot;, find_module.name, &quot;module_base:&quot;, find_module.base, &quot;offset:&quot;, ptr(fnPtr_ptr).sub(find_module.base));                &#125;            &#125;,            onLeave: function (retval) &#123; &#125;        &#125;);    &#125;&#125;hook_linker_call_constructors();\n\n成功打印出jni调用的函数，也就是说，离frida trace所有vmp的指令又进一步。\n\n暂时先到这吧，明天面携程，先复习一下加解密算法，之后继续复现vmp。\n ok，继续分析，也不知道携程能不能有个善终——20250514 09:28。\n我将jni调用的日志输出到文件中，慢慢看。\n我们要分析的被vmp的函数是onCreate，不妨猜测它会调用super.onCreate，而要实现super.onCreate，不能只靠vmp的解释器进行解释执行，还需要用到jni调用，因此可以在日志中搜索onCreate，于是得到下面的日志。\n于是，我们能确定了解释器是在哪里获取的onCreate的jmethod_id（0x5df18）和在哪里真正调用onCreate函数的（0x54370）。\n[GetMethodID] class_name:androidx.appcompat.app.AppCompatActivity name:onCreate, sig:(Landroid/os/Bundle;)V 0x743fd08f18 libbaiduprotect.so!0x5df18[GetMethodID] class_name:android.system.StructStatVfs name:&lt;init&gt;, sig:(JJJJJJJJJJJ)V 0x744a5310b4 libjavacore.so!0x310b4&lt;&gt;CallNonvirtual: 0x743fcff370 libbaiduprotect.so!0x54370 androidx.appcompat.app.AppCompatActivity com.example.test.MainActivity void androidx.appcompat.app.AppCompatActivity.onCreate(android.os.Bundle)\n\n不妨想想如何倒推——如果没有被vmp化，原onCreate中，大概率要执行super.onCreate，对应的smali指令，大概率是invoke-super，通过invoke-super调用父类的onCreate。\n先尝试将指令trace下来吧，试了一下，即便先绕过反调，仍然无法trace下来，那是什么原因呢？\n追踪指令流，发现执行到sub_45EBC后，程序便不会返回到BL sub_45EBC的下一条指令了，而sub_45EBC的最后一条指令是，将栈指针寄存器变成了0x1，难怪会退出——为什么使用frida-stalker之后，会出现这种问题呢？\nmov wsp, #1\n\n整理一下现有的信息，我知道：\n\n哪里调用了onCreate。\n\n执行sub_45EBC就会崩溃。\n\n\n那我是否可以根据onCreate的交叉引用，一步一步回推是哪个跳转出现了问题，最后进入了sub_45EBC退出的。\n已知0x5df18处会获取onCreate的method_id，而0x54370会调用onCreate，交叉引用一下这两个地址，发现两个函数都追踪到了.data节，除此之外，没有其它函数引用了它们。\n把函数地址存放在.data节中，而且不只一个函数地址，大概率是通过BLR或BR指令跳转的。\nBL和BLR的区别在，前者是通过PC相对偏移量跳转到目标函数在内存中的地址，而后者是跳转到寄存器中存储的地址，也就是说，BL的跳转地址基本是硬编码在指令里的，是编译时就确定的，而BLR可以根据寄存器的内容进行跳转，在运行时决定。这里这么多个地址放在一块，大概率在执行时要跳转很多个函数，所以使用有R的跳转指令。\n这里继续交叉引用off_BD040。\n\n\nBR X8，符合上面的分析。\n\n\n回到函数列表中，突然发现它有256个函数地址，smali的操作码是1个字节，对应256种操作，这里会不会就是vmp解释器模拟smali指令的地方？读取解密后的vmp_code_item，然后根据vmp_code_item里的每一条指令，模拟执行对应的函数。\n.data:00000000000BD040 58 CD 04 00 00 00 00 00 off_BD040       DCQ sub_4CD58           ; DATA XREF: sub_4CC20+C4↑o.data:00000000000BD048 8C CD 04 00 00 00 00 00                 DCQ sub_4CD8C.data:00000000000BD050 E0 CD 04 00 00 00 00 00                 DCQ sub_4CDE0.data:00000000000BD058 34 CE 04 00 00 00 00 00                 DCQ sub_4CE34.data:00000000000BD060 84 CE 04 00 00 00 00 00                 DCQ sub_4CE84.data:00000000000BD068 D4 CE 04 00 00 00 00 00                 DCQ sub_4CED4.data:00000000000BD070 24 CF 04 00 00 00 00 00                 DCQ sub_4CF24.data:00000000000BD078 70 CF 04 00 00 00 00 00                 DCQ sub_4CF70.data:00000000000BD080 C0 CF 04 00 00 00 00 00                 DCQ sub_4CFC0.data:00000000000BD088 10 D0 04 00 00 00 00 00                 DCQ sub_4D010.data:00000000000BD090 5C D0 04 00 00 00 00 00                 DCQ sub_4D05C.data:00000000000BD098 C0 D0 04 00 00 00 00 00                 DCQ sub_4D0C0.data:00000000000BD0A0 2C D1 04 00 00 00 00 00                 DCQ sub_4D12C.data:00000000000BD0A8 98 D1 04 00 00 00 00 00                 DCQ sub_4D198.data:00000000000BD0B0 DC 46 05 00 00 00 00 00                 DCQ loc_546DC           ; jumptable 0000000000053D00 cases 69,71,72,75,77-82,84,85,87-89.data:00000000000BD0B0                                                                 ; jumptable 0000000000053D50 cases 69,71,72,75,77-82,84,85,87-89.data:00000000000BD0B0                                                                 ; jumptable 0000000000053DAC cases 69,71,72,75,77-82,84,85,87-89.data:00000000000BD0B8 BC 46 05 00 00 00 00 00                 DCQ loc_546BC.data:00000000000BD0C0 14 D2 04 00 00 00 00 00                 DCQ sub_4D214.data:00000000000BD0C8 14 D2 04 00 00 00 00 00                 DCQ sub_4D214.data:00000000000BD0D0 34 D2 04 00 00 00 00 00                 DCQ loc_4D234.data:00000000000BD0D8 80 D2 04 00 00 00 00 00                 DCQ loc_4D280.data:00000000000BD0E0 D0 D2 04 00 00 00 00 00                 DCQ loc_4D2D0.data:00000000000BD0E8 24 D3 04 00 00 00 00 00                 DCQ loc_4D324.data:00000000000BD0F0 74 D3 04 00 00 00 00 00                 DCQ loc_4D374.data:00000000000BD0F8 C0 D3 04 00 00 00 00 00                 DCQ loc_4D3C0.data:00000000000BD100 18 D4 04 00 00 00 00 00                 DCQ loc_4D418.data:00000000000BD108 7C D4 04 00 00 00 00 00                 DCQ loc_4D47C.data:00000000000BD110 CC D4 04 00 00 00 00 00                 DCQ loc_4D4CC.data:00000000000BD118 44 D5 04 00 00 00 00 00                 DCQ loc_4D544.data:00000000000BD120 C4 D5 04 00 00 00 00 00                 DCQ loc_4D5C4.data:00000000000BD128 40 D6 04 00 00 00 00 00                 DCQ loc_4D640.data:00000000000BD130 A8 D6 04 00 00 00 00 00                 DCQ loc_4D6A8.data:00000000000BD138 24 D7 04 00 00 00 00 00                 DCQ loc_4D724.data:00000000000BD140 C4 D7 04 00 00 00 00 00                 DCQ loc_4D7C4.data:00000000000BD148 68 D8 04 00 00 00 00 00                 DCQ loc_4D868.data:00000000000BD150 E0 D8 04 00 00 00 00 00                 DCQ loc_4D8E0.data:00000000000BD158 C0 DA 04 00 00 00 00 00                 DCQ loc_4DAC0.data:00000000000BD160 90 33 05 00 00 00 00 00                 DCQ loc_53390.data:00000000000BD168 28 DC 04 00 00 00 00 00                 DCQ loc_4DC28.data:00000000000BD170 30 DC 04 00 00 00 00 00                 DCQ loc_4DC30.data:00000000000BD178 AC DC 04 00 00 00 00 00                 DCQ loc_4DCAC.data:00000000000BD180 E8 DC 04 00 00 00 00 00                 DCQ loc_4DCE8.data:00000000000BD188 24 DD 04 00 00 00 00 00                 DCQ loc_4DD24.data:00000000000BD190 60 DD 04 00 00 00 00 00                 DCQ loc_4DD60.data:00000000000BD198 A4 DD 04 00 00 00 00 00                 DCQ loc_4DDA4.data:00000000000BD1A0 24 DE 04 00 00 00 00 00                 DCQ loc_4DE24.data:00000000000BD1A8 A4 DE 04 00 00 00 00 00                 DCQ loc_4DEA4.data:00000000000BD1B0 30 DF 04 00 00 00 00 00                 DCQ loc_4DF30.data:00000000000BD1B8 B0 DF 04 00 00 00 00 00                 DCQ loc_4DFB0.data:00000000000BD1C0 34 E0 04 00 00 00 00 00                 DCQ loc_4E034.data:00000000000BD1C8 AC E0 04 00 00 00 00 00                 DCQ loc_4E0AC.data:00000000000BD1D0 28 E1 04 00 00 00 00 00                 DCQ loc_4E128.data:00000000000BD1D8 14 E2 04 00 00 00 00 00                 DCQ loc_4E214.data:00000000000BD1E0 00 E3 04 00 00 00 00 00                 DCQ loc_4E300.data:00000000000BD1E8 94 E3 04 00 00 00 00 00                 DCQ loc_4E394.data:00000000000BD1F0 28 E4 04 00 00 00 00 00                 DCQ loc_4E428.data:00000000000BD1F8 BC E4 04 00 00 00 00 00                 DCQ loc_4E4BC.data:00000000000BD200 50 E5 04 00 00 00 00 00                 DCQ loc_4E550.data:00000000000BD208 D4 E5 04 00 00 00 00 00                 DCQ loc_4E5D4.data:00000000000BD210 58 E6 04 00 00 00 00 00                 DCQ loc_4E658.data:00000000000BD218 E0 E6 04 00 00 00 00 00                 DCQ loc_4E6E0.data:00000000000BD220 68 E7 04 00 00 00 00 00                 DCQ loc_4E768.data:00000000000BD228 F0 E7 04 00 00 00 00 00                 DCQ loc_4E7F0.data:00000000000BD230 78 E8 04 00 00 00 00 00                 DCQ loc_4E878.data:00000000000BD238 78 E8 04 00 00 00 00 00                 DCQ loc_4E878.data:00000000000BD240 78 E8 04 00 00 00 00 00                 DCQ loc_4E878.data:00000000000BD248 78 E8 04 00 00 00 00 00                 DCQ loc_4E878.data:00000000000BD250 78 E8 04 00 00 00 00 00                 DCQ loc_4E878.data:00000000000BD258 78 E8 04 00 00 00 00 00                 DCQ loc_4E878.data:00000000000BD260 78 E8 04 00 00 00 00 00                 DCQ loc_4E878.data:00000000000BD268 A4 E9 04 00 00 00 00 00                 DCQ loc_4E9A4.data:00000000000BD270 A4 EA 04 00 00 00 00 00                 DCQ loc_4EAA4.data:00000000000BD278 30 EC 04 00 00 00 00 00                 DCQ loc_4EC30.data:00000000000BD280 1C ED 04 00 00 00 00 00                 DCQ loc_4ED1C.data:00000000000BD288 E0 ED 04 00 00 00 00 00                 DCQ loc_4EDE0.data:00000000000BD290 A0 EE 04 00 00 00 00 00                 DCQ loc_4EEA0.data:00000000000BD298 64 EF 04 00 00 00 00 00                 DCQ loc_4EF64.data:00000000000BD2A0 60 F0 04 00 00 00 00 00                 DCQ loc_4F060.data:00000000000BD2A8 50 F1 04 00 00 00 00 00                 DCQ loc_4F150.data:00000000000BD2B0 F4 F1 04 00 00 00 00 00                 DCQ loc_4F1F4.data:00000000000BD2B8 9C F2 04 00 00 00 00 00                 DCQ loc_4F29C.data:00000000000BD2C0 44 F3 04 00 00 00 00 00                 DCQ loc_4F344.data:00000000000BD2C8 EC F3 04 00 00 00 00 00                 DCQ loc_4F3EC.data:00000000000BD2D0 94 F4 04 00 00 00 00 00                 DCQ loc_4F494.data:00000000000BD2D8 6C F5 04 00 00 00 00 00                 DCQ loc_4F56C.data:00000000000BD2E0 30 F6 04 00 00 00 00 00                 DCQ loc_4F630.data:00000000000BD2E8 A4 F7 04 00 00 00 00 00                 DCQ loc_4F7A4.data:00000000000BD2F0 4C F8 04 00 00 00 00 00                 DCQ loc_4F84C.data:00000000000BD2F8 F8 F8 04 00 00 00 00 00                 DCQ loc_4F8F8.data:00000000000BD300 A0 F9 04 00 00 00 00 00                 DCQ loc_4F9A0.data:00000000000BD308 4C FA 04 00 00 00 00 00                 DCQ loc_4FA4C.data:00000000000BD310 0C FB 04 00 00 00 00 00                 DCQ loc_4FB0C.data:00000000000BD318 C8 FB 04 00 00 00 00 00                 DCQ loc_4FBC8.data:00000000000BD320 68 FC 04 00 00 00 00 00                 DCQ loc_4FC68.data:00000000000BD328 0C FD 04 00 00 00 00 00                 DCQ loc_4FD0C.data:00000000000BD330 B0 FD 04 00 00 00 00 00                 DCQ loc_4FDB0.data:00000000000BD338 54 FE 04 00 00 00 00 00                 DCQ loc_4FE54.data:00000000000BD340 F8 FE 04 00 00 00 00 00                 DCQ loc_4FEF8.data:00000000000BD348 C0 FF 04 00 00 00 00 00                 DCQ loc_4FFC0.data:00000000000BD350 78 00 05 00 00 00 00 00                 DCQ loc_50078.data:00000000000BD358 E8 01 05 00 00 00 00 00                 DCQ loc_501E8.data:00000000000BD360 88 02 05 00 00 00 00 00                 DCQ loc_50288.data:00000000000BD368 2C 03 05 00 00 00 00 00                 DCQ loc_5032C.data:00000000000BD370 CC 03 05 00 00 00 00 00                 DCQ loc_503CC.data:00000000000BD378 70 04 05 00 00 00 00 00                 DCQ loc_50470.data:00000000000BD380 24 05 05 00 00 00 00 00                 DCQ loc_50524.data:00000000000BD388 D4 05 05 00 00 00 00 00                 DCQ loc_505D4.data:00000000000BD390 6C 06 05 00 00 00 00 00                 DCQ loc_5066C.data:00000000000BD398 08 07 05 00 00 00 00 00                 DCQ loc_50708.data:00000000000BD3A0 A4 07 05 00 00 00 00 00                 DCQ loc_507A4.data:00000000000BD3A8 40 08 05 00 00 00 00 00                 DCQ loc_50840.data:00000000000BD3B0 74 37 05 00 00 00 00 00                 DCQ loc_53774.data:00000000000BD3B8 C4 37 05 00 00 00 00 00                 DCQ loc_537C4.data:00000000000BD3C0 9C 38 05 00 00 00 00 00                 DCQ loc_5389C.data:00000000000BD3C8 CC 39 05 00 00 00 00 00                 DCQ loc_539CC.data:00000000000BD3D0 44 38 05 00 00 00 00 00                 DCQ loc_53844.data:00000000000BD3D8 70 37 05 00 00 00 00 00                 DCQ loc_53770.data:00000000000BD3E0 70 37 05 00 00 00 00 00                 DCQ loc_53770.data:00000000000BD3E8 C0 37 05 00 00 00 00 00                 DCQ loc_537C0.data:00000000000BD3F0 DC 08 05 00 00 00 00 00                 DCQ loc_508DC.data:00000000000BD3F8 C8 39 05 00 00 00 00 00                 DCQ loc_539C8.data:00000000000BD400 40 38 05 00 00 00 00 00                 DCQ loc_53840.data:00000000000BD408 F4 08 05 00 00 00 00 00                 DCQ loc_508F4.data:00000000000BD410 F4 08 05 00 00 00 00 00                 DCQ loc_508F4.data:00000000000BD418 F4 08 05 00 00 00 00 00                 DCQ loc_508F4.data:00000000000BD420 4C 09 05 00 00 00 00 00                 DCQ loc_5094C.data:00000000000BD428 A4 09 05 00 00 00 00 00                 DCQ loc_509A4.data:00000000000BD430 F8 09 05 00 00 00 00 00                 DCQ loc_509F8.data:00000000000BD438 4C 0A 05 00 00 00 00 00                 DCQ loc_50A4C.data:00000000000BD440 AC 0A 05 00 00 00 00 00                 DCQ loc_50AAC.data:00000000000BD448 00 0B 05 00 00 00 00 00                 DCQ loc_50B00.data:00000000000BD450 54 0B 05 00 00 00 00 00                 DCQ loc_50B54.data:00000000000BD458 B4 0B 05 00 00 00 00 00                 DCQ loc_50BB4.data:00000000000BD460 10 0C 05 00 00 00 00 00                 DCQ loc_50C10.data:00000000000BD468 68 0C 05 00 00 00 00 00                 DCQ loc_50C68.data:00000000000BD470 C4 0C 05 00 00 00 00 00                 DCQ loc_50CC4.data:00000000000BD478 18 0D 05 00 00 00 00 00                 DCQ loc_50D18.data:00000000000BD480 B8 0D 05 00 00 00 00 00                 DCQ loc_50DB8.data:00000000000BD488 50 0E 05 00 00 00 00 00                 DCQ loc_50E50.data:00000000000BD490 A8 0E 05 00 00 00 00 00                 DCQ loc_50EA8.data:00000000000BD498 44 0F 05 00 00 00 00 00                 DCQ loc_50F44.data:00000000000BD4A0 D8 0F 05 00 00 00 00 00                 DCQ loc_50FD8.data:00000000000BD4A8 34 10 05 00 00 00 00 00                 DCQ loc_51034.data:00000000000BD4B0 88 10 05 00 00 00 00 00                 DCQ loc_51088.data:00000000000BD4B8 DC 10 05 00 00 00 00 00                 DCQ loc_510DC.data:00000000000BD4C0 30 11 05 00 00 00 00 00                 DCQ loc_51130.data:00000000000BD4C8 98 11 05 00 00 00 00 00                 DCQ loc_51198.data:00000000000BD4D0 00 12 05 00 00 00 00 00                 DCQ loc_51200.data:00000000000BD4D8 68 12 05 00 00 00 00 00                 DCQ loc_51268.data:00000000000BD4E0 0C 13 05 00 00 00 00 00                 DCQ loc_5130C.data:00000000000BD4E8 98 13 05 00 00 00 00 00                 DCQ loc_51398.data:00000000000BD4F0 00 14 05 00 00 00 00 00                 DCQ loc_51400.data:00000000000BD4F8 68 14 05 00 00 00 00 00                 DCQ loc_51468.data:00000000000BD500 D0 14 05 00 00 00 00 00                 DCQ loc_514D0.data:00000000000BD508 3C 15 05 00 00 00 00 00                 DCQ loc_5153C.data:00000000000BD510 A8 15 05 00 00 00 00 00                 DCQ loc_515A8.data:00000000000BD518 14 16 05 00 00 00 00 00                 DCQ loc_51614.data:00000000000BD520 74 16 05 00 00 00 00 00                 DCQ loc_51674.data:00000000000BD528 D4 16 05 00 00 00 00 00                 DCQ loc_516D4.data:00000000000BD530 34 17 05 00 00 00 00 00                 DCQ loc_51734.data:00000000000BD538 C4 17 05 00 00 00 00 00                 DCQ loc_517C4.data:00000000000BD540 48 18 05 00 00 00 00 00                 DCQ loc_51848.data:00000000000BD548 A8 18 05 00 00 00 00 00                 DCQ loc_518A8.data:00000000000BD550 08 19 05 00 00 00 00 00                 DCQ loc_51908.data:00000000000BD558 68 19 05 00 00 00 00 00                 DCQ loc_51968.data:00000000000BD560 D0 19 05 00 00 00 00 00                 DCQ loc_519D0.data:00000000000BD568 38 1A 05 00 00 00 00 00                 DCQ loc_51A38.data:00000000000BD570 A0 1A 05 00 00 00 00 00                 DCQ loc_51AA0.data:00000000000BD578 10 1B 05 00 00 00 00 00                 DCQ loc_51B10.data:00000000000BD580 80 1B 05 00 00 00 00 00                 DCQ loc_51B80.data:00000000000BD588 F0 1B 05 00 00 00 00 00                 DCQ loc_51BF0.data:00000000000BD590 60 1C 05 00 00 00 00 00                 DCQ loc_51C60.data:00000000000BD598 F0 1C 05 00 00 00 00 00                 DCQ loc_51CF0.data:00000000000BD5A0 50 1D 05 00 00 00 00 00                 DCQ loc_51D50.data:00000000000BD5A8 B0 1D 05 00 00 00 00 00                 DCQ loc_51DB0.data:00000000000BD5B0 10 1E 05 00 00 00 00 00                 DCQ loc_51E10.data:00000000000BD5B8 70 1E 05 00 00 00 00 00                 DCQ loc_51E70.data:00000000000BD5C0 F0 1E 05 00 00 00 00 00                 DCQ loc_51EF0.data:00000000000BD5C8 50 1F 05 00 00 00 00 00                 DCQ loc_51F50.data:00000000000BD5D0 B0 1F 05 00 00 00 00 00                 DCQ loc_51FB0.data:00000000000BD5D8 10 20 05 00 00 00 00 00                 DCQ loc_52010.data:00000000000BD5E0 A0 20 05 00 00 00 00 00                 DCQ loc_520A0.data:00000000000BD5E8 24 21 05 00 00 00 00 00                 DCQ loc_52124.data:00000000000BD5F0 84 21 05 00 00 00 00 00                 DCQ loc_52184.data:00000000000BD5F8 E4 21 05 00 00 00 00 00                 DCQ loc_521E4.data:00000000000BD600 44 22 05 00 00 00 00 00                 DCQ loc_52244.data:00000000000BD608 A8 22 05 00 00 00 00 00                 DCQ loc_522A8.data:00000000000BD610 0C 23 05 00 00 00 00 00                 DCQ loc_5230C.data:00000000000BD618 70 23 05 00 00 00 00 00                 DCQ loc_52370.data:00000000000BD620 CC 23 05 00 00 00 00 00                 DCQ loc_523CC.data:00000000000BD628 28 24 05 00 00 00 00 00                 DCQ loc_52428.data:00000000000BD630 84 24 05 00 00 00 00 00                 DCQ loc_52484.data:00000000000BD638 0C 25 05 00 00 00 00 00                 DCQ loc_5250C.data:00000000000BD640 88 25 05 00 00 00 00 00                 DCQ loc_52588.data:00000000000BD648 E4 25 05 00 00 00 00 00                 DCQ loc_525E4.data:00000000000BD650 40 26 05 00 00 00 00 00                 DCQ loc_52640.data:00000000000BD658 9C 26 05 00 00 00 00 00                 DCQ loc_5269C.data:00000000000BD660 00 27 05 00 00 00 00 00                 DCQ loc_52700.data:00000000000BD668 64 27 05 00 00 00 00 00                 DCQ loc_52764.data:00000000000BD670 C8 27 05 00 00 00 00 00                 DCQ loc_527C8.data:00000000000BD678 2C 28 05 00 00 00 00 00                 DCQ loc_5282C.data:00000000000BD680 90 28 05 00 00 00 00 00                 DCQ loc_52890.data:00000000000BD688 F4 28 05 00 00 00 00 00                 DCQ loc_528F4.data:00000000000BD690 58 29 05 00 00 00 00 00                 DCQ loc_52958.data:00000000000BD698 DC 29 05 00 00 00 00 00                 DCQ loc_529DC.data:00000000000BD6A0 38 2A 05 00 00 00 00 00                 DCQ loc_52A38.data:00000000000BD6A8 94 2A 05 00 00 00 00 00                 DCQ loc_52A94.data:00000000000BD6B0 F0 2A 05 00 00 00 00 00                 DCQ loc_52AF0.data:00000000000BD6B8 4C 2B 05 00 00 00 00 00                 DCQ loc_52B4C.data:00000000000BD6C0 C8 2B 05 00 00 00 00 00                 DCQ loc_52BC8.data:00000000000BD6C8 24 2C 05 00 00 00 00 00                 DCQ loc_52C24.data:00000000000BD6D0 80 2C 05 00 00 00 00 00                 DCQ loc_52C80.data:00000000000BD6D8 DC 2C 05 00 00 00 00 00                 DCQ loc_52CDC.data:00000000000BD6E0 70 2D 05 00 00 00 00 00                 DCQ loc_52D70.data:00000000000BD6E8 F8 2D 05 00 00 00 00 00                 DCQ loc_52DF8.data:00000000000BD6F0 54 2E 05 00 00 00 00 00                 DCQ loc_52E54.data:00000000000BD6F8 B0 2E 05 00 00 00 00 00                 DCQ loc_52EB0.data:00000000000BD700 0C 2F 05 00 00 00 00 00                 DCQ loc_52F0C.data:00000000000BD708 6C 2F 05 00 00 00 00 00                 DCQ loc_52F6C.data:00000000000BD710 D0 2F 05 00 00 00 00 00                 DCQ loc_52FD0.data:00000000000BD718 34 30 05 00 00 00 00 00                 DCQ loc_53034.data:00000000000BD720 C8 30 05 00 00 00 00 00                 DCQ loc_530C8.data:00000000000BD728 50 31 05 00 00 00 00 00                 DCQ loc_53150.data:00000000000BD730 B0 31 05 00 00 00 00 00                 DCQ loc_531B0.data:00000000000BD738 10 32 05 00 00 00 00 00                 DCQ loc_53210.data:00000000000BD740 70 32 05 00 00 00 00 00                 DCQ loc_53270.data:00000000000BD748 D0 32 05 00 00 00 00 00                 DCQ loc_532D0.data:00000000000BD750 30 33 05 00 00 00 00 00                 DCQ loc_53330.data:00000000000BD758 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD760 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD768 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD770 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD778 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD780 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD788 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD790 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD798 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD7A0 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD7A8 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD7B0 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD7B8 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD7C0 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD7C8 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD7D0 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD7D8 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD7E0 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD7E8 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD7F0 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD7F8 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD800 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD808 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD810 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD818 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD820 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD828 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD830 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD838 98 33 05 00 00 00 00 00                 DCQ loc_53398\n\n继续交叉引用sub_4CC20，来到了关键的地方，基本可以确认sub_4CC20就是解释器了。\n\nhook了一些libc的open、strstr、read、strcmp之类的函数，并没有发现对frida的检测，好奇怪，那为什么会执行到sub_45EBC就崩溃呢？\n对着sub_45EBC进行分析，发现一个比较关键的地方。\n\n这个时候，可以打开我们之前trace的汇编指令，究竟是谁让w8变成了0。从0x4ad0c往上找，关于x8&#x2F;w8的赋值。\n\n很容易就找到，x11存放了一个地址，而x10的值为0，因此w8变成了0，继续追踪x10&#x2F;x11的含义。\n\n可以根据减去基址，看看x8和x0的含义，基址是0x743fc99000。\nx0对应0x2F38BFB0，x8对应0x2D40FEC78，看来调用的不是libbaiduprotect.so的函数，应该是别的库，所以减错了基址。\n我在ida中还原过这个地方，x8是malloc的运行地址，所以这里的x0是分配到的空间地址，和我想得不太一样啊？\n\n这说明，进入sub_45EBC函数后，应该是能正常出来的。\n其实仔细观察，为什么会发生崩溃呢？MOV WSP, #1虽然将栈顶寄存器指向了一个会奇怪的地方，但下一条指令很快的覆盖了SP的内容，因此应该不会造成崩溃，那问题只能处在frida-stalker了，它是不是在插桩的时候用到了SP？\n\n我们来看一下frida-stalker的原理。\n\n离我们的猜想很近，如果插桩的黄色代码中，使用到了sp寄存器，就会把程序弄崩溃，我们试试能不能在识别到MOV WSP, #1时候将它NOP掉，不执行，避免产生这样的问题。\n代码如下，下面这个代码可以绕过这一条指令，继续打印追踪的流程。\nvar offset = 0x88060;var module_size = 0;var module_name = &quot;libbaiduprotect.so&quot;;var base_addr = null; // To store the base address of libbaiduprotect.so// Create an empty functionvar empty_func = new NativeCallback(function() &#123;    // console.log(&quot;[Anti-Debug] Empty function executed.&quot;); // 可选日志    return 0;&#125;, &#x27;int&#x27;, [&#x27;pointer&#x27;]);function hook_linker_call_constructors() &#123;    // 为提高健壮性，建议使用更完善的 linker 及 call_constructors 查找逻辑    // 但为保持与你原始脚本的结构，暂时保留这种直接方式    let linker_module_name = Process.arch === &#x27;arm64&#x27; ? &#x27;linker64&#x27; : &#x27;linker&#x27;;    let linker64_base_addr = Module.getBaseAddress(linker_module_name);    if (!linker64_base_addr) &#123;        console.warn(&quot;[-] Failed to get &quot; + linker_module_name + &quot; base address. Trying to find module directly later.&quot;);        // Fallback if linker not found        setTimeout(function() &#123;            if (!base_addr) &#123; // Check if already found                let secmodule = Process.findModuleByName(module_name);                if (secmodule) &#123;                    base_addr = secmodule.base;                    module_size = secmodule.size;                    console.log(module_name + &quot; base (fallback): &quot; + base_addr + &quot;, size: &quot; + module_size);                    hook_target_func(base_addr);                &#125; else &#123;                    console.error(&quot;[-] &quot; + module_name + &quot; not found via fallback. Cannot proceed.&quot;);                &#125;            &#125;        &#125;, 1500); // Delay slightly        return;    &#125;    let offset_call = 0x51BA8; // __dl__ZN6soinfo17call_constructorsEv - 这个偏移非常依赖系统    let call_constructors = linker64_base_addr.add(offset_call);    console.log(&quot;[i] Attempting to attach to linker&#x27;s call_constructors at &quot; + call_constructors);    try &#123;        let listener = Interceptor.attach(call_constructors, &#123;            onEnter: function(args) &#123;                // console.log(&#x27;[linker] Call_Constructors onEnter&#x27;);                let secmodule = Process.findModuleByName(module_name);                if (secmodule != null) &#123;                    if (base_addr === null) &#123; // 确保只初始化一次                        module_size = secmodule.size;                        base_addr = secmodule.base; // Save the base address                        console.log(module_name + &quot; base: &quot; + base_addr + &quot;, size: &quot; + module_size);                                                // *** 在这里也可以考虑直接打补丁已知崩溃点, 但Stalker内处理更灵活些 ***                        // patchInstructionToNop(base_addr, 0x48AC0, 4);                        // patchInstructionToNop(base_addr, 0x4ABB8, 4);                        hook_target_func(base_addr);                        listener.detach();                        console.log(&quot;[i] Detached from linker hook.&quot;);                    &#125;                &#125;            &#125;        &#125;);    &#125; catch (e) &#123;        console.error(&quot;[-] Failed to attach to linker&#x27;s call_constructors: &quot; + e.message);        console.log(&quot;    Will rely on fallback to find module &quot; + module_name);         setTimeout(function() &#123; // 与上面的 fallback 逻辑类似            if (!base_addr) &#123;                let secmodule = Process.findModuleByName(module_name);                if (secmodule) &#123;                    base_addr = secmodule.base;                    module_size = secmodule.size;                    console.log(module_name + &quot; base (fallback after attach error): &quot; + base_addr + &quot;, size: &quot; + module_size);                    hook_target_func(base_addr);                &#125; else &#123;                    console.error(&quot;[-] Fallback after attach error: &quot; + module_name + &quot; not found.&quot;);                &#125;            &#125;        &#125;, 1500);    &#125;&#125;function hook_target_func(current_base_addr) &#123; // 使用 current_base_addr 区分全局 base_addr    if (!current_base_addr || current_base_addr.isNull())&#123;        console.error(&quot;[-] hook_target_func: current_base_addr is invalid.&quot;);        return;    &#125;    let target_addr = current_base_addr.add(offset); // offset = 0x88060    console.log(&quot;[+] Hooking target function at &quot; + target_addr + &quot; (offset 0x&quot; + offset.toString(16) + &quot;)&quot;);    try &#123;        let listener = Interceptor.attach(target_addr, &#123;            onEnter: function(args) &#123;                console.log(&quot;Target function &quot; + module_name + &quot;!0x&quot; + offset.toString(16) + &quot; entered. Called from: &quot; + this.returnAddress);            &#125;,            onLeave: function(retval) &#123;                console.log(module_name + &quot;!0x&quot; + offset.toString(16) + &quot; onLeave. Base address: &quot; + current_base_addr);                if (base_addr &amp;&amp; !base_addr.isNull()) &#123; // 确保全局base_addr有效                    hook_pthread_create();                    StalkerTrace(base_addr); // 传递正确的模块基址给StalkerTrace                &#125; else &#123;                    console.error(&quot;[-] Global base_addr not set in hook_target_func onLeave. Cannot start Stalker / pthread hook.&quot;);                &#125;                listener.detach();                console.log(&quot;[i] Detached from target_func hook at &quot; + target_addr);            &#125;        &#125;);    &#125; catch (e) &#123;        console.error(&quot;[-] Failed to attach to target_func at &quot; + target_addr + &quot;: &quot; + e.message);    &#125;&#125;function hook_pthread_create() &#123;    if (!base_addr || base_addr.isNull()) &#123;        console.error(&quot;[-] hook_pthread_create: Global base_addr is null.&quot;);        return;    &#125;    let pthread_create_addr = Module.findExportByName(&quot;libc.so&quot;, &quot;pthread_create&quot;);    if (pthread_create_addr) &#123;        console.log(&quot;[+] Hooking pthread_create at &quot; + pthread_create_addr);        try &#123;            Interceptor.attach(pthread_create_addr, &#123;                onEnter: function(args) &#123;                    let func_addr = args[2];                    let target_func_addr = base_addr.add(0x3E9F0);                    if (func_addr.equals(target_func_addr)) &#123;                        console.log(&quot;[Anti-Debug] Replacing thread start_routine &quot; + func_addr + &quot; with empty function.&quot;);                        args[2] = empty_func;                    &#125;                &#125;            &#125;);        &#125; catch (e) &#123;            console.error(&quot;[-] Failed to attach to pthread_create: &quot; + e.message);        &#125;    &#125; else &#123;        console.warn(&quot;[-] pthread_create not found in libc.so. Hook skipped.&quot;);    &#125;&#125;const TARGET_MODULE_NAME = &quot;libbaiduprotect.so&quot;; // 等同于 module_namefunction get_diff_regs(context, pre_regs) &#123;    var diff_regs = &#123;&#125;;    const current_regs_snapshot = JSON.parse(JSON.stringify(context));    for (const reg_name_orig in current_regs_snapshot) &#123;        if (current_regs_snapshot.hasOwnProperty(reg_name_orig)) &#123;            const reg_name = reg_name_orig.toLowerCase();            if (reg_name !== &quot;pc&quot; &amp;&amp; !reg_name.startsWith(&quot;q&quot;) &amp;&amp; reg_name !== &quot;sp&quot;) &#123; // 也可以过滤掉sp                if (pre_regs[reg_name_orig] !== current_regs_snapshot[reg_name_orig]) &#123;                    pre_regs[reg_name_orig] = current_regs_snapshot[reg_name_orig];                    diff_regs[reg_name_orig] = current_regs_snapshot[reg_name_orig];                &#125;            &#125;        &#125;    &#125;    return diff_regs;&#125;function get_involved_regs(instruction) &#123; /* ... (保持不变) ... */    const involved_regs = new Set();    instruction.operands.forEach(op =&gt; &#123;        if (op.type === &#x27;reg&#x27;) &#123; involved_regs.add(op.value); &#125;        else if (op.type === &#x27;mem&#x27;) &#123;            if (op.value.base) &#123; involved_regs.add(op.value.base); &#125;            if (op.value.index) &#123; involved_regs.add(op.value.index); &#125;        &#125;    &#125;);    return Array.from(involved_regs);&#125;// =======================================================================================// 修改 StalkerTrace 函数// =======================================================================================function StalkerTrace(current_module_baseaddr) &#123; // 确保传入的是正确的模块基地址    var stalker_target_func_offset = 0x4a458; // 这是你希望Stalker开始追踪的函数偏移    var sub_42598_addr = current_module_baseaddr.add(stalker_target_func_offset);    console.log(&quot;[+] StalkerTrace will target &quot; + TARGET_MODULE_NAME + &quot;!&quot; + ptr(stalker_target_func_offset) + &quot; at actual address: &quot; + sub_42598_addr);    var module_stalk_target = Process.findModuleByAddress(sub_42598_addr);    if (!module_stalk_target || module_stalk_target.name !== TARGET_MODULE_NAME) &#123;        console.error(&quot;[-] StalkerTrace: Module for target function (&quot; + sub_42598_addr + &quot;) is not &quot; + TARGET_MODULE_NAME +                      &quot;. Found: &quot; + (module_stalk_target ? module_stalk_target.name : &quot;none&quot;) +                      &quot;. Ensure base address and offset are correct. Stalker might not work as expected.&quot;);        // 如果模块名不匹配，我们可能不应该继续，或者用传入的 baseaddr 作为module_start/end的依据        if (!current_module_baseaddr || current_module_baseaddr.isNull()) &#123;            console.error(&quot;[-] StalkerTrace: No valid base address to proceed with module bounds.&quot;);            return;        &#125;         module_stalk_target = &#123; base: current_module_baseaddr, size: module_size, name: TARGET_MODULE_NAME &#125;; // module_size 是全局的         console.warn(&quot;[-] StalkerTrace: Using passed base_addr for module bounds for Stalker.&quot;);    &#125;        const module_start = module_stalk_target.base;    const module_end = module_stalk_target.base.add(module_stalk_target.size); // Stalker只记录此模块内的指令    console.log(&quot;[i] Stalker module bounds: Start=&quot; + module_start + &quot;, End=&quot; + module_end);    Interceptor.attach(sub_42598_addr, &#123;        onEnter: function (args) &#123;            this.tid = Process.getCurrentThreadId();            console.log(&quot;[+] Stalker: Entered &quot; + TARGET_MODULE_NAME + &quot;!&quot; + ptr(stalker_target_func_offset) + &quot; (TID: &quot; + this.tid + &quot;)&quot;);            const local_pre_regs = &#123;&#125;;            const initial_context_snapshot = JSON.parse(JSON.stringify(this.context));            for (const reg_name_orig in initial_context_snapshot) &#123;                if (initial_context_snapshot.hasOwnProperty(reg_name_orig)) &#123;                    const reg_name = reg_name_orig.toLowerCase();                    if (reg_name !== &quot;pc&quot; &amp;&amp; !reg_name.startsWith(&quot;q&quot;)) &#123;                        local_pre_regs[reg_name_orig] = initial_context_snapshot[reg_name_orig];                    &#125;                &#125;            &#125;                        // === 新增：用于直接patch的已知崩溃点 ===            // 这些地址相对于 current_module_baseaddr (即 libbaiduprotect.so 的基地址)            const knownCrashOffsets = [0x48AC0, 0x4ABB8]; // 把已知的都列出来            knownCrashOffsets.forEach(offset =&gt; &#123;                try &#123;                    const patchAddr = current_module_baseaddr.add(offset);                    // 读取指令，确认是否是 MOV WSP, #1                    const instrBytes = patchAddr.readByteArray(4);                    // MOV WSP, #1 (MOVZ W31, #1, LSL #0) -&gt; FF 03 00 32 (Little Endian: 320003FF)                    if (instrBytes &amp;&amp; instrBytes[0] === 0x32 &amp;&amp; instrBytes[1] === 0x00 &amp;&amp; instrBytes[2] === 0x03 &amp;&amp; instrBytes[3] === 0xFF) &#123;                        Memory.patchCode(patchAddr, 4, code =&gt; &#123;                            const writer = new Arm64Writer(code, &#123; pc: patchAddr &#125;);                            writer.putNop();                            writer.flush();                        &#125;);                        console.log(&quot;[MemoryPatch] Stalker&#x27;s onEnter: NOPped known crash (MOV WSP, #1) at &quot; + module_name + &quot;!&quot; + ptr(offset) + &quot; (&quot;+ patchAddr + &quot;)&quot;);                    &#125; else &#123;                        // console.log(&quot;[MemoryPatch] Stalker&#x27;s onEnter: Instruction at &quot; + module_name + &quot;!&quot; + ptr(offset) + &quot; is not MOV WSP, #1. Bytes: &quot; + Array.from(new Uint8Array(instrBytes)).map(b =&gt; b.toString(16).padStart(2,&#x27;0&#x27;)).join(&#x27;&#x27;));                    &#125;                &#125; catch (e) &#123;                    console.warn(&quot;[MemoryPatch] Stalker&#x27;s onEnter: Error patching &quot; + module_name + &quot;!&quot; + ptr(offset) + &quot;: &quot; + e.message);                &#125;            &#125;);            // =====================================            Stalker.follow(this.tid, &#123;                events: &#123; call: false, ret: false, exec: true, block: false, compile: false &#125;,                transform(iterator) &#123;                    let instruction = iterator.next();                    do &#123;                        const currentAddress = instruction.address;                        let patchedThisInstruction = false;                        // 通用的 MOV WSP/SP, #1 检测和NOP逻辑 (作为补充)                        const mnemonic = instruction.mnemonic.toLowerCase();                        if ((mnemonic === &#x27;mov&#x27; || mnemonic === &#x27;movz&#x27;) &amp;&amp; instruction.operands.length &gt;= 2) &#123;                            const destOperand = instruction.operands[0];                            const srcOperand = instruction.operands[1];                            if (destOperand.type === &#x27;reg&#x27; &amp;&amp;                                (destOperand.value === &#x27;wsp&#x27; || destOperand.value === &#x27;sp&#x27; ||                                 destOperand.value === &#x27;w31&#x27; || destOperand.value === &#x27;x31&#x27;) &amp;&amp;                                srcOperand.type === &#x27;imm&#x27; &amp;&amp;                                parseInt(srcOperand.value.toString()) === 1) &#123;                                console.warn(&quot;[StalkerTransform] Identified &#x27;&quot; + instruction.toString() + &quot;&#x27; at &quot; + currentAddress + &quot;. Replacing with NOP.&quot;);                                iterator.putNop();                                patchedThisInstruction = true;                            &#125;                        &#125;                        if (!patchedThisInstruction) &#123;                            // 仅在模块代码范围内执行putCallout，减少日志量并避免干扰其他模块                            const is_module_code = currentAddress.compare(module_start) &gt;= 0 &amp;&amp;                                                   currentAddress.compare(module_end) &lt; 0;                            if (is_module_code) &#123;                                iterator.putCallout(function (context) &#123;                                    var pc = context.pc;                                    // module_start, module_end, TARGET_MODULE_NAME, get_diff_regs, local_pre_regs                                    // 这些变量需要能被这个闭包访问到。local_pre_regs 是 onEnter 作用域的。                                    // module_start 等可以考虑从外部作用域传入或再次获取。                                    // 为简化，假设它们可访问。                                    var current_callout_module = Process.findModuleByAddress(pc);                                    if (current_callout_module &amp;&amp; current_callout_module.name === TARGET_MODULE_NAME) &#123;                                        const instrToLog = Instruction.parse(pc);                                        const diff_regs = get_diff_regs(context, local_pre_regs);                                        console.log(                                            current_callout_module.name + &quot;!&quot; + pc.sub(current_callout_module.base),                                            instrToLog.toString(),                                            &quot;\\t\\t&quot;, JSON.stringify(diff_regs)                                        );                                    &#125;                                &#125;);                            &#125;                            iterator.keep();                        &#125;                    &#125; while ((instruction = iterator.next()) !== null);                &#125;            &#125;);        &#125;,        onLeave: function (retval) &#123;            console.log(&quot;[+] &quot; + TARGET_MODULE_NAME + &quot;!&quot; + ptr(stalker_target_func_offset) + &quot; onLeave, TID:&quot;, this.tid);            Stalker.unfollow(this.tid); // 在函数退出时明确停止Stalker是个好习惯            Stalker.garbageCollect();   // 回收Stalker资源        &#125;    &#125;);&#125;setImmediate(function() &#123;    console.log(&quot;[i] Script starting for &quot; + module_name + &quot;...&quot;);    hook_linker_call_constructors();&#125;);console.log(&quot;[i] Script loaded. Waiting for &quot; + module_name + &quot;...&quot;);\n\n听说frida-sktrace实现了字符串（连续有4个可显示的字符时，打印字符串）的打印，而且更美观一些，这里试试使用frida-sktrace，但似乎不支持spawn模式附加进程，而且hook的时机还得修改，我决定在我原有的代码上添加这个功能。——我改成了，存在连续3个可视字符时，把指针内容当成字符串地址。\n下面是让大模型帮我写的代码，不过也太长了吧。\n// =======================================================================================// Modified StalkerTrace Function (FIXED local_pre_regs access)// =======================================================================================function StalkerTrace(current_module_baseaddr) &#123; // Ensure the correct module base address is passed    // Use the global module_size which should be set by now    if (!current_module_baseaddr || current_module_baseaddr.isNull() || module_size === 0) &#123;         console.error(&quot;[-] StalkerTrace: Invalid module base address or size. Cannot proceed.&quot;);         return;    &#125;    var stalker_target_func_offset = 0x4a458; // The offset of the function you want Stalker to trace    var stalker_start_addr = current_module_baseaddr.add(stalker_target_func_offset);    console.log(&quot;[+] StalkerTrace will target &quot; + TARGET_MODULE_NAME + &quot;!&quot; + ptr(stalker_target_func_offset) + &quot; at actual address: &quot; + stalker_start_addr);    // Define the module bounds for Stalker logging    const module_start = current_module_baseaddr;    const module_end = current_module_baseaddr.add(module_size);    console.log(&quot;[i] Stalker module bounds: Start=&quot; + module_start + &quot;, End=&quot; + module_end);    Interceptor.attach(stalker_start_addr, &#123;        onEnter: function (args) &#123;            // Stalker operates per thread. Get the current thread ID.            this.tid = Process.getCurrentThreadId();            console.log(&quot;[+] Stalker: Entered &quot; + TARGET_MODULE_NAME + &quot;!&quot; + ptr(stalker_target_func_offset) + &quot; (TID: &quot; + this.tid + &quot;)&quot;);            // Initialize previous register state *for this specific thread*.            // This variable is local to this onEnter call but will be captured by the closure.            const local_pre_regs = &#123;&#125;;             // Populate initial state, excluding filtered registers            const initial_context_snapshot = JSON.parse(JSON.stringify(this.context));            for (const reg_name_orig in initial_context_snapshot) &#123;                if (initial_context_snapshot.hasOwnProperty(reg_name_orig)) &#123;                    const reg_name_lower = reg_name_orig.toLowerCase();                     if (reg_name_lower !== &quot;pc&quot; &amp;&amp; reg_name_lower !== &quot;sp&quot; &amp;&amp; !reg_name_lower.startsWith(&quot;q&quot;) &amp;&amp; !reg_name_lower.startsWith(&quot;v&quot;)) &#123;                        local_pre_regs[reg_name_orig] = initial_context_snapshot[reg_name_orig];                    &#125;                &#125;            &#125;            // *** REMOVE THIS LINE *** this.local_pre_regs = local_pre_regs;             // The variable &#x27;local_pre_regs&#x27; is already in scope for the transform/callout closures.            // === Patch known crashing instructions on entering the traced function ===            // These addresses are relative to the module base address (current_module_baseaddr)            const knownCrashOffsets = [0x48AC0, 0x4ABB8]; // List of known problematic instruction offsets            knownCrashOffsets.forEach(offset =&gt; &#123;                try &#123;                    const patchAddr = current_module_baseaddr.add(offset);                    // Read instruction bytes to verify it&#x27;s the expected &#x27;MOV WSP, #1&#x27;                    // ARM64: MOV WSP, #1 is 320003FF (little endian)                    const expectedBytes = new Uint8Array([0x32, 0x00, 0x03, 0xFF]);                    const instrBytes = patchAddr.readByteArray(4);                    const actualBytes = new Uint8Array(instrBytes);                    let matchesExpected = true;                    if (actualBytes.length === 4) &#123;                         for(let i=0; i&lt;4; i++) &#123;                              if (actualBytes[i] !== expectedBytes[i]) &#123;                                   matchesExpected = false;                                   break;                              &#125;                         &#125;                    &#125; else &#123;                         matchesExpected = false;                    &#125;                    if (matchesExpected) &#123;                         // If it matches, NOP it                         Memory.patchCode(patchAddr, 4, code =&gt; &#123;                             const writer = new Arm64Writer(code, &#123; pc: patchAddr &#125;);                             writer.putNop(); // Replace the instruction with NOP                             writer.flush();                         &#125;);                         console.log(&quot;[MemoryPatch] Stalker&#x27;s onEnter: NOPped known crash (MOV WSP, #1) at &quot; + module_name + &quot;!&quot; + ptr(offset) + &quot; (&quot;+ patchAddr + &quot;)&quot;);                    &#125; else &#123;                         // console.log(&quot;[MemoryPatch] Stalker&#x27;s onEnter: Instruction at &quot; + module_name + &quot;!&quot; + ptr(offset) + &quot; is not MOV WSP, #1. Bytes: &quot; + Array.from(actualBytes).map(b =&gt; b.toString(16).padStart(2,&#x27;0&#x27;)).join(&#x27;&#x27;)); // Optional log                    &#125;                &#125; catch (e) &#123;                    console.warn(&quot;[MemoryPatch] Stalker&#x27;s onEnter: Error patching &quot; + module_name + &quot;!&quot; + ptr(offset) + &quot;: &quot; + e.message);                &#125;            &#125;);            // ==================================================================            Stalker.follow(this.tid, &#123;                 // Configure events to trace. exec=true traces every executed instruction.                events: &#123; call: false, ret: false, exec: true, block: false, compile: false &#125;,                 // The transform callback allows inspecting/rewriting instruction blocks                transform(iterator) &#123;                    let instruction = iterator.next();                    do &#123;                        const currentAddress = instruction.address;                        let patchedThisInstruction = false;                        // Check if the instruction is within the target module&#x27;s bounds                        const is_module_code = currentAddress.compare(module_start) &gt;= 0 &amp;&amp;                                               currentAddress.compare(module_end) &lt; 0;                         // === Universal MOV WSP/SP, #1 detection and NOP logic ===                         // This is a fallback/alternative to the onEnter patch                         // It happens per block compiled by Stalker                        if (is_module_code) &#123; // Only patch instructions within the target module                            const mnemonic = instruction.mnemonic.toLowerCase();                             // Check for MOV or MOVZ with SP/WSP as destination and immediate 1                             if ((mnemonic === &#x27;mov&#x27; || mnemonic === &#x27;movz&#x27;) &amp;&amp; instruction.operands.length &gt;= 2) &#123;                                 const destOperand = instruction.operands[0];                                 const srcOperand = instruction.operands[1];                                 if (destOperand.type === &#x27;reg&#x27; &amp;&amp;                                     (destOperand.value === &#x27;wsp&#x27; || destOperand.value === &#x27;sp&#x27; ||                                      destOperand.value === &#x27;w31&#x27; || destOperand.value === &#x27;x31&#x27;) &amp;&amp; // w31/x31 are aliases for wsp/sp                                     srcOperand.type === &#x27;imm&#x27; &amp;&amp;                                     parseInt(srcOperand.value.toString()) === 1) &#123;                                     console.warn(&quot;[StalkerTransform] Identified potential crash instruction &#x27;&quot; + instruction.toString() + &quot;&#x27; at &quot; + currentAddress + &quot;. Replacing with NOP.&quot;);                                     iterator.putNop(); // Replace the instruction with NOP                                     patchedThisInstruction = true;                                 &#125;                             &#125;                        &#125;                        // =========================================================                        // If the instruction wasn&#x27;t NOPped by the above check, add a callout for logging                        if (!patchedThisInstruction) &#123;                            // Only add callout for instructions within the target module                            if (is_module_code) &#123;                                // &#x27;local_pre_regs&#x27; is accessible here via closure                                iterator.putCallout(function (context) &#123;                                    // Access local_pre_regs directly from the outer scope (captured by closure)                                    const thread_pre_regs = local_pre_regs;                                     const pc = context.pc;                                    // Get the register differences after this instruction executes                                    // get_diff_regs modifies thread_pre_regs in place                                    const diff_regs = get_diff_regs(context, thread_pre_regs);                                                                        // Find the module info again (can be optimized by caching, but this is reliable)                                    var current_callout_module = Process.findModuleByAddress(pc);                                     // Ensure we are logging code from the target module                                     if (current_callout_module &amp;&amp; current_callout_module.name === TARGET_MODULE_NAME) &#123;                                         const instrToLog = Instruction.parse(pc);                                         let logLine = `$&#123;current_callout_module.name&#125;!$&#123;pc.sub(current_callout_module.base)&#125; $&#123;instrToLog.toString()&#125;`;                                         // Append changed registers and potential strings                                         const diffRegKeys = Object.keys(diff_regs);                                         if (diffRegKeys.length &gt; 0) &#123;                                              logLine += `\\t\\t| Changed Regs: `;                                              let firstReg = true;                                              for (const regName of diffRegKeys) &#123;                                                   if (!firstReg) logLine += &quot;, &quot;;                                                   firstReg = false;                                                   const regValue = diff_regs[regName]; // The new value of the register                                                   logLine += `$&#123;regName&#125;=$&#123;regValue&#125;`;                                                   // --- Check if the register value points to a string ---                                                   const potentialString = tryReadString(regValue);                                                   if (potentialString !== null) &#123;                                                       // Truncate long strings for readability                                                       const displayString = potentialString.length &gt; 60 ? potentialString.substring(0, 57) + &quot;...&quot; : potentialString;                                                       // Escape potential quotes in the string for cleaner output                                                       const escapedString = displayString.replace(/&quot;/g, &#x27;\\\\&quot;&#x27;).replace(/\\n/g, &#x27;\\\\n&#x27;).replace(/\\r/g, &#x27;\\\\r&#x27;);                                                        logLine += ` (&quot;$&#123;escapedString&#125;&quot;)`;                                                   &#125;                                                   // ----------------------------------------------------------                                              &#125;                                         &#125;                                         console.log(logLine);                                     &#125;                                &#125;);                            &#125;                            // Keep the original instruction                            iterator.keep();                        &#125;                    &#125; while ((instruction = iterator.next()) !== null); // Process next instruction in the block                &#125;            &#125;);        &#125;,        onLeave: function (retval) &#123;            console.log(&quot;[+] &quot; + TARGET_MODULE_NAME + &quot;!&quot; + ptr(stalker_target_func_offset) + &quot; onLeave, TID:&quot;, this.tid);             // Stop stalking this thread when the function exits            Stalker.unfollow(this.tid);             // Clean up Stalker&#x27;s compiled code cache            Stalker.garbageCollect();        &#125;    &#125;);&#125;// ... (rest of the script remains the same)// hook_linker_call_constructors();// hook_target_func(base_addr); // Called from linker hook or fallback// hook_pthread_create(); // Called from hook_target_func onLeave// tryReadString() // Helper function defined above// get_diff_regs() // Helper function defined above// get_involved_regs() // Helper function defined abovevar offset = 0x88060;var module_size = 0; // Will be populated when module is foundvar module_name = &quot;libbaiduprotect.so&quot;;var base_addr = null; // To store the base address of libbaiduprotect.so// Create an empty functionvar empty_func = new NativeCallback(function() &#123;    // console.log(&quot;[Anti-Debug] Empty function executed.&quot;); // Optional log    return 0;&#125;, &#x27;int&#x27;, [&#x27;pointer&#x27;]);// --- Helper function to attempt reading a string ---function tryReadString(address, minPrintableBytes = 3, maxReadLength = 256) &#123;    if (!address) &#123;        return null; // Cannot read from null address    &#125;        try &#123;        // Step 1: Read the first few bytes to see if they look like printable ASCII        const preliminaryBytes = address.readByteArray(minPrintableBytes);        if (!preliminaryBytes) &#123;             // Can&#x27;t read the initial bytes (e.g., invalid address)            return null;        &#125;                const uint8Array = new Uint8Array(preliminaryBytes);        let allPrintable = true;        for (let i = 0; i &lt; uint8Array.length; i++) &#123;            const byte = uint8Array[i];            // Basic check for printable ASCII (0x20 to 0x7E)            if (byte &lt; 0x20 || byte &gt; 0x7E) &#123;                allPrintable = false;                break;            &#125;        &#125;        if (allPrintable) &#123;            // Step 2: If they look printable, attempt to read a C-string            // readCString reads until null terminator or max length            const str = address.readCString(maxReadLength);             // Filter out empty strings or strings that only contained non-null printable chars but no null terminator early on            if (str &amp;&amp; str.length &gt; 0) &#123;                return str;            &#125;        &#125;            &#125; catch (e) &#123;        // Reading failed (e.g., invalid memory access)        // console.warn(&quot;[-] Failed to read memory at &quot; + address + &quot; for string check: &quot; + e.message); // Optional: Log errors        return null;    &#125;    return null; // Did not pass the checks or failed to read&#125;// ---------------------------------------------------function hook_linker_call_constructors() &#123;    // 为提高健壮性，建议使用更完善的 linker 及 call_constructors 查找逻辑    // 但为保持与你原始脚本的结构，暂时保留这种直接方式    let linker_module_name = Process.arch === &#x27;arm64&#x27; ? &#x27;linker64&#x27; : &#x27;linker&#x27;;    let linker64_base_addr = Module.getBaseAddress(linker_module_name);    if (!linker64_base_addr) &#123;        console.warn(&quot;[-] Failed to get &quot; + linker_module_name + &quot; base address. Trying to find module directly later.&quot;);        // Fallback if linker not found        setTimeout(function() &#123;            if (!base_addr) &#123; // Check if already found                let secmodule = Process.findModuleByName(module_name);                if (secmodule) &#123;                    base_addr = secmodule.base;                    module_size = secmodule.size;                    console.log(module_name + &quot; base (fallback): &quot; + base_addr + &quot;, size: &quot; + module_size);                    hook_target_func(base_addr);                &#125; else &#123;                    console.error(&quot;[-] &quot; + module_name + &quot; not found via fallback. Cannot proceed.&quot;);                &#125;            &#125;        &#125;, 1500); // Delay slightly        return;    &#125;    // NOTE: This offset is highly dependent on the system/Android version and linker variant!    // A more robust approach would involve scanning for the function signature.    let offset_call = 0x51BA8; // Example: __dl__ZN6soinfo17call_constructorsEv on some systems    let call_constructors = linker64_base_addr.add(offset_call);    console.log(&quot;[i] Attempting to attach to linker&#x27;s call_constructors at &quot; + call_constructors);    try &#123;        let listener = Interceptor.attach(call_constructors, &#123;            onEnter: function(args) &#123;                // console.log(&#x27;[linker] Call_Constructors onEnter&#x27;);                let secmodule = Process.findModuleByName(module_name);                if (secmodule != null) &#123;                    if (base_addr === null) &#123; // Ensure initialized only once                        module_size = secmodule.size;                        base_addr = secmodule.base; // Save the base address                        console.log(module_name + &quot; base: &quot; + base_addr + &quot;, size: &quot; + module_size);                                                // *** Consider patching known points here or within Stalker ***                        // Patching here happens earlier, might be safer for some anti-debug                        // patchInstructionToNop(base_addr, 0x48AC0, 4); // Example offset                        // patchInstructionToNop(base_addr, 0x4ABB8, 4); // Example offset                        hook_target_func(base_addr);                        listener.detach(); // Detach once the module is found                        console.log(&quot;[i] Detached from linker hook.&quot;);                    &#125;                &#125;            &#125;            // No onLeave needed for just finding the module base        &#125;);    &#125; catch (e) &#123;        console.error(&quot;[-] Failed to attach to linker&#x27;s call_constructors: &quot; + e.message);        console.log(&quot;    Will rely on fallback to find module &quot; + module_name);          setTimeout(function() &#123; // Similar fallback logic as above              if (!base_addr) &#123;                  let secmodule = Process.findModuleByName(module_name);                  if (secmodule) &#123;                      base_addr = secmodule.base;                      module_size = secmodule.size;                      console.log(module_name + &quot; base (fallback after attach error): &quot; + base_addr + &quot;, size: &quot; + module_size);                      hook_target_func(base_addr);                  &#125; else &#123;                      console.error(&quot;[-] Fallback after attach error: &quot; + module_name + &quot; not found.&quot;);                  &#125;              &#125;          &#125;, 1500);    &#125;&#125;function hook_target_func(current_base_addr) &#123; // Use current_base_addr to distinguish from global base_addr    if (!current_base_addr || current_base_addr.isNull())&#123;        console.error(&quot;[-] hook_target_func: current_base_addr is invalid.&quot;);        return;    &#125;    let target_addr = current_base_addr.add(offset); // offset = 0x88060    console.log(&quot;[+] Hooking target function at &quot; + target_addr + &quot; (offset 0x&quot; + offset.toString(16) + &quot;)&quot;);    try &#123;        // Use attachOnce if you only need it to trigger once        Interceptor.attach(target_addr, &#123;            onEnter: function(args) &#123;                console.log(&quot;Target function &quot; + module_name + &quot;!0x&quot; + offset.toString(16) + &quot; entered. Called from: &quot; + this.returnAddress);            &#125;,            onLeave: function(retval) &#123;                console.log(module_name + &quot;!0x&quot; + offset.toString(16) + &quot; onLeave. Base address: &quot; + current_base_addr);                // IMPORTANT: Use the global base_addr here as it should be set by now and is needed by StalkerTrace/pthread hook                if (base_addr &amp;&amp; !base_addr.isNull()) &#123;                     hook_pthread_create();                    StalkerTrace(base_addr); // Pass the correct module base address to StalkerTrace                &#125; else &#123;                    console.error(&quot;[-] Global base_addr not set in hook_target_func onLeave. Cannot start Stalker / pthread hook.&quot;);                &#125;                 // No need to detach here if using attachOnce, but if using attach, you might detach                 // listener.detach();                 // console.log(&quot;[i] Detached from target_func hook at &quot; + target_addr);            &#125;        &#125;);         // Note: Interceptor.attachOnce is often better if you only need the onLeave logic once         // However, let&#x27;s stick to attach and detach in onLeave for now based on your original code structure.    &#125; catch (e) &#123;        console.error(&quot;[-] Failed to attach to target_func at &quot; + target_addr + &quot;: &quot; + e.message);    &#125;&#125;function hook_pthread_create() &#123;    // Ensure base_addr is set before hooking pthread_create as it&#x27;s needed for comparison    if (!base_addr || base_addr.isNull()) &#123;        console.error(&quot;[-] hook_pthread_create: Global base_addr is null. Skipping hook.&quot;);        return;    &#125;    let pthread_create_addr = Module.findExportByName(&quot;libc.so&quot;, &quot;pthread_create&quot;);    if (pthread_create_addr) &#123;        console.log(&quot;[+] Hooking pthread_create at &quot; + pthread_create_addr);        try &#123;            Interceptor.attach(pthread_create_addr, &#123;                onEnter: function(args) &#123;                    // pthread_create signature:                    // int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);                    // start_routine is the 3rd argument (index 2)                    let func_addr = args[2];                                         // Target function address within libbaiduprotect.so                    // This offset (0x3E9F0) might also need dynamic finding                    let target_func_offset_pthread = 0x3E9F0;                     let target_func_addr = base_addr.add(target_func_offset_pthread);                    // Check if the thread being created is the one we want to intercept                    if (func_addr.equals(target_func_addr)) &#123;                        console.log(&quot;[Anti-Debug] Replacing thread start_routine &quot; + func_addr + &quot; with empty function.&quot;);                        // Replace the actual start routine pointer with our empty function&#x27;s pointer                        args[2] = empty_func;                     &#125;                &#125;            &#125;);        &#125; catch (e) &#123;            console.error(&quot;[-] Failed to attach to pthread_create: &quot; + e.message);        &#125;    &#125; else &#123;        console.warn(&quot;[-] pthread_create not found in libc.so. Hook skipped.&quot;);    &#125;&#125;const TARGET_MODULE_NAME = &quot;libbaiduprotect.so&quot;; // Same as module_name for clarity with Stalkerfunction get_diff_regs(context, pre_regs) &#123;    var diff_regs = &#123;&#125;;    // Create a snapshot of the current context&#x27;s general-purpose registers    const current_regs_snapshot = JSON.parse(JSON.stringify(context));         // Iterate through the original register names from the snapshot    for (const reg_name_orig in current_regs_snapshot) &#123;        // Ensure it&#x27;s a direct property, not inherited        if (current_regs_snapshot.hasOwnProperty(reg_name_orig)) &#123;            const reg_name_lower = reg_name_orig.toLowerCase();            // Filter out PC, SP, and floating-point/vector registers (q* or v*)            if (reg_name_lower !== &quot;pc&quot; &amp;&amp; reg_name_lower !== &quot;sp&quot; &amp;&amp; !reg_name_lower.startsWith(&quot;q&quot;) &amp;&amp; !reg_name_lower.startsWith(&quot;v&quot;)) &#123;                 // Compare with the previous snapshot                if (pre_regs[reg_name_orig] !== current_regs_snapshot[reg_name_orig]) &#123;                    // If the value has changed, update the previous snapshot and record the difference                    pre_regs[reg_name_orig] = current_regs_snapshot[reg_name_orig];                    diff_regs[reg_name_orig] = current_regs_snapshot[reg_name_orig]; // Store the NEW value                &#125;            &#125;        &#125;    &#125;    return diff_regs;&#125;// This function is defined but not currently used in the logging. Keeping it as it was in the original code.function get_involved_regs(instruction) &#123;     const involved_regs = new Set();    instruction.operands.forEach(op =&gt; &#123;        if (op.type === &#x27;reg&#x27;) &#123; involved_regs.add(op.value); &#125;        else if (op.type === &#x27;mem&#x27;) &#123;            if (op.value.base) &#123; involved_regs.add(op.value.base); &#125;            if (op.value.index) &#123; involved_regs.add(op.value.index); &#125;        &#125;    &#125;);    return Array.from(involved_regs);&#125;// =======================================================================================// Modified StalkerTrace Function (FIXED local_pre_regs access)// =======================================================================================function StalkerTrace(current_module_baseaddr) &#123; // Ensure the correct module base address is passed    // Use the global module_size which should be set by now    if (!current_module_baseaddr || current_module_baseaddr.isNull() || module_size === 0) &#123;         console.error(&quot;[-] StalkerTrace: Invalid module base address or size. Cannot proceed.&quot;);         return;    &#125;    var stalker_target_func_offset = 0x4a458; // The offset of the function you want Stalker to trace    var stalker_start_addr = current_module_baseaddr.add(stalker_target_func_offset);    console.log(&quot;[+] StalkerTrace will target &quot; + TARGET_MODULE_NAME + &quot;!&quot; + ptr(stalker_target_func_offset) + &quot; at actual address: &quot; + stalker_start_addr);    // Define the module bounds for Stalker logging    const module_start = current_module_baseaddr;    const module_end = current_module_baseaddr.add(module_size);    console.log(&quot;[i] Stalker module bounds: Start=&quot; + module_start + &quot;, End=&quot; + module_end);    Interceptor.attach(stalker_start_addr, &#123;        onEnter: function (args) &#123;            // Stalker operates per thread. Get the current thread ID.            this.tid = Process.getCurrentThreadId();            console.log(&quot;[+] Stalker: Entered &quot; + TARGET_MODULE_NAME + &quot;!&quot; + ptr(stalker_target_func_offset) + &quot; (TID: &quot; + this.tid + &quot;)&quot;);            // Initialize previous register state *for this specific thread*.            // This variable is local to this onEnter call but will be captured by the closure.            const local_pre_regs = &#123;&#125;;             // Populate initial state, excluding filtered registers            const initial_context_snapshot = JSON.parse(JSON.stringify(this.context));            for (const reg_name_orig in initial_context_snapshot) &#123;                if (initial_context_snapshot.hasOwnProperty(reg_name_orig)) &#123;                    const reg_name_lower = reg_name_orig.toLowerCase();                     if (reg_name_lower !== &quot;pc&quot; &amp;&amp; reg_name_lower !== &quot;sp&quot; &amp;&amp; !reg_name_lower.startsWith(&quot;q&quot;) &amp;&amp; !reg_name_lower.startsWith(&quot;v&quot;)) &#123;                        local_pre_regs[reg_name_orig] = initial_context_snapshot[reg_name_orig];                    &#125;                &#125;            &#125;            // *** REMOVE THIS LINE *** this.local_pre_regs = local_pre_regs;             // The variable &#x27;local_pre_regs&#x27; is already in scope for the transform/callout closures.            // === Patch known crashing instructions on entering the traced function ===            // These addresses are relative to the module base address (current_module_baseaddr)            const knownCrashOffsets = [0x48AC0, 0x4ABB8]; // List of known problematic instruction offsets            knownCrashOffsets.forEach(offset =&gt; &#123;                try &#123;                    const patchAddr = current_module_baseaddr.add(offset);                    // Read instruction bytes to verify it&#x27;s the expected &#x27;MOV WSP, #1&#x27;                    // ARM64: MOV WSP, #1 is 320003FF (little endian)                    const expectedBytes = new Uint8Array([0x32, 0x00, 0x03, 0xFF]);                    const instrBytes = patchAddr.readByteArray(4);                    const actualBytes = new Uint8Array(instrBytes);                    let matchesExpected = true;                    if (actualBytes.length === 4) &#123;                         for(let i=0; i&lt;4; i++) &#123;                              if (actualBytes[i] !== expectedBytes[i]) &#123;                                   matchesExpected = false;                                   break;                              &#125;                         &#125;                    &#125; else &#123;                         matchesExpected = false;                    &#125;                    if (matchesExpected) &#123;                         // If it matches, NOP it                         Memory.patchCode(patchAddr, 4, code =&gt; &#123;                             const writer = new Arm64Writer(code, &#123; pc: patchAddr &#125;);                             writer.putNop(); // Replace the instruction with NOP                             writer.flush();                         &#125;);                         console.log(&quot;[MemoryPatch] Stalker&#x27;s onEnter: NOPped known crash (MOV WSP, #1) at &quot; + module_name + &quot;!&quot; + ptr(offset) + &quot; (&quot;+ patchAddr + &quot;)&quot;);                    &#125; else &#123;                         // console.log(&quot;[MemoryPatch] Stalker&#x27;s onEnter: Instruction at &quot; + module_name + &quot;!&quot; + ptr(offset) + &quot; is not MOV WSP, #1. Bytes: &quot; + Array.from(actualBytes).map(b =&gt; b.toString(16).padStart(2,&#x27;0&#x27;)).join(&#x27;&#x27;)); // Optional log                    &#125;                &#125; catch (e) &#123;                    console.warn(&quot;[MemoryPatch] Stalker&#x27;s onEnter: Error patching &quot; + module_name + &quot;!&quot; + ptr(offset) + &quot;: &quot; + e.message);                &#125;            &#125;);            // ==================================================================            Stalker.follow(this.tid, &#123;                 // Configure events to trace. exec=true traces every executed instruction.                events: &#123; call: false, ret: false, exec: true, block: false, compile: false &#125;,                 // The transform callback allows inspecting/rewriting instruction blocks                transform(iterator) &#123;                    let instruction = iterator.next();                    do &#123;                        const currentAddress = instruction.address;                        let patchedThisInstruction = false;                        // Check if the instruction is within the target module&#x27;s bounds                        const is_module_code = currentAddress.compare(module_start) &gt;= 0 &amp;&amp;                                               currentAddress.compare(module_end) &lt; 0;                         // === Universal MOV WSP/SP, #1 detection and NOP logic ===                         // This is a fallback/alternative to the onEnter patch                         // It happens per block compiled by Stalker                        if (is_module_code) &#123; // Only patch instructions within the target module                            const mnemonic = instruction.mnemonic.toLowerCase();                             // Check for MOV or MOVZ with SP/WSP as destination and immediate 1                             if ((mnemonic === &#x27;mov&#x27; || mnemonic === &#x27;movz&#x27;) &amp;&amp; instruction.operands.length &gt;= 2) &#123;                                 const destOperand = instruction.operands[0];                                 const srcOperand = instruction.operands[1];                                 if (destOperand.type === &#x27;reg&#x27; &amp;&amp;                                     (destOperand.value === &#x27;wsp&#x27; || destOperand.value === &#x27;sp&#x27; ||                                      destOperand.value === &#x27;w31&#x27; || destOperand.value === &#x27;x31&#x27;) &amp;&amp; // w31/x31 are aliases for wsp/sp                                     srcOperand.type === &#x27;imm&#x27; &amp;&amp;                                     parseInt(srcOperand.value.toString()) === 1) &#123;                                     console.warn(&quot;[StalkerTransform] Identified potential crash instruction &#x27;&quot; + instruction.toString() + &quot;&#x27; at &quot; + currentAddress + &quot;. Replacing with NOP.&quot;);                                     iterator.putNop(); // Replace the instruction with NOP                                     patchedThisInstruction = true;                                 &#125;                             &#125;                        &#125;                        // =========================================================                        // If the instruction wasn&#x27;t NOPped by the above check, add a callout for logging                        if (!patchedThisInstruction) &#123;                            // Only add callout for instructions within the target module                            if (is_module_code) &#123;                                // &#x27;local_pre_regs&#x27; is accessible here via closure                                iterator.putCallout(function (context) &#123;                                    // Access local_pre_regs directly from the outer scope (captured by closure)                                    const thread_pre_regs = local_pre_regs;                                     const pc = context.pc;                                    // Get the register differences after this instruction executes                                    // get_diff_regs modifies thread_pre_regs in place                                    const diff_regs = get_diff_regs(context, thread_pre_regs);                                                                        // Find the module info again (can be optimized by caching, but this is reliable)                                    var current_callout_module = Process.findModuleByAddress(pc);                                     // Ensure we are logging code from the target module                                     if (current_callout_module &amp;&amp; current_callout_module.name === TARGET_MODULE_NAME) &#123;                                         const instrToLog = Instruction.parse(pc);                                         let logLine = `$&#123;current_callout_module.name&#125;!$&#123;pc.sub(current_callout_module.base)&#125; $&#123;instrToLog.toString()&#125;`;                                         // Append changed registers and potential strings                                         const diffRegKeys = Object.keys(diff_regs);                                         if (diffRegKeys.length &gt; 0) &#123;                                              logLine += `\\t\\t| Changed Regs: `;                                              let firstReg = true;                                              for (const regName of diffRegKeys) &#123;                                                   if (!firstReg) logLine += &quot;, &quot;;                                                   firstReg = false;                                                   const regValue = diff_regs[regName]; // The new value of the register                                                   logLine += `$&#123;regName&#125;=$&#123;regValue&#125;`;                                                   // --- Check if the register value points to a string ---                                                   const potentialString = tryReadString(regValue);                                                   if (potentialString !== null) &#123;                                                       // Truncate long strings for readability                                                       const displayString = potentialString.length &gt; 60 ? potentialString.substring(0, 57) + &quot;...&quot; : potentialString;                                                       // Escape potential quotes in the string for cleaner output                                                       const escapedString = displayString.replace(/&quot;/g, &#x27;\\\\&quot;&#x27;).replace(/\\n/g, &#x27;\\\\n&#x27;).replace(/\\r/g, &#x27;\\\\r&#x27;);                                                        logLine += ` (&quot;$&#123;escapedString&#125;&quot;)`;                                                   &#125;                                                   // ----------------------------------------------------------                                              &#125;                                         &#125;                                         console.log(logLine);                                     &#125;                                &#125;);                            &#125;                            // Keep the original instruction                            iterator.keep();                        &#125;                    &#125; while ((instruction = iterator.next()) !== null); // Process next instruction in the block                &#125;            &#125;);        &#125;,        onLeave: function (retval) &#123;            console.log(&quot;[+] &quot; + TARGET_MODULE_NAME + &quot;!&quot; + ptr(stalker_target_func_offset) + &quot; onLeave, TID:&quot;, this.tid);             // Stop stalking this thread when the function exits            Stalker.unfollow(this.tid);             // Clean up Stalker&#x27;s compiled code cache            Stalker.garbageCollect();        &#125;    &#125;);&#125;// Start the script execution by hooking the linkersetImmediate(function() &#123;    console.log(&quot;[i] Script starting for &quot; + module_name + &quot;...&quot;);    hook_linker_call_constructors();&#125;);console.log(&quot;[i] Script loaded. Waiting for &quot; + module_name + &quot; to be loaded...&quot;);\n\n接下来又遇到一个问题，在trace到sub_5AE5C内部的时候，会在随机某处地址断开trace。由于是随机断开的，没搞清楚到底是为什么？头疼。\n\n\n先通过下面这个脚本，hook上了sub_5AE5C，跑起来没问题。\nvar offset = 0x88060;var module_size = 0;var module_name = &quot;libbaiduprotect.so&quot;;var base_addr = null; // To store the base address of libbaiduprotect.so// Create an empty functionvar empty_func = new NativeCallback(function() &#123;    return 0;&#125;, &#x27;int&#x27;, [&#x27;pointer&#x27;]);function hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;);    let offset_call = 0x51BA8; // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset_call);    let listener = Interceptor.attach(call_constructors, &#123;        onEnter: function(args) &#123;            console.log(&#x27;[linker] Call_Constructors onEnter&#x27;);            let secmodule = Process.findModuleByName(module_name);            if (secmodule != null) &#123;                module_size = secmodule.size;                base_addr = secmodule.base; // Save the base address                console.log(&quot;libbaiduprotect.so base: &quot; + base_addr + &quot;, size: &quot; + module_size);                hook_target_func(base_addr);                listener.detach();            &#125;        &#125;    &#125;);&#125;function hook_target_func(baseaddr) &#123;    let target_addr = baseaddr.add(offset);    let listener = Interceptor.attach(target_addr, &#123;        onEnter: function(args) &#123;            console.log(&quot;Target function at &quot; + target_addr + &quot; entered&quot;);        &#125;,        onLeave: function(retval) &#123;            console.log(&quot;libbaiduprotect.so base address: &quot; + baseaddr);            hook_pthread_create();            hook_sub_5ae5c(baseaddr); // Hook sub_5AE5C after target function            listener.detach();        &#125;    &#125;);&#125;function hook_pthread_create() &#123;    let pthread_create_addr = Module.findExportByName(&quot;libc.so&quot;, &quot;pthread_create&quot;);    Interceptor.attach(pthread_create_addr, &#123;        onEnter: function(args) &#123;            let func_addr = args[2];            let target_func_addr = base_addr.add(0x3E9F0); // Calculate the target function address            if (func_addr.equals(target_func_addr)) &#123;                console.log(&quot;Replacing func_addr &quot; + func_addr + &quot; with empty function&quot;);                args[2] = empty_func; // Replace with the empty function                // hook_libart(); // Commented out as it was not provided            &#125; else &#123;                let module = Process.findModuleByAddress(func_addr);                if (module &amp;&amp; module.name === module_name) &#123;                    console.log(&quot;pthread_create called in libbaiduprotect.so, function address: &quot; + func_addr);                &#125;            &#125;        &#125;,        onLeave: function(retval) &#123;            // Optionally log return value        &#125;    &#125;);&#125;function hook_sub_5ae5c(baseaddr) &#123;    if (!baseaddr || baseaddr.isNull()) &#123;        console.error(&quot;[-] hook_sub_5ae5c: Invalid base address. Cannot proceed.&quot;);        return;    &#125;    let target_addr = baseaddr.add(0x5AE5C);    console.log(&quot;[+] Hooking sub_5AE5C at &quot; + target_addr);    Interceptor.attach(target_addr, &#123;        onEnter: function(args) &#123;            console.log(&quot;[sub_5AE5C] onEnter&quot;);            // Dump args[0] (pointer to _QWORD)            try &#123;                if (!args[0].isNull()) &#123;                    console.log(&quot;args[0] (*_QWORD at &quot; + args[0] + &quot;):&quot;);                    console.log(hexdump(args[0], &#123; length: 64, ansi: true &#125;));                &#125; else &#123;                    console.warn(&quot;args[0] is null&quot;);                &#125;            &#125; catch (e) &#123;                console.warn(&quot;Failed to hexdump args[0]: &quot; + e.message);            &#125;            // Dump args[2] (data + 8)            try &#123;                if (!args[2].isNull()) &#123;                    console.log(&quot;args[2] (data + 8 at &quot; + args[2] + &quot;):&quot;);                    console.log(hexdump(args[2], &#123; length: 64, ansi: true &#125;));                &#125; else &#123;                    console.warn(&quot;args[2] is null&quot;);                &#125;            &#125; catch (e) &#123;                console.warn(&quot;Failed to hexdump args[2]: &quot; + e.message);            &#125;            // Store pointers for comparison in onLeave            this.arg0 = args[0];            this.arg2 = args[2];        &#125;,        onLeave: function(retval) &#123;            console.log(&quot;[sub_5AE5C] onLeave, Return value: &quot; + retval);            // Dump args[0] again to check for changes            try &#123;                if (!this.arg0.isNull()) &#123;                    console.log(&quot;args[0] (*_QWORD at &quot; + this.arg0 + &quot;) after execution:&quot;);                    console.log(hexdump(this.arg0, &#123; length: 64, ansi: true &#125;));                &#125; else &#123;                    console.warn(&quot;args[0] is null in onLeave&quot;);                &#125;            &#125; catch (e) &#123;                console.warn(&quot;Failed to hexdump args[0] in onLeave: &quot; + e.message);            &#125;            // Dump args[2] again to check for changes            try &#123;                if (!this.arg2.isNull()) &#123;                    console.log(&quot;args[2] (data + 8 at &quot; + this.arg2 + &quot;) after execution:&quot;);                    console.log(hexdump(this.arg2, &#123; length: 64, ansi: true &#125;));                &#125; else &#123;                    console.warn(&quot;args[2] is null in onLeave&quot;);                &#125;            &#125; catch (e) &#123;                console.warn(&quot;Failed to hexdump args[2] in onLeave: &quot; + e.message);            &#125;        &#125;    &#125;);&#125;setImmediate(function() &#123;    console.log(&quot;[i] Script starting for &quot; + module_name + &quot;...&quot;);    hook_linker_call_constructors();&#125;);console.log(&quot;[i] Script loaded. Waiting for &quot; + module_name + &quot; to be loaded...&quot;);\n\n可以看到，after execution的args[2]中，存放的内容是一大片地址，将这些地址减去libbaiduprotect.so的基地址，可以发现这些地址都是vmp__funcs_256这个表上的地址。也就是说，经过函数sub_5ae5c，会从第一个参数中，获得到实现JNI函数所需要的的vmp指令集合列表。\n\n既然trace不了函数5ae5c，那就从sub_5ae5c的汇编代码分析吧。\n基本块1。\n\n基本块2。\n\n基本块3。\n\n基本块4。\n\n基本块5。\n\n基本块6。\n\n基本块7。\n\n\n基本块7的下一个块又是基本块4，也就是说，将上述流程写成伪代码的话，如下所示。\nfor(int index = 0; index &lt; 256; index++)&#123;\ta2 + (*(((byte*)a0) + 64 + index*4)) * 8 = *(a1 + index*8)&#125;\n\n和ida做一个对比，会发现ida的伪代码看不懂。\n\n通过这个伪代码，我们可以得知，a0是一个已知的数据源，它的64字节大小的offset偏移处，存放着解密后的vmp_code映射表，比方说，读取一个 a0 + 64 + index*4，命名为v1，然后将vmp_funcs_list的从0到255，把每一个元素，依次赋给 v1*8 + a2 的内存地址上，注意，这里的v1并不是逐增的。\n↑我把我的表述扔给gemini，哈哈哈，得到认可了，看来没分析错。\n\n我将函数sub_5ae5c命名为：from_DecodeVmpCode_map_to_SimulateSmaliCode。\n分析完它之后，不妨再分析sub_4A458，我想分析vmp_explain传入的参数的含义是什么。\nIDA的伪代码问题太大了，传入2个v19很明显没意义。\n\n\n基本块1。\n\n基本块2。\n\n基本块3，调用了sub_5cb98([[qword_BED18地址 + (vmp_method_code &amp; 0xFF0000)&gt;&gt;16]], vmp_method_code &amp; 0xFFFF)\n\n基本块4，sub_5cb98的操作如下。\n\n基本块5。\n\n\n基本块6。\n\n\n基本块7。\n\n\n基本块8。\n\n基本块9，sub_45EBC比较复杂，暂时先不分析，待会hook一下这个函数，可以不费吹灰之力获得——\n\n[[[qword_BED18地址 + (vmp_method_code &amp; 0xFF0000)&gt;&gt;16] + 0x38] + (vmp_method_code &amp; 0xFFFF)*8]\n\n[原SP-0x40]\n\nbundle数组的内容\n\nmalloc1的内容\n\nmalloc2的内容\n\n\n\n基本块10。\n\n\n基本块11。\n\n后面还要分析好多函数，暂时先分析到这。——2025&#x2F;05&#x2F;17。\n参考文章https://bbs.kanxue.com/thread-257926.htm#msg_header_h1_3\nhttps://bbs.kanxue.com/thread-257926.htm#msg_header_h1_2\n"},{"title":"批量上传typora图片到图床的脚本","url":"/2025/05/29/%E6%89%B9%E9%87%8F%E4%B8%8A%E4%BC%A0typora%E5%9B%BE%E7%89%87%E5%88%B0%E5%9B%BE%E5%BA%8A%E7%9A%84%E8%84%9A%E6%9C%AC/","content":"分享一个脚本，改一改配置项就可以用了~\nimport osimport reimport requestsimport shutilfrom pathlib import Pathimport time# --- 配置项 ---MARKDOWN_DIR = &quot;E:\\BLOG\\source\\_posts&quot;  # &lt;--- 修改这里为你的 Typora 笔记目录!PICGO_API_URL = &quot;http://127.0.0.1:36677/upload&quot;  # PicGo API 地址BACKUP_ORIGINAL_FILES = True  # 是否备份原始 Markdown 文件BACKUP_SUFFIX = &quot;.backup&quot;     # 备份文件的后缀# --- Regular Expressions ---# Standard Markdown images: ![alt text](local_path)# Excludes http/https and data: URIsIMAGE_REGEX = re.compile(r&quot;!\\[(.*?)\\]\\((?!https?://|data:)(.*?)\\)&quot;)# To find complete HTML &lt;img&gt; tagsHTML_TAG_REGEX = re.compile(r&quot;&lt;img[^&gt;]+&gt;&quot;, re.IGNORECASE)# To find &#x27;src&#x27; attribute with a local path within an HTML tag string.# - \\bsrc\\b: Ensures &#x27;src&#x27; is a whole word.# - \\s*=\\s*: Allows spaces around &#x27;=&#x27;.# - ([&quot;&#x27;]): Captures the quote character (Group 1).# - ((?!(?:https?://|data:))[^&quot;&#x27;&gt;]+?): Captures the path if it&#x27;s not an online URL or data URI (Group 2).#   - [^&quot;&#x27;&gt;]+?: Matches characters that are not quotes or &#x27;&gt;&#x27;, non-greedily.# - \\1: Matches the same quote character that opened the attribute value.SRC_ATTR_REGEX = re.compile(    r&quot;&quot;&quot;\\bsrc\\s*=\\s*([&quot;&#x27;])((?!(?:https?://|data:))[^&quot;&#x27;&gt;]+?)\\1&quot;&quot;&quot;,    re.IGNORECASE)def upload_image_to_picgo(image_path):    &quot;&quot;&quot;    使用 PicGo API 上传图片 (发送 JSON 格式的图片路径列表)。    Args:        image_path (str): 本地图片的绝对路径。    Returns:        str or None: 上传成功返回在线 URL，否则返回 None。    &quot;&quot;&quot;    try:        payload = &#123;&quot;list&quot;: [image_path]&#125;  # PicGo server expects a JSON list of absolute paths        headers = &#123;&quot;Content-Type&quot;: &quot;application/json&quot;&#125;        # print(f&quot;    Uploading to PicGo: &#123;image_path&#125; with payload: &#123;payload&#125;&quot;) # Verbose logging        response = requests.post(PICGO_API_URL, json=payload, headers=headers, timeout=30) # Added timeout        response.raise_for_status()  # Raises HTTPError for bad responses (4xx or 5xx)        result = response.json()        if result.get(&quot;success&quot;) and result.get(&quot;result&quot;):            if isinstance(result[&quot;result&quot;], list) and len(result[&quot;result&quot;]) &gt; 0:                uploaded_url = result[&quot;result&quot;][0]                # print(f&quot;    PicGo Upload OK: &#123;uploaded_url&#125;&quot;) # Verbose logging                return uploaded_url            else:                print(f&quot;    [错误] PicGo 返回的 result 格式不正确: &#123;result.get(&#x27;result&#x27;)&#125;&quot;)                return None        else:            error_message = result.get(&#x27;message&#x27;, &#x27;未知错误&#x27;)            print(f&quot;    [错误] PicGo 上传失败: &#123;error_message&#125;&quot;)            print(f&quot;    [错误] PicGo 完整响应: &#123;result&#125;&quot;)            return None    except requests.exceptions.HTTPError as http_err:        print(f&quot;    [错误] HTTP 错误发生: &#123;http_err&#125;&quot;)        if http_err.response is not None:            print(f&quot;    [错误] PicGo 服务器响应状态码: &#123;http_err.response.status_code&#125;&quot;)            try:                print(f&quot;    [错误] PicGo 服务器响应内容: &#123;http_err.response.text&#125;&quot;)            except Exception:                pass        return None    except requests.exceptions.RequestException as e: # Catches ConnectTimeout, ReadTimeout, etc.        print(f&quot;    [错误] 连接 PicGo API 失败或请求过程中出错: &#123;e&#125;&quot;)        return None    except Exception as e:        print(f&quot;    [错误] 上传图片 &#x27;&#123;image_path&#125;&#x27; 时发生未知错误: &#123;e&#125;&quot;)        return Nonedef original_full_tag_summary(tag_string, max_len=70):    &quot;&quot;&quot;Helper function to print a summary of a tag if it&#x27;s too long.&quot;&quot;&quot;    if len(tag_string) &gt; max_len:        return tag_string[:max_len-3] + &quot;...&quot;    return tag_stringdef process_markdown_file(md_file_path_str):    &quot;&quot;&quot;    处理单个 Markdown 文件，上传本地图片 (Markdown 和 HTML 格式) 并替换链接。    &quot;&quot;&quot;    print(f&quot;--- 正在处理文件: &#123;md_file_path_str&#125; ---&quot;)    md_file_path_obj = Path(md_file_path_str)    md_dir = md_file_path_obj.parent    try:        with open(md_file_path_obj, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f:            original_content = f.read()    except Exception as e:        print(f&quot;  [错误] 读取文件 &#x27;&#123;md_file_path_str&#125;&#x27; 失败: &#123;e&#125;&quot;)        return    content_being_processed = original_content    modified_in_this_file = False    # --- Pass 1: Process standard Markdown images ---    print(&quot;  Pass 1: Processing Markdown images `![alt](path)`...&quot;)    new_md_pass_content_parts = []    last_md_end = 0    markdown_images_found_count = 0    markdown_images_replaced_count = 0    for match in IMAGE_REGEX.finditer(content_being_processed):        markdown_images_found_count += 1        new_md_pass_content_parts.append(content_being_processed[last_md_end:match.start()])                alt_text = match.group(1)        local_image_path_str = match.group(2)        original_md_tag = match.group(0)        print(f&quot;    MD_IMG: Found: &#123;original_full_tag_summary(original_md_tag)&#125;&quot;)        local_image_path = Path(local_image_path_str)        if not local_image_path.is_absolute():            absolute_image_path = (md_dir / local_image_path).resolve()        else:            absolute_image_path = local_image_path.resolve()        if not absolute_image_path.exists():            print(f&quot;    [警告] MD_IMG: File not found, skipping: &#123;absolute_image_path&#125;&quot;)            new_md_pass_content_parts.append(original_md_tag)        else:            online_url = upload_image_to_picgo(str(absolute_image_path))            if online_url:                new_image_md_tag = f&quot;![&#123;alt_text&#125;](&#123;online_url&#125;)&quot;                new_md_pass_content_parts.append(new_image_md_tag)                modified_in_this_file = True                markdown_images_replaced_count += 1                print(f&quot;    MD_IMG: Replaced with: &#123;new_image_md_tag&#125;&quot;)            else:                print(f&quot;    MD_IMG: Upload failed for &#x27;&#123;local_image_path_str&#125;&#x27;, skipping replacement.&quot;)                new_md_pass_content_parts.append(original_md_tag)        last_md_end = match.end()        new_md_pass_content_parts.append(content_being_processed[last_md_end:])    content_after_md_pass = &quot;&quot;.join(new_md_pass_content_parts)    if markdown_images_found_count &gt; 0:        print(f&quot;  Pass 1 Summary: Found &#123;markdown_images_found_count&#125; MD images, Replaced &#123;markdown_images_replaced_count&#125;.&quot;)    else:        print(f&quot;  Pass 1 Summary: No Markdown images `![alt](path)` found.&quot;)    # --- Pass 2: Process HTML &lt;img&gt; tags ---    print(&quot;  Pass 2: Processing HTML images `&lt;img src=&#x27;path&#x27;&gt;`...&quot;)    content_for_html_pass = content_after_md_pass    new_html_pass_content_parts = []    last_html_end = 0    html_tags_processed_count = 0 # Counts &lt;img&gt; tags where local src was sought    html_src_replaced_count = 0    for tag_match in HTML_TAG_REGEX.finditer(content_for_html_pass):        new_html_pass_content_parts.append(content_for_html_pass[last_html_end:tag_match.start()])                original_full_tag = tag_match.group(0)        modified_tag_output = original_full_tag # Assume not modified unless src is replaced        src_attr_match = SRC_ATTR_REGEX.search(original_full_tag)        if src_attr_match:            html_tags_processed_count +=1            quote_char = src_attr_match.group(1)            local_image_path_str = src_attr_match.group(2)            original_src_attr_part = src_attr_match.group(0)            print(f&quot;    HTML_IMG: Found local src=&#x27;&#123;local_image_path_str&#125;&#x27; in tag: &#123;original_full_tag_summary(original_full_tag)&#125;&quot;)            local_image_path = Path(local_image_path_str)            if not local_image_path.is_absolute():                absolute_image_path = (md_dir / local_image_path).resolve()            else:                absolute_image_path = local_image_path.resolve()            if not absolute_image_path.exists():                print(f&quot;    [警告] HTML_IMG: File not found, skipping: &#123;absolute_image_path&#125;&quot;)            else:                online_url = upload_image_to_picgo(str(absolute_image_path))                if online_url:                    new_src_attr_part = f&#x27;src=&#123;quote_char&#125;&#123;online_url&#125;&#123;quote_char&#125;&#x27;                    modified_tag_output = original_full_tag.replace(original_src_attr_part, new_src_attr_part, 1)                    if original_full_tag != modified_tag_output:                        modified_in_this_file = True                        html_src_replaced_count +=1                        print(f&quot;    HTML_IMG: Replaced src. New tag: &#123;original_full_tag_summary(modified_tag_output)&#125;&quot;)                else:                    print(f&quot;    HTML_IMG: Upload failed for &#x27;&#123;local_image_path_str&#125;&#x27;, skipping replacement in tag.&quot;)                new_html_pass_content_parts.append(modified_tag_output)        last_html_end = tag_match.end()    new_html_pass_content_parts.append(content_for_html_pass[last_html_end:])    final_content = &quot;&quot;.join(new_html_pass_content_parts)    if html_tags_processed_count &gt; 0:        print(f&quot;  Pass 2 Summary: Processed &#123;html_tags_processed_count&#125; &lt;img&gt; tags for local &#x27;src&#x27;, Replaced &#123;html_src_replaced_count&#125; &#x27;src&#x27; attributes.&quot;)    else:        print(f&quot;  Pass 2 Summary: No HTML &lt;img&gt; tags with processable local &#x27;src&#x27; attributes found.&quot;)    # --- Save file if modified_in_this_file ---    if modified_in_this_file:        try:            if BACKUP_ORIGINAL_FILES:                backup_file_path = md_file_path_obj.with_suffix(md_file_path_obj.suffix + BACKUP_SUFFIX)                # Backup the file as it is on disk (original version for this run)                shutil.copy2(md_file_path_obj, backup_file_path)                print(f&quot;  已备份原始文件到: &#123;backup_file_path&#125;&quot;)            with open(md_file_path_obj, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f:                f.write(final_content)            print(f&quot;  文件已更新: &#123;md_file_path_str&#125;&quot;)        except Exception as e:            print(f&quot;  [错误] 写入文件或备份文件失败: &#123;e&#125;&quot;)            if BACKUP_ORIGINAL_FILES and &#x27;backup_file_path&#x27; in locals() and Path(backup_file_path).exists():                try:                    # Attempt to restore from backup if write failed                    shutil.copy2(backup_file_path, md_file_path_obj)                    print(f&quot;  [警告] 写入失败，已尝试从备份 &#123;backup_file_path&#125; 恢复。请检查文件。&quot;)                except Exception as restore_e:                    print(f&quot;  [严重错误] 写入失败且恢复备份也失败: &#123;restore_e&#125;。原始文件可能已损坏，请从手动备份中恢复。&quot;)    else:        print(f&quot;  文件 &#x27;&#123;md_file_path_str&#125;&#x27; 无需修改。&quot;)    print(&quot;-&quot; * 30)def main():    &quot;&quot;&quot;    主函数，遍历目录并处理 Markdown 文件。    &quot;&quot;&quot;    markdown_dir_path = Path(MARKDOWN_DIR)    if not markdown_dir_path.is_dir():        print(f&quot;[错误] 指定的目录不存在或不是一个目录: &#123;MARKDOWN_DIR&#125;&quot;)        return    print(f&quot;开始扫描目录: &#123;markdown_dir_path&#125;&quot;)    file_count = 0    for md_file in markdown_dir_path.rglob(&quot;*.md&quot;): # rglob 会递归查找所有子目录中的 .md 文件        if BACKUP_SUFFIX in md_file.name: # Skip backup files            print(f&quot;跳过备份文件: &#123;md_file&#125;&quot;)            continue        process_markdown_file(str(md_file))        file_count += 1        if file_count == 0:        print(&quot;在指定目录中未找到 .md 文件。&quot;)    else:        print(f&quot;所有 &#123;file_count&#125; 个 Markdown 文件处理完毕。&quot;)if __name__ == &quot;__main__&quot;:    print(&quot;*********************************************************************&quot;)    print(&quot;* Typora 图片上传脚本 (Markdown &amp; HTML)                              *&quot;)    print(&quot;*********************************************************************&quot;)    print(&quot;* 重要提示:                                                          *&quot;)    print(&quot;* 1. 请确保 PicGo 正在运行并已正确配置图床和Server。                *&quot;)    print(&quot;* 2. 脚本将修改 Markdown 文件中的本地图片链接。                     *&quot;)    print(f&quot;* 3. 配置的笔记目录: &#123;MARKDOWN_DIR&#125;                         *&quot;)    print(f&quot;* 4. PicGo API: &#123;PICGO_API_URL&#125;                                 *&quot;)    if BACKUP_ORIGINAL_FILES:        print(f&quot;* 5. 原始文件将备份为 *.md&#123;BACKUP_SUFFIX&#125;。                         *&quot;)    else:        print(&quot;* 5. 文件备份已禁用。                                               *&quot;)    print(&quot;* 6. 强烈建议在首次运行或对重要笔记操作前备份您的整个笔记目录。     *&quot;)    print(&quot;*********************************************************************\\n&quot;)    if MARKDOWN_DIR == &quot;/path/to/your/typora/notes&quot;:        print(&quot;[配置错误] 请务必修改脚本中的 `MARKDOWN_DIR`变量，指向你的 Typora 笔记目录！&quot;)        exit(1)    confirm = input(f&quot;确认开始处理目录 &#x27;&#123;MARKDOWN_DIR&#125;&#x27; 下的 Markdown 文件吗? (yes/no): &quot;).lower()    if confirm == &#x27;yes&#x27;:        print(&quot;脚本将在 3 秒后开始执行... 按 Ctrl+C 取消。&quot;)        try:            time.sleep(3)            main()        except KeyboardInterrupt:            print(&quot;\\n操作已由用户取消。&quot;)        except Exception as e:            print(f&quot;\\n[严重错误] 脚本执行过程中发生意外错误: &#123;e&#125;&quot;)    else:        print(&quot;操作已取消。&quot;)\n\n"},{"title":"初学angr与去混淆","url":"/2025/05/29/angr%E4%B8%8E%E5%8E%BB%E6%B7%B7%E6%B7%86/","content":"学习angr我打算根据https://github.com/jakespringer/angr_ctf里的解题代码进行学习。\n00_angr_findimport angrimport sysdef main(argv):  # Create an Angr project.  # If you want to be able to point to the binary from the command line, you can  # use argv[1] as the parameter. Then, you can run the script from the command  # line as follows:  # python ./scaffold00.py [binary]  # (!)  path_to_binary = ???  # :string  project = angr.Project(path_to_binary)  # Tell Angr where to start executing (should it start from the main()  # function or somewhere else?) For now, use the entry_state function  # to instruct Angr to start from the main() function.  initial_state = project.factory.entry_state()  # Create a simulation manager initialized with the starting state. It provides  # a number of useful tools to search and execute the binary.  simulation = project.factory.simgr(initial_state)  # Explore the binary to attempt to find the address that prints &quot;Good Job.&quot;  # You will have to find the address you want to find and insert it here.   # This function will keep executing until it either finds a solution or it   # has explored every possible path through the executable.  # (!)  print_good_address = ???  # :integer (probably in hexadecimal)  simulation.explore(find=print_good_address)  # Check that we have found a solution. The simulation.explore() method will  # set simulation.found to a list of the states that it could find that reach  # the instruction we asked it to search for. Remember, in Python, if a list  # is empty, it will be evaluated as false, otherwise true.  if simulation.found:    # The explore method stops after it finds a single state that arrives at the    # target address.    solution_state = simulation.found[0]    # Print the string that Angr wrote to stdin to follow solution_state. This     # is our solution.    print(solution_state.posix.dumps(sys.stdin.fileno()))  else:    # If Angr could not find a path that reaches print_good_address, throw an    # error. Perhaps you mistyped the print_good_address?    raise Exception(&#x27;Could not find the solution&#x27;)if __name__ == &#x27;__main__&#x27;:  main(sys.argv)\n\n解析创建Angr项目，angr会对二进制文件解析。\nproject = angr.Project(path_to_binary)\n\n创建一个初始状态，通常从程序的入口点开始，即文件的入口函数main。\ninitial_state = project.factory.entry_state()\n\n创建一个模拟管理器，通过这个模拟器可以使用很多工具，对二进制文件进行搜索和执行。\nsimulation = project.factory.simgr(initial_state)\n\n自动探索路径，直到找到一个到达find参数指定的地址的状态。\nsimulation.explore(find=print_good_address)\n\n这是一个列表，如果搜索成功，这个列表会包含所有可到达目标地址的状态。\nsimulation.found\n\n从成功状态中，提取标准输入的内容。\nsolution_state = simulation.found[0]solution_state.posix.dumps(sys.stdin.fileno()).decode()\n\n01_angr_avoidimport angrimport sysdef main(argv):  path_to_binary = argv[1]  project = angr.Project(path_to_binary)  initial_state = project.factory.entry_state(    add_options = &#123; angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,                    angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS&#125;  )  simulation = project.factory.simgr(initial_state)  print_good_address = 0x80485f7 # 目标成功地址（示例）  will_not_succeed_address = 0x80485bf # 需要避开的地址（示例）  # 探索时，寻找print_good_address，并避开will_not_succeed_address  simulation.explore(find=print_good_address, avoid=will_not_succeed_address)  if simulation.found:    solution_state = simulation.found[0]    print(solution_state.posix.dumps(sys.stdin.fileno()).decode())  else:    raise Exception(&#x27;Could not find the solution&#x27;)if __name__ == &#x27;__main__&#x27;:  main(sys.argv)\n\n解析这次程序中不仅有成功路径，还有一些我们不希望进入的“陷阱”路径（例如，一个会打印失败信息然后退出的路径）。我们需要找到成功路径，同时避开这些陷阱。\n在探索路径的时候，avoid参数可以避免某些状态的产生。比方说，不进入基本块A，则不会在基本块A处产生新状态，基本块A之后的基本块也不会继续通过基本块A产生新状态。\nsimulation.explore(find=find_address, avoid=avoid_address)\n\n02_angr_find_conditionimport angrimport sysdef main(argv):  path_to_binary = argv[1]  project = angr.Project(path_to_binary)  initial_state = project.factory.entry_state(    add_options = &#123; angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,                    angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS&#125;  )  simulation = project.factory.simgr(initial_state)  # 定义成功条件函数  def is_successful(state):    stdout_output = state.posix.dumps(sys.stdout.fileno()) # 获取标准输出    return b&#x27;Good Job.&#x27; in stdout_output # 检查是否包含 &quot;Good Job.&quot; (注意是字节串)  # 定义应中止路径的条件函数  def should_abort(state):    stdout_output = state.posix.dumps(sys.stdout.fileno())    return b&#x27;Try again.&#x27; in stdout_output # 检查是否包含 &quot;Try again.&quot;  simulation.explore(find=is_successful, avoid=should_abort)  if simulation.found:    solution_state = simulation.found[0]    print(solution_state.posix.dumps(sys.stdin.fileno()).decode())  else:    raise Exception(&#x27;Could not find the solution&#x27;)if __name__ == &#x27;__main__&#x27;:  main(sys.argv)\n\n解析有时候，可能不知道确切“成功”的指令地址，而是某种行为。比如说，某个基本块会标准输出“Good Job.”。\nexplore方法的find和avoid参数不仅可以接受地址，还可以接受一个函数。这个函数会以一个state对象为参数，返回True代表找到了或者应该避开，而返回False代表没找到成功状态或者不应该避开。\nAngr会在每一步执行后，用这些函数评判当前状态，如果状态是True，就代表成功了。\n# 定义成功条件函数  def is_successful(state):    stdout_output = state.posix.dumps(sys.stdout.fileno()) # 获取标准输出    return b&#x27;Good Job.&#x27; in stdout_output # 检查是否包含 &quot;Good Job.&quot; (注意是字节串)  # 定义应中止路径的条件函数  def should_abort(state):    stdout_output = state.posix.dumps(sys.stdout.fileno())    return b&#x27;Try again.&#x27; in stdout_output # 检查是否包含 &quot;Try again.&quot;\n\n03_angr_symbolic_registersimport claripy # 导入claripy用于创建符号变量import sysdef main(argv):  path_to_binary = argv[1]  project = angr.Project(path_to_binary)  # 设定一个开始地址，通常是scanf调用之后，这样我们可以手动控制输入  start_address = 0x80488c7 # 示例地址，你需要反汇编找到它  initial_state = project.factory.blank_state(    addr=start_address, # 从指定地址开始    add_options = &#123; angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,                    angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS&#125;  )  # 创建符号变量来代表密码的各个部分  # 假设程序从scanf读取3个32位整数，然后这些值被放到了eax, ebx, edx  password0_size_in_bits = 32  password0 = claripy.BVS(&#x27;password0&#x27;, password0_size_in_bits) # &#x27;password0&#x27;是名字，32是位数  password1_size_in_bits = 32  password1 = claripy.BVS(&#x27;password1&#x27;, password1_size_in_bits)  password2_size_in_bits = 32  password2 = claripy.BVS(&#x27;password2&#x27;, password2_size_in_bits)  # 将符号变量注入到相应的寄存器  initial_state.regs.eax = password0  initial_state.regs.ebx = password1  initial_state.regs.edx = password2 # 实际使用哪个寄存器取决于反汇编结果  simulation = project.factory.simgr(initial_state)  def is_successful(state):    stdout_output = state.posix.dumps(sys.stdout.fileno())    return b&#x27;Good Job.&#x27; in stdout_output  def should_abort(state):    stdout_output = state.posix.dumps(sys.stdout.fileno())    return b&#x27;Try again.&#x27; in stdout_output  simulation.explore(find=is_successful, avoid=should_abort)  if simulation.found:    solution_state = simulation.found[0]    # 从成功状态中求解出各个符号变量的具体值    solution0 = solution_state.solver.eval(password0)    solution1 = solution_state.solver.eval(password1)    solution2 = solution_state.solver.eval(password2)    # 将解格式化为程序期望的输入格式（这里假设是十六进制，空格分隔）    solution_string = &#x27; &#x27;.join(map(&#x27;&#123;:x&#125;&#x27;.format, [ solution0, solution1, solution2 ]))    print(solution_string)  else:    raise Exception(&#x27;Could not find the solution&#x27;)if __name__ == &#x27;__main__&#x27;:  main(sys.argv)\n\n解析虽然现在的Angr支持函数scanf了，但之前是不支持的，这道题目是想教会读者，可以在任意地址设置状态，并符号执行。\n在任意地址创建状态。\nproject.factory.blank_state(addr=start_address)\n\n创建符号向量，例如，一个代表32位数值的符号。\nclaripy.BVS(&#x27;name&#x27;, bit_length)\n\n将符号值赋给寄存器。\nstate.regs.REG_NAME = symbolic_value# 例如: initial_state.regs.eax = password0\n\n获取符号变量的一个具体满足约束的值。\nstate.solver.eval(symbolic_value)\n\n04_angr_symbolic_stackimport angrimport claripyimport sysdef main(argv):  path_to_binary = argv[1]  project = angr.Project(path_to_binary)  # 挑战描述 scanf(&quot;%u %u&quot;)  # 通常 scanf 的参数是：格式字符串地址、变量1地址、变量2地址...  # 这些地址本身可能在栈上（如果是局部变量的地址）  start_address = 0x80486ae # 跳过scanf的地址 (示例)  initial_state = project.factory.blank_state(    addr=start_address,    add_options = &#123; angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,                    angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS&#125;  )  # 模拟函数栈帧的建立  # mov %esp, %ebp (通常在函数开始)  # sub $0x18, %esp (为局部变量分配空间)  # 我们跳过了这些，所以需要手动设置  initial_state.regs.ebp = initial_state.regs.esp # 假设 ebp 指向当前 esp  password0 = claripy.BVS(&#x27;password0&#x27;, 32) # 第一个32位符号整数  password1 = claripy.BVS(&#x27;password1&#x27;, 32) # 第二个32位符号整数  # 根据反汇编，scanf的参数是 ebp-0xc 和 ebp-0x10  # scanf(format_string, ebp - 0xc, ebp - 0x10)  # 假设 ebp 和 esp 初始化后相等，我们需要在栈上为这两个变量腾出空间。  # 并且，由于我们跳过了scanf之前的参数压栈，栈的布局需要我们模拟。  # solve04.py 中:  # ebp -&gt;     |          padding          | (ebp 指向这里，也是初始 esp 指向这里)  # ...  # ebp - 0x0c |   password0 (符号值)    | &lt;- scanf 会写入这里 (即 initial_state.regs.ebp - 0xc)  # ...  # ebp - 0x10 |   password1 (符号值)    | &lt;- scanf 会写入这里 (即 initial_state.regs.ebp - 0x10)  # ...  # esp -&gt;     |                           | (esp 在分配完所有局部变量后指向这里)  # 为了让 scanf 操作的地址 (ebp-0xc, ebp-0x10) 包含我们的符号值，  # 我们需要在这些“模拟的”内存位置存储符号值。  # solve04.py 通过 stack_push 来实现，这暗示它认为这些 scanf 的目标缓冲区  # 就是在栈上连续分配的。  # 首先，为栈上的局部变量和 scanf 的参数指针（如果它们是通过压栈传递的话）分配空间。  # `solve04.py` 中 padding_length_in_bytes = 8，然后 esp -= padding_length_in_bytes  # 之后 stack_push(password0) 和 stack_push(password1)  # 这意味着它期望 password0 和 password1 直接作为值被程序使用，  # 并且它们位于 esp 指向的栈顶附近。  # 这需要非常小心地根据实际反汇编代码来确定栈布局。  # scanf(&quot;%u %u&quot;, &amp;var1, &amp;var2) -&gt; var1 和 var2 是栈上的局部变量  # 假设 var1 在 ebp-0xc, var2 在 ebp-0x10  # 我们需要确保在 initial_state 中，内存地址 (ebp-0xc) 处的值是 password0，(ebp-0x10) 处是 password1。  # 更直接的方法可能是:  # initial_state.memory.store(initial_state.regs.ebp - 0xc, password0, endness=project.arch.memory_endness)  # initial_state.memory.store(initial_state.regs.ebp - 0x10, password1, endness=project.arch.memory_endness)  #  # 但 solve04.py 的做法是：  padding_length_in_bytes = 8 # 这个值需要根据具体情况调整  initial_state.regs.esp -= padding_length_in_bytes  # 将符号变量压入栈。注意顺序！x86参数通常自右向左压栈。  # 但这里我们是模拟 scanf 已经执行完后，数据已在栈上变量中的情况。  # 所以这里的顺序是 password0 在较高的地址 (ebp-0xc)，password1 在较低地址 (ebp-0x10)。  # stack_push 会将值放到当前esp，然后esp相应调整。  # 为了匹配 ebp-0xc 和 ebp-0x10，可能需要先push password1，再push password0，  # 或者调整 padding 和 esp 的初始值。  # solve04.py 的顺序是：  initial_state.stack_push(password0)  initial_state.stack_push(password1)  # 这意味着 password1 在栈顶 (低地址)，password0 在其后 (高地址)。  # 这需要与程序如何从栈上读取这些值相对应。  simulation = project.factory.simgr(initial_state)  def is_successful(state):    stdout_output = state.posix.dumps(sys.stdout.fileno())    return b&#x27;Good Job.&#x27; in stdout_output  def should_abort(state):    stdout_output = state.posix.dumps(sys.stdout.fileno())    return b&#x27;Try again.&#x27; in stdout_output  simulation.explore(find=is_successful, avoid=should_abort)  if simulation.found:    solution_state = simulation.found[0]    solution0 = solution_state.solver.eval(password0)    solution1 = solution_state.solver.eval(password1)    # 格式化输出    solution_string = &#x27; &#x27;.join(map(str, [solution0, solution1])) # 假设是十进制整数，空格分隔    print(solution_string)  else:    raise Exception(&#x27;Could not find the solution&#x27;)if __name__ == &#x27;__main__&#x27;:  main(sys.argv)\n\n解析类似于Level3，但这次scanf读取的值可能直接存储于栈上的局部变量，而非像Level3一样，将值直接传递给3个寄存器。\n获得初始状态，angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY和SYMBOL_FILL_UNCONSTRAINED_REGISTERS用于设置未初始化的内存、寄存器为符号。\ninitial_state = project.factory.blank_state(  addr=start_address,  add_options = &#123; angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,                  angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS&#125;)\n\n模拟栈帧的建立，令ebp指向当前esp。\ninitial_state.regs.ebp = initial_state.regs.esp\n\n创建2个32位的符号整数。\npassword0 = claripy.BVS(&#x27;password0&#x27;, 32) # 第一个32位符号整数password1 = claripy.BVS(&#x27;password1&#x27;, 32) # 第二个32位符号整数\n\n根据反汇编，scanf的参数是 ebp-0xc 和 ebp-0x10，相当于：\nscanf(format_string, ebp - 0xc, ebp - 0x10)\n\nesp开辟8个字节的栈帧。\npadding_length_in_bytes = 8 # 这个值需要根据具体情况调整initial_state.regs.esp -= padding_length_in_bytes\n\n压栈。\ninitial_state.stack_push(password0)initial_state.stack_push(password1)\n\n创建模拟器。\nsimulation = project.factory.simgr(initial_state)\n\n解析成功状态时，符号的值。\nsolution0 = solution_state.solver.eval(password0)solution1 = solution_state.solver.eval(password1)\n\n为什么这里需要设置ebp &#x3D; esp，并且esp -&#x3D; 8？\n观察反汇编代码，发现之后调用参数的时候，都是基于ebp来调用的，因此这里ebp先设置为esp，然后让esp -&#x3D; 8，之后压栈操作又会令esp - 4，这个时候，ebp + var_10和ebp + var_C可以正确访问到栈上的符号变量了。\n\n\n05_angr_symbolic_memoryimport angrimport claripyimport sysdef main(argv):  path_to_binary = argv[1]  project = angr.Project(path_to_binary)  # 挑战描述 scanf(&quot;%8s %8s %8s %8s&quot;)  # 假设这些字符串被存储在已知的全局地址  start_address = 0x8048618 # scanf之后开始 (示例)  initial_state = project.factory.blank_state(    addr=start_address,    add_options = &#123; angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,                    angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS&#125;  )  # 创建符号字符串，每个8字节 (8*8=64位)  password0 = claripy.BVS(&#x27;password0&#x27;, 8*8)  password1 = claripy.BVS(&#x27;password1&#x27;, 8*8)  password2 = claripy.BVS(&#x27;password2&#x27;, 8*8)  password3 = claripy.BVS(&#x27;password3&#x27;, 8*8)  # 将符号字符串存储到它们在内存中的地址  # 这些地址需要通过反汇编确定  password0_address = 0xab232c0 # 示例地址  initial_state.memory.store(password0_address, password0) # 默认字节序，对于字符串通常OK  password1_address = 0xab232c8 # 示例地址  initial_state.memory.store(password1_address, password1)  password2_address = 0xab232d0 # 示例地址  initial_state.memory.store(password2_address, password2)  password3_address = 0xab232d8 # 示例地址  initial_state.memory.store(password3_address, password3)  simulation = project.factory.simgr(initial_state)  def is_successful(state):    stdout_output = state.posix.dumps(sys.stdout.fileno())    return b&#x27;Good Job.&#x27; in stdout_output  def should_abort(state):    stdout_output = state.posix.dumps(sys.stdout.fileno())    return b&#x27;Try again.&#x27; in stdout_output  simulation.explore(find=is_successful, avoid=should_abort)  if simulation.found:    solution_state = simulation.found[0]    # 求解符号字符串    solution0 = solution_state.solver.eval(password0, cast_to=bytes).decode()    solution1 = solution_state.solver.eval(password1, cast_to=bytes).decode()    solution2 = solution_state.solver.eval(password2, cast_to=bytes).decode()    solution3 = solution_state.solver.eval(password3, cast_to=bytes).decode()    # 组合成最终输入字符串，假设空格分隔    solution_string = &#x27; &#x27;.join([solution0, solution1, solution2, solution3])    print(solution_string)  else:    raise Exception(&#x27;Could not find the solution&#x27;)if __name__ == &#x27;__main__&#x27;:  main(sys.argv)\n\n解析scanf可以获得输入，这个输入在Level3中写入了寄存器，在Level4中写入了栈，在本次案例中，写入了全局变量。\n创建起始状态。\ninitial_state = project.factory.blank_state(  addr=start_address,  add_options = &#123; angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,                  angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS&#125;)\n\n创建符号变量。\n# 创建符号字符串，每个8字节 (8*8=64位)password0 = claripy.BVS(&#x27;password0&#x27;, 8*8)password1 = claripy.BVS(&#x27;password1&#x27;, 8*8)password2 = claripy.BVS(&#x27;password2&#x27;, 8*8)password3 = claripy.BVS(&#x27;password3&#x27;, 8*8)\n\n使用initial_state.memory.store，将符号值存储到已知的全局变量地址。（偏移地址）\n# 将符号字符串存储到它们在内存中的地址  # 这些地址需要通过反汇编确定  password0_address = 0xab232c0 # 示例地址  initial_state.memory.store(password0_address, password0) # 默认字节序，对于字符串通常OK  password1_address = 0xab232c8 # 示例地址  initial_state.memory.store(password1_address, password1)  password2_address = 0xab232d0 # 示例地址  initial_state.memory.store(password2_address, password2)  password3_address = 0xab232d8 # 示例地址  initial_state.memory.store(password3_address, password3)\n\n\n\n解析符号的值。\nsolution_state.solver.eval(symbolic_value, cast_to=bytes).decode()\n\n06_angr_symbolic_dynamic_memoryimport angrimport claripyimport sysdef main(argv):  path_to_binary = argv[1]  project = angr.Project(path_to_binary)  # 挑战描述 scanf(&quot;%8s %8s&quot;)，输入存储在动态分配的内存中  start_address = 0x80486af # scanf 之后 (示例)  initial_state = project.factory.blank_state(    addr=start_address,    add_options = &#123; angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,                    angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS&#125;  )  password0 = claripy.BVS(&#x27;password0&#x27;, 8*8) # 8字节字符串  password1 = claripy.BVS(&#x27;password1&#x27;, 8*8) # 注意solve06.py这里写的是password0，应为password1  # 伪造的堆地址，我们可以控制这块内存  fake_heap_address0 = 0x4444444   # 存储了 malloc返回地址 的那个指针变量的地址 (需反汇编确定)  pointer_to_malloc_memory_address0 = 0xa2def74 # 示例  # 修改程序中的指针，使其指向我们的伪造堆地址  # 对于32位程序，地址是4字节  initial_state.memory.store(pointer_to_malloc_memory_address0, fake_heap_address0, endness=project.arch.memory_endness, size=4)  fake_heap_address1 = 0x4444454 # 为第二个密码准备的伪造地址  pointer_to_malloc_memory_address1 = 0xa2def7c # 示例  initial_state.memory.store(pointer_to_malloc_memory_address1, fake_heap_address1, endness=project.arch.memory_endness, size=4)  # 在伪造的堆地址上存储我们的符号密码  initial_state.memory.store(fake_heap_address0, password0)  initial_state.memory.store(fake_heap_address1, password1)  simulation = project.factory.simgr(initial_state)  def is_successful(state):    stdout_output = state.posix.dumps(sys.stdout.fileno())    return b&#x27;Good Job.&#x27; in stdout_output  def should_abort(state):    stdout_output = state.posix.dumps(sys.stdout.fileno())    return b&#x27;Try again.&#x27; in stdout_output  simulation.explore(find=is_successful, avoid=should_abort)  if simulation.found:    solution_state = simulation.found[0]    solution0 = solution_state.solver.eval(password0, cast_to=bytes).decode()    solution1 = solution_state.solver.eval(password1, cast_to=bytes).decode() # 原为password0        solution_string = &#x27; &#x27;.join([solution0, solution1])    print(solution_string)  else:    raise Exception(&#x27;Could not find the solution&#x27;)if __name__ == &#x27;__main__&#x27;:  main(sys.argv)\n\n解析本次案例中，输入的值保存到了堆上。\n\n\n在scanf之后的地址创建初始状态。\nstart_address = 0x80486af # scanf 之后 (示例)  initial_state = project.factory.blank_state(    addr=start_address,    add_options = &#123; angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,                    angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS&#125;  )\n\n程序中会有一个指针变量（全局变量或是局部变量）用于存储malloc返回的地址，如上图的buffer0、buffer1。\n选择一个angr知道的、未被使用的“伪造堆地址”，使用下面这个语句修改存储malloc结果的指针，让它指向伪造的堆地址，这里的endness指字节序。\n # 伪造的堆地址，我们可以控制这块内存  fake_heap_address0 = 0x4444444   # 存储了 malloc返回地址 的那个指针变量的地址 (需反汇编确定)  pointer_to_malloc_memory_address0 = 0xa2def74 # 示例initial_state.memory.store(pointer_to_malloc_memory_address1, fake_heap_address1, endness=project.arch.memory_endness, size=4)\n\n在对地址上存储符号向量。\npassword0 = claripy.BVS(&#x27;password0&#x27;, 8*8)password1 = claripy.BVS(&#x27;password1&#x27;, 8*8)# 在伪造的堆地址上存储我们的符号密码initial_state.memory.store(fake_heap_address0, password0)initial_state.memory.store(fake_heap_address1, password1)\n\n探索路径。\ndef is_successful(state):  stdout_output = state.posix.dumps(sys.stdout.fileno())  return b&#x27;Good Job.&#x27; in stdout_outputdef should_abort(state):  stdout_output = state.posix.dumps(sys.stdout.fileno())  return b&#x27;Try again.&#x27; in stdout_outputsimulation.explore(find=is_successful, avoid=should_abort)\n\n解析符号。\nsolution0 = solution_state.solver.eval(password0, cast_to=bytes).decode()   solution1 = solution_state.solver.eval(password1, cast_to=bytes).decode() \n\n07_angr_syombolic_fileimport angrimport claripyimport sysdef main(argv):  path_to_binary = argv[1]  project = angr.Project(path_to_binary)  # fread(buffer, sizeof(char), 64, file) - 题目提示，但实际解法用了8字节  # 可能程序逻辑只需要前8字节，或者solve07.py中的大小是正确的。  start_address = 0x80488bc # 通常是fread调用之前或包含fread的函数入口 (示例)  initial_state = project.factory.blank_state( # 或 entry_state，取决于是否需要模拟fopen    addr=start_address,    add_options = &#123; angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,                    angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS&#125;  )  filename = &#x27;FOQVSBZB.txt&#x27; # 程序将要读取的文件名 (示例)  symbolic_file_size_bytes = 8 # 假设密码是8字节  # 创建代表文件内容的符号位向量  password_data = claripy.BVS(&#x27;password_file_content&#x27;, symbolic_file_size_bytes * 8)  # 创建一个模拟文件，其内容是我们的符号数据  # &#x27;r&#x27;表示只读模式，Angr的SimFile也接受模式参数，但content更直接  password_file = angr.storage.SimFile(filename, content=password_data)  # 将这个模拟文件插入到初始状态的文件系统中  # 当程序尝试打开并读取 &#x27;FOQVSBZB.txt&#x27; 时，它会读到 password_data  initial_state.fs.insert(filename, password_file)  simulation = project.factory.simgr(initial_state)  def is_successful(state):    stdout_output = state.posix.dumps(sys.stdout.fileno())    return b&#x27;Good Job.&#x27; in stdout_output  def should_abort(state):    stdout_output = state.posix.dumps(sys.stdout.fileno())    return b&#x27;Try again.&#x27; in stdout_output  simulation.explore(find=is_successful, avoid=should_abort)  if simulation.found:    solution_state = simulation.found[0]    # 求解文件内容    solution_bytes = solution_state.solver.eval(password_data, cast_to=bytes)    print(solution_bytes.decode()) # 假设是可打印字符  else:    raise Exception(&#x27;Could not find the solution&#x27;)if __name__ == &#x27;__main__&#x27;:  main(sys.argv)\n\n解析程序会从文件中读取密码，而不是标准的输入或命令行参数。\n解题思路：\n确定程序读取的文件名和预期的大小。\nfilename = &#x27;FOQVSBZB.txt&#x27; # 程序将要读取的文件名 (示例)symbolic_file_size_bytes = 8 # 假设密码是8字节\n\n创建符号位向量代表文件内容。\n# 创建代表文件内容的符号位向量password_data = claripy.BVS(&#x27;password_file_content&#x27;, symbolic_file_size_bytes * 8)\n\n使用angr.storage.SimFile(filename, content=symbolic_data)创建一个模拟文件，内容是我们的符号数据。将这个模拟文件插入到初始状态的文件系统中。\n# 创建一个模拟文件，其内容是我们的符号数据# &#x27;r&#x27;表示只读模式，Angr的SimFile也接受模式参数，但content更直接password_file = angr.storage.SimFile(filename, content=password_data)# 将这个模拟文件插入到初始状态的文件系统中# 当程序尝试打开并读取 &#x27;FOQVSBZB.txt&#x27; 时，它会读到 password_datainitial_state.fs.insert(filename, password_file)\n\n当程序执行 fopen, fread 等文件操作时，它会从我们提供的这个符号化文件中读取。\n08_angr_constrainsimport angrimport claripyimport sysdef main(argv):  path_to_binary = argv[1]  project = angr.Project(path_to_binary)  # 目标是找到complex_function的输入，使其输出等于硬编码的字符串  # 我们从main函数中scanf之后，complex_function执行之后，但在check_equals_调用之前开始  start_address = 0x804863c # scanf之后，complex_function之前的某个点 (示例)                           # 或者，让Angr执行scanf和complex_function  initial_state = project.factory.blank_state(    addr=start_address, # 实际上，应该让Angr执行scanf和complex_function                        # 所以可能还是entry_state()或者scanf后的地址，                        # 并将原始密码符号化。                        # solve08.py中直接从0x804863c开始，并符号化了password_address处的内存    add_options = &#123; angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,                    angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS&#125;  )    # 原始密码（complex_function的输入）是符号化的  # 假设原始密码存储在 password_address，长度16字节  password_size_bytes = 16  password = claripy.BVS(&#x27;password&#x27;, password_size_bytes * 8)  password_address = 0x804a040 # 假设这是存储原始密码的全局变量地址 (示例)  initial_state.memory.store(password_address, password) # 注入符号化的原始密码  simulation = project.factory.simgr(initial_state)  # 探索到调用 check_equals_ 函数之前的地址  address_to_check_constraint = 0x8048683 # call check_equals_... 指令的地址 (示例)  simulation.explore(find=address_to_check_constraint)  if simulation.found:    solution_state = simulation.found[0] # 到达了 call check_equals_ 的状态    # check_equals_ 的第一个参数 (char* to_check) 是 complex_function 的输出    # 这个参数的地址通常是已知的，或者可以通过分析调用前的汇编指令得到    # 在这个题目中，complex_function 的输出结果（即 to_check）覆盖了原始密码的内存区域    # 所以 constrained_parameter_address 就是 password_address    constrained_parameter_address = 0x804a040 # (示例) complex_function的输出存放地址    constrained_parameter_size_bytes = 16    # 从当前状态的内存中加载这个参数，它应该是符号化的    constrained_parameter_bitvector = solution_state.memory.load(      constrained_parameter_address,      constrained_parameter_size_bytes    )        # 我们知道 check_equals_ 期望的字符串 (通过反汇编或题目描述)    constrained_parameter_desired_value = &#x27;OSIWHBXIFOQVSBZB&#x27;.encode() # 目标字符串 (示例)    # 添加约束：要求 complex_function 的输出等于期望的字符串    solution_state.add_constraints(constrained_parameter_bitvector == constrained_parameter_desired_value)    # 现在，求解原始的符号密码 password    # Angr会找到一个 password，使得经过 complex_function 变换后，    # 其结果 (constrained_parameter_bitvector) 等于 constrained_parameter_desired_value    solution_bytes = solution_state.solver.eval(password, cast_to=bytes)    print(solution_bytes.decode())  else:    raise Exception(&#x27;Could not find the solution&#x27;)if __name__ == &#x27;__main__&#x27;:  main(sys.argv)\n\n解析程序中有一个非常复杂的检查函数（check_equals_...），它逐字节比较输入经过某个 complex_function 转换后的结果与一个硬编码的字符串。如果让Angr完整符号执行这个检查函数，由于大量的分支 (每个字节比较都是一个分支)，会导致状态爆炸，非常耗时。\n\n\n创建初始状态，假设这里的0x804863C是符号执行的起始地址。\nstart_address = 0x804863cinitial_state = project.factory.blank_state(    addr=start_address,    add_options=&#123;        angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,        angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS    &#125;)\n\n符号化密码，假设密码是16字节长，创建一个16字节的符号变量，password_address是原始密码的内存地址，\npassword_size_bytes = 16password = claripy.BVS(&#x27;password&#x27;, password_size_bytes * 8)password_address = 0x804a040initial_state.memory.store(password_address, password) # 将符号变量password写入内存地址0x804a040\n\n创建模拟管理器，探索目标地址。\nsimulation = project.factory.simgr(initial_state)address_to_check_constraint = 0x8048683simulation.explore(find=address_to_check_constraint)\n\n处理成功状态。\nif simulation.found:    solution_state = simulation.found[0]\n\n加载和约束输出。solution_state.add_constraints(…)添加约束。\nconstrained_parameter_address = 0x804a040constrained_parameter_size_bytes = 16constrained_parameter_bitvector = solution_state.memory.load(    constrained_parameter_address,    constrained_parameter_size_bytes)constrained_parameter_desired_value = &#x27;OSIWHBXIFOQVSBZB&#x27;.encode()solution_state.add_constraints(constrained_parameter_bitvector == constrained_parameter_desired_value)\n\n求解密码。\nsolution_bytes = solution_state.solver.eval(password, cast_to=bytes)print(solution_bytes.decode())\n\n09_angr_hooksimport angrimport claripyimport sysdef main(argv):  path_to_binary = argv[1]  project = angr.Project(path_to_binary)  initial_state = project.factory.entry_state( # 从程序入口开始，让Angr处理scanf    add_options = &#123; angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,                    angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS&#125;  )  check_equals_called_address = 0x80486ca # call check_equals_... 指令的地址 (示例)  instruction_to_skip_length = 5 # call指令的长度 (示例，通常是5字节: E8 XX XX XX XX)  # 定义钩子函数  @project.hook(check_equals_called_address, length=instruction_to_skip_length)  def skip_check_equals_(state):    # 假设 check_equals_ 的第一个参数 (char* to_check) 指向的地址是已知的    # 在此题中，它指向 complex_function 的输出，该输出存储在全局变量 0x804a044    user_input_buffer_address = 0x804a044 # (示例)    user_input_buffer_length = 16 # 字符串长度    # 加载这个参数（它应该是符号化的，因为它来自用户输入经过complex_function)    user_input_string_bv = state.memory.load(      user_input_buffer_address,      user_input_buffer_length # load的长度单位是字节    )        check_against_string_concrete = &#x27;OSIWHBXIFOQVSBZB&#x27;.encode() # 硬编码的目标字符串    # 构造符号化的返回值：如果匹配则为1，否则为0 (32位整数)    return_value = claripy.If(      user_input_string_bv == check_against_string_concrete, # 条件      claripy.BVV(1, 32), # 如果为真，eax = 1 (32位)      claripy.BVV(0, 32)  # 如果为假，eax = 0 (32位)    )    state.regs.eax = return_value # 将返回值放入eax  simulation = project.factory.simgr(initial_state)  def is_successful(state):    stdout_output = state.posix.dumps(sys.stdout.fileno())    return b&#x27;Good Job.&#x27; in stdout_output  def should_abort(state):    stdout_output = state.posix.dumps(sys.stdout.fileno())    return b&#x27;Try again.&#x27; in stdout_output  simulation.explore(find=is_successful, avoid=should_abort)  if simulation.found:    solution_state = simulation.found[0]    # 输入是由Angr的scanf SimProcedure处理的，所以直接从stdin dump    print(solution_state.posix.dumps(sys.stdin.fileno()).decode())  else:    raise Exception(&#x27;Could not find the solution&#x27;)if __name__ == &#x27;__main__&#x27;:  main(sys.argv)\n\n解析设置钩子。\n# 在地址0x80486ca设置钩子，替换check_equals_的调用# 当程序执行到此地址时，angr执行自定义函数skip_check_equals_# 而不会调用实际的check_equals_check_equals_called_address = 0x80486cainstruction_to_skip_length = 5@project.hook(check_equals_called_address, length=instruction_to_skip_length)def skip_check_equals_(state):# 用户输入的内容存在buffer中，buffer地址是0x804a044，长度是16    user_input_buffer_address = 0x804a044    user_input_buffer_length = 16# 加载16字节的符号变量    user_input_string_bv = state.memory.load(        user_input_buffer_address,        user_input_buffer_length    )    check_against_string_concrete = &#x27;OSIWHBXIFOQVSBZB&#x27;.encode()# 构造符号化的返回值# 成功则return_value = claripy.BVV(1,32)# 失败则return_value = claripy.BVV(0,32)    return_value = claripy.If(        user_input_string_bv == check_against_string_concrete,        claripy.BVV(1, 32),        claripy.BVV(0, 32)    )    state.regs.eax = return_value\n\n加载二进制文件：创建 angr 项目，解析程序。\n设置初始状态：从程序入口（main）开始，允许 angr 模拟 scanf 和 complex_function。\n钩子处理：\n\n在 check_equals_ 调用处（0x80486ca）设置钩子，跳过其执行。\n模拟 check_equals_ 的行为，比较 0x804a044 处的符号输出与目标字符串，设置 eax 为 1（匹配）或 0（不匹配）。\n\n符号执行：\n\n探索所有路径，寻找输出 “Good Job.” 的状态，避免输出 “Try again.” 的状态。\n\n提取输入：从成功状态的 stdin 中提取输入密码，打印结果。\n利用angr解混淆已经有大佬写过了，利用angr符号执行去除虚假控制流，思路很简单，不是活跃状态的基本块全部NOP掉。\n思路：https://bbs.kanxue.com/thread-266005.htm\n项目代码：https://github.com/bluesadi/debogus\n局限也是有的：\n\n依赖于z3约束求解，如果解不出来，则判定为非活跃状态的基本块；\n未约束导致路径爆炸。\n\n我的理解什么是状态、成功状态？在一开始，符号执行还没开始的时候，需要一个初始状态（寄存器、堆栈、内存等，它们可以被定义成符号），初始状态没有对符号的约束；\n而成功状态就是走到了目标地址或者目标行为的状态，此时的寄存器、堆栈、内存等共同构成了成功状态；\n在初始状态到成功状态的过程中，angr会为被定义为符号的变量收集约束，正是有了这些约束，程序才可以从初始状态走到成功状态；\n在成功状态时，可以调用angr相关的函数，根据约束计算出符号变量的值。\n状态的更新与分裂？每个基本块都有一个状态，每执行一条指令，状态都会对自身进行更新；而当来到条件分支的时候，会基于当前的状态，创建分裂出独立的、并行的多个状态，此时称作产生了新的状态。\nangr符号执行与基本块的关系？基本块的特点是：\n\n只有一个入口点（第一条指令）；\n只有一个出口点（最后一条指令，通常是跳转、返回、条件分支）。\n\nangr是一种符号执行框架，它通过将程序的输入（例如标准输入或参数）表示为符号变量（claripy.BVS），模拟程序的所有可能执行路径。angr 跟踪符号变量如何影响程序的状态（寄存器、内存等），并使用约束求解器（通常是 Z3）来确定哪些输入能够引导程序到达特定目标（如某个地址）。\n在 angr 的符号执行过程中，基本块是程序执行的“原子单位”，而符号执行是基于这些基本块进行路径探索的。\n\n基本块是执行的单位\n\nangr 在符号执行时，会将程序分解为基本块（通过静态分析生成 CFG 或动态执行时解析）。每个基本块代表一段连续的指令，angr 会逐块模拟执行。\n在执行一个基本块时，angr 更新当前状态的寄存器、内存等内容，并根据基本块的出口指令（例如跳转、条件分支、返回）决定下一步的执行路径。\n\n\n状态分叉与基本块的出口\n\n当基本块的最后一条指令是条件分支（例如 if 语句对应的 je、jne 等跳转指令），angr 会根据条件生成多个新的状态（state），分别对应分支的真假路径。\n\n例如，假设一个基本块以 \nif (input[0] &#x3D;&#x3D; ‘A’)\n 结束，angr 会：\n\n创建一个状态，约束 input[0] &#x3D;&#x3D; ‘A’，继续执行真分支。\n创建另一个状态，约束 input[0] !&#x3D; ‘A’，继续执行假分支。\n\n\n这些分叉点通常发生在基本块的出口，因此基本块的边界决定了状态分叉的时机。\n\n\n\n符号执行跟踪基本块的路径\n\nangr 的符号执行本质上是沿着 CFG 的路径探索，每个路径由一系列基本块组成。angr 维护一个状态池（通过 SimulationManager，即 simgr），跟踪每个状态对应的执行路径。\n每个状态在执行一个基本块后，会更新其上下文（例如寄存器、内存），并根据基本块的出口指令跳转到下一个基本块。\n\n\n约束累积与基本块\n\n在执行基本块的过程中，angr 会根据指令的逻辑为符号变量添加约束。例如，如果一个基本块包含比较指令 cmp input[0], ‘A’，angr 会在分支时为符号变量 input[0] 添加约束（如 input[0] &#x3D;&#x3D; ‘A’ 或 input[0] !&#x3D; ‘A’）。\n这些约束是符号执行的核心，用于在成功状态中求解具体输入。\n\n\n成功状态与基本块\n\n当 angr 的符号执行到达目标地址（例如 find&#x3D;print_good_address），对应的状态通常位于某个基本块的入口或内部。成功状态包含了从初始状态到目标地址的完整执行路径（即一系列基本块），以及符号输入的约束集合。\n通过 solution_state.posix.dumps(sys.stdin.fileno())，angr 求解这些约束，得到引导程序到达目标基本块的输入值。\n\n\n\n同时，angr 不会为每条指令生成新状态（而是基于原状态进行更新），而在基本块的边界（特别是条件分支）生成新状态。状态分叉发生在基本块的出口，基于分支条件。\n","tags":["angr"]}]