[{"title":"baidu免费壳分析","url":"/2025/05/17/baidu%E5%85%8D%E8%B4%B9%E5%A3%B3%E5%88%86%E6%9E%90/","content":"libbaiduprotect.so加载分析通过Manifest可以看到包名和第一个加载的app类。——“com.example.test”和“com.baidu.protect.StubApplication”。\n\n在原来的lib下，多出了一个libbaiduprotect.so，而在assets下面也多了几个文件。\n\n猜测是libbaiduprotect.so将assets下的文件解密出了dex，然后进行加载。\n下面开始分析。\n根据app类的名称，找到app类，一般整体壳，app类会对attachBaseContext和onCreate进行覆写。\n先看attachBaseContext。\n\n\n其中，StubApplication.loadLibrary实际上是加载了libbaiduprotect.so，因此，接下来用ida查看libbaiduprotect.so。\n\n搜索函数“init_proc”并没有搜到，接下来查看.init_array节，存在以下在加载so阶段会执行的函数。\n\n\n先来看sub_88060，一眼混淆，本来靠着NOP，去掉了几个虚假控制流和不透明谓词，但还是太多了，直接使用d810进行处理。\n\n处理完后，算上default的话，有32个case选项，看样子是在做解密操作。\n\n再来看JNI_OnLoad，会发现被加密了，可以猜到是sub_88060对它进行了加密。\n\n下面是一个frida脚本，用于在sub_88060解完密后，第一时间dump整个so。\n// 要hook的函数offsetvar offset = 0x88060;// so文件的大小var module_size = 0;// 要hook的so的名字var module_name = &quot;libbaiduprotect.so&quot;;function hook_linker_call_constructors() &#123;    // 获得linker64的地址    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;)    let offset_call = 0x51BA8    // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset_call)    let listener = Interceptor.attach(call_constructors,&#123;        onEnter:function(args)&#123;            // 判断是否可以通过findModuleByName查找到目标so文件            console.log(&#x27;[linker] Call_Constructors onEnter&#x27;)            let secmodule = Process.findModuleByName(module_name);            if (secmodule != null)&#123;                module_size = secmodule.size;                // 第一时间hook                hook_target_func(secmodule.base);                listener.detach();            &#125;        &#125;    &#125;)&#125;function hook_target_func(baseaddr)&#123;    let listener = Interceptor.attach(baseaddr.add(offset), &#123;        onEnter:function(args)&#123;        &#125;,        onLeave:function(retval)&#123;            // 在执行完某个函数后，立马进行dump            dump(baseaddr, module_size);            listener.detach();        &#125;    &#125;);&#125;function dump(begin_addr, dump_size)&#123;    console.log(&quot;[name] &quot;, module_name);    console.log(&quot;[base] &quot;, begin_addr);    console.log(&quot;[size] &quot;, &quot;0x&quot; + dump_size.toString(16));    var file_path = &quot;/data/data/com.example.test/zzc_&quot; + begin_addr + &quot;_0x&quot; + dump_size.toString(16) + &quot;.so&quot;;    var file_handle = new File(file_path, &quot;wb&quot;);    if (file_handle &amp;&amp; file_handle != null) &#123;        Memory.protect(ptr(begin_addr), dump_size, &#x27;rwx&#x27;);        var libso_buffer = ptr(begin_addr).readByteArray(dump_size);        file_handle.write(libso_buffer);        file_handle.flush();        file_handle.close();        console.log(&quot;[dump] &quot;, file_path);    &#125;&#125;setImmediate(hook_linker_call_constructors)\n\n将dump下来的so文件，通过soFixer进行修复。\nSoFixer-Windows-64.exe -s .\\zzc_0x6f7471a000_0xc1000.so -o .\\zzc_0x6f7471a000_0xc1000.sofixer.so -m 0x6f7471a000 -d\n\n可以看到，JNI_OnLoad已经恢复正常了。\n\n接下来看其它的在.init_array上的函数（在加密so的中查看）。\n查看sub_6FC4。\n\n可以看出来，qword_28c28s是一个函数指针，它在解密后面那一串内容。\n\n点开地址28c28的位置，发现存在加密的内容。\n\n\n这说明这个函数也需要得到解密，那就只能是在sub_88060里了，去另一个解密的so文件看一眼，发现果然解密了。\n\n\n通过hook解密后的sub_28c28，可以得到解密字符串，脚本如下。\n// 要hook的函数offsetvar offset = 0x88060;// so文件的大小var module_size = 0;// 要hook的so的名字var module_name = &quot;libbaiduprotect.so&quot;;function hook_linker_call_constructors() &#123;    // 获得linker64的地址    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;)    let offset_call = 0x51BA8    // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset_call)    let listener = Interceptor.attach(call_constructors,&#123;        onEnter:function(args)&#123;            // 判断是否可以通过findModuleByName查找到目标so文件            console.log(&#x27;[linker] Call_Constructors onEnter&#x27;)            let secmodule = Process.findModuleByName(module_name);            if (secmodule != null)&#123;                module_size = secmodule.size;                // 第一时间hook                hook_target_func(secmodule.base);                listener.detach();            &#125;        &#125;    &#125;)&#125;function hook_target_func(baseaddr)&#123;    let listener = Interceptor.attach(baseaddr.add(offset), &#123;        onEnter:function(args)&#123;        &#125;,        onLeave:function(retval)&#123;            // 第一个函数解密完后，才能hook sub_28c28            decrypt_28c28(baseaddr);            listener.detach();        &#125;    &#125;);&#125;function decrypt_28c28(baseaddr)&#123;        Interceptor.attach(baseaddr.add(0x28c28), &#123;            onEnter:function(args)&#123;                console.log(&quot;[sub_28c28] &quot;, &quot;arg = &quot;, ptr(args[0]).readCString());            &#125;, onLeave:function(retval)&#123;                console.log(&quot;[sub_28c28] &quot;, &quot;retval = &quot;, ptr(retval).readCString());            &#125;        &#125;)&#125;setImmediate(hook_linker_call_constructors)\n\n执行的结果如下。\n\n\n写了一个ida脚本，给这些字符串的地方添加注释。\nimport idaapiimport idautils# 加密/明文映射mappings = &#123;    &quot;710E34DFB3D273975E0936FBB4CF62BE541F3CC4A8&quot;: &quot;FeatureLibcProtection&quot;,    &quot;530A39DDAFCB39A84E1821CEAB8F52BE4F3B34DFAEEC7FA843&quot;: &quot;dalvik/system/DexPathList&quot;&#125;# 函数列表（地址或函数名）func_list = [    0x28c28]def find_string_addr(search_str):    &quot;&quot;&quot;查找字符串的地址&quot;&quot;&quot;    for addr in idautils.Strings():        if str(addr) == search_str:            return addr.ea    return Nonedef resolve_func_addr(func_entry):    &quot;&quot;&quot;将函数名或地址转换为地址&quot;&quot;&quot;    if isinstance(func_entry, int):        return func_entry    elif isinstance(func_entry, str):        func_addr = idaapi.get_name_ea_simple(func_entry)        if func_addr == idaapi.BADADDR:            print(f&quot;Function not found: &#123;func_entry&#125;&quot;)            return None        return func_addr    else:        print(f&quot;Invalid function entry: &#123;func_entry&#125;&quot;)        return Nonedef add_comments_to_strings():    &quot;&quot;&quot;为 .rodata 中的字符串添加解密注释和重命名&quot;&quot;&quot;    for encrypted, decrypted in mappings.items():        str_addr = find_string_addr(encrypted)        if str_addr:            idaapi.set_cmt(str_addr, f&quot;Decrypted: &#123;decrypted&#125;&quot;, 0)            # 重命名字符串，替换特殊字符以符合命名规则            safe_name = f&quot;str_&#123;decrypted.replace(&#x27;/&#x27;, &#x27;_&#x27;).replace(&#x27; &#x27;, &#x27;_&#x27;)&#125;&quot;            idaapi.set_name(str_addr, safe_name, idaapi.SN_FORCE)            print(f&quot;Added comment at 0x&#123;str_addr:x&#125;: &#123;encrypted&#125; -&gt; &#123;decrypted&#125;&quot;)        else:            print(f&quot;String not found in .rodata: &#123;encrypted&#125;&quot;)def add_comments_to_function(func_addr):    &quot;&quot;&quot;为指定函数添加注释，扫描加载字符串的指令&quot;&quot;&quot;    func = idaapi.get_func(func_addr)    if not func:        print(f&quot;Function at 0x&#123;func_addr:x&#125; not found or invalid&quot;)        return    # 添加函数注释    func_name = idaapi.get_func_name(func_addr)    idaapi.set_func_cmt(func_addr, f&quot;Decrypts strings (e.g., &#123;&#x27;, &#x27;.join(f&#x27;&#123;k&#125;-&gt;&#123;v&#125;&#x27; for k, v in mappings.items())&#125;)&quot;, 1)    print(f&quot;Processing function: &#123;func_name&#125; at 0x&#123;func_addr:x&#125;&quot;)    # 扫描函数指令，查找加载字符串的指令    for ea in idautils.FuncItems(func.start_ea):        disasm = idaapi.generate_disasm_line(ea, 0)        if &quot;LDR&quot; in disasm:  # 检查加载指令            for enc, dec in mappings.items():                if enc in disasm:                    idaapi.set_cmt(ea, f&quot;Loads &#123;enc&#125; -&gt; &#123;dec&#125;&quot;, 0)                    print(f&quot;Added comment at 0x&#123;ea:x&#125;: &#123;enc&#125; -&gt; &#123;dec&#125;&quot;)def main():    &quot;&quot;&quot;主函数：处理字符串和函数列表&quot;&quot;&quot;    # 处理 .rodata 中的字符串    print(&quot;Processing strings in .rodata...&quot;)    add_comments_to_strings()    # 处理函数列表    print(&quot;\\nProcessing functions...&quot;)    for func_entry in func_list:        func_addr = resolve_func_addr(func_entry)        if func_addr is not None:            add_comments_to_function(func_addr)        else:            print(f&quot;Skipping invalid function: &#123;func_entry&#125;&quot;)# 执行脚本if __name__ == &quot;__main__&quot;:    main()\n\nida脚本的执行情况如下，自动添加注释并对字符串重命名。\n\n回到sub_6FC4的位置，710….代表FeatureLibcProtection。\n\n函数sub_3E590也被加密了，通过解密的so文件查看，它似乎是在赋值？a1是一个全局变量，a2是解密后的字符串，a3是1，似乎是一个索引。\n\n\nBB9B0是一个函数指针，存放着的内容是sub_811B8的地址（也就是811B8）。\n\n这里创建一个结构体，由于函数指针和字符串指针都是指针，这里定义为__int64*。\n\n结构就比较容易懂了。\n\n因此，sub_6FC4可以理解为在做函数注册。\n\n会根据index，在对应的槽位注册。\n\n\n根据分析，注册了8个函数。\n\n\n整理一下，注册关系大致如下。\nsub_B3B4 -&gt; 索引1 -&gt; global_func_list[1]。\nsub_3E29C -&gt; 索引3 -&gt; global_func_list[3]。\nsub_40CF8 -&gt; 索引6 -&gt; global_func_list[6]。\nsub_3DFC4 -&gt; 索引7 -&gt; global_func_list[7]。\nsub_11F5C -&gt; 索引8 -&gt; global_func_list[8]。\nsub_45964 -&gt; 索引9 -&gt; global_func_list[9]。\nsub_3E96C -&gt; 索引10 -&gt; global_func_list[10]。\nsub_42388 -&gt; 索引13 -&gt; global_func_list[13]。\n之后开始分析JNI_onLoad，由于加密的so中，JNI_onLoad没有解密，所以这里根据解密的so的JNI_onLoad进行分析。\n\n\n上来就看到一大堆混淆，用d810处理一下。\n可能是由于从内存中dump出来的缘故，反汇编伪代码的效果不是很好，连vm都看不到在哪里使用了。\n\n\n先看sub_91D8，十分眼熟，+48，基本可以确认a1是JNIEnv*的类型了。\n\n\n\n\n之后再看sub_7BC4，槽位0是经过初始化的，但没存前面的函数（应该被sub_82254初始化了），如果0号元素的内容为空，则调用sub_3E5A8进行清空。\n\n\n\n\n所以，可以把函数sub_7BC4理解为，判断函数是否注册完毕。\n接着看函数sub_3E628，没搞明白v11、v12在做什么，但能看得出来，是在调用函数列表里的函数，第一个参数是自己的地址，第二个参数是1（JNI_OnLoad传入的a2）。\n\n先来观察函数列表的index为1的函数sub_B3B4。\n\n\n如果a2不为1，直接返回，说明sub_B3B4只接受a2&#x3D;&#x3D;1的情况。\n\nsub_B3B4对很多字符串进行了解密，同时连接了很多字符串。\n\n\n配合着脚本，实现了对这些字符串的解密。\n// 要hook的函数offsetvar offset = 0x88060;// so文件的大小var module_size = 0;// 要hook的so的名字var module_name = &quot;libbaiduprotect.so&quot;;// 解密函数的偏移列表（从 sub_28AD0 到 sub_28A24）var decrypt_offsets = [    0x28AD0, 0x25E78, 0x25F24, 0x25FD0, 0x2607C, 0x26128, 0x261D4, 0x26280,    0x2632C, 0x263D8, 0x26484, 0x26530, 0x265DC, 0x26688, 0x26734, 0x267E0,    0x2688C, 0x26938, 0x269E4, 0x26A90, 0x26B3C, 0x26BE8, 0x26C94, 0x26D40,    0x26DEC, 0x26E98, 0x26F44, 0x26FF0, 0x2709C, 0x27148, 0x271F4, 0x272A0,    0x2734C, 0x273F8, 0x274A4, 0x27550, 0x275FC, 0x276A8, 0x27754, 0x27800,    0x278AC, 0x27958, 0x27A04, 0x27AB0, 0x27B5C, 0x27C08, 0x27CB4, 0x27D60,    0x27E0C, 0x27EB8, 0x27F64, 0x28010, 0x280BC, 0x28168, 0x28214, 0x282C0,    0x2836C, 0x28418, 0x284C4, 0x28570, 0x2861C, 0x286C8, 0x28774, 0x28820,    0x288CC, 0x28A24];function hook_linker_call_constructors() &#123;    // 获得linker64的地址    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;);    let offset_call = 0x51BA8;    // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset_call);    let listener = Interceptor.attach(call_constructors, &#123;        onEnter: function(args) &#123;            // 判断是否可以通过findModuleByName查找到目标so文件            console.log(&#x27;[linker] Call_Constructors onEnter&#x27;);            let secmodule = Process.findModuleByName(module_name);            if (secmodule != null) &#123;                module_size = secmodule.size;                // 第一时间hook                hook_target_func(secmodule.base);                listener.detach();            &#125;        &#125;    &#125;);&#125;function hook_target_func(baseaddr) &#123;    let listener = Interceptor.attach(baseaddr.add(offset), &#123;        onEnter: function(args) &#123;            console.log(&quot;[target_func] onEnter, offset:&quot;, offset.toString(16));        &#125;,        onLeave: function(retval) &#123;            console.log(&quot;[target_func] onLeave, retval:&quot;, retval);            // 第一个函数解密完后，Hook 所有解密函数            hook_decrypt_funcs(baseaddr);            listener.detach();        &#125;    &#125;);&#125;function hook_decrypt_funcs(baseaddr) &#123;    // Hook sub_28C28（保持原有逻辑）    Interceptor.attach(baseaddr.add(0x28C28), &#123;        onEnter: function(args) &#123;            console.log(&quot;[sub_28C28] arg =&quot;, ptr(args[0]).readCString());        &#125;,        onLeave: function(retval) &#123;            console.log(&quot;[sub_28C28] retval =&quot;, ptr(retval).readCString());        &#125;    &#125;);    // 循环 Hook 所有解密函数    decrypt_offsets.forEach(function(offset) &#123;        let func_name = &quot;sub_&quot; + offset.toString(16).toUpperCase();        Interceptor.attach(baseaddr.add(offset), &#123;            onEnter: function(args) &#123;                console.log(&quot;[&quot; + func_name + &quot;] arg =&quot;, ptr(args[0]).readCString());            &#125;,            onLeave: function(retval) &#123;                console.log(&quot;[&quot; + func_name + &quot;] retval =&quot;, ptr(retval).readCString());            &#125;        &#125;);    &#125;);&#125;setImmediate(hook_linker_call_constructors);\n\n用ida进行修改并添加注释。\nimport idaapiimport idautils# 加密/明文映射（从 Frida 输出中提取）mappings = &#123;    &quot;710E34DFB3D273975E0936FBB4CF62BE541F3CC4A8&quot;: &quot;FeatureLibcProtection&quot;,    &quot;530A39DDAFCB39A84E1821CEAB8F52BE4F3B34DFAEEC7FA843&quot;: &quot;dalvik/system/DexPathList&quot;,    &quot;3D7CDAABED5340D60976CFBAFB5560E80D70C9B0F64C40E80F&quot;: &quot;FeatureProtectEnvironment&quot;,    &quot;5227DBB22926DA554467C6EF2433D6524567F7&quot;: &quot;com/baidu/protect/A&quot;,    &quot;14D64606364E3C6D&quot;: &quot;unknown&quot;,    &quot;5A483597E76FC0D170423682FE54CBF073&quot;: &quot;FeatureGlobalInfo&quot;,    &quot;47986CBE0A46F6EE6F8968AD0D5DE7DE429568A914&quot;: &quot;FeatureIntegrityCheck&quot;,    &quot;5227DBB22926DA554467C6EF2433D6524567F5EF2A34DB795026D2F12E35&quot;: &quot;com/baidu/protect/CrashHandler&quot;,    &quot;02D740473B583B0914975D1A364D370E15976F&quot;: &quot;com/baidu/protect/B&quot;,    &quot;0406D0C873B03D581246CD957EA5315F1346FC9761983A5A08&quot;: &quot;com/baidu/protect/AppInfo&quot;,    &quot;C7D432A325E854F696D43CFF27BF03F7&quot;: &quot;c07954f5209e7c14&quot;,    &quot;67C538FE4857A6C4309F39AB4B06A5C5&quot;: &quot;f8547c5c1b4a426b&quot;,    &quot;260714BFA582481D715D15EAA6D34B1C785B43B8F385444A705E15EAF3D54C4B&quot;: &quot;f8547c5c1b4a426b8db3ad940a4aa415&quot;,    &quot;57585C810030ABC6530C06D65363FF9C545A5CD60367A9CD545400D45430A8C9&quot;: &quot;359b71797ac5dbcc07954f5209e7c146&quot;,    &quot;7E6EA364435927F7&quot;: &quot;.suuid&quot;,    &quot;3148B69D4B47B331&quot;: &quot;&quot;,    &quot;61B82D685939526D&quot;: &quot;&quot;,    &quot;065A40FFE793182D255C54F9FB95042D0474&quot;: &quot;FeatureSecuritySDK&quot;,    &quot;1901FAF72A31D21E5D29D8FA6408D15B542BC2A6100BD950472999F12A29D41E7E2ADCF82833881867&quot;: &quot;(ILjava/lang/Object;[Ljava/lang/Object;)V&quot;,    &quot;49F16102384F33420DD9430F7676300704DB59530275380C17D90204385735422EDA470D3A4D69443B&quot;: &quot;(ILjava/lang/Object;[Ljava/lang/Object;)Z&quot;,    &quot;4F20F18D70A735130B08D3803E9E3656020AC9DC4A9D3E5D1108928B70BF3313280BD78272A56F1525&quot;: &quot;(ILjava/lang/Object;[Ljava/lang/Object;)B&quot;,    &quot;8CAD49F071AA53ECC8856BFD3F9350A9C18771A14B9058A2D2852AF671B255ECEB866FFF73A809EAE7&quot;: &quot;(ILjava/lang/Object;[Ljava/lang/Object;)C&quot;,    &quot;29B441A01E42F2886D9C63AD507BF1CD649E79F12478F9C6779C22A61E5AF4884E9F67AF1C40A88E52&quot;: &quot;(ILjava/lang/Object;[Ljava/lang/Object;)S&quot;,    &quot;68766DE1F3971C512C5E4FECBDAE1F14255C55B0C9AD171F365E0EE7F38F1A510F5D4BEEF195465709&quot;: &quot;(ILjava/lang/Object;[Ljava/lang/Object;)I&quot;,    &quot;4C2429895677FDD0080C0B84184EFE95010E11D86C4DF69E120C4A8F566FFBD02B0F0F865475A7D62E&quot;: &quot;(ILjava/lang/Object;[Ljava/lang/Object;)J&quot;,    &quot;78549A7B4B4B46D83C7CB8760572459D357EA22A71714D96267CF97D4B5340D81F7FBC7449491CDE16&quot;: &quot;(ILjava/lang/Object;[Ljava/lang/Object;)F&quot;,    &quot;8F4502F0DDCDC5C2CB6D20FD93F4C687C26F3AA1E7F7CE8CD16D61F6DDD5C3C2E86E24FFDFCF9FC4E3&quot;: &quot;(ILjava/lang/Object;[Ljava/lang/Object;)D&quot;,    &quot;A34B5090CFED8214E763729D81D48151EE6168C1F5D7895AFD633396CFF58414C460769FCDEFD812C7687D8CCFB48F5AE56533B5CCF18658FF39&quot;: &quot;(ILjava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;&quot;,    &quot;2E68C02CC53A063D255DD337C42D001F0162CF&quot;: &quot;FeatureVMProtection&quot;,    &quot;F48398ED31542B0E&quot;: &quot;libc.so&quot;,    &quot;6E2DCEF43F47B331&quot;: &quot;_exit&quot;,    &quot;04C0441C5939526D&quot;: &quot;exit&quot;,    &quot;171DD59574B03063041BD88665B4&quot;: &quot;pthread_create&quot;,    &quot;D4906DE875BD569CCE8B6CF4&quot;: &quot;pthread_join&quot;,    &quot;6C9860A90F4D93A7&quot;: &quot;memcpy&quot;,    &quot;2D5E4DE7FD827D7E&quot;: &quot;malloc&quot;,    &quot;070C098F58629CFF&quot;: &quot;calloc&quot;,    &quot;3D78BB624F4927F7&quot;: &quot;memset&quot;,    &quot;C1633EFFD2BBA4ED&quot;: &quot;fopen&quot;,    &quot;ED617095DDFEE33B&quot;: &quot;fclose&quot;,    &quot;E24E68C72ED3BB4E&quot;: &quot;fgets&quot;,    &quot;4EFE6FC425A325B6&quot;: &quot;strtoul&quot;,    &quot;30640DB4A5A47CCE&quot;: &quot;strtoull&quot;,    &quot;59CA0B1C240EE666&quot;: &quot;strstr&quot;,    &quot;B3783A25593967C1&quot;: &quot;ptrace&quot;,    &quot;715D268CE678C6E2&quot;: &quot;mprotect&quot;,    &quot;678568CC1272D9F4&quot;: &quot;strlen&quot;,    &quot;4333E40A59E92B6B&quot;: &quot;sscanf&quot;,    &quot;20C396763EB607CE&quot;: &quot;free&quot;,    &quot;59EFF51F63070DB8&quot;: &quot;strdup&quot;,    &quot;1B79D33BDD38636B&quot;: &quot;strcmp&quot;,    &quot;11EDA0D862CA71BA0FE9&quot;: &quot;strcasecmp&quot;,    &quot;AD1C8CA1863C3CF3&quot;: &quot;utime&quot;,    &quot;7F7567B6D496D9AC&quot;: &quot;mkdir&quot;,    &quot;3F4E6764B2499D86&quot;: &quot;open&quot;,    &quot;7838B71CCAAF75C6&quot;: &quot;close&quot;,    &quot;04B2CD050F9C47EE&quot;: &quot;unlink&quot;,    &quot;086DDAAB98212586&quot;: &quot;stat&quot;,    &quot;E2292D97D01141B6&quot;: &quot;time&quot;,    &quot;6E4AC4CB291788D4&quot;: &quot;snprintf&quot;,    &quot;302FD3054ECECD91&quot;: &quot;strchr&quot;,    &quot;C65AB9D5625867A8&quot;: &quot;strncmp&quot;,    &quot;0C8A9ABA3559D876189B86A93350&quot;: &quot;pthread_detach&quot;,    &quot;B4D5455E4F6B8C3BB7C4414A&quot;: &quot;pthread_self&quot;,    &quot;A832C433D41105B4&quot;: &quot;opendir&quot;,    &quot;63C7D8A1855BE1D1&quot;: &quot;readdir&quot;,    &quot;DD596595BC74408E&quot;: &quot;closedir&quot;,    &quot;711BD780E966683E&quot;: &quot;mmap&quot;,    &quot;3B70EDB05642EDB6&quot;: &quot;munmap&quot;,    &quot;31F4B35BA15DF8D9&quot;: &quot;lseek&quot;,    &quot;3A7B1DDB8EAEEB3C&quot;: &quot;fstat&quot;,    &quot;2DC5B93C51DE4E8C&quot;: &quot;read&quot;,    &quot;CD3E5AC4CE4EB523&quot;: &quot;select&quot;,    &quot;9C6E379605B933C39F71&quot;: &quot;bsd_signal&quot;,    &quot;C489B09443666A3D&quot;: &quot;fork&quot;,    &quot;266DF31562D26748&quot;: &quot;prctl&quot;,    &quot;176E4794FD670E8110&quot;: &quot;setrlimit&quot;,    &quot;50660A65A953F202&quot;: &quot;getppid&quot;,    &quot;9B333E341D4B67D8&quot;: &quot;getpid&quot;,    &quot;68D77BE990FA40DB&quot;: &quot;waitpid&quot;,    &quot;03B093571B66B5A9&quot;: &quot;kill&quot;,    &quot;75F6DC484BF43E44&quot;: &quot;flock&quot;,    &quot;795BD9475A856CF3&quot;: &quot;write&quot;,    &quot;BE66196673ACF758&quot;: &quot;execve&quot;,    &quot;296C25084100FFA8&quot;: &quot;execv&quot;,    &quot;164C148245E50A35&quot;: &quot;execl&quot;,    &quot;FEF19D484641B9EC&quot;: &quot;sysconf&quot;,    &quot;E215844F2E808FC7E23A85592D9198DEC415905329&quot;: &quot;__system_property_get&quot;,    &quot;C033AAA8B3EE1BBFC3&quot;: &quot;ftruncate&quot;,    &quot;D818528B9AD01DD0&quot;: &quot;gettid&quot;,    &quot;2E1331FA88B61B58&quot;: &quot;pread64&quot;,    &quot;8F6EB5FBB011CE0A&quot;: &quot;pwrite64&quot;,    &quot;3DFBFF6E535AF038&quot;: &quot;pread&quot;,    &quot;B2D06CEC09B428DF&quot;: &quot;pwrite&quot;,    &quot;326FA0A56FCADBAB&quot;: &quot;statvfs&quot;,    &quot;09598DD611D1543C&quot;: &quot;n001&quot;,    &quot;8CA86FFB66BD1DAFC58A62B543A840AACA833ED67ABD44A28B8864F477F361B7D68D6BFD2B9058A2D2852AF671B255ECF79077F37EBB098FCE8573FB3FB053ADC3CB56EE62B55CA49FAD5FB346&quot;: &quot;(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;IZ)V&quot;,    &quot;6FCD3DF87F3493A7&quot;: &quot;n002&quot;,    &quot;687340E5F6931217241042E4FC951810341062E4FC951806340408DD&quot;: &quot;(Landroid/content/Context;)V&quot;,    &quot;0A5D55D037019CFF&quot;: &quot;n003&quot;,    &quot;783480112A3D27F7&quot;: &quot;()V&quot;,    &quot;226212F6FEFC669A22&quot;: &quot;arm64-v8a&quot;,    &quot;4819CF8872FE27590B0F928A70A127&quot;: &quot;/proc/self/maps&quot;,    &quot;D6E4059A10DC32C3&quot;: &quot;r&quot;,    &quot;6D946FAE0959BDD46E&quot;: &quot;libdvm.so&quot;,    &quot;2C5643EAE095530D2F&quot;: &quot;libart.so&quot;,    &quot;080407955A6AF59B3B01008E4273B28C0B&quot;: &quot;libvmkid_lemur.so&quot;,    &quot;3C74B470455E09843F&quot;: &quot;libaoc.so&quot;,    &quot;54AFA16C61F747EE&quot;: &quot;%s&quot;,    &quot;44CB02463B5D3E0202D3&quot;: &quot;%s/.bdlock&quot;,    &quot;050301915868F8D007020B97526FE8D014004AB05E66F29E10181786&quot;: &quot;android/content/pm/Signature&quot;,    &quot;3173B263455443D83372B8654F5353D82070F9414B5E4C9637789F7F4C52&quot;: &quot;android/content/pm/PackageInfo&quot;,    &quot;C6622AE8D3D2C0C2C46320EED9D5D0C2D76161CADDD8CF8CC06903FBD2DAC388D5&quot;: &quot;android/content/pm/PackageManager&quot;,    &quot;EA6C7888C1F28714EA726CD5EFF89752FD6B6883FAF3915EEA66&quot;: &quot;android/app/ActivityThread&quot;,    &quot;E54769C132BADF61E5597D9C1EBCD53AE15179FA30A3D7&quot;: &quot;android/app/ContextImpl&quot;,    &quot;5AEF69E333A53DD350C972DE3EB331C2&quot;: &quot;getSystemContext&quot;,    &quot;6B3933A1A4B562CD2A7450A1BAA13FE12C7E0BA5B2A559CF337C44&quot;: &quot;()Landroid/app/ContextImpl;&quot;,    &quot;49CB0B1D3512922749CA101939089F3242CC1C0E34&quot;: &quot;currentActivityThread&quot;,    &quot;EB250425543815AEAA6867254A2C4880A078213253281E95AB7E2D255E67&quot;: &quot;()Landroid/app/ActivityThread;&quot;,    &quot;7B4820B3F37ECEF77B481982FC7CC2F36E&quot;: &quot;getPackageManager&quot;,    &quot;3CD856C11978AB9B7D9535C31872AD917A8535D01A338995779A7BC71251B89A75967FD24C&quot;: &quot;()Landroid/content/pm/PackageManager;&quot;,    &quot;5725F33B56EC400A5725CE0551E0&quot;: &quot;getPackageInfo&quot;,    &quot;6EFD997248D728A227DF943C6DC275A728D6C85A17FA66A022C39C7A5A9964A128C5967D4A9977A369E1927055D760AB0FDF957C05&quot;: &quot;(Ljava/lang/String;I)Landroid/content/pm/PackageInfo;&quot;,    &quot;59F2E015770378CA4FE8&quot;: &quot;signatures&quot;,    &quot;3341C036D43A0C020C22C237DE3C06051C22D1359F1B0A0C066CD52DC22D58&quot;: &quot;[Landroid/content/pm/Signature;&quot;,    &quot;16F690C277DC55AB10F8AB&quot;: &quot;toByteArray&quot;,    &quot;F041BE8EE33C3CF3&quot;: &quot;()[B&quot;,    &quot;376D2CF19796D9AC&quot;: &quot;%s/.1&quot;,    &quot;754D2D248366B8F5&quot;: &quot;%s/.1/%s&quot;,    &quot;EA6C7888C1F28714E47133B8DBF28F5F&quot;: &quot;android/os/Build&quot;,    &quot;C96649F611D3BB4E&quot;: &quot;MODEL&quot;,    &quot;71E07CC62BF925D753ED32E33EA420D85AB1&quot;: &quot;Ljava/lang/String;&quot;,    &quot;E67F6728533E67C1&quot;: &quot;%s/lib&quot;,    &quot;395E7BCDB779A596&quot;: &quot;%s/.%d&quot;,    &quot;758269C5036FF69675987ED5076EB68071926E851332B39566&quot;: &quot;assets/baiduprotect%d.jar&quot;,    &quot;1F71A90156FD2B6B&quot;: &quot;/1.jar&quot;,    &quot;69D29F724DC562BD68DB9261&quot;: &quot;/classes.jar&quot;,    &quot;05F8EB1A650468CB04FFE203&quot;: &quot;/classes.dex&quot;,    &quot;4769C02CD167070A1C6C8E7DC3674D4E0C22C234D13B100E1B23CB39C2&quot;: &quot;/data/data/%s/.%d/classes.jar&quot;,    &quot;4DFDB3CF629670B816F8FD9E70963AFC06B6B1D762CA67BC11B7B6DE7B&quot;: &quot;/data/data/%s/.%d/classes.dex&quot;,    &quot;0DD14F092B4D300C12DD031B36&quot;: &quot;libartbase.so&quot;,    &quot;1E38C4F22868C0545D2E99F02A37C0&quot;: &quot;/proc/self/maps&quot;,    &quot;13B82D685939526D&quot;: &quot;r&quot;,    &quot;1544909711D1543C&quot;: &quot;r--p&quot;,    &quot;819725BF63FC17E9D7C420B063FC17E9D7C420E9&quot;: &quot;%s %s %*s %*s %*s %s&quot;,    &quot;73D075BA7F3493A7&quot;: &quot;r-xp&quot;,    &quot;FBBB64F474AE5DAAC0BB69F5778342B1CD8A71&quot;: &quot;__android_log_print&quot;,    &quot;2D5240FB92E17D7E&quot;: &quot;mmap&quot;,    &quot;503BC5F83F349C535021D2E83B35DC45542BC2B82F69D95043&quot;: &quot;assets/baiduprotect%d.jar&quot;,    &quot;0900049337019CFF&quot;: &quot;mmap&quot;,    &quot;D2290DB35DD3BB4E&quot;: &quot;V&quot;,    &quot;678A1DB04AD649B6&quot;: &quot;Z&quot;,    &quot;01107FC0CAD110A2&quot;: &quot;B&quot;,    &quot;69BE796F507CE666&quot;: &quot;C&quot;,    &quot;900C48443A5C67C1&quot;: &quot;S&quot;,    &quot;552D54E3921DA596&quot;: &quot;I&quot;,    &quot;5EF11AA0771CD9F4&quot;: &quot;J&quot;,    &quot;7640876B378F2B6B&quot;: &quot;F&quot;,    &quot;02B1F3133EB607CE&quot;: &quot;D&quot;,    &quot;669B877B16770DB8&quot;: &quot;L&quot;,    &quot;6A0EB69D4B47B331&quot;: &quot;[F&quot;,    &quot;3AFC2D685939526D&quot;: &quot;[D&quot;,    &quot;0D08CB863EBD35520046FF887EBD315D09&quot;: &quot;java/lang/Boolean&quot;,    &quot;CE8573FB3FB053ADC3CB47E364B9&quot;: &quot;java/lang/Byte&quot;,    &quot;6B9C7BAB5058F2C966D24EA21E46F2C475987F&quot;: &quot;java/lang/Character&quot;,    &quot;2A5E57EABD8D1C10271072E3FD9309&quot;: &quot;java/lang/Short&quot;,    &quot;0E0C1382186DFD9103422C8D4364FB9A16&quot;: &quot;java/lang/Integer&quot;,    &quot;3A7CA0700551469937329A7E445A&quot;: &quot;java/lang/Long&quot;,    &quot;CD6D38FB93D7C583C02308F6D3DAD0&quot;: &quot;java/lang/Float&quot;,    &quot;E1636A9B81F78255EC2D5895DBF98F5E&quot;: &quot;java/lang/Double&quot;,    &quot;EE487BD272BFDA20E30642D137B6D83A&quot;: &quot;java/lang/Object&quot;,    &quot;01E373D93EE849B6&quot;: &quot;&lt;init&gt;&quot;,    &quot;6B4A5696CAD110A2&quot;: &quot;(Z)V&quot;,    &quot;16D717062442E666&quot;: &quot;&lt;init&gt;&quot;,    &quot;EB4E61123A5C67C1&quot;: &quot;(B)V&quot;,    &quot;20443A8AE623A596&quot;: &quot;&lt;init&gt;&quot;,    &quot;3CB233F6771CD9F4&quot;: &quot;(C)V&quot;,    &quot;0C29E90243B12B6B&quot;: &quot;&lt;init&gt;&quot;,    &quot;6EE2DA453EB607CE&quot;: &quot;(S)V&quot;,    &quot;16F2E91262490DB8&quot;: &quot;&lt;init&gt;&quot;,    &quot;4044880EB048636B&quot;: &quot;(I)V&quot;,    &quot;5EF0BCD2778714D9&quot;: &quot;&lt;init&gt;&quot;,    &quot;F022CC9AE33C3CF3&quot;: &quot;(J)V&quot;,    &quot;2E776DB6D2A8D9AC&quot;: &quot;&lt;init&gt;&quot;,    &quot;78782B5CB2499D86&quot;: &quot;(F)V&quot;,    &quot;273DB606DB9175C6&quot;: &quot;&lt;init&gt;&quot;,    &quot;5998883A61F747EE&quot;: &quot;(D)V&quot;,    &quot;1976D4B3FD404BD01A75CEBA&quot;: &quot;booleanValue&quot;,    &quot;BE691AF2D01141B6&quot;: &quot;()Z&quot;,    &quot;7F5DC0DC161890C778&quot;: &quot;byteValue&quot;,    &quot;6B72E36626BCCD91&quot;: &quot;()B&quot;,    &quot;D646AAC957547BDDD0&quot;: &quot;charValue&quot;,    &quot;54D7B1C85038BC29&quot;: &quot;()C&quot;,    &quot;B7C9425E5E5C8908B1C4&quot;: &quot;shortValue&quot;,    &quot;EF6BF25DB07877B4&quot;: &quot;()S&quot;,    &quot;78CCCD93805EE6B4&quot;: &quot;intValue&quot;,    &quot;961C43E6D91029FC&quot;: &quot;()I&quot;,    &quot;7019D897BF07044B79&quot;: &quot;longValue&quot;,    &quot;7E2CC9DD3732EDB6&quot;: &quot;()J&quot;,    &quot;3BEBB95FBE0B99B528E2&quot;: &quot;floatValue&quot;,    &quot;74212FBAFAAEEB3C&quot;: &quot;()F&quot;,    &quot;3BCFAD3A3DBB18ED33D5BD&quot;: &quot;doubleValue&quot;,    &quot;967272A1AD3AB523&quot;: &quot;()D&quot;,    &quot;947C25A859BC35C3993200BD04B93ACA&quot;: &quot;java/lang/String&quot;,    &quot;CB88B69A31086A3D&quot;: &quot;intern&quot;,    &quot;7E36DC0B6FA406673A7EFE062181133A3F71F75A&quot;: &quot;()Ljava/lang/String;&quot;,    &quot;0406D0C873B03D581246C59479B831500346DC843E891C&quot;: &quot;com/baidu/xshield/ac/XH&quot;,    &quot;8CA864F474AE5DAAC0CB66F57EA857ADD0CB46F57EA857BBD0DF49F071AA53ECC8856BFD3F8F46B1CD8A62A15CB653B5C5CB69FB7EBB1D90D0966CF477E7698A8DB2&quot;: &quot;(Landroid/content/Context;Ljava/lang/String;Ljava/lang/String;[I)V&quot;,    &quot;689364BE7F3493A7&quot;: &quot;init&quot;,    &quot;503BC5F83F349C535021D2E83B35DC45542BC2B326&quot;: &quot;assets/baiduprotect.m&quot;,    &quot;44CB2D685939526D&quot;: &quot;%s&quot;,    &quot;3E27F603C0CC1EC6&quot;: &quot;%s.lock&quot;&#125;# 函数列表（从 Frida 输出中提取涉及的函数地址）func_list = [    0x28C28,  # sub_28C28    0x2709C,  # sub_2709C    0x25E78,  # sub_25E78    0x25F24,  # sub_25F24    0x25FD0,  # sub_25FD0    0x2607C,  # sub_2607C    0x26128,  # sub_26128    0x261D4,  # sub_261D4    0x26280,  # sub_26280    0x2632C,  # sub_2632C    0x263D8,  # sub_263D8    0x26484,  # sub_26484    0x26BE8,  # sub_26BE8    0x28AD0   # sub_28AD0]def find_string_addr(search_str):    &quot;&quot;&quot;查找字符串的地址&quot;&quot;&quot;    for addr in idautils.Strings():        if str(addr) == search_str:            return addr.ea    return Nonedef resolve_func_addr(func_entry):    &quot;&quot;&quot;将函数名或地址转换为地址&quot;&quot;&quot;    if isinstance(func_entry, int):        return func_entry    elif isinstance(func_entry, str):        func_addr = idaapi.get_name_ea_simple(func_entry)        if func_addr == idaapi.BADADDR:            print(f&quot;Function not found: &#123;func_entry&#125;&quot;)            return None        return func_addr    else:        print(f&quot;Invalid function entry: &#123;func_entry&#125;&quot;)        return Nonedef add_comments_to_strings():    &quot;&quot;&quot;为 .rodata 中的字符串添加解密注释和重命名&quot;&quot;&quot;    for encrypted, decrypted in mappings.items():        str_addr = find_string_addr(encrypted)        if str_addr:            idaapi.set_cmt(str_addr, f&quot;Decrypted: &#123;decrypted&#125;&quot;, 0)            # 重命名字符串，替换特殊字符以符合命名规则            safe_name = f&quot;str_&#123;decrypted.replace(&#x27;/&#x27;, &#x27;_&#x27;).replace(&#x27; &#x27;, &#x27;_&#x27;).replace(&#x27;(&#x27;, &#x27;_&#x27;).replace(&#x27;)&#x27;, &#x27;_&#x27;).replace(&#x27;;&#x27;, &#x27;_&#x27;).replace(&#x27;[&#x27;, &#x27;_&#x27;).replace(&#x27;]&#x27;, &#x27;_&#x27;)&#125;&quot;            idaapi.set_name(str_addr, safe_name, idaapi.SN_FORCE)            print(f&quot;Added comment at 0x&#123;str_addr:x&#125;: &#123;encrypted&#125; -&gt; &#123;decrypted&#125;&quot;)        else:            print(f&quot;String not found in .rodata: &#123;encrypted&#125;&quot;)def add_comments_to_function(func_addr):    &quot;&quot;&quot;为指定函数添加注释，扫描加载字符串的指令&quot;&quot;&quot;    func = idaapi.get_func(func_addr)    if not func:        print(f&quot;Function at 0x&#123;func_addr:x&#125; not found or invalid&quot;)        return    # 添加函数注释    func_name = idaapi.get_func_name(func_addr)    idaapi.set_func_cmt(func_addr, f&quot;Decrypts strings (e.g., &#123;&#x27;, &#x27;.join(f&#x27;&#123;k&#125;-&gt;&#123;v&#125;&#x27; for k, v in list(mappings.items())[:5])&#125;...)&quot;, 1)    print(f&quot;Processing function: &#123;func_name&#125; at 0x&#123;func_addr:x&#125;&quot;)    # 扫描函数指令，查找加载字符串的指令    for ea in idautils.FuncItems(func.start_ea):        disasm = idaapi.generate_disasm_line(ea, 0)        if &quot;LDR&quot; in disasm:  # 检查加载指令            for enc, dec in mappings.items():                if enc in disasm:                    idaapi.set_cmt(ea, f&quot;Loads &#123;enc&#125; -&gt; &#123;dec&#125;&quot;, 0)                    print(f&quot;Added comment at 0x&#123;ea:x&#125;: &#123;enc&#125; -&gt; &#123;dec&#125;&quot;)def main():    &quot;&quot;&quot;主函数：处理字符串和函数列表&quot;&quot;&quot;    # 处理 .rodata 中的字符串    print(&quot;Processing strings in .rodata...&quot;)    add_comments_to_strings()    # 处理函数列表    print(&quot;\\nProcessing functions...&quot;)    for func_entry in func_list:        func_addr = resolve_func_addr(func_entry)        if func_addr is not None:            add_comments_to_function(func_addr)        else:            print(f&quot;Skipping invalid function: &#123;func_entry&#125;&quot;)# 执行脚本if __name__ == &quot;__main__&quot;:    main()\n\n效果如下。\n\n由于解密我在hook的脚本里，设置第一个参数是字符串，而在sub_b3b4中，有些解密函数的参数是字节码，因此还需要补充5个解密函数的hook。\n// 要 hook 的 so 文件名字var module_name = &quot;libbaiduprotect.so&quot;;// so 文件的大小var module_size = 0;// 默认的目标函数偏移var target_offset = 0x88060;// 需要 hook 的字节码解密函数偏移列表var bytecode_decrypt_offsets = [    0x267e0, 0x26A90, 0x27550, 0x27800, 0x28418];// Hook linker64 的 call_constructors，检测目标 so 文件加载function hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;);    let offset_call = 0x51BA8; // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset_call);    let listener = Interceptor.attach(call_constructors, &#123;        onEnter: function(args) &#123;            console.log(&#x27;[linker] Call_Constructors onEnter&#x27;);            let secmodule = Process.findModuleByName(module_name);            if (secmodule != null) &#123;                module_size = secmodule.size;                // 第一时间 hook 目标函数                hook_target_func(secmodule.base);                listener.detach();            &#125;        &#125;    &#125;);&#125;// Hook 目标函数（触发后续字节码解密函数的 hook）function hook_target_func(baseaddr) &#123;    let listener = Interceptor.attach(baseaddr.add(target_offset), &#123;        onEnter: function(args) &#123;            console.log(&quot;[target_func] onEnter, offset: 0x&quot; + target_offset.toString(16));        &#125;,        onLeave: function(retval) &#123;            console.log(&quot;[target_func] onLeave, retval: &quot; + retval);            // 在目标函数退出时，hook 所有字节码解密函数            hook_bytecode_decrypt_funcs(baseaddr);            listener.detach();        &#125;    &#125;);&#125;// Hook 指定的字节码解密函数function hook_bytecode_decrypt_funcs(baseaddr) &#123;    bytecode_decrypt_offsets.forEach(function(offset) &#123;        let func_name = &quot;sub_&quot; + offset.toString(16).toUpperCase();        Interceptor.attach(baseaddr.add(offset), &#123;            onEnter: function(args) &#123;                let input_ptr = args[0]; // 捕获输入指针（指向字节数组）                console.log(&quot;[&quot; + func_name + &quot;] Input pointer: &quot; + input_ptr);                                // 读取以 0x00 结尾的字节数组                let bytes = [];                let i = 0;                while (true) &#123;                    let byte = Memory.readU8(input_ptr.add(i));                    if (byte === 0x00) break; // 遇到 0x00 停止                    bytes.push(byte.toString(16));                    i++;                &#125;                console.log(&quot;[&quot; + func_name + &quot;] Input bytes: &quot; + bytes.join(&quot;, &quot;));            &#125;,            onLeave: function(retval) &#123;                // 捕获返回值（解密后的字符串）                let output_str = retval.readCString();                console.log(&quot;[&quot; + func_name + &quot;] Output string: &quot; + output_str);            &#125;        &#125;);    &#125;);&#125;// 主逻辑：启动 hooksetImmediate(hook_linker_call_constructors);\n\n看得出来，sub_b3b4负责解密字符串，因此改名成这个。\n\n接下来看其它的函数，根据分析，当a2&#x3D;&#x3D;1时，只执行sub_B3B4。\n\n\n回到JNI_OnLoad，继续分析sub_91E4。\n\n\n可以看出来，在进行JNI动态注册，所以给它改了些函数名及变量名。\n\n回到JNI_OnLoad，我一直很好奇剩下的fread是什么东西？下图是别人对同样的so文件的分析，它这里伪代码是gettimeofday，那就很好理解了，在计算时间差，一般计算时间差是为了反调试，博主说这里只是收集信息。\n\n接下来可以分析第a2&#x3D;&#x3D;2的时候，会调用什么内容。\n\n已知B3B4只当a2&#x3D;&#x3D;1时才调用，这里从3E29C开始分析。\n\n\n直接分析3E36C。\n\n\n再进入3E3F0。\n\n\n3E3F0这两个函数很奇怪，似乎是我dump出现了点bug？\n\n和博主dump下来的so不太一样呢。\n\n用博主的图来讲函数3E3F0，大概是通过&#x2F;proc&#x2F;self&#x2F;maps获取进程虚拟机类型。\n\n这样子分析下去有点难受，我重新dump了一个，还是这样子，难道是壳做了什么手脚？——保留疑惑。看了一下修复的soFixer，它github写着。——阿这。\n\n之后换了一个so修复的程序，需要自己编译。\n链接：https://github.com/maiyao1988/elf-dump-fix\n再次查看3e3f0，这回终于没问题了。\n\n\n继续看函数列表，发现当a2&#x3D;&#x3D;2时，只执行了3E29C。\n\n\n总结至此，libbaiduprotect.so加载完了，总结一下：\n\n在.init_array的sub_88060进行解密，对so里的一些关键函数进行恢复。\n下述这些函数，统统在全局函数列表处进行注册添加，等待调用。\n\n\n\n\n在JNI_OnLoad处。\nsub_B3B4（a2&#x3D;&#x3D;1）解密了一些libc常用的函数地址，存在全局变量中。\n\n\nsub_91E4处，进行JNI动态注册，注册了n001、n002、n003共3个JNI函数。\n\nsub_3E29C（a2&#x3D;&#x3D;2）执行了下面的内容，获取最大IO向量数量并获得虚拟机类型。\n\n\n\nJNI函数分析（attachBaseContext&#x2F;onCreate）n001Java层的n001，对应于sub_91E4注册的3个函数的第1个函数。\n通过分析，得知n001属于类com.baidu.protect.A。\n\n\n然后在com.baidu.protect.StubApplication类的attachBaseContext中进行调用。\n\n接下来进入native层进行分析。\n首先简单的改了一下名字和类型。\n\n\n下图中，还原了一些函数名。\n\n\n先来分析sub_95B4。\n下面两个图中，可以看到函数sub_968C的参数列表不一样。\n\n\n\n\n在sub_95B4调用sub_968C的地方，进入汇编层分析。\n可以看到，前sub_968C的前两个参数是sub_9584的前两个参数，而X2 &#x3D; X19 + X1 &#x3D; strlen(X1) + X1，因此，sub_968C的参数列表应该是3个参数，第3个参数是a2字符串的结束地址。\n\n\n修改后是这样。\n\n\n进入sub_968C进行分析，修改了一些变量名后，如下图所示。\n它大致是一个管理缓冲区的函数，将字符串复制到目标缓冲区，并防止缓冲区溢出，重命名为buffer_manager。\n\n回到n001的JNI函数，继续往下分析，尝试hook decrypt_str2，观察返回值。\n\nhook的脚本如下。\n// 要 hook 的 so 文件名字var module_name = &quot;libbaiduprotect.so&quot;;// so 文件的大小var module_size = 0;// 默认的目标函数偏移var target_offset = 0x88060;// 需要 hook 的字节码解密函数偏移列表var bytecode_decrypt_offsets = [    0x95F4];// Hook linker64 的 call_constructors，检测目标 so 文件加载function hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;);    let offset_call = 0x51BA8; // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset_call);    let listener = Interceptor.attach(call_constructors, &#123;        onEnter: function(args) &#123;            console.log(&#x27;[linker] Call_Constructors onEnter&#x27;);            let secmodule = Process.findModuleByName(module_name);            if (secmodule != null) &#123;                module_size = secmodule.size;                // 第一时间 hook 目标函数                hook_target_func(secmodule.base);                listener.detach();            &#125;        &#125;    &#125;);&#125;// Hook 目标函数（触发后续字节码解密函数的 hook）function hook_target_func(baseaddr) &#123;    let listener = Interceptor.attach(baseaddr.add(target_offset), &#123;        onEnter: function(args) &#123;            console.log(&quot;[target_func] onEnter, offset: 0x&quot; + target_offset.toString(16));        &#125;,        onLeave: function(retval) &#123;            console.log(&quot;[target_func] onLeave, retval: &quot; + retval);            // 在目标函数退出时，hook 所有字节码解密函数            hook_bytecode_decrypt_funcs(baseaddr);            listener.detach();        &#125;    &#125;);&#125;// Hook 指定的字节码解密函数function hook_bytecode_decrypt_funcs(baseaddr) &#123;    bytecode_decrypt_offsets.forEach(function(offset) &#123;        let func_name = &quot;sub_&quot; + offset.toString(16).toUpperCase();        Interceptor.attach(baseaddr.add(offset), &#123;            onEnter: function(args) &#123;                let input_ptr = args[0]; // 捕获输入指针（指向字节数组）                console.log(&quot;[&quot; + func_name + &quot;] Input pointer: &quot; + input_ptr);                                // 读取以 0x00 结尾的字节数组                let bytes = [];                let i = 0;                while (true) &#123;                    let byte = Memory.readU8(input_ptr.add(i));                    if (byte === 0x00) break; // 遇到 0x00 停止                    bytes.push(byte.toString(16));                    i++;                &#125;                console.log(&quot;[&quot; + func_name + &quot;] Input bytes: &quot; + bytes.join(&quot;, &quot;));            &#125;,            onLeave: function(retval) &#123;                // 捕获返回值（解密后的字符串）                let output_str = retval.readCString();                console.log(&quot;[&quot; + func_name + &quot;] Output string: &quot; + output_str);            &#125;        &#125;);    &#125;);&#125;// 主逻辑：启动 hooksetImmediate(hook_linker_call_constructors);\n\n打印的结果如下。\n\n打印了几个字符串，BCDB0[0]的值是BE660，因此可以确定，&#x2F;data&#x2F;user&#x2F;0&#x2F;com.example.test是我们要找的解密字符串。\n\n\n之后又调用函数sub_95FC。\n\n在这个函数中，创建了文件&#x2F;data&#x2F;user&#x2F;0&#x2F;com.example.test&#x2F;.bdlock，然后通过flock函数上锁（文件锁）。更名为open_and_lock。\n\n之后再分析sub_781C，又有混淆，通过d810去一下混淆，又调用函数列表，这回调用a2&#x3D;&#x3D;3的情况。\n\n\n观察函数列表的函数，先整理出有哪些函数当a2&#x3D;&#x3D;3的时候执行。\n\n\n经过整理，会执行3E29C、40CF8（与java层传入的arg5有关）、3DFC4、11F5C、45964。\nsub_3E29C(a2&#x3D;&#x3D;3)先分析3E29C。\n查看call_funcs_list，传入的参数为：a1是函数列表，a2是3，a3是env。\n\n\n进入sub_13880进行查看。\n\n解密了很多系统库中的函数名，通过JNI进行调用。\n这一块代码有点怪，v29应该传入getPackageInfo的函数参数里的，可以从汇编看看。\n\n如下图所示，应该有5个参数。（arm64支持X0-X7传递参数）\n\n但这里不能修改一下callxxxxx的函数签名，因为他是一个不定长的函数调用。但我们知道，a2是一个字符串（包名，稍微追踪一下，发现是在JNI_OnLoad赋值的，当时没改名字，现在苦苦分析）。\n\n\nflags的值是0x40，代表返回PackageInfo的PackageInfo对象，包含签名信息。（如果不填0x40，返回的PackageInfo对象中的signatures字段将会是null）\n继续分析，为他们修改注释和变量名。\n\n进入sub_3AE58，直接返回16字节，有点像md5的初始化常量。\n\n借助大模型的力量，我成功识别了md5的相关函数，不过也说明了算法是我的薄弱点，得找时间好好看看。\n\n\n分析完了，sub_13880的行为：根据签名数组的第0个签名生成md5，赋值给a3并返回。\n\n接着看sub_66064。\n在sub_65E94中，会根据md5的值，在result地址+8的为止，根据md5，累积异或产生了16个新字节（假如记作buf1）。\n在sub_64A50中，result将指向ptr_result+1的位置，也就是result &#x3D; buf1，然后在sub_64A50中，根据buf1的最后4个字节，又生成了160个字节，也就是说，result指向的字节数组大小为176。\n因此，将sub_66064命名为md5_extend_176。\n\n整理一下，sub_3E29C得到了一个md5和一个基于md5的176字节。\nsub_40cf8(a2&#x3D;&#x3D;3)继续看，下一个看40CF8——3E29C、40CF8（与java层传入的arg5有关）、3DFC4、11F5C、45964。\n\n这里的BCE28，和n001传入的arg5有关。\n\n\n为了确定这个值，尝试hook一下Java层的n001，脚本如下。\nfunction hook_n001()&#123;    Java.perform(function()&#123;        var clazz_A = Java.use(&quot;com.baidu.protect.A&quot;);        clazz_A.n001.implementation = function(arg0, arg1, arg2, arg3, arg4, arg5)&#123;            console.log(&quot;[arg0] &quot;, arg0);            console.log(&quot;[arg1] &quot;, arg1);            console.log(&quot;[arg2] &quot;, arg2);            console.log(&quot;[arg3] &quot;, arg3);            console.log(&quot;[arg4] &quot;, arg4);            console.log(&quot;[arg5] &quot;, arg5);            var result = this.n001(arg0,arg1,arg2,arg3,arg4,arg5);            return result;        &#125;    &#125;)&#125;setImmediate(hook_n001);\n\n结果如下。\n\n从调用的地方可以猜到含义，分别代表着：包名、app名、apk路径、数据路径、sdk版本、是否报崩溃的错误。\n\n回到40CF8，这回知道了off_BCE28的含义了，用来判断是否上报crash信息的，那40CF8的这段代码，应该是用来处理崩溃信息上传的？\n在调用call_funcs_list这个函数中，调用函数列表每个函数的传参方式是：函数地址、a2、env、a4、a5、a6。（a3就是env）\n\n因此，在40CF8中，sub_409E0和sub_40F38的传参就好懂了。\n\n\n先进入409E0，修改a2的类型，看样子是注册了两个函数。\n\n\n交叉引用qword_BE808，找到它赋值的位置，发现它是一个之前的解密字符串，“com&#x2F;baidu&#x2F;protect&#x2F;CrashHandler”。\n\n鉴于sub_7398、sub_409E0等函数还存在字符串未解密，这里先把它们的解密字符串收集起来，就不提供脚本了，脚本都大差不差。\n回到409e0。\n有些搞不明白这里的v10与v11的关系，v11按理来说应该是异常的回调函数，但这里的写法我确实没看懂。\n总之，sub_409E0动态注册了com.baidu.protect.CrashHandler.a()和com.baidu.protect.CrashHandler.b(Ljava&#x2F;lang&#x2F;String)。\n同时，注册了一个统一的自定义处理函数sub_40bd0，负责处理异常。\n综上所述，直接将这个函数改名成处理异常。\n\n回到40cf8，这个函数在a2&#x3D;&#x3D;3时，做了下面的操作，接着看下一个函数列表的函数。\n\nsub_3DFC4(a2&#x3D;&#x3D;3)该看3DFC4了——3E29C、40CF8（与java层传入的arg5有关）、3DFC4、11F5C、45964。\n先将a3的类型改为JNIEnv*，然后尝试阅读一下代码。\n\n这一个函数的难度，比我想象中难很多啊，博客说，3D6AC是3DFC4的关键函数…点进去一看，不知道3D6AC在做什么，ptr_buf的大小是0x13E80，不妨hook sub_3d6ac，观察结束后，ptr_buf的内容是多少。\n\n脚本如下。\n// Frida脚本：hexdump sub_3D6AC的第一个参数ptr_buf// 1. 请将 &quot;libyourtarget.so&quot; 替换为目标SO文件的实际名称const TARGET_MODULE_NAME = &quot;libbaiduprotect.so&quot;;// 2. 这是 sub_3D6AC 函数在SO文件中的偏移地址//    如果 &quot;sub_3D6AC&quot; 是一个导出的函数名，你可以尝试使用 Module.findExportByName()//    但通常这种 &quot;sub_XXXXX&quot; 格式的名称是IDA反编译后基于地址命名的，所以使用偏移量更可靠。const FUNCTION_OFFSET = 0x3D6AC; // 函数 sub_3D6AC 的偏移地址// 3. ptr_buf 指向的内存区域大小const BUFFER_SIZE = 0x13e80;// (可选) 你想在hexdump中实际打印的最大字节数，以防BUFFER_SIZE过大导致控制台输出混乱// 如果你想打印全部内容，可以将MAX_DUMP_SIZE设置为BUFFER_SIZEconst MAX_DUMP_SIZE = Math.min(BUFFER_SIZE); // 例如，最多打印1024字节function hook_linker_call_constructors() &#123;    // 获得linker64的地址    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;);    let offset_call = 0x51BA8;    // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset_call);    let listener = Interceptor.attach(call_constructors, &#123;        onEnter: function(args) &#123;            // 判断是否可以通过findModuleByName查找到目标so文件            console.log(&#x27;[linker] Call_Constructors onEnter&#x27;);            let secmodule = Process.findModuleByName(TARGET_MODULE_NAME);            if (secmodule != null) &#123;                // 第一时间hook                hook_target_func(secmodule.base);                listener.detach();            &#125;        &#125;    &#125;);&#125;function hook_target_func(baseaddr)&#123;    let listener = Interceptor.attach(baseaddr.add(0x88060), &#123;        onEnter:function(args)&#123;        &#125;,        onLeave:function(retval)&#123;            // 第一个函数解密完后，才能hook sub_28c28            main(baseaddr);            listener.detach();        &#125;    &#125;);&#125;function main(base) &#123;    const moduleBase = base;    if (!moduleBase) &#123;        console.error(&quot;[-] 模块 &quot; + TARGET_MODULE_NAME + &quot; 未找到。请确保模块名正确且已加载。&quot;);        return;    &#125;    const targetFunctionAddr = moduleBase.add(FUNCTION_OFFSET);    console.log(&quot;[+] 目标函数 sub_3D6AC 地址: &quot; + targetFunctionAddr);    console.log(&quot;[+] ptr_buf 大小: 0x&quot; + BUFFER_SIZE.toString(16) + &quot; (&quot; + BUFFER_SIZE + &quot; bytes)&quot;);    console.log(&quot;[+] hexdump 将显示最多: 0x&quot; + MAX_DUMP_SIZE.toString(16) + &quot; (&quot; + MAX_DUMP_SIZE + &quot; bytes)&quot;);    Interceptor.attach(targetFunctionAddr, &#123;        onEnter: function(args) &#123;            // args[0] 是第一个参数 (__int64 a1, 即 ptr_buf)            // args[1] 是第二个参数 (JNIEnv *env)            this.ptr_buf = args[0]; // 保存 ptr_buf 的指针以在 onLeave 中使用            this.jniEnv = args[1];  // 保存 JNIEnv 指针            console.log(&quot;\\n[*] 进入 sub_3D6AC:&quot;);            console.log(&quot;    ptr_buf (a1): &quot; + this.ptr_buf);            console.log(&quot;    JNIEnv* (a2): &quot; + this.jniEnv);        &#125;,        onLeave: function(retval) &#123;            console.log(&quot;[*] 离开 sub_3D6AC. 返回值: &quot; + retval);            if (this.ptr_buf &amp;&amp; !this.ptr_buf.isNull()) &#123;                console.log(&quot;[+] ptr_buf (&quot; + this.ptr_buf + &quot;) 内容 (前 &quot; + MAX_DUMP_SIZE + &quot; 字节):&quot;);                try &#123;                    // Memory.readByteArray(pointer, length) 返回一个 ArrayBuffer                    const bufferContent = Memory.readByteArray(this.ptr_buf, Math.min(BUFFER_SIZE, MAX_DUMP_SIZE));                    console.log(hexdump(bufferContent, &#123;                        offset: 0,                        length: Math.min(BUFFER_SIZE, MAX_DUMP_SIZE), // 确保hexdump长度与读取长度一致                        header: true,                        ansi: true // 如果你的控制台支持，可以开启颜色高亮                    &#125;));                    // 如果你想保存整个缓冲区到文件（这部分比较复杂，通常建议在PC端Python脚本中处理）                    // 你可以在这里发送 bufferContent (或者 this.ptr_buf 和 BUFFER_SIZE) 到你的Python脚本                    // 例如: send(&#123; ptr: this.ptr_buf.toString(), size: BUFFER_SIZE &#125;);                    // 然后在Python端接收并保存：                    // def on_message(message, data):                    //     if message[&#x27;type&#x27;] == &#x27;send&#x27;:                    //         payload = message[&#x27;payload&#x27;]                    //         ptr = int(payload[&#x27;ptr&#x27;], 16)                    //         size = payload[&#x27;size&#x27;]                    //         print(f&quot;Receiving buffer from &#123;hex(ptr)&#125; with size &#123;size&#125;&quot;)                    //         buffer_data = process.read_bytes(ptr, size)                    //         with open(f&quot;ptr_buf_dump_&#123;hex(ptr)&#125;.bin&quot;, &quot;wb&quot;) as f_out:                    //             f_out.write(buffer_data)                    //         print(f&quot;Buffer dumped to ptr_buf_dump_&#123;hex(ptr)&#125;.bin&quot;)                    // script.on(&#x27;message&#x27;, on_message)                &#125; catch (e) &#123;                    console.error(&quot;[-] 读取或hexdump ptr_buf 时发生错误: &quot; + e);                    console.error(&quot;    错误详情: &quot; + e.stack);                &#125;            &#125; else &#123;                console.warn(&quot;[-] ptr_buf 在 onLeave 时为 null 或无效。&quot;);            &#125;            console.log(&quot;--- 结束 sub_3D6AC 打印 ---&quot;);        &#125;    &#125;);&#125;// 确保在Java环境准备好后执行main函数，尤其是在attach模式下早期hook时// 对于 Android SO 文件中的函数，通常直接调用 main() 即可，// 或者使用 setImmediate(main) 来确保主循环已准备好setImmediate(hook_linker_call_constructors);// 或者对于某些情况，特别是应用启动非常早期的hook，可能需要等待Java VM加载完毕// Java.perform(function() &#123;//     console.log(&quot;[+] Java VM 已加载，开始执行 main()&quot;);//     main();// &#125;);\n\n打印的结果如下图所示，文件还挺大的。\n\n回到3DFC4，验证一下我们之前的分析，第0x721个元素存放了目录路径的个数。0x721 x 4 &#x3D; 0x1C84，因此到0x1C84去读取个数。\n\n读4个字节，02 00 00 00，即为2。因此会创建2个文件夹，再来到第0x744个元素（也就是0x744 x 4 &#x3D; 0x1D10），去读取目录字符串。\n\n也就是说，第一个目录字符串的地址存放再0x7969adfcc0处，下一个地址则是0x7969adfd20。\n\n要获取这2个字符串，即去读取ptr_buf + 0x1D10和ptr_buf + 0x1D40，修改一下脚本。\nconst TARGET_MODULE_NAME = &quot;libbaiduprotect.so&quot;;const FUNCTION_OFFSET = 0x3D6AC;const BUFFER_SIZE = 0x13e80;const MAX_DUMP_SIZE = Math.min(BUFFER_SIZE);function hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;);    let offset_call = 0x51BA8; // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset_call);    let listener = Interceptor.attach(call_constructors, &#123;        onEnter: function(args) &#123;            console.log(&#x27;[linker] Call_Constructors onEnter&#x27;);            let secmodule = Process.findModuleByName(TARGET_MODULE_NAME);            if (secmodule != null) &#123;                hook_target_func(secmodule.base);                listener.detach();            &#125;        &#125;    &#125;);&#125;function hook_target_func(baseaddr) &#123;    let listener = Interceptor.attach(baseaddr.add(0x88060), &#123;        onEnter: function(args) &#123;&#125;,        onLeave: function(retval) &#123;            main(baseaddr);            listener.detach();        &#125;    &#125;);&#125;function main(base) &#123;    const moduleBase = base;    if (!moduleBase) &#123;        console.error(&quot;[-] 模块 &quot; + TARGET_MODULE_NAME + &quot; 未找到。请确保模块名正确且已加载。&quot;);        return;    &#125;    const targetFunctionAddr = moduleBase.add(FUNCTION_OFFSET);    console.log(&quot;[+] 目标函数 sub_3D6AC 地址: &quot; + targetFunctionAddr);    console.log(&quot;[+] ptr_buf 大小: 0x&quot; + BUFFER_SIZE.toString(16) + &quot; (&quot; + BUFFER_SIZE + &quot; bytes)&quot;);    console.log(&quot;[+] hexdump 将显示最多: 0x&quot; + MAX_DUMP_SIZE.toString(16) + &quot; (&quot; + MAX_DUMP_SIZE + &quot; bytes)&quot;);    Interceptor.attach(targetFunctionAddr, &#123;        onEnter: function(args) &#123;            this.ptr_buf = args[0]; // 保存 ptr_buf 的指针            this.jniEnv = args[1];  // 保存 JNIEnv 指针            console.log(&quot;\\n[*] 进入 sub_3D6AC:&quot;);            console.log(&quot;    ptr_buf (a1): &quot; + this.ptr_buf);            console.log(&quot;    JNIEnv* (a2): &quot; + this.jniEnv);        &#125;,        onLeave: function(retval) &#123;            console.log(&quot;[*] 离开 sub_3D6AC. 返回值: &quot; + retval);            if (this.ptr_buf &amp;&amp; !this.ptr_buf.isNull()) &#123;                console.log(&quot;[+] ptr_buf (&quot; + this.ptr_buf + &quot;) 内容:&quot;);                try &#123;                    // 读取目录个数 (ptr_buf[0x721])                    const dirCount = this.ptr_buf.add(0x721 * 4).readU32();                    console.log(&quot;[+] 目录个数 (ptr_buf[0x721]): &quot; + dirCount);                    // 从 0x744 开始遍历目录结构                    let dirOffset = 0x744 * 4; // 字节偏移                    for (let i = 0; i &lt; dirCount; i++) &#123;                        const dirEntry = this.ptr_buf.add(dirOffset);                        const dirPathPtr = dirEntry.readPointer(); // 读取目录路径指针                        try &#123;                            const dirPath = dirPathPtr.readCString();                            console.log(`[Dir $&#123;i&#125;] $&#123;dirPathPtr&#125;: $&#123;dirPath&#125;`);                        &#125; catch (e) &#123;                            console.log(`[Dir $&#123;i&#125;] $&#123;dirPathPtr&#125;: (无法读取字符串: $&#123;e&#125;)`);                        &#125;                        dirOffset += 48; // 每个目录结构 48 字节                    &#125;                    // 可选：打印整个缓冲区 (注释掉，避免输出过多)                    /*                    const bufferContent = Memory.readByteArray(this.ptr_buf, Math.min(BUFFER_SIZE, MAX_DUMP_SIZE));                    console.log(hexdump(bufferContent, Math.min(BUFFER_SIZE, MAX_DUMP_SIZE)));                    */                &#125; catch (e) &#123;                    console.error(&quot;[-] 读取 ptr_buf 时发生错误: &quot; + e);                    console.error(&quot;    错误详情: &quot; + e.stack);                &#125;            &#125; else &#123;                console.warn(&quot;[-] ptr_buf 在 onLeave 时为 null 或无效。&quot;);            &#125;            console.log(&quot;--- 结束 sub_3D6AC 打印 ---&quot;);        &#125;    &#125;);&#125;setImmediate(hook_linker_call_constructors);\n\n打印的结果如下图所示，创建了2个目录。\n\n至于sub_3DFC4d剩下的内容就不分析了，因为sdk版本之前打印好像是32。\n\nsub_11F5C(a2&#x3D;&#x3D;3)接着看11F5C。——3E29C、40CF8（与java层传入的arg5有关）、3DFC4、11F5C、45964。\n直接调用sub_BC60。\n\n\n在sub_BC60中，根据sdk版本，执行不同的代码块，我记得之前打印过，sdk_version是32，因此这里只关注需要执行的函数。\n\n\n来看看sub_188AC，用d810去一下混淆。\n\n\nhook这些字符串，打印看看什么含义，似乎没打印出来，说明没执行到。v0是一个指针，存储着BCEB8。我猜测，这里是在根据sdk，选择对应的so。\n\n\n我知道libart.so，但libartbase.so是什么呢？\n\n\n接着看sub_4029c，进行一定分析，修改变量名，写注释，如下图所示。\n看上去，sub_4029C是一个处理内存映射的函数。\n\n整理一下：\n\n读取 &#x2F;proc&#x2F;self&#x2F;maps：\n\n\n打开 &#x2F;proc&#x2F;self&#x2F;maps 文件，获取当前进程的内存映射信息。\n\n\n查找目标模块（str）：\n\n\n在内存映射中查找包含 str（例如 “libartbase.so”）的条目。\n\n\n修改内存权限：\n\n\n对于目标模块的内存段，修改其权限（mprotect）：\n如果段权限是 r–p（只读），改为 r-x（可读可执行）。\n如果段权限是 r-xp（可读可执行），改为 rwx（可读可写可执行）。\n\n\n\n\n存储基地址：\n\n\n将目标模块的基地址存储到 a1 中。\n\n回到sub_188AC，继续分析，将sub_4029C改名成get_so_baseaddr_AND_change_flags。\n我之前hook过sub_25E78，但这里似乎并没有对6A6DC5A……进行解密，大概率是没执行，这里分析else分支，继续分析sub_3FF9C。\n\nbaseaddr是libartbase.so的基址，这里看上去是在解析ELF文件。\n\n\n随便打开一个普通的so文件看看，寻找第0x38个字节和0x20个字节的含义。——先取指针，后进行运算，所以这里用0x38*8。\n第0x38字节的含义：e_phnum_NUMBER_OF_PROGRAM_HEADER_ENTRIES，代表PHT的个数。\n\n第0x20字节的含义：e_phoff_PROGRAM_HEADER_OFFSET_IN_FILE，代表PHT在文件中的偏移量。\n\n除此之外，还有访问pht + 16位置的代码段…这里就不贴图了，直接修改变量名。\n这个函数手动解析了ELF动态信息，这种方式可以绕过一些针对标准dlsym的Hook，或者在某些特殊环境中加载和解析符号。\n那么，sub_3FF9C看似是在解析动态链接库，并找到对应的符号。——当然不是这样，继续往下看。\n\n可以注意到，函数3FAE0和3F924出现在了switch-case结构中，这里简单介绍这俩函数的作用。\n函数sub_3FAE0负责处理标准的ELF重定位表（如 .rela.dyn 用于数据重定位，.rela.plt 用于过程链接表PLT的函数调用重定位）。它查找对目标符号的引用，并将这些引用重定向到a3（调用时提供的“空函数”地址，伏笔）。\n函数sub_3FAE0负责处理一个自定义的、以”APS2”开头的特殊数据结构。这个结构中也包含了对某些符号的引用信息（可能是为了处理更复杂的场景，如与符号版本控制相关的重定位，或者是一些内部模块间的链接）。它同样查找对目标符号的引用，并将这些引用重定向到提供的“空函数”地址。\n这里的空函数，指的是sub_1B044，这是一个空函数，点进去只有一个return。（这里的redirect_func_to_a3是sub_3FF9C，被我改名了）。\n\n\n\n在sub_188AC中，除了将__android_log_print进行hook，重定位到一个空函数，还将mmap进行了hook，重定位到了sub_1B070，博主说，这里在加载Dex的时候有用。那就待会再来看sub_1B070吧。\n\n回到sub_BC60，总结一下sub_188AC，它将__android_log_print和mmap进行了hook。\n因为我们的sdk是32，再继续分析sub_11AB0。\n\n\n还有好多未解密的字符串，写个脚本打印一下。\n\n\n打印的结果如下，涉及动态加载。\n\n有个很奇怪的现象，可能是我没分析到？当把未解密的so文件放入ida中，跳转到11ab0，是可以看到循环的（和博客一致）。而解密后的so文件在查看时，没有for循环，不知道是什么导致的。麻了，因为这个so文件我没添加注释，没改变量名，有些东西乍一看看不出来。\n\n\n直接拿博客的图来用一下吧，好糊。\n简单说一下思路，将jar文件转换成dex文件，然后通过InMemoryDexClassLoader进行加载，然后将两个加载器的Element数组合并，重新设置成原加载器的Element数组（为了之后加载的类，可以被原始类加载器加载，热更新），随后将Dex文件的信息，在baidu设置的0x13E80个字节的缓冲区里进行更新——也不知道更新什么东西？费这么大信息，hook上mmap函数，最后只是为了拿到mmap分配的地址，给到函数update_dex_info_to_baidu_struct。\n\n\n回到sub_bc60，再次总结一下，在hook mmap之后，会加载jar文件（目标dex文件），然后去除mmap的hook。\n\n\n至此，sub_bc60分析完了——我没特意分析具体是如何解密出dex文件的，感觉很复杂——之前的签名扩展的176字节，会被用来当密钥，也就是说，如果这个apk被修改后重新签名，是无法打开的，因为Dex文件解不开。\n要想得到这个Dex文件，可以通过hook sub_3BA90，在onLeave时dump第3个参数，而dump的大小是第4个参数。\n\n\nsub_45964(a2&#x3D;&#x3D;3)最后，分析sub_45964。——3E29C、40CF8（与java层传入的arg5有关）、3DFC4、11F5C、45964。\n做了一下简单的分析。\n在RegisterNative_10item的函数中，注册了10个JNI函数，10个JNI函数全部注册到了1个Native地址上。\n\n10个函数全部注册到1个地址，说明是vmp。\n\n下图来自未解密的so文件，又有do-while没被检测出来。在函数sub_42D8C中，会对每个Dex文件去解析附加数据3。\n\n下图是每个Jar文件的内容。sub_42D8C负责处理其中的附加数据3。\n\n这里直接引用博主的分析，如下图所示。\n\n如何分析出来的呢？过几天来看看。\n总结至此，n001分析完了，总结一下。\nsub_3E29C取出了签名数组，取了数组的第0个元素，通过md5得到了16个字节，再把这16字节扩展成了176字节。\nsub_40cf8注册的函数异常处理有关，大致是负责异常处理。\nsub_3DFC4创建了两个目录，分别是&#x2F;data&#x2F;user&#x2F;0&#x2F;com.example.test&#x2F;.1和&#x2F;data&#x2F;user&#x2F;0&#x2F;com.example.test&#x2F;.2，这两个目录应该是与dex、jar相关，为sub_11f5c服务的。——我发现了一些字符串，&#x2F;data&#x2F;data&#x2F;包名&#x2F; &#x3D;&#x3D; &#x2F;data&#x2F;user&#x2F;0&#x2F;包名。\n\nsub_11f5C hook了两个函数，一个是__android_log_print，一个是mmap，然后解密加载了业务dex文件（需要用到sub_3E29C签名扩展的176字节进行解密），加载完后，删除了mmap的hook。\nsub_4596c注册了10个JNI函数，解析了vmp的方法数组和指令替换表。\nn002n002函数是在onCreate函数中调用的，也是启动app的流程必经的函数之一。\n在n002中，又是调用函数列表上的函数，这回的a2&#x3D;&#x3D;4。\n通过分析，会有sub_ 40CF8、sub_ 3E96C、sub_ 42388这3个函数执行。\nsub_ 40CF8调用CrashHandler.asynRun方法，向https://apkprotect.baidu.com/apklog发送统计信息。\nsub_ 3E96C assets&#x2F;baiduprotect.m检查dex的完整性，该文件中存有加密的dex MD5，如果修改dex进行重新签名，会导致app打不开。——应该还有对调试器的检测，因为使用frida和IDA的时候会异常退出。\nsub_ 42388注册com.baidu.xshield.jni.Asc和com.baidu.xshield.utility.KeyUtil的本地函数，调用com.baidu.xshield.ac.XH.init方法。\n至此，app启动流程涉及到的n001和n002分析完了。\nvmp分析先把dex dump下来，下面是脚本，hook sub_3BA90，在onLeave时进行dump。\n脚本如下。\nconst TARGET_MODULE_NAME = &quot;libbaiduprotect.so&quot;;function hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;);    let offset_call = 0x51BA8; // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset_call);    let listener = Interceptor.attach(call_constructors, &#123;        onEnter: function(args) &#123;            console.log(&#x27;[linker] Call_Constructors onEnter&#x27;);            let secmodule = Process.findModuleByName(TARGET_MODULE_NAME);            if (secmodule != null) &#123;                hook_target_func(secmodule.base);                listener.detach();            &#125;        &#125;    &#125;);&#125;function hook_target_func(baseaddr) &#123;    let listener = Interceptor.attach(baseaddr.add(0x88060), &#123;        onEnter: function(args) &#123;&#125;,        onLeave: function(retval) &#123;            // hook sub_3BA90            hook_3BA90(baseaddr);            listener.detach();        &#125;    &#125;);&#125;function hook_3BA90(baseaddr) &#123;    Interceptor.attach(baseaddr.add(0x3BA90), &#123;        onEnter: function(args) &#123;            // 保存指针地址            this.dexPtr = args[2]; // &amp;dex_ 的地址            this.sizePtr = args[3]; // &amp;v6 的地址            console.log(&quot;[+] sub_3BA90 - dexPtr:&quot;, this.dexPtr, &quot;sizePtr:&quot;, this.sizePtr);            console.log(&quot;[+] Call stack:\\n&quot;, Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join(&quot;\\n&quot;));        &#125;,        onLeave: function(retval) &#123;                // 读取 dex_ 和 v6 的值                this.ptr = this.dexPtr.readPointer(); // *dexPtr, 即 dex_ 的值                this.size = this.sizePtr.readU64().toNumber(); // *sizePtr, 即 v6 的值                console.log(&quot;[+] DEX dump - ptr:&quot;, this.ptr, &quot;size:&quot;, this.size);                if (this.ptr &amp;&amp; !this.ptr.isNull() &amp;&amp; this.size &gt; 0 &amp;&amp; this.size &lt; 0x10000000) &#123; // 限制最大 256MB                    // 修改内存权限                    Memory.protect(this.ptr, this.size, &#x27;rwx&#x27;);                    console.log(&quot;[+] 内存权限已修改为 rwx&quot;);                    // 读取 DEX 文件内容                    const dexData = Memory.readByteArray(this.ptr, this.size);                    console.log(&quot;[+] 成功读取 DEX 数据&quot;);                    // 生成唯一的文件名                    const filename = `/data/data/com.example.test/dex_dump_$&#123;this.ptr.toString(16)&#125;_$&#123;Date.now()&#125;.dex`;                    // 写入文件                    const file = new File(filename, &quot;wb&quot;);                    if (file) &#123;                        file.write(dexData);                        file.flush();                        file.close();                        console.log(&quot;[+] DEX 文件成功保存到:&quot;, filename);                    &#125; else &#123;                        console.error(&quot;[-] 无法打开文件:&quot;, filename);                    &#125;                &#125; else &#123;                    console.warn(&quot;[-] 无效的 ptr 或 size:&quot;, this.ptr, this.size);                &#125;        &#125;    &#125;);&#125;setImmediate(hook_linker_call_constructors);\n\n打印的结果如下。\n\n\n这里图方便，分析onCreate函数（vmp化），需要判断它在哪个dex文件里。\n通过这个指令：grep -r “MainActivity” .&#x2F;dex_dump 可以找到。\n\n算了，直接将2个dex都pull出来，丢进行jadx里看看。\n成功找到了类MainActivity，onCreate明显被vmp动过。\n\n\n-1426063360即为0xAB00 0000。\n\n\n来到之前注册V的函数的地方，函数列表很怪，按理来说，应该有5个参数，前2个是JNIEnv和jclass，然后是A.V传的3个参数。\n\n把签名改成我期待的样子。\n\n再看这个sub_4A458，很不正常，连传了3个BYTE(a3)，还是看汇编吧。\n\n通过汇编的还原，调用的参数列表应该是这样子的。\n\n\n接下来，进入sub_4a458。看一眼就累了，很多函数的参数都是瞎传递的，ida没正确识别。\n\n试试用ida的trace，由于vmp这一块代码是加密的，要等到解密后才方便下断点。因此，还是使用frida进行trace吧。\n但是frida trace受挫了，似乎有反调？我之前尝试使用jnitrace也是执行到特定时候就会退出。\n之后尝试绕过。——hook pthread_create的线程函数，置为空，然后重新使用hook_libart.js来查看调用的JNI函数，看看会不会退出。\n好消息，成功了，脚本如下。\nvar offset = 0x88060;var module_size = 0;var module_name = &quot;libbaiduprotect.so&quot;;var base_addr = null; // To store the base address of libbaiduprotect.so// Create an empty functionvar empty_func = new NativeCallback(function() &#123;    return 0;&#125;, &#x27;int&#x27;, [&#x27;pointer&#x27;]);function hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;);    let offset_call = 0x51BA8; // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset_call);    let listener = Interceptor.attach(call_constructors, &#123;        onEnter: function(args) &#123;            console.log(&#x27;[linker] Call_Constructors onEnter&#x27;);            let secmodule = Process.findModuleByName(module_name);            if (secmodule != null) &#123;                module_size = secmodule.size;                base_addr = secmodule.base; // Save the base address                console.log(&quot;libbaiduprotect.so base: &quot; + base_addr + &quot;, size: &quot; + module_size);                hook_target_func(base_addr);                listener.detach();            &#125;        &#125;    &#125;);&#125;function hook_target_func(baseaddr) &#123;    let target_addr = baseaddr.add(offset);    let listener = Interceptor.attach(target_addr, &#123;        onEnter: function(args) &#123;            console.log(&quot;Target function at &quot; + target_addr + &quot; entered&quot;);        &#125;,        onLeave: function(retval) &#123;            console.log(&quot;libbaiduprotect.so base address: &quot; + baseaddr);            hook_pthread_create();            listener.detach();        &#125;    &#125;);&#125;function hook_pthread_create() &#123;    let pthread_create_addr = Module.getExportByName(&quot;libc.so&quot;, &quot;pthread_create&quot;);    Interceptor.attach(pthread_create_addr, &#123;        onEnter: function(args) &#123;            let func_addr = args[2];            let target_func_addr = base_addr.add(0x3E9F0); // Calculate the target function address            if (func_addr.equals(target_func_addr)) &#123;                console.log(&quot;Replacing func_addr &quot; + func_addr + &quot; with empty function&quot;);                args[2] = empty_func; // Replace with the empty function                hook_libart(); // Execute hook_libart            &#125; else &#123;                let module = Process.findModuleByAddress(func_addr);                if (module &amp;&amp; module.name === module_name) &#123;                    console.log(&quot;pthread_create called in libbaiduprotect.so, function address: &quot; + func_addr);                &#125;            &#125;        &#125;,        onLeave: function(retval) &#123;            // Optionally log return value        &#125;    &#125;);&#125;const STD_STRING_SIZE = 3 * Process.pointerSize;class StdString &#123;    constructor() &#123;        this.handle = Memory.alloc(STD_STRING_SIZE);    &#125;    dispose() &#123;        const [data, isTiny] = this._getData();        if (!isTiny) &#123;            Java.api.$delete(data);        &#125;    &#125;    disposeToString() &#123;        const result = this.toString();        this.dispose();        return result;    &#125;    toString() &#123;        const [data] = this._getData();        return data.readUtf8String();    &#125;    _getData() &#123;        const str = this.handle;        const isTiny = (str.readU8() &amp; 1) === 0;        const data = isTiny ? str.add(1) : str.add(2 * Process.pointerSize).readPointer();        return [data, isTiny];    &#125;&#125;function prettyMethod(method_id, withSignature) &#123;    const result = new StdString();    Java.api[&#x27;art::ArtMethod::PrettyMethod&#x27;](result, method_id, withSignature ? 1 : 0);    return result.disposeToString();&#125;function hook_libart() &#123;    var symbols = Module.enumerateSymbolsSync(&quot;libart.so&quot;);    var addrGetStringUTFChars = null;    var addrNewStringUTF = null;    var addrFindClass = null;    var addrGetMethodID = null;    var addrGetStaticMethodID = null;    var addrGetFieldID = null;    var addrGetStaticFieldID = null;    var addrRegisterNatives = null;    var so_name = &quot;lib&quot;;      // TODO: Specify the SO to filter    for (var i = 0; i &lt; symbols.length; i++) &#123;        var symbol = symbols[i];        if (symbol.name.indexOf(&quot;art&quot;) &gt;= 0 &amp;&amp;            symbol.name.indexOf(&quot;JNI&quot;) &gt;= 0 &amp;&amp;            symbol.name.indexOf(&quot;CheckJNI&quot;) &lt; 0 &amp;&amp;            symbol.name.indexOf(&quot;_ZN3art3JNIILb0&quot;) &gt;= 0        ) &#123;            if (symbol.name.indexOf(&quot;GetStringUTFChars&quot;) &gt;= 0) &#123;                addrGetStringUTFChars = symbol.address;                console.log(&quot;GetStringUTFChars is at &quot;, symbol.address, symbol.name);            &#125; else if (symbol.name.indexOf(&quot;NewStringUTF&quot;) &gt;= 0) &#123;                addrNewStringUTF = symbol.address;                console.log(&quot;NewStringUTF is at &quot;, symbol.address, symbol.name);            &#125; else if (symbol.name.indexOf(&quot;FindClass&quot;) &gt;= 0) &#123;                addrFindClass = symbol.address;                console.log(&quot;FindClass is at &quot;, symbol.address, symbol.name);            &#125; else if (symbol.name.indexOf(&quot;GetMethodID&quot;) &gt;= 0) &#123;                addrGetMethodID = symbol.address;                console.log(&quot;GetMethodID is at &quot;, symbol.address, symbol.name);            &#125; else if (symbol.name.indexOf(&quot;GetStaticMethodID&quot;) &gt;= 0) &#123;                addrGetStaticMethodID = symbol.address;                console.log(&quot;GetStaticMethodID is at &quot;, symbol.address, symbol.name);            &#125; else if (symbol.name.indexOf(&quot;GetFieldID&quot;) &gt;= 0) &#123;                addrGetFieldID = symbol.address;                console.log(&quot;GetFieldID is at &quot;, symbol.address, symbol.name);            &#125; else if (symbol.name.indexOf(&quot;GetStaticFieldID&quot;) &gt;= 0) &#123;                addrGetStaticFieldID = symbol.address;                console.log(&quot;GetStaticFieldID is at &quot;, symbol.address, symbol.name);            &#125; else if (symbol.name.indexOf(&quot;RegisterNatives&quot;) &gt;= 0) &#123;                addrRegisterNatives = symbol.address;                console.log(&quot;RegisterNatives is at &quot;, symbol.address, symbol.name);            &#125; else if (symbol.name.indexOf(&quot;CallStatic&quot;) &gt;= 0) &#123;                console.log(&quot;CallStatic is at &quot;, symbol.address, symbol.name);                Interceptor.attach(symbol.address, &#123;                    onEnter: function (args) &#123;                        var module = Process.findModuleByAddress(this.returnAddress);                        if (module != null &amp;&amp; module.name.indexOf(so_name) == 0) &#123;                            var java_class = args[1];                            var mid = args[2];                            var class_name = Java.vm.tryGetEnv().getClassName(java_class);                            if (class_name.indexOf(&quot;java.&quot;) == -1 &amp;&amp; class_name.indexOf(&quot;android.&quot;) == -1) &#123;                                var method_name = prettyMethod(mid, 1);                                console.log(&quot;&lt;&gt;CallStatic:&quot;, DebugSymbol.fromAddress(this.returnAddress), class_name, method_name);                            &#125;                        &#125;                    &#125;,                    onLeave: function (retval) &#123; &#125;                &#125;);            &#125; else if (symbol.name.indexOf(&quot;CallNonvirtual&quot;) &gt;= 0) &#123;                console.log(&quot;CallNonvirtual is at &quot;, symbol.address, symbol.name);                Interceptor.attach(symbol.address, &#123;                    onEnter: function (args) &#123;                        var module = Process.findModuleByAddress(this.returnAddress);                        if (module != null &amp;&amp; module.name.indexOf(so_name) == 0) &#123;                            var jobject = args[1];                            var jclass = args[2];                            var jmethodID = args[3];                            var obj_class_name = Java.vm.tryGetEnv().getObjectClassName(jobject);                            var class_name = Java.vm.tryGetEnv().getClassName(jclass);                            if (class_name.indexOf(&quot;java.&quot;) == -1 &amp;&amp; class_name.indexOf(&quot;android.&quot;) == -1) &#123;                                var method_name = prettyMethod(jmethodID, 1);                                console.log(&quot;&lt;&gt;CallNonvirtual:&quot;, DebugSymbol.fromAddress(this.returnAddress), class_name, obj_class_name, method_name);                            &#125;                        &#125;                    &#125;,                    onLeave: function (retval) &#123; &#125;                &#125;);            &#125; else if (symbol.name.indexOf(&quot;Call&quot;) &gt;= 0 &amp;&amp; symbol.name.indexOf(&quot;Method&quot;) &gt;= 0) &#123;                console.log(&quot;Call&lt;&gt;Method is at &quot;, symbol.address, symbol.name);                Interceptor.attach(symbol.address, &#123;                    onEnter: function (args) &#123;                        var module = Process.findModuleByAddress(this.returnAddress);                        if (module != null &amp;&amp; module.name.indexOf(so_name) == 0) &#123;                            var java_class = args[1];                            var mid = args[2];                            var class_name = Java.vm.tryGetEnv().getObjectClassName(java_class);                            if (class_name.indexOf(&quot;java.&quot;) == -1 &amp;&amp; class_name.indexOf(&quot;android.&quot;) == -1) &#123;                                var method_name = prettyMethod(mid, 1);                                console.log(&quot;&lt;&gt;Call&lt;&gt;Method:&quot;, DebugSymbol.fromAddress(this.returnAddress), class_name, method_name);                            &#125;                        &#125;                    &#125;,                    onLeave: function (retval) &#123; &#125;                &#125;);            &#125;        &#125;    &#125;    if (addrGetStringUTFChars != null) &#123;        Interceptor.attach(addrGetStringUTFChars, &#123;            onEnter: function (args) &#123;            &#125;,            onLeave: function (retval) &#123;                if (retval != null) &#123;                    var module = Process.findModuleByAddress(this.returnAddress);                    if (module != null &amp;&amp; module.name.indexOf(so_name) == 0) &#123;                        var bytes = Memory.readCString(retval);                        console.log(&quot;[GetStringUTFChars] result:&quot; + bytes, DebugSymbol.fromAddress(this.returnAddress));                    &#125;                &#125;            &#125;        &#125;);    &#125;    if (addrNewStringUTF != null) &#123;        Interceptor.attach(addrNewStringUTF, &#123;            onEnter: function (args) &#123;                if (args[1] != null) &#123;                    var module = Process.findModuleByAddress(this.returnAddress);                    if (module != null &amp;&amp; module.name.indexOf(so_name) == 0) &#123;                        var string = Memory.readCString(args[1]);                        console.log(&quot;[NewStringUTF] bytes:&quot; + string, DebugSymbol.fromAddress(this.returnAddress));                    &#125;                &#125;            &#125;,            onLeave: function (retval) &#123; &#125;        &#125;);    &#125;    if (addrFindClass != null) &#123;        Interceptor.attach(addrFindClass, &#123;            onEnter: function (args) &#123;                if (args[1] != null) &#123;                    var module = Process.findModuleByAddress(this.returnAddress);                    if (module != null &amp;&amp; module.name.indexOf(so_name) == 0) &#123;                        var name = Memory.readCString(args[1]);                        console.log(&quot;[FindClass] name:&quot; + name, DebugSymbol.fromAddress(this.returnAddress));                    &#125;                &#125;            &#125;,            onLeave: function (retval) &#123; &#125;        &#125;);    &#125;    if (addrGetMethodID != null) &#123;        Interceptor.attach(addrGetMethodID, &#123;            onEnter: function (args) &#123;                if (args[2] != null) &#123;                    var clazz = args[1];                    var class_name = Java.vm.tryGetEnv().getClassName(clazz);                    var module = Process.findModuleByAddress(this.returnAddress);                    if (module != null &amp;&amp; module.name.indexOf(so_name) == 0) &#123;                        var name = Memory.readCString(args[2]);                        if (args[3] != null) &#123;                            var sig = Memory.readCString(args[3]);                            console.log(&quot;[GetMethodID] class_name:&quot; + class_name + &quot; name:&quot; + name + &quot;, sig:&quot; + sig, DebugSymbol.fromAddress(this.returnAddress));                        &#125; else &#123;                            console.log(&quot;[GetMethodID] class_name:&quot; + class_name + &quot; name:&quot; + name, DebugSymbol.fromAddress(this.returnAddress));                        &#125;                    &#125;                &#125;            &#125;,            onLeave: function (retval) &#123; &#125;        &#125;);    &#125;    if (addrGetStaticMethodID != null) &#123;        Interceptor.attach(addrGetStaticMethodID, &#123;            onEnter: function (args) &#123;                if (args[2] != null) &#123;                    var clazz = args[1];                    var class_name = Java.vm.tryGetEnv().getClassName(clazz);                    var module = Process.findModuleByAddress(this.returnAddress);                    if (module != null &amp;&amp; module.name.indexOf(so_name) == 0) &#123;                        var name = Memory.readCString(args[2]);                        if (args[3] != null) &#123;                            var sig = Memory.readCString(args[3]);                            console.log(&quot;[GetStaticMethodID] class_name:&quot; + class_name + &quot; name:&quot; + name + &quot;, sig:&quot; + sig, DebugSymbol.fromAddress(this.returnAddress));                        &#125; else &#123;                            console.log(&quot;[GetStaticMethodID] class_name:&quot; + class_name + &quot; name:&quot; + name, DebugSymbol.fromAddress(this.returnAddress));                        &#125;                    &#125;                &#125;            &#125;,            onLeave: function (retval) &#123; &#125;        &#125;);    &#125;    if (addrGetFieldID != null) &#123;        Interceptor.attach(addrGetFieldID, &#123;            onEnter: function (args) &#123;                if (args[2] != null) &#123;                    var module = Process.findModuleByAddress(this.returnAddress);                    if (module != null &amp;&amp; module.name.indexOf(so_name) == 0) &#123;                        var name = Memory.readCString(args[2]);                        if (args[3] != null) &#123;                            var sig = Memory.readCString(args[3]);                            console.log(&quot;[GetFieldID] name:&quot; + name + &quot;, sig:&quot; + sig, DebugSymbol.fromAddress(this.returnAddress));                        &#125; else &#123;                            console.log(&quot;[GetFieldID] name:&quot; + name, DebugSymbol.fromAddress(this.returnAddress));                        &#125;                    &#125;                &#125;            &#125;,            onLeave: function (retval) &#123; &#125;        &#125;);    &#125;    if (addrGetStaticFieldID != null) &#123;        Interceptor.attach(addrGetStaticFieldID, &#123;            onEnter: function (args) &#123;                if (args[2] != null) &#123;                    var module = Process.findModuleByAddress(this.returnAddress);                    if (module != null &amp;&amp; module.name.indexOf(so_name) == 0) &#123;                        var name = Memory.readCString(args[2]);                        if (args[3] != null) &#123;                            var sig = Memory.readCString(args[3]);                            console.log(&quot;[GetStaticFieldID] name:&quot; + name + &quot;, sig:&quot; + sig, DebugSymbol.fromAddress(this.returnAddress));                        &#125; else &#123;                            console.log(&quot;[GetStaticFieldID] name:&quot; + name, DebugSymbol.fromAddress(this.returnAddress));                        &#125;                    &#125;                &#125;            &#125;,            onLeave: function (retval) &#123; &#125;        &#125;);    &#125;    if (addrRegisterNatives != null) &#123;        Interceptor.attach(addrRegisterNatives, &#123;            onEnter: function (args) &#123;                console.log(&quot;[RegisterNatives] method_count:&quot;, args[3], DebugSymbol.fromAddress(this.returnAddress));                var env = args[0];                var java_class = args[1];                var class_name = Java.vm.tryGetEnv().getClassName(java_class);                var methods_ptr = ptr(args[2]);                var method_count = parseInt(args[3]);                for (var i = 0; i &lt; method_count; i++) &#123;                    var name_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3));                    var sig_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize));                    var fnPtr_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize * 2));                    var name = Memory.readCString(name_ptr);                    var sig = Memory.readCString(sig_ptr);                    var find_module = Process.findModuleByAddress(fnPtr_ptr);                    console.log(&quot;[RegisterNatives] java_class:&quot;, class_name, &quot;name:&quot;, name, &quot;sig:&quot;, sig, &quot;fnPtr:&quot;, fnPtr_ptr, &quot;module_name:&quot;, find_module.name, &quot;module_base:&quot;, find_module.base, &quot;offset:&quot;, ptr(fnPtr_ptr).sub(find_module.base));                &#125;            &#125;,            onLeave: function (retval) &#123; &#125;        &#125;);    &#125;&#125;hook_linker_call_constructors();\n\n成功打印出jni调用的函数，也就是说，离frida trace所有vmp的指令又进一步。\n\n暂时先到这吧，明天面携程，先复习一下加解密算法，之后继续复现vmp。\n ok，继续分析，也不知道携程能不能有个善终——20250514 09:28。\n我将jni调用的日志输出到文件中，慢慢看。\n我们要分析的被vmp的函数是onCreate，不妨猜测它会调用super.onCreate，而要实现super.onCreate，不能只靠vmp的解释器进行解释执行，还需要用到jni调用，因此可以在日志中搜索onCreate，于是得到下面的日志。\n于是，我们能确定了解释器是在哪里获取的onCreate的jmethod_id（0x5df18）和在哪里真正调用onCreate函数的（0x54370）。\n[GetMethodID] class_name:androidx.appcompat.app.AppCompatActivity name:onCreate, sig:(Landroid/os/Bundle;)V 0x743fd08f18 libbaiduprotect.so!0x5df18[GetMethodID] class_name:android.system.StructStatVfs name:&lt;init&gt;, sig:(JJJJJJJJJJJ)V 0x744a5310b4 libjavacore.so!0x310b4&lt;&gt;CallNonvirtual: 0x743fcff370 libbaiduprotect.so!0x54370 androidx.appcompat.app.AppCompatActivity com.example.test.MainActivity void androidx.appcompat.app.AppCompatActivity.onCreate(android.os.Bundle)\n\n不妨想想如何倒推——如果没有被vmp化，原onCreate中，大概率要执行super.onCreate，对应的smali指令，大概率是invoke-super，通过invoke-super调用父类的onCreate。\n先尝试将指令trace下来吧，试了一下，即便先绕过反调，仍然无法trace下来，那是什么原因呢？\n追踪指令流，发现执行到sub_45EBC后，程序便不会返回到BL sub_45EBC的下一条指令了，而sub_45EBC的最后一条指令是，将栈指针寄存器变成了0x1，难怪会退出——为什么使用frida-stalker之后，会出现这种问题呢？\nmov wsp, #1\n\n整理一下现有的信息，我知道：\n\n哪里调用了onCreate。\n\n执行sub_45EBC就会崩溃。\n\n\n那我是否可以根据onCreate的交叉引用，一步一步回推是哪个跳转出现了问题，最后进入了sub_45EBC退出的。\n已知0x5df18处会获取onCreate的method_id，而0x54370会调用onCreate，交叉引用一下这两个地址，发现两个函数都追踪到了.data节，除此之外，没有其它函数引用了它们。\n把函数地址存放在.data节中，而且不只一个函数地址，大概率是通过BLR或BR指令跳转的。\nBL和BLR的区别在，前者是通过PC相对偏移量跳转到目标函数在内存中的地址，而后者是跳转到寄存器中存储的地址，也就是说，BL的跳转地址基本是硬编码在指令里的，是编译时就确定的，而BLR可以根据寄存器的内容进行跳转，在运行时决定。这里这么多个地址放在一块，大概率在执行时要跳转很多个函数，所以使用有R的跳转指令。\n这里继续交叉引用off_BD040。\n\n\nBR X8，符合上面的分析。\n\n\n回到函数列表中，突然发现它有256个函数地址，smali的操作码是1个字节，对应256种操作，这里会不会就是vmp解释器模拟smali指令的地方？读取解密后的vmp_code_item，然后根据vmp_code_item里的每一条指令，模拟执行对应的函数。\n.data:00000000000BD040 58 CD 04 00 00 00 00 00 off_BD040       DCQ sub_4CD58           ; DATA XREF: sub_4CC20+C4↑o.data:00000000000BD048 8C CD 04 00 00 00 00 00                 DCQ sub_4CD8C.data:00000000000BD050 E0 CD 04 00 00 00 00 00                 DCQ sub_4CDE0.data:00000000000BD058 34 CE 04 00 00 00 00 00                 DCQ sub_4CE34.data:00000000000BD060 84 CE 04 00 00 00 00 00                 DCQ sub_4CE84.data:00000000000BD068 D4 CE 04 00 00 00 00 00                 DCQ sub_4CED4.data:00000000000BD070 24 CF 04 00 00 00 00 00                 DCQ sub_4CF24.data:00000000000BD078 70 CF 04 00 00 00 00 00                 DCQ sub_4CF70.data:00000000000BD080 C0 CF 04 00 00 00 00 00                 DCQ sub_4CFC0.data:00000000000BD088 10 D0 04 00 00 00 00 00                 DCQ sub_4D010.data:00000000000BD090 5C D0 04 00 00 00 00 00                 DCQ sub_4D05C.data:00000000000BD098 C0 D0 04 00 00 00 00 00                 DCQ sub_4D0C0.data:00000000000BD0A0 2C D1 04 00 00 00 00 00                 DCQ sub_4D12C.data:00000000000BD0A8 98 D1 04 00 00 00 00 00                 DCQ sub_4D198.data:00000000000BD0B0 DC 46 05 00 00 00 00 00                 DCQ loc_546DC           ; jumptable 0000000000053D00 cases 69,71,72,75,77-82,84,85,87-89.data:00000000000BD0B0                                                                 ; jumptable 0000000000053D50 cases 69,71,72,75,77-82,84,85,87-89.data:00000000000BD0B0                                                                 ; jumptable 0000000000053DAC cases 69,71,72,75,77-82,84,85,87-89.data:00000000000BD0B8 BC 46 05 00 00 00 00 00                 DCQ loc_546BC.data:00000000000BD0C0 14 D2 04 00 00 00 00 00                 DCQ sub_4D214.data:00000000000BD0C8 14 D2 04 00 00 00 00 00                 DCQ sub_4D214.data:00000000000BD0D0 34 D2 04 00 00 00 00 00                 DCQ loc_4D234.data:00000000000BD0D8 80 D2 04 00 00 00 00 00                 DCQ loc_4D280.data:00000000000BD0E0 D0 D2 04 00 00 00 00 00                 DCQ loc_4D2D0.data:00000000000BD0E8 24 D3 04 00 00 00 00 00                 DCQ loc_4D324.data:00000000000BD0F0 74 D3 04 00 00 00 00 00                 DCQ loc_4D374.data:00000000000BD0F8 C0 D3 04 00 00 00 00 00                 DCQ loc_4D3C0.data:00000000000BD100 18 D4 04 00 00 00 00 00                 DCQ loc_4D418.data:00000000000BD108 7C D4 04 00 00 00 00 00                 DCQ loc_4D47C.data:00000000000BD110 CC D4 04 00 00 00 00 00                 DCQ loc_4D4CC.data:00000000000BD118 44 D5 04 00 00 00 00 00                 DCQ loc_4D544.data:00000000000BD120 C4 D5 04 00 00 00 00 00                 DCQ loc_4D5C4.data:00000000000BD128 40 D6 04 00 00 00 00 00                 DCQ loc_4D640.data:00000000000BD130 A8 D6 04 00 00 00 00 00                 DCQ loc_4D6A8.data:00000000000BD138 24 D7 04 00 00 00 00 00                 DCQ loc_4D724.data:00000000000BD140 C4 D7 04 00 00 00 00 00                 DCQ loc_4D7C4.data:00000000000BD148 68 D8 04 00 00 00 00 00                 DCQ loc_4D868.data:00000000000BD150 E0 D8 04 00 00 00 00 00                 DCQ loc_4D8E0.data:00000000000BD158 C0 DA 04 00 00 00 00 00                 DCQ loc_4DAC0.data:00000000000BD160 90 33 05 00 00 00 00 00                 DCQ loc_53390.data:00000000000BD168 28 DC 04 00 00 00 00 00                 DCQ loc_4DC28.data:00000000000BD170 30 DC 04 00 00 00 00 00                 DCQ loc_4DC30.data:00000000000BD178 AC DC 04 00 00 00 00 00                 DCQ loc_4DCAC.data:00000000000BD180 E8 DC 04 00 00 00 00 00                 DCQ loc_4DCE8.data:00000000000BD188 24 DD 04 00 00 00 00 00                 DCQ loc_4DD24.data:00000000000BD190 60 DD 04 00 00 00 00 00                 DCQ loc_4DD60.data:00000000000BD198 A4 DD 04 00 00 00 00 00                 DCQ loc_4DDA4.data:00000000000BD1A0 24 DE 04 00 00 00 00 00                 DCQ loc_4DE24.data:00000000000BD1A8 A4 DE 04 00 00 00 00 00                 DCQ loc_4DEA4.data:00000000000BD1B0 30 DF 04 00 00 00 00 00                 DCQ loc_4DF30.data:00000000000BD1B8 B0 DF 04 00 00 00 00 00                 DCQ loc_4DFB0.data:00000000000BD1C0 34 E0 04 00 00 00 00 00                 DCQ loc_4E034.data:00000000000BD1C8 AC E0 04 00 00 00 00 00                 DCQ loc_4E0AC.data:00000000000BD1D0 28 E1 04 00 00 00 00 00                 DCQ loc_4E128.data:00000000000BD1D8 14 E2 04 00 00 00 00 00                 DCQ loc_4E214.data:00000000000BD1E0 00 E3 04 00 00 00 00 00                 DCQ loc_4E300.data:00000000000BD1E8 94 E3 04 00 00 00 00 00                 DCQ loc_4E394.data:00000000000BD1F0 28 E4 04 00 00 00 00 00                 DCQ loc_4E428.data:00000000000BD1F8 BC E4 04 00 00 00 00 00                 DCQ loc_4E4BC.data:00000000000BD200 50 E5 04 00 00 00 00 00                 DCQ loc_4E550.data:00000000000BD208 D4 E5 04 00 00 00 00 00                 DCQ loc_4E5D4.data:00000000000BD210 58 E6 04 00 00 00 00 00                 DCQ loc_4E658.data:00000000000BD218 E0 E6 04 00 00 00 00 00                 DCQ loc_4E6E0.data:00000000000BD220 68 E7 04 00 00 00 00 00                 DCQ loc_4E768.data:00000000000BD228 F0 E7 04 00 00 00 00 00                 DCQ loc_4E7F0.data:00000000000BD230 78 E8 04 00 00 00 00 00                 DCQ loc_4E878.data:00000000000BD238 78 E8 04 00 00 00 00 00                 DCQ loc_4E878.data:00000000000BD240 78 E8 04 00 00 00 00 00                 DCQ loc_4E878.data:00000000000BD248 78 E8 04 00 00 00 00 00                 DCQ loc_4E878.data:00000000000BD250 78 E8 04 00 00 00 00 00                 DCQ loc_4E878.data:00000000000BD258 78 E8 04 00 00 00 00 00                 DCQ loc_4E878.data:00000000000BD260 78 E8 04 00 00 00 00 00                 DCQ loc_4E878.data:00000000000BD268 A4 E9 04 00 00 00 00 00                 DCQ loc_4E9A4.data:00000000000BD270 A4 EA 04 00 00 00 00 00                 DCQ loc_4EAA4.data:00000000000BD278 30 EC 04 00 00 00 00 00                 DCQ loc_4EC30.data:00000000000BD280 1C ED 04 00 00 00 00 00                 DCQ loc_4ED1C.data:00000000000BD288 E0 ED 04 00 00 00 00 00                 DCQ loc_4EDE0.data:00000000000BD290 A0 EE 04 00 00 00 00 00                 DCQ loc_4EEA0.data:00000000000BD298 64 EF 04 00 00 00 00 00                 DCQ loc_4EF64.data:00000000000BD2A0 60 F0 04 00 00 00 00 00                 DCQ loc_4F060.data:00000000000BD2A8 50 F1 04 00 00 00 00 00                 DCQ loc_4F150.data:00000000000BD2B0 F4 F1 04 00 00 00 00 00                 DCQ loc_4F1F4.data:00000000000BD2B8 9C F2 04 00 00 00 00 00                 DCQ loc_4F29C.data:00000000000BD2C0 44 F3 04 00 00 00 00 00                 DCQ loc_4F344.data:00000000000BD2C8 EC F3 04 00 00 00 00 00                 DCQ loc_4F3EC.data:00000000000BD2D0 94 F4 04 00 00 00 00 00                 DCQ loc_4F494.data:00000000000BD2D8 6C F5 04 00 00 00 00 00                 DCQ loc_4F56C.data:00000000000BD2E0 30 F6 04 00 00 00 00 00                 DCQ loc_4F630.data:00000000000BD2E8 A4 F7 04 00 00 00 00 00                 DCQ loc_4F7A4.data:00000000000BD2F0 4C F8 04 00 00 00 00 00                 DCQ loc_4F84C.data:00000000000BD2F8 F8 F8 04 00 00 00 00 00                 DCQ loc_4F8F8.data:00000000000BD300 A0 F9 04 00 00 00 00 00                 DCQ loc_4F9A0.data:00000000000BD308 4C FA 04 00 00 00 00 00                 DCQ loc_4FA4C.data:00000000000BD310 0C FB 04 00 00 00 00 00                 DCQ loc_4FB0C.data:00000000000BD318 C8 FB 04 00 00 00 00 00                 DCQ loc_4FBC8.data:00000000000BD320 68 FC 04 00 00 00 00 00                 DCQ loc_4FC68.data:00000000000BD328 0C FD 04 00 00 00 00 00                 DCQ loc_4FD0C.data:00000000000BD330 B0 FD 04 00 00 00 00 00                 DCQ loc_4FDB0.data:00000000000BD338 54 FE 04 00 00 00 00 00                 DCQ loc_4FE54.data:00000000000BD340 F8 FE 04 00 00 00 00 00                 DCQ loc_4FEF8.data:00000000000BD348 C0 FF 04 00 00 00 00 00                 DCQ loc_4FFC0.data:00000000000BD350 78 00 05 00 00 00 00 00                 DCQ loc_50078.data:00000000000BD358 E8 01 05 00 00 00 00 00                 DCQ loc_501E8.data:00000000000BD360 88 02 05 00 00 00 00 00                 DCQ loc_50288.data:00000000000BD368 2C 03 05 00 00 00 00 00                 DCQ loc_5032C.data:00000000000BD370 CC 03 05 00 00 00 00 00                 DCQ loc_503CC.data:00000000000BD378 70 04 05 00 00 00 00 00                 DCQ loc_50470.data:00000000000BD380 24 05 05 00 00 00 00 00                 DCQ loc_50524.data:00000000000BD388 D4 05 05 00 00 00 00 00                 DCQ loc_505D4.data:00000000000BD390 6C 06 05 00 00 00 00 00                 DCQ loc_5066C.data:00000000000BD398 08 07 05 00 00 00 00 00                 DCQ loc_50708.data:00000000000BD3A0 A4 07 05 00 00 00 00 00                 DCQ loc_507A4.data:00000000000BD3A8 40 08 05 00 00 00 00 00                 DCQ loc_50840.data:00000000000BD3B0 74 37 05 00 00 00 00 00                 DCQ loc_53774.data:00000000000BD3B8 C4 37 05 00 00 00 00 00                 DCQ loc_537C4.data:00000000000BD3C0 9C 38 05 00 00 00 00 00                 DCQ loc_5389C.data:00000000000BD3C8 CC 39 05 00 00 00 00 00                 DCQ loc_539CC.data:00000000000BD3D0 44 38 05 00 00 00 00 00                 DCQ loc_53844.data:00000000000BD3D8 70 37 05 00 00 00 00 00                 DCQ loc_53770.data:00000000000BD3E0 70 37 05 00 00 00 00 00                 DCQ loc_53770.data:00000000000BD3E8 C0 37 05 00 00 00 00 00                 DCQ loc_537C0.data:00000000000BD3F0 DC 08 05 00 00 00 00 00                 DCQ loc_508DC.data:00000000000BD3F8 C8 39 05 00 00 00 00 00                 DCQ loc_539C8.data:00000000000BD400 40 38 05 00 00 00 00 00                 DCQ loc_53840.data:00000000000BD408 F4 08 05 00 00 00 00 00                 DCQ loc_508F4.data:00000000000BD410 F4 08 05 00 00 00 00 00                 DCQ loc_508F4.data:00000000000BD418 F4 08 05 00 00 00 00 00                 DCQ loc_508F4.data:00000000000BD420 4C 09 05 00 00 00 00 00                 DCQ loc_5094C.data:00000000000BD428 A4 09 05 00 00 00 00 00                 DCQ loc_509A4.data:00000000000BD430 F8 09 05 00 00 00 00 00                 DCQ loc_509F8.data:00000000000BD438 4C 0A 05 00 00 00 00 00                 DCQ loc_50A4C.data:00000000000BD440 AC 0A 05 00 00 00 00 00                 DCQ loc_50AAC.data:00000000000BD448 00 0B 05 00 00 00 00 00                 DCQ loc_50B00.data:00000000000BD450 54 0B 05 00 00 00 00 00                 DCQ loc_50B54.data:00000000000BD458 B4 0B 05 00 00 00 00 00                 DCQ loc_50BB4.data:00000000000BD460 10 0C 05 00 00 00 00 00                 DCQ loc_50C10.data:00000000000BD468 68 0C 05 00 00 00 00 00                 DCQ loc_50C68.data:00000000000BD470 C4 0C 05 00 00 00 00 00                 DCQ loc_50CC4.data:00000000000BD478 18 0D 05 00 00 00 00 00                 DCQ loc_50D18.data:00000000000BD480 B8 0D 05 00 00 00 00 00                 DCQ loc_50DB8.data:00000000000BD488 50 0E 05 00 00 00 00 00                 DCQ loc_50E50.data:00000000000BD490 A8 0E 05 00 00 00 00 00                 DCQ loc_50EA8.data:00000000000BD498 44 0F 05 00 00 00 00 00                 DCQ loc_50F44.data:00000000000BD4A0 D8 0F 05 00 00 00 00 00                 DCQ loc_50FD8.data:00000000000BD4A8 34 10 05 00 00 00 00 00                 DCQ loc_51034.data:00000000000BD4B0 88 10 05 00 00 00 00 00                 DCQ loc_51088.data:00000000000BD4B8 DC 10 05 00 00 00 00 00                 DCQ loc_510DC.data:00000000000BD4C0 30 11 05 00 00 00 00 00                 DCQ loc_51130.data:00000000000BD4C8 98 11 05 00 00 00 00 00                 DCQ loc_51198.data:00000000000BD4D0 00 12 05 00 00 00 00 00                 DCQ loc_51200.data:00000000000BD4D8 68 12 05 00 00 00 00 00                 DCQ loc_51268.data:00000000000BD4E0 0C 13 05 00 00 00 00 00                 DCQ loc_5130C.data:00000000000BD4E8 98 13 05 00 00 00 00 00                 DCQ loc_51398.data:00000000000BD4F0 00 14 05 00 00 00 00 00                 DCQ loc_51400.data:00000000000BD4F8 68 14 05 00 00 00 00 00                 DCQ loc_51468.data:00000000000BD500 D0 14 05 00 00 00 00 00                 DCQ loc_514D0.data:00000000000BD508 3C 15 05 00 00 00 00 00                 DCQ loc_5153C.data:00000000000BD510 A8 15 05 00 00 00 00 00                 DCQ loc_515A8.data:00000000000BD518 14 16 05 00 00 00 00 00                 DCQ loc_51614.data:00000000000BD520 74 16 05 00 00 00 00 00                 DCQ loc_51674.data:00000000000BD528 D4 16 05 00 00 00 00 00                 DCQ loc_516D4.data:00000000000BD530 34 17 05 00 00 00 00 00                 DCQ loc_51734.data:00000000000BD538 C4 17 05 00 00 00 00 00                 DCQ loc_517C4.data:00000000000BD540 48 18 05 00 00 00 00 00                 DCQ loc_51848.data:00000000000BD548 A8 18 05 00 00 00 00 00                 DCQ loc_518A8.data:00000000000BD550 08 19 05 00 00 00 00 00                 DCQ loc_51908.data:00000000000BD558 68 19 05 00 00 00 00 00                 DCQ loc_51968.data:00000000000BD560 D0 19 05 00 00 00 00 00                 DCQ loc_519D0.data:00000000000BD568 38 1A 05 00 00 00 00 00                 DCQ loc_51A38.data:00000000000BD570 A0 1A 05 00 00 00 00 00                 DCQ loc_51AA0.data:00000000000BD578 10 1B 05 00 00 00 00 00                 DCQ loc_51B10.data:00000000000BD580 80 1B 05 00 00 00 00 00                 DCQ loc_51B80.data:00000000000BD588 F0 1B 05 00 00 00 00 00                 DCQ loc_51BF0.data:00000000000BD590 60 1C 05 00 00 00 00 00                 DCQ loc_51C60.data:00000000000BD598 F0 1C 05 00 00 00 00 00                 DCQ loc_51CF0.data:00000000000BD5A0 50 1D 05 00 00 00 00 00                 DCQ loc_51D50.data:00000000000BD5A8 B0 1D 05 00 00 00 00 00                 DCQ loc_51DB0.data:00000000000BD5B0 10 1E 05 00 00 00 00 00                 DCQ loc_51E10.data:00000000000BD5B8 70 1E 05 00 00 00 00 00                 DCQ loc_51E70.data:00000000000BD5C0 F0 1E 05 00 00 00 00 00                 DCQ loc_51EF0.data:00000000000BD5C8 50 1F 05 00 00 00 00 00                 DCQ loc_51F50.data:00000000000BD5D0 B0 1F 05 00 00 00 00 00                 DCQ loc_51FB0.data:00000000000BD5D8 10 20 05 00 00 00 00 00                 DCQ loc_52010.data:00000000000BD5E0 A0 20 05 00 00 00 00 00                 DCQ loc_520A0.data:00000000000BD5E8 24 21 05 00 00 00 00 00                 DCQ loc_52124.data:00000000000BD5F0 84 21 05 00 00 00 00 00                 DCQ loc_52184.data:00000000000BD5F8 E4 21 05 00 00 00 00 00                 DCQ loc_521E4.data:00000000000BD600 44 22 05 00 00 00 00 00                 DCQ loc_52244.data:00000000000BD608 A8 22 05 00 00 00 00 00                 DCQ loc_522A8.data:00000000000BD610 0C 23 05 00 00 00 00 00                 DCQ loc_5230C.data:00000000000BD618 70 23 05 00 00 00 00 00                 DCQ loc_52370.data:00000000000BD620 CC 23 05 00 00 00 00 00                 DCQ loc_523CC.data:00000000000BD628 28 24 05 00 00 00 00 00                 DCQ loc_52428.data:00000000000BD630 84 24 05 00 00 00 00 00                 DCQ loc_52484.data:00000000000BD638 0C 25 05 00 00 00 00 00                 DCQ loc_5250C.data:00000000000BD640 88 25 05 00 00 00 00 00                 DCQ loc_52588.data:00000000000BD648 E4 25 05 00 00 00 00 00                 DCQ loc_525E4.data:00000000000BD650 40 26 05 00 00 00 00 00                 DCQ loc_52640.data:00000000000BD658 9C 26 05 00 00 00 00 00                 DCQ loc_5269C.data:00000000000BD660 00 27 05 00 00 00 00 00                 DCQ loc_52700.data:00000000000BD668 64 27 05 00 00 00 00 00                 DCQ loc_52764.data:00000000000BD670 C8 27 05 00 00 00 00 00                 DCQ loc_527C8.data:00000000000BD678 2C 28 05 00 00 00 00 00                 DCQ loc_5282C.data:00000000000BD680 90 28 05 00 00 00 00 00                 DCQ loc_52890.data:00000000000BD688 F4 28 05 00 00 00 00 00                 DCQ loc_528F4.data:00000000000BD690 58 29 05 00 00 00 00 00                 DCQ loc_52958.data:00000000000BD698 DC 29 05 00 00 00 00 00                 DCQ loc_529DC.data:00000000000BD6A0 38 2A 05 00 00 00 00 00                 DCQ loc_52A38.data:00000000000BD6A8 94 2A 05 00 00 00 00 00                 DCQ loc_52A94.data:00000000000BD6B0 F0 2A 05 00 00 00 00 00                 DCQ loc_52AF0.data:00000000000BD6B8 4C 2B 05 00 00 00 00 00                 DCQ loc_52B4C.data:00000000000BD6C0 C8 2B 05 00 00 00 00 00                 DCQ loc_52BC8.data:00000000000BD6C8 24 2C 05 00 00 00 00 00                 DCQ loc_52C24.data:00000000000BD6D0 80 2C 05 00 00 00 00 00                 DCQ loc_52C80.data:00000000000BD6D8 DC 2C 05 00 00 00 00 00                 DCQ loc_52CDC.data:00000000000BD6E0 70 2D 05 00 00 00 00 00                 DCQ loc_52D70.data:00000000000BD6E8 F8 2D 05 00 00 00 00 00                 DCQ loc_52DF8.data:00000000000BD6F0 54 2E 05 00 00 00 00 00                 DCQ loc_52E54.data:00000000000BD6F8 B0 2E 05 00 00 00 00 00                 DCQ loc_52EB0.data:00000000000BD700 0C 2F 05 00 00 00 00 00                 DCQ loc_52F0C.data:00000000000BD708 6C 2F 05 00 00 00 00 00                 DCQ loc_52F6C.data:00000000000BD710 D0 2F 05 00 00 00 00 00                 DCQ loc_52FD0.data:00000000000BD718 34 30 05 00 00 00 00 00                 DCQ loc_53034.data:00000000000BD720 C8 30 05 00 00 00 00 00                 DCQ loc_530C8.data:00000000000BD728 50 31 05 00 00 00 00 00                 DCQ loc_53150.data:00000000000BD730 B0 31 05 00 00 00 00 00                 DCQ loc_531B0.data:00000000000BD738 10 32 05 00 00 00 00 00                 DCQ loc_53210.data:00000000000BD740 70 32 05 00 00 00 00 00                 DCQ loc_53270.data:00000000000BD748 D0 32 05 00 00 00 00 00                 DCQ loc_532D0.data:00000000000BD750 30 33 05 00 00 00 00 00                 DCQ loc_53330.data:00000000000BD758 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD760 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD768 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD770 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD778 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD780 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD788 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD790 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD798 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD7A0 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD7A8 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD7B0 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD7B8 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD7C0 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD7C8 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD7D0 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD7D8 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD7E0 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD7E8 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD7F0 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD7F8 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD800 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD808 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD810 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD818 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD820 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD828 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD830 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD838 98 33 05 00 00 00 00 00                 DCQ loc_53398\n\n继续交叉引用sub_4CC20，来到了关键的地方，基本可以确认sub_4CC20就是解释器了。\n\nhook了一些libc的open、strstr、read、strcmp之类的函数，并没有发现对frida的检测，好奇怪，那为什么会执行到sub_45EBC就崩溃呢？\n对着sub_45EBC进行分析，发现一个比较关键的地方。\n\n这个时候，可以打开我们之前trace的汇编指令，究竟是谁让w8变成了0。从0x4ad0c往上找，关于x8&#x2F;w8的赋值。\n\n很容易就找到，x11存放了一个地址，而x10的值为0，因此w8变成了0，继续追踪x10&#x2F;x11的含义。\n\n可以根据减去基址，看看x8和x0的含义，基址是0x743fc99000。\nx0对应0x2F38BFB0，x8对应0x2D40FEC78，看来调用的不是libbaiduprotect.so的函数，应该是别的库，所以减错了基址。\n我在ida中还原过这个地方，x8是malloc的运行地址，所以这里的x0是分配到的空间地址，和我想得不太一样啊？\n\n这说明，进入sub_45EBC函数后，应该是能正常出来的。\n其实仔细观察，为什么会发生崩溃呢？MOV WSP, #1虽然将栈顶寄存器指向了一个会奇怪的地方，但下一条指令很快的覆盖了SP的内容，因此应该不会造成崩溃，那问题只能处在frida-stalker了，它是不是在插桩的时候用到了SP？\n\n我们来看一下frida-stalker的原理。\n\n离我们的猜想很近，如果插桩的黄色代码中，使用到了sp寄存器，就会把程序弄崩溃，我们试试能不能在识别到MOV WSP, #1时候将它NOP掉，不执行，避免产生这样的问题。\n代码如下，下面这个代码可以绕过这一条指令，继续打印追踪的流程。\nvar offset = 0x88060;var module_size = 0;var module_name = &quot;libbaiduprotect.so&quot;;var base_addr = null; // To store the base address of libbaiduprotect.so// Create an empty functionvar empty_func = new NativeCallback(function() &#123;    // console.log(&quot;[Anti-Debug] Empty function executed.&quot;); // 可选日志    return 0;&#125;, &#x27;int&#x27;, [&#x27;pointer&#x27;]);function hook_linker_call_constructors() &#123;    // 为提高健壮性，建议使用更完善的 linker 及 call_constructors 查找逻辑    // 但为保持与你原始脚本的结构，暂时保留这种直接方式    let linker_module_name = Process.arch === &#x27;arm64&#x27; ? &#x27;linker64&#x27; : &#x27;linker&#x27;;    let linker64_base_addr = Module.getBaseAddress(linker_module_name);    if (!linker64_base_addr) &#123;        console.warn(&quot;[-] Failed to get &quot; + linker_module_name + &quot; base address. Trying to find module directly later.&quot;);        // Fallback if linker not found        setTimeout(function() &#123;            if (!base_addr) &#123; // Check if already found                let secmodule = Process.findModuleByName(module_name);                if (secmodule) &#123;                    base_addr = secmodule.base;                    module_size = secmodule.size;                    console.log(module_name + &quot; base (fallback): &quot; + base_addr + &quot;, size: &quot; + module_size);                    hook_target_func(base_addr);                &#125; else &#123;                    console.error(&quot;[-] &quot; + module_name + &quot; not found via fallback. Cannot proceed.&quot;);                &#125;            &#125;        &#125;, 1500); // Delay slightly        return;    &#125;    let offset_call = 0x51BA8; // __dl__ZN6soinfo17call_constructorsEv - 这个偏移非常依赖系统    let call_constructors = linker64_base_addr.add(offset_call);    console.log(&quot;[i] Attempting to attach to linker&#x27;s call_constructors at &quot; + call_constructors);    try &#123;        let listener = Interceptor.attach(call_constructors, &#123;            onEnter: function(args) &#123;                // console.log(&#x27;[linker] Call_Constructors onEnter&#x27;);                let secmodule = Process.findModuleByName(module_name);                if (secmodule != null) &#123;                    if (base_addr === null) &#123; // 确保只初始化一次                        module_size = secmodule.size;                        base_addr = secmodule.base; // Save the base address                        console.log(module_name + &quot; base: &quot; + base_addr + &quot;, size: &quot; + module_size);                                                // *** 在这里也可以考虑直接打补丁已知崩溃点, 但Stalker内处理更灵活些 ***                        // patchInstructionToNop(base_addr, 0x48AC0, 4);                        // patchInstructionToNop(base_addr, 0x4ABB8, 4);                        hook_target_func(base_addr);                        listener.detach();                        console.log(&quot;[i] Detached from linker hook.&quot;);                    &#125;                &#125;            &#125;        &#125;);    &#125; catch (e) &#123;        console.error(&quot;[-] Failed to attach to linker&#x27;s call_constructors: &quot; + e.message);        console.log(&quot;    Will rely on fallback to find module &quot; + module_name);         setTimeout(function() &#123; // 与上面的 fallback 逻辑类似            if (!base_addr) &#123;                let secmodule = Process.findModuleByName(module_name);                if (secmodule) &#123;                    base_addr = secmodule.base;                    module_size = secmodule.size;                    console.log(module_name + &quot; base (fallback after attach error): &quot; + base_addr + &quot;, size: &quot; + module_size);                    hook_target_func(base_addr);                &#125; else &#123;                    console.error(&quot;[-] Fallback after attach error: &quot; + module_name + &quot; not found.&quot;);                &#125;            &#125;        &#125;, 1500);    &#125;&#125;function hook_target_func(current_base_addr) &#123; // 使用 current_base_addr 区分全局 base_addr    if (!current_base_addr || current_base_addr.isNull())&#123;        console.error(&quot;[-] hook_target_func: current_base_addr is invalid.&quot;);        return;    &#125;    let target_addr = current_base_addr.add(offset); // offset = 0x88060    console.log(&quot;[+] Hooking target function at &quot; + target_addr + &quot; (offset 0x&quot; + offset.toString(16) + &quot;)&quot;);    try &#123;        let listener = Interceptor.attach(target_addr, &#123;            onEnter: function(args) &#123;                console.log(&quot;Target function &quot; + module_name + &quot;!0x&quot; + offset.toString(16) + &quot; entered. Called from: &quot; + this.returnAddress);            &#125;,            onLeave: function(retval) &#123;                console.log(module_name + &quot;!0x&quot; + offset.toString(16) + &quot; onLeave. Base address: &quot; + current_base_addr);                if (base_addr &amp;&amp; !base_addr.isNull()) &#123; // 确保全局base_addr有效                    hook_pthread_create();                    StalkerTrace(base_addr); // 传递正确的模块基址给StalkerTrace                &#125; else &#123;                    console.error(&quot;[-] Global base_addr not set in hook_target_func onLeave. Cannot start Stalker / pthread hook.&quot;);                &#125;                listener.detach();                console.log(&quot;[i] Detached from target_func hook at &quot; + target_addr);            &#125;        &#125;);    &#125; catch (e) &#123;        console.error(&quot;[-] Failed to attach to target_func at &quot; + target_addr + &quot;: &quot; + e.message);    &#125;&#125;function hook_pthread_create() &#123;    if (!base_addr || base_addr.isNull()) &#123;        console.error(&quot;[-] hook_pthread_create: Global base_addr is null.&quot;);        return;    &#125;    let pthread_create_addr = Module.findExportByName(&quot;libc.so&quot;, &quot;pthread_create&quot;);    if (pthread_create_addr) &#123;        console.log(&quot;[+] Hooking pthread_create at &quot; + pthread_create_addr);        try &#123;            Interceptor.attach(pthread_create_addr, &#123;                onEnter: function(args) &#123;                    let func_addr = args[2];                    let target_func_addr = base_addr.add(0x3E9F0);                    if (func_addr.equals(target_func_addr)) &#123;                        console.log(&quot;[Anti-Debug] Replacing thread start_routine &quot; + func_addr + &quot; with empty function.&quot;);                        args[2] = empty_func;                    &#125;                &#125;            &#125;);        &#125; catch (e) &#123;            console.error(&quot;[-] Failed to attach to pthread_create: &quot; + e.message);        &#125;    &#125; else &#123;        console.warn(&quot;[-] pthread_create not found in libc.so. Hook skipped.&quot;);    &#125;&#125;const TARGET_MODULE_NAME = &quot;libbaiduprotect.so&quot;; // 等同于 module_namefunction get_diff_regs(context, pre_regs) &#123;    var diff_regs = &#123;&#125;;    const current_regs_snapshot = JSON.parse(JSON.stringify(context));    for (const reg_name_orig in current_regs_snapshot) &#123;        if (current_regs_snapshot.hasOwnProperty(reg_name_orig)) &#123;            const reg_name = reg_name_orig.toLowerCase();            if (reg_name !== &quot;pc&quot; &amp;&amp; !reg_name.startsWith(&quot;q&quot;) &amp;&amp; reg_name !== &quot;sp&quot;) &#123; // 也可以过滤掉sp                if (pre_regs[reg_name_orig] !== current_regs_snapshot[reg_name_orig]) &#123;                    pre_regs[reg_name_orig] = current_regs_snapshot[reg_name_orig];                    diff_regs[reg_name_orig] = current_regs_snapshot[reg_name_orig];                &#125;            &#125;        &#125;    &#125;    return diff_regs;&#125;function get_involved_regs(instruction) &#123; /* ... (保持不变) ... */    const involved_regs = new Set();    instruction.operands.forEach(op =&gt; &#123;        if (op.type === &#x27;reg&#x27;) &#123; involved_regs.add(op.value); &#125;        else if (op.type === &#x27;mem&#x27;) &#123;            if (op.value.base) &#123; involved_regs.add(op.value.base); &#125;            if (op.value.index) &#123; involved_regs.add(op.value.index); &#125;        &#125;    &#125;);    return Array.from(involved_regs);&#125;// =======================================================================================// 修改 StalkerTrace 函数// =======================================================================================function StalkerTrace(current_module_baseaddr) &#123; // 确保传入的是正确的模块基地址    var stalker_target_func_offset = 0x4a458; // 这是你希望Stalker开始追踪的函数偏移    var sub_42598_addr = current_module_baseaddr.add(stalker_target_func_offset);    console.log(&quot;[+] StalkerTrace will target &quot; + TARGET_MODULE_NAME + &quot;!&quot; + ptr(stalker_target_func_offset) + &quot; at actual address: &quot; + sub_42598_addr);    var module_stalk_target = Process.findModuleByAddress(sub_42598_addr);    if (!module_stalk_target || module_stalk_target.name !== TARGET_MODULE_NAME) &#123;        console.error(&quot;[-] StalkerTrace: Module for target function (&quot; + sub_42598_addr + &quot;) is not &quot; + TARGET_MODULE_NAME +                      &quot;. Found: &quot; + (module_stalk_target ? module_stalk_target.name : &quot;none&quot;) +                      &quot;. Ensure base address and offset are correct. Stalker might not work as expected.&quot;);        // 如果模块名不匹配，我们可能不应该继续，或者用传入的 baseaddr 作为module_start/end的依据        if (!current_module_baseaddr || current_module_baseaddr.isNull()) &#123;            console.error(&quot;[-] StalkerTrace: No valid base address to proceed with module bounds.&quot;);            return;        &#125;         module_stalk_target = &#123; base: current_module_baseaddr, size: module_size, name: TARGET_MODULE_NAME &#125;; // module_size 是全局的         console.warn(&quot;[-] StalkerTrace: Using passed base_addr for module bounds for Stalker.&quot;);    &#125;        const module_start = module_stalk_target.base;    const module_end = module_stalk_target.base.add(module_stalk_target.size); // Stalker只记录此模块内的指令    console.log(&quot;[i] Stalker module bounds: Start=&quot; + module_start + &quot;, End=&quot; + module_end);    Interceptor.attach(sub_42598_addr, &#123;        onEnter: function (args) &#123;            this.tid = Process.getCurrentThreadId();            console.log(&quot;[+] Stalker: Entered &quot; + TARGET_MODULE_NAME + &quot;!&quot; + ptr(stalker_target_func_offset) + &quot; (TID: &quot; + this.tid + &quot;)&quot;);            const local_pre_regs = &#123;&#125;;            const initial_context_snapshot = JSON.parse(JSON.stringify(this.context));            for (const reg_name_orig in initial_context_snapshot) &#123;                if (initial_context_snapshot.hasOwnProperty(reg_name_orig)) &#123;                    const reg_name = reg_name_orig.toLowerCase();                    if (reg_name !== &quot;pc&quot; &amp;&amp; !reg_name.startsWith(&quot;q&quot;)) &#123;                        local_pre_regs[reg_name_orig] = initial_context_snapshot[reg_name_orig];                    &#125;                &#125;            &#125;                        // === 新增：用于直接patch的已知崩溃点 ===            // 这些地址相对于 current_module_baseaddr (即 libbaiduprotect.so 的基地址)            const knownCrashOffsets = [0x48AC0, 0x4ABB8]; // 把已知的都列出来            knownCrashOffsets.forEach(offset =&gt; &#123;                try &#123;                    const patchAddr = current_module_baseaddr.add(offset);                    // 读取指令，确认是否是 MOV WSP, #1                    const instrBytes = patchAddr.readByteArray(4);                    // MOV WSP, #1 (MOVZ W31, #1, LSL #0) -&gt; FF 03 00 32 (Little Endian: 320003FF)                    if (instrBytes &amp;&amp; instrBytes[0] === 0x32 &amp;&amp; instrBytes[1] === 0x00 &amp;&amp; instrBytes[2] === 0x03 &amp;&amp; instrBytes[3] === 0xFF) &#123;                        Memory.patchCode(patchAddr, 4, code =&gt; &#123;                            const writer = new Arm64Writer(code, &#123; pc: patchAddr &#125;);                            writer.putNop();                            writer.flush();                        &#125;);                        console.log(&quot;[MemoryPatch] Stalker&#x27;s onEnter: NOPped known crash (MOV WSP, #1) at &quot; + module_name + &quot;!&quot; + ptr(offset) + &quot; (&quot;+ patchAddr + &quot;)&quot;);                    &#125; else &#123;                        // console.log(&quot;[MemoryPatch] Stalker&#x27;s onEnter: Instruction at &quot; + module_name + &quot;!&quot; + ptr(offset) + &quot; is not MOV WSP, #1. Bytes: &quot; + Array.from(new Uint8Array(instrBytes)).map(b =&gt; b.toString(16).padStart(2,&#x27;0&#x27;)).join(&#x27;&#x27;));                    &#125;                &#125; catch (e) &#123;                    console.warn(&quot;[MemoryPatch] Stalker&#x27;s onEnter: Error patching &quot; + module_name + &quot;!&quot; + ptr(offset) + &quot;: &quot; + e.message);                &#125;            &#125;);            // =====================================            Stalker.follow(this.tid, &#123;                events: &#123; call: false, ret: false, exec: true, block: false, compile: false &#125;,                transform(iterator) &#123;                    let instruction = iterator.next();                    do &#123;                        const currentAddress = instruction.address;                        let patchedThisInstruction = false;                        // 通用的 MOV WSP/SP, #1 检测和NOP逻辑 (作为补充)                        const mnemonic = instruction.mnemonic.toLowerCase();                        if ((mnemonic === &#x27;mov&#x27; || mnemonic === &#x27;movz&#x27;) &amp;&amp; instruction.operands.length &gt;= 2) &#123;                            const destOperand = instruction.operands[0];                            const srcOperand = instruction.operands[1];                            if (destOperand.type === &#x27;reg&#x27; &amp;&amp;                                (destOperand.value === &#x27;wsp&#x27; || destOperand.value === &#x27;sp&#x27; ||                                 destOperand.value === &#x27;w31&#x27; || destOperand.value === &#x27;x31&#x27;) &amp;&amp;                                srcOperand.type === &#x27;imm&#x27; &amp;&amp;                                parseInt(srcOperand.value.toString()) === 1) &#123;                                console.warn(&quot;[StalkerTransform] Identified &#x27;&quot; + instruction.toString() + &quot;&#x27; at &quot; + currentAddress + &quot;. Replacing with NOP.&quot;);                                iterator.putNop();                                patchedThisInstruction = true;                            &#125;                        &#125;                        if (!patchedThisInstruction) &#123;                            // 仅在模块代码范围内执行putCallout，减少日志量并避免干扰其他模块                            const is_module_code = currentAddress.compare(module_start) &gt;= 0 &amp;&amp;                                                   currentAddress.compare(module_end) &lt; 0;                            if (is_module_code) &#123;                                iterator.putCallout(function (context) &#123;                                    var pc = context.pc;                                    // module_start, module_end, TARGET_MODULE_NAME, get_diff_regs, local_pre_regs                                    // 这些变量需要能被这个闭包访问到。local_pre_regs 是 onEnter 作用域的。                                    // module_start 等可以考虑从外部作用域传入或再次获取。                                    // 为简化，假设它们可访问。                                    var current_callout_module = Process.findModuleByAddress(pc);                                    if (current_callout_module &amp;&amp; current_callout_module.name === TARGET_MODULE_NAME) &#123;                                        const instrToLog = Instruction.parse(pc);                                        const diff_regs = get_diff_regs(context, local_pre_regs);                                        console.log(                                            current_callout_module.name + &quot;!&quot; + pc.sub(current_callout_module.base),                                            instrToLog.toString(),                                            &quot;\\t\\t&quot;, JSON.stringify(diff_regs)                                        );                                    &#125;                                &#125;);                            &#125;                            iterator.keep();                        &#125;                    &#125; while ((instruction = iterator.next()) !== null);                &#125;            &#125;);        &#125;,        onLeave: function (retval) &#123;            console.log(&quot;[+] &quot; + TARGET_MODULE_NAME + &quot;!&quot; + ptr(stalker_target_func_offset) + &quot; onLeave, TID:&quot;, this.tid);            Stalker.unfollow(this.tid); // 在函数退出时明确停止Stalker是个好习惯            Stalker.garbageCollect();   // 回收Stalker资源        &#125;    &#125;);&#125;setImmediate(function() &#123;    console.log(&quot;[i] Script starting for &quot; + module_name + &quot;...&quot;);    hook_linker_call_constructors();&#125;);console.log(&quot;[i] Script loaded. Waiting for &quot; + module_name + &quot;...&quot;);\n\n听说frida-sktrace实现了字符串（连续有4个可显示的字符时，打印字符串）的打印，而且更美观一些，这里试试使用frida-sktrace，但似乎不支持spawn模式附加进程，而且hook的时机还得修改，我决定在我原有的代码上添加这个功能。——我改成了，存在连续3个可视字符时，把指针内容当成字符串地址。\n下面是让大模型帮我写的代码，不过也太长了吧。\n// =======================================================================================// Modified StalkerTrace Function (FIXED local_pre_regs access)// =======================================================================================function StalkerTrace(current_module_baseaddr) &#123; // Ensure the correct module base address is passed    // Use the global module_size which should be set by now    if (!current_module_baseaddr || current_module_baseaddr.isNull() || module_size === 0) &#123;         console.error(&quot;[-] StalkerTrace: Invalid module base address or size. Cannot proceed.&quot;);         return;    &#125;    var stalker_target_func_offset = 0x4a458; // The offset of the function you want Stalker to trace    var stalker_start_addr = current_module_baseaddr.add(stalker_target_func_offset);    console.log(&quot;[+] StalkerTrace will target &quot; + TARGET_MODULE_NAME + &quot;!&quot; + ptr(stalker_target_func_offset) + &quot; at actual address: &quot; + stalker_start_addr);    // Define the module bounds for Stalker logging    const module_start = current_module_baseaddr;    const module_end = current_module_baseaddr.add(module_size);    console.log(&quot;[i] Stalker module bounds: Start=&quot; + module_start + &quot;, End=&quot; + module_end);    Interceptor.attach(stalker_start_addr, &#123;        onEnter: function (args) &#123;            // Stalker operates per thread. Get the current thread ID.            this.tid = Process.getCurrentThreadId();            console.log(&quot;[+] Stalker: Entered &quot; + TARGET_MODULE_NAME + &quot;!&quot; + ptr(stalker_target_func_offset) + &quot; (TID: &quot; + this.tid + &quot;)&quot;);            // Initialize previous register state *for this specific thread*.            // This variable is local to this onEnter call but will be captured by the closure.            const local_pre_regs = &#123;&#125;;             // Populate initial state, excluding filtered registers            const initial_context_snapshot = JSON.parse(JSON.stringify(this.context));            for (const reg_name_orig in initial_context_snapshot) &#123;                if (initial_context_snapshot.hasOwnProperty(reg_name_orig)) &#123;                    const reg_name_lower = reg_name_orig.toLowerCase();                     if (reg_name_lower !== &quot;pc&quot; &amp;&amp; reg_name_lower !== &quot;sp&quot; &amp;&amp; !reg_name_lower.startsWith(&quot;q&quot;) &amp;&amp; !reg_name_lower.startsWith(&quot;v&quot;)) &#123;                        local_pre_regs[reg_name_orig] = initial_context_snapshot[reg_name_orig];                    &#125;                &#125;            &#125;            // *** REMOVE THIS LINE *** this.local_pre_regs = local_pre_regs;             // The variable &#x27;local_pre_regs&#x27; is already in scope for the transform/callout closures.            // === Patch known crashing instructions on entering the traced function ===            // These addresses are relative to the module base address (current_module_baseaddr)            const knownCrashOffsets = [0x48AC0, 0x4ABB8]; // List of known problematic instruction offsets            knownCrashOffsets.forEach(offset =&gt; &#123;                try &#123;                    const patchAddr = current_module_baseaddr.add(offset);                    // Read instruction bytes to verify it&#x27;s the expected &#x27;MOV WSP, #1&#x27;                    // ARM64: MOV WSP, #1 is 320003FF (little endian)                    const expectedBytes = new Uint8Array([0x32, 0x00, 0x03, 0xFF]);                    const instrBytes = patchAddr.readByteArray(4);                    const actualBytes = new Uint8Array(instrBytes);                    let matchesExpected = true;                    if (actualBytes.length === 4) &#123;                         for(let i=0; i&lt;4; i++) &#123;                              if (actualBytes[i] !== expectedBytes[i]) &#123;                                   matchesExpected = false;                                   break;                              &#125;                         &#125;                    &#125; else &#123;                         matchesExpected = false;                    &#125;                    if (matchesExpected) &#123;                         // If it matches, NOP it                         Memory.patchCode(patchAddr, 4, code =&gt; &#123;                             const writer = new Arm64Writer(code, &#123; pc: patchAddr &#125;);                             writer.putNop(); // Replace the instruction with NOP                             writer.flush();                         &#125;);                         console.log(&quot;[MemoryPatch] Stalker&#x27;s onEnter: NOPped known crash (MOV WSP, #1) at &quot; + module_name + &quot;!&quot; + ptr(offset) + &quot; (&quot;+ patchAddr + &quot;)&quot;);                    &#125; else &#123;                         // console.log(&quot;[MemoryPatch] Stalker&#x27;s onEnter: Instruction at &quot; + module_name + &quot;!&quot; + ptr(offset) + &quot; is not MOV WSP, #1. Bytes: &quot; + Array.from(actualBytes).map(b =&gt; b.toString(16).padStart(2,&#x27;0&#x27;)).join(&#x27;&#x27;)); // Optional log                    &#125;                &#125; catch (e) &#123;                    console.warn(&quot;[MemoryPatch] Stalker&#x27;s onEnter: Error patching &quot; + module_name + &quot;!&quot; + ptr(offset) + &quot;: &quot; + e.message);                &#125;            &#125;);            // ==================================================================            Stalker.follow(this.tid, &#123;                 // Configure events to trace. exec=true traces every executed instruction.                events: &#123; call: false, ret: false, exec: true, block: false, compile: false &#125;,                 // The transform callback allows inspecting/rewriting instruction blocks                transform(iterator) &#123;                    let instruction = iterator.next();                    do &#123;                        const currentAddress = instruction.address;                        let patchedThisInstruction = false;                        // Check if the instruction is within the target module&#x27;s bounds                        const is_module_code = currentAddress.compare(module_start) &gt;= 0 &amp;&amp;                                               currentAddress.compare(module_end) &lt; 0;                         // === Universal MOV WSP/SP, #1 detection and NOP logic ===                         // This is a fallback/alternative to the onEnter patch                         // It happens per block compiled by Stalker                        if (is_module_code) &#123; // Only patch instructions within the target module                            const mnemonic = instruction.mnemonic.toLowerCase();                             // Check for MOV or MOVZ with SP/WSP as destination and immediate 1                             if ((mnemonic === &#x27;mov&#x27; || mnemonic === &#x27;movz&#x27;) &amp;&amp; instruction.operands.length &gt;= 2) &#123;                                 const destOperand = instruction.operands[0];                                 const srcOperand = instruction.operands[1];                                 if (destOperand.type === &#x27;reg&#x27; &amp;&amp;                                     (destOperand.value === &#x27;wsp&#x27; || destOperand.value === &#x27;sp&#x27; ||                                      destOperand.value === &#x27;w31&#x27; || destOperand.value === &#x27;x31&#x27;) &amp;&amp; // w31/x31 are aliases for wsp/sp                                     srcOperand.type === &#x27;imm&#x27; &amp;&amp;                                     parseInt(srcOperand.value.toString()) === 1) &#123;                                     console.warn(&quot;[StalkerTransform] Identified potential crash instruction &#x27;&quot; + instruction.toString() + &quot;&#x27; at &quot; + currentAddress + &quot;. Replacing with NOP.&quot;);                                     iterator.putNop(); // Replace the instruction with NOP                                     patchedThisInstruction = true;                                 &#125;                             &#125;                        &#125;                        // =========================================================                        // If the instruction wasn&#x27;t NOPped by the above check, add a callout for logging                        if (!patchedThisInstruction) &#123;                            // Only add callout for instructions within the target module                            if (is_module_code) &#123;                                // &#x27;local_pre_regs&#x27; is accessible here via closure                                iterator.putCallout(function (context) &#123;                                    // Access local_pre_regs directly from the outer scope (captured by closure)                                    const thread_pre_regs = local_pre_regs;                                     const pc = context.pc;                                    // Get the register differences after this instruction executes                                    // get_diff_regs modifies thread_pre_regs in place                                    const diff_regs = get_diff_regs(context, thread_pre_regs);                                                                        // Find the module info again (can be optimized by caching, but this is reliable)                                    var current_callout_module = Process.findModuleByAddress(pc);                                     // Ensure we are logging code from the target module                                     if (current_callout_module &amp;&amp; current_callout_module.name === TARGET_MODULE_NAME) &#123;                                         const instrToLog = Instruction.parse(pc);                                         let logLine = `$&#123;current_callout_module.name&#125;!$&#123;pc.sub(current_callout_module.base)&#125; $&#123;instrToLog.toString()&#125;`;                                         // Append changed registers and potential strings                                         const diffRegKeys = Object.keys(diff_regs);                                         if (diffRegKeys.length &gt; 0) &#123;                                              logLine += `\\t\\t| Changed Regs: `;                                              let firstReg = true;                                              for (const regName of diffRegKeys) &#123;                                                   if (!firstReg) logLine += &quot;, &quot;;                                                   firstReg = false;                                                   const regValue = diff_regs[regName]; // The new value of the register                                                   logLine += `$&#123;regName&#125;=$&#123;regValue&#125;`;                                                   // --- Check if the register value points to a string ---                                                   const potentialString = tryReadString(regValue);                                                   if (potentialString !== null) &#123;                                                       // Truncate long strings for readability                                                       const displayString = potentialString.length &gt; 60 ? potentialString.substring(0, 57) + &quot;...&quot; : potentialString;                                                       // Escape potential quotes in the string for cleaner output                                                       const escapedString = displayString.replace(/&quot;/g, &#x27;\\\\&quot;&#x27;).replace(/\\n/g, &#x27;\\\\n&#x27;).replace(/\\r/g, &#x27;\\\\r&#x27;);                                                        logLine += ` (&quot;$&#123;escapedString&#125;&quot;)`;                                                   &#125;                                                   // ----------------------------------------------------------                                              &#125;                                         &#125;                                         console.log(logLine);                                     &#125;                                &#125;);                            &#125;                            // Keep the original instruction                            iterator.keep();                        &#125;                    &#125; while ((instruction = iterator.next()) !== null); // Process next instruction in the block                &#125;            &#125;);        &#125;,        onLeave: function (retval) &#123;            console.log(&quot;[+] &quot; + TARGET_MODULE_NAME + &quot;!&quot; + ptr(stalker_target_func_offset) + &quot; onLeave, TID:&quot;, this.tid);             // Stop stalking this thread when the function exits            Stalker.unfollow(this.tid);             // Clean up Stalker&#x27;s compiled code cache            Stalker.garbageCollect();        &#125;    &#125;);&#125;// ... (rest of the script remains the same)// hook_linker_call_constructors();// hook_target_func(base_addr); // Called from linker hook or fallback// hook_pthread_create(); // Called from hook_target_func onLeave// tryReadString() // Helper function defined above// get_diff_regs() // Helper function defined above// get_involved_regs() // Helper function defined abovevar offset = 0x88060;var module_size = 0; // Will be populated when module is foundvar module_name = &quot;libbaiduprotect.so&quot;;var base_addr = null; // To store the base address of libbaiduprotect.so// Create an empty functionvar empty_func = new NativeCallback(function() &#123;    // console.log(&quot;[Anti-Debug] Empty function executed.&quot;); // Optional log    return 0;&#125;, &#x27;int&#x27;, [&#x27;pointer&#x27;]);// --- Helper function to attempt reading a string ---function tryReadString(address, minPrintableBytes = 3, maxReadLength = 256) &#123;    if (!address) &#123;        return null; // Cannot read from null address    &#125;        try &#123;        // Step 1: Read the first few bytes to see if they look like printable ASCII        const preliminaryBytes = address.readByteArray(minPrintableBytes);        if (!preliminaryBytes) &#123;             // Can&#x27;t read the initial bytes (e.g., invalid address)            return null;        &#125;                const uint8Array = new Uint8Array(preliminaryBytes);        let allPrintable = true;        for (let i = 0; i &lt; uint8Array.length; i++) &#123;            const byte = uint8Array[i];            // Basic check for printable ASCII (0x20 to 0x7E)            if (byte &lt; 0x20 || byte &gt; 0x7E) &#123;                allPrintable = false;                break;            &#125;        &#125;        if (allPrintable) &#123;            // Step 2: If they look printable, attempt to read a C-string            // readCString reads until null terminator or max length            const str = address.readCString(maxReadLength);             // Filter out empty strings or strings that only contained non-null printable chars but no null terminator early on            if (str &amp;&amp; str.length &gt; 0) &#123;                return str;            &#125;        &#125;            &#125; catch (e) &#123;        // Reading failed (e.g., invalid memory access)        // console.warn(&quot;[-] Failed to read memory at &quot; + address + &quot; for string check: &quot; + e.message); // Optional: Log errors        return null;    &#125;    return null; // Did not pass the checks or failed to read&#125;// ---------------------------------------------------function hook_linker_call_constructors() &#123;    // 为提高健壮性，建议使用更完善的 linker 及 call_constructors 查找逻辑    // 但为保持与你原始脚本的结构，暂时保留这种直接方式    let linker_module_name = Process.arch === &#x27;arm64&#x27; ? &#x27;linker64&#x27; : &#x27;linker&#x27;;    let linker64_base_addr = Module.getBaseAddress(linker_module_name);    if (!linker64_base_addr) &#123;        console.warn(&quot;[-] Failed to get &quot; + linker_module_name + &quot; base address. Trying to find module directly later.&quot;);        // Fallback if linker not found        setTimeout(function() &#123;            if (!base_addr) &#123; // Check if already found                let secmodule = Process.findModuleByName(module_name);                if (secmodule) &#123;                    base_addr = secmodule.base;                    module_size = secmodule.size;                    console.log(module_name + &quot; base (fallback): &quot; + base_addr + &quot;, size: &quot; + module_size);                    hook_target_func(base_addr);                &#125; else &#123;                    console.error(&quot;[-] &quot; + module_name + &quot; not found via fallback. Cannot proceed.&quot;);                &#125;            &#125;        &#125;, 1500); // Delay slightly        return;    &#125;    // NOTE: This offset is highly dependent on the system/Android version and linker variant!    // A more robust approach would involve scanning for the function signature.    let offset_call = 0x51BA8; // Example: __dl__ZN6soinfo17call_constructorsEv on some systems    let call_constructors = linker64_base_addr.add(offset_call);    console.log(&quot;[i] Attempting to attach to linker&#x27;s call_constructors at &quot; + call_constructors);    try &#123;        let listener = Interceptor.attach(call_constructors, &#123;            onEnter: function(args) &#123;                // console.log(&#x27;[linker] Call_Constructors onEnter&#x27;);                let secmodule = Process.findModuleByName(module_name);                if (secmodule != null) &#123;                    if (base_addr === null) &#123; // Ensure initialized only once                        module_size = secmodule.size;                        base_addr = secmodule.base; // Save the base address                        console.log(module_name + &quot; base: &quot; + base_addr + &quot;, size: &quot; + module_size);                                                // *** Consider patching known points here or within Stalker ***                        // Patching here happens earlier, might be safer for some anti-debug                        // patchInstructionToNop(base_addr, 0x48AC0, 4); // Example offset                        // patchInstructionToNop(base_addr, 0x4ABB8, 4); // Example offset                        hook_target_func(base_addr);                        listener.detach(); // Detach once the module is found                        console.log(&quot;[i] Detached from linker hook.&quot;);                    &#125;                &#125;            &#125;            // No onLeave needed for just finding the module base        &#125;);    &#125; catch (e) &#123;        console.error(&quot;[-] Failed to attach to linker&#x27;s call_constructors: &quot; + e.message);        console.log(&quot;    Will rely on fallback to find module &quot; + module_name);          setTimeout(function() &#123; // Similar fallback logic as above              if (!base_addr) &#123;                  let secmodule = Process.findModuleByName(module_name);                  if (secmodule) &#123;                      base_addr = secmodule.base;                      module_size = secmodule.size;                      console.log(module_name + &quot; base (fallback after attach error): &quot; + base_addr + &quot;, size: &quot; + module_size);                      hook_target_func(base_addr);                  &#125; else &#123;                      console.error(&quot;[-] Fallback after attach error: &quot; + module_name + &quot; not found.&quot;);                  &#125;              &#125;          &#125;, 1500);    &#125;&#125;function hook_target_func(current_base_addr) &#123; // Use current_base_addr to distinguish from global base_addr    if (!current_base_addr || current_base_addr.isNull())&#123;        console.error(&quot;[-] hook_target_func: current_base_addr is invalid.&quot;);        return;    &#125;    let target_addr = current_base_addr.add(offset); // offset = 0x88060    console.log(&quot;[+] Hooking target function at &quot; + target_addr + &quot; (offset 0x&quot; + offset.toString(16) + &quot;)&quot;);    try &#123;        // Use attachOnce if you only need it to trigger once        Interceptor.attach(target_addr, &#123;            onEnter: function(args) &#123;                console.log(&quot;Target function &quot; + module_name + &quot;!0x&quot; + offset.toString(16) + &quot; entered. Called from: &quot; + this.returnAddress);            &#125;,            onLeave: function(retval) &#123;                console.log(module_name + &quot;!0x&quot; + offset.toString(16) + &quot; onLeave. Base address: &quot; + current_base_addr);                // IMPORTANT: Use the global base_addr here as it should be set by now and is needed by StalkerTrace/pthread hook                if (base_addr &amp;&amp; !base_addr.isNull()) &#123;                     hook_pthread_create();                    StalkerTrace(base_addr); // Pass the correct module base address to StalkerTrace                &#125; else &#123;                    console.error(&quot;[-] Global base_addr not set in hook_target_func onLeave. Cannot start Stalker / pthread hook.&quot;);                &#125;                 // No need to detach here if using attachOnce, but if using attach, you might detach                 // listener.detach();                 // console.log(&quot;[i] Detached from target_func hook at &quot; + target_addr);            &#125;        &#125;);         // Note: Interceptor.attachOnce is often better if you only need the onLeave logic once         // However, let&#x27;s stick to attach and detach in onLeave for now based on your original code structure.    &#125; catch (e) &#123;        console.error(&quot;[-] Failed to attach to target_func at &quot; + target_addr + &quot;: &quot; + e.message);    &#125;&#125;function hook_pthread_create() &#123;    // Ensure base_addr is set before hooking pthread_create as it&#x27;s needed for comparison    if (!base_addr || base_addr.isNull()) &#123;        console.error(&quot;[-] hook_pthread_create: Global base_addr is null. Skipping hook.&quot;);        return;    &#125;    let pthread_create_addr = Module.findExportByName(&quot;libc.so&quot;, &quot;pthread_create&quot;);    if (pthread_create_addr) &#123;        console.log(&quot;[+] Hooking pthread_create at &quot; + pthread_create_addr);        try &#123;            Interceptor.attach(pthread_create_addr, &#123;                onEnter: function(args) &#123;                    // pthread_create signature:                    // int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);                    // start_routine is the 3rd argument (index 2)                    let func_addr = args[2];                                         // Target function address within libbaiduprotect.so                    // This offset (0x3E9F0) might also need dynamic finding                    let target_func_offset_pthread = 0x3E9F0;                     let target_func_addr = base_addr.add(target_func_offset_pthread);                    // Check if the thread being created is the one we want to intercept                    if (func_addr.equals(target_func_addr)) &#123;                        console.log(&quot;[Anti-Debug] Replacing thread start_routine &quot; + func_addr + &quot; with empty function.&quot;);                        // Replace the actual start routine pointer with our empty function&#x27;s pointer                        args[2] = empty_func;                     &#125;                &#125;            &#125;);        &#125; catch (e) &#123;            console.error(&quot;[-] Failed to attach to pthread_create: &quot; + e.message);        &#125;    &#125; else &#123;        console.warn(&quot;[-] pthread_create not found in libc.so. Hook skipped.&quot;);    &#125;&#125;const TARGET_MODULE_NAME = &quot;libbaiduprotect.so&quot;; // Same as module_name for clarity with Stalkerfunction get_diff_regs(context, pre_regs) &#123;    var diff_regs = &#123;&#125;;    // Create a snapshot of the current context&#x27;s general-purpose registers    const current_regs_snapshot = JSON.parse(JSON.stringify(context));         // Iterate through the original register names from the snapshot    for (const reg_name_orig in current_regs_snapshot) &#123;        // Ensure it&#x27;s a direct property, not inherited        if (current_regs_snapshot.hasOwnProperty(reg_name_orig)) &#123;            const reg_name_lower = reg_name_orig.toLowerCase();            // Filter out PC, SP, and floating-point/vector registers (q* or v*)            if (reg_name_lower !== &quot;pc&quot; &amp;&amp; reg_name_lower !== &quot;sp&quot; &amp;&amp; !reg_name_lower.startsWith(&quot;q&quot;) &amp;&amp; !reg_name_lower.startsWith(&quot;v&quot;)) &#123;                 // Compare with the previous snapshot                if (pre_regs[reg_name_orig] !== current_regs_snapshot[reg_name_orig]) &#123;                    // If the value has changed, update the previous snapshot and record the difference                    pre_regs[reg_name_orig] = current_regs_snapshot[reg_name_orig];                    diff_regs[reg_name_orig] = current_regs_snapshot[reg_name_orig]; // Store the NEW value                &#125;            &#125;        &#125;    &#125;    return diff_regs;&#125;// This function is defined but not currently used in the logging. Keeping it as it was in the original code.function get_involved_regs(instruction) &#123;     const involved_regs = new Set();    instruction.operands.forEach(op =&gt; &#123;        if (op.type === &#x27;reg&#x27;) &#123; involved_regs.add(op.value); &#125;        else if (op.type === &#x27;mem&#x27;) &#123;            if (op.value.base) &#123; involved_regs.add(op.value.base); &#125;            if (op.value.index) &#123; involved_regs.add(op.value.index); &#125;        &#125;    &#125;);    return Array.from(involved_regs);&#125;// =======================================================================================// Modified StalkerTrace Function (FIXED local_pre_regs access)// =======================================================================================function StalkerTrace(current_module_baseaddr) &#123; // Ensure the correct module base address is passed    // Use the global module_size which should be set by now    if (!current_module_baseaddr || current_module_baseaddr.isNull() || module_size === 0) &#123;         console.error(&quot;[-] StalkerTrace: Invalid module base address or size. Cannot proceed.&quot;);         return;    &#125;    var stalker_target_func_offset = 0x4a458; // The offset of the function you want Stalker to trace    var stalker_start_addr = current_module_baseaddr.add(stalker_target_func_offset);    console.log(&quot;[+] StalkerTrace will target &quot; + TARGET_MODULE_NAME + &quot;!&quot; + ptr(stalker_target_func_offset) + &quot; at actual address: &quot; + stalker_start_addr);    // Define the module bounds for Stalker logging    const module_start = current_module_baseaddr;    const module_end = current_module_baseaddr.add(module_size);    console.log(&quot;[i] Stalker module bounds: Start=&quot; + module_start + &quot;, End=&quot; + module_end);    Interceptor.attach(stalker_start_addr, &#123;        onEnter: function (args) &#123;            // Stalker operates per thread. Get the current thread ID.            this.tid = Process.getCurrentThreadId();            console.log(&quot;[+] Stalker: Entered &quot; + TARGET_MODULE_NAME + &quot;!&quot; + ptr(stalker_target_func_offset) + &quot; (TID: &quot; + this.tid + &quot;)&quot;);            // Initialize previous register state *for this specific thread*.            // This variable is local to this onEnter call but will be captured by the closure.            const local_pre_regs = &#123;&#125;;             // Populate initial state, excluding filtered registers            const initial_context_snapshot = JSON.parse(JSON.stringify(this.context));            for (const reg_name_orig in initial_context_snapshot) &#123;                if (initial_context_snapshot.hasOwnProperty(reg_name_orig)) &#123;                    const reg_name_lower = reg_name_orig.toLowerCase();                     if (reg_name_lower !== &quot;pc&quot; &amp;&amp; reg_name_lower !== &quot;sp&quot; &amp;&amp; !reg_name_lower.startsWith(&quot;q&quot;) &amp;&amp; !reg_name_lower.startsWith(&quot;v&quot;)) &#123;                        local_pre_regs[reg_name_orig] = initial_context_snapshot[reg_name_orig];                    &#125;                &#125;            &#125;            // *** REMOVE THIS LINE *** this.local_pre_regs = local_pre_regs;             // The variable &#x27;local_pre_regs&#x27; is already in scope for the transform/callout closures.            // === Patch known crashing instructions on entering the traced function ===            // These addresses are relative to the module base address (current_module_baseaddr)            const knownCrashOffsets = [0x48AC0, 0x4ABB8]; // List of known problematic instruction offsets            knownCrashOffsets.forEach(offset =&gt; &#123;                try &#123;                    const patchAddr = current_module_baseaddr.add(offset);                    // Read instruction bytes to verify it&#x27;s the expected &#x27;MOV WSP, #1&#x27;                    // ARM64: MOV WSP, #1 is 320003FF (little endian)                    const expectedBytes = new Uint8Array([0x32, 0x00, 0x03, 0xFF]);                    const instrBytes = patchAddr.readByteArray(4);                    const actualBytes = new Uint8Array(instrBytes);                    let matchesExpected = true;                    if (actualBytes.length === 4) &#123;                         for(let i=0; i&lt;4; i++) &#123;                              if (actualBytes[i] !== expectedBytes[i]) &#123;                                   matchesExpected = false;                                   break;                              &#125;                         &#125;                    &#125; else &#123;                         matchesExpected = false;                    &#125;                    if (matchesExpected) &#123;                         // If it matches, NOP it                         Memory.patchCode(patchAddr, 4, code =&gt; &#123;                             const writer = new Arm64Writer(code, &#123; pc: patchAddr &#125;);                             writer.putNop(); // Replace the instruction with NOP                             writer.flush();                         &#125;);                         console.log(&quot;[MemoryPatch] Stalker&#x27;s onEnter: NOPped known crash (MOV WSP, #1) at &quot; + module_name + &quot;!&quot; + ptr(offset) + &quot; (&quot;+ patchAddr + &quot;)&quot;);                    &#125; else &#123;                         // console.log(&quot;[MemoryPatch] Stalker&#x27;s onEnter: Instruction at &quot; + module_name + &quot;!&quot; + ptr(offset) + &quot; is not MOV WSP, #1. Bytes: &quot; + Array.from(actualBytes).map(b =&gt; b.toString(16).padStart(2,&#x27;0&#x27;)).join(&#x27;&#x27;)); // Optional log                    &#125;                &#125; catch (e) &#123;                    console.warn(&quot;[MemoryPatch] Stalker&#x27;s onEnter: Error patching &quot; + module_name + &quot;!&quot; + ptr(offset) + &quot;: &quot; + e.message);                &#125;            &#125;);            // ==================================================================            Stalker.follow(this.tid, &#123;                 // Configure events to trace. exec=true traces every executed instruction.                events: &#123; call: false, ret: false, exec: true, block: false, compile: false &#125;,                 // The transform callback allows inspecting/rewriting instruction blocks                transform(iterator) &#123;                    let instruction = iterator.next();                    do &#123;                        const currentAddress = instruction.address;                        let patchedThisInstruction = false;                        // Check if the instruction is within the target module&#x27;s bounds                        const is_module_code = currentAddress.compare(module_start) &gt;= 0 &amp;&amp;                                               currentAddress.compare(module_end) &lt; 0;                         // === Universal MOV WSP/SP, #1 detection and NOP logic ===                         // This is a fallback/alternative to the onEnter patch                         // It happens per block compiled by Stalker                        if (is_module_code) &#123; // Only patch instructions within the target module                            const mnemonic = instruction.mnemonic.toLowerCase();                             // Check for MOV or MOVZ with SP/WSP as destination and immediate 1                             if ((mnemonic === &#x27;mov&#x27; || mnemonic === &#x27;movz&#x27;) &amp;&amp; instruction.operands.length &gt;= 2) &#123;                                 const destOperand = instruction.operands[0];                                 const srcOperand = instruction.operands[1];                                 if (destOperand.type === &#x27;reg&#x27; &amp;&amp;                                     (destOperand.value === &#x27;wsp&#x27; || destOperand.value === &#x27;sp&#x27; ||                                      destOperand.value === &#x27;w31&#x27; || destOperand.value === &#x27;x31&#x27;) &amp;&amp; // w31/x31 are aliases for wsp/sp                                     srcOperand.type === &#x27;imm&#x27; &amp;&amp;                                     parseInt(srcOperand.value.toString()) === 1) &#123;                                     console.warn(&quot;[StalkerTransform] Identified potential crash instruction &#x27;&quot; + instruction.toString() + &quot;&#x27; at &quot; + currentAddress + &quot;. Replacing with NOP.&quot;);                                     iterator.putNop(); // Replace the instruction with NOP                                     patchedThisInstruction = true;                                 &#125;                             &#125;                        &#125;                        // =========================================================                        // If the instruction wasn&#x27;t NOPped by the above check, add a callout for logging                        if (!patchedThisInstruction) &#123;                            // Only add callout for instructions within the target module                            if (is_module_code) &#123;                                // &#x27;local_pre_regs&#x27; is accessible here via closure                                iterator.putCallout(function (context) &#123;                                    // Access local_pre_regs directly from the outer scope (captured by closure)                                    const thread_pre_regs = local_pre_regs;                                     const pc = context.pc;                                    // Get the register differences after this instruction executes                                    // get_diff_regs modifies thread_pre_regs in place                                    const diff_regs = get_diff_regs(context, thread_pre_regs);                                                                        // Find the module info again (can be optimized by caching, but this is reliable)                                    var current_callout_module = Process.findModuleByAddress(pc);                                     // Ensure we are logging code from the target module                                     if (current_callout_module &amp;&amp; current_callout_module.name === TARGET_MODULE_NAME) &#123;                                         const instrToLog = Instruction.parse(pc);                                         let logLine = `$&#123;current_callout_module.name&#125;!$&#123;pc.sub(current_callout_module.base)&#125; $&#123;instrToLog.toString()&#125;`;                                         // Append changed registers and potential strings                                         const diffRegKeys = Object.keys(diff_regs);                                         if (diffRegKeys.length &gt; 0) &#123;                                              logLine += `\\t\\t| Changed Regs: `;                                              let firstReg = true;                                              for (const regName of diffRegKeys) &#123;                                                   if (!firstReg) logLine += &quot;, &quot;;                                                   firstReg = false;                                                   const regValue = diff_regs[regName]; // The new value of the register                                                   logLine += `$&#123;regName&#125;=$&#123;regValue&#125;`;                                                   // --- Check if the register value points to a string ---                                                   const potentialString = tryReadString(regValue);                                                   if (potentialString !== null) &#123;                                                       // Truncate long strings for readability                                                       const displayString = potentialString.length &gt; 60 ? potentialString.substring(0, 57) + &quot;...&quot; : potentialString;                                                       // Escape potential quotes in the string for cleaner output                                                       const escapedString = displayString.replace(/&quot;/g, &#x27;\\\\&quot;&#x27;).replace(/\\n/g, &#x27;\\\\n&#x27;).replace(/\\r/g, &#x27;\\\\r&#x27;);                                                        logLine += ` (&quot;$&#123;escapedString&#125;&quot;)`;                                                   &#125;                                                   // ----------------------------------------------------------                                              &#125;                                         &#125;                                         console.log(logLine);                                     &#125;                                &#125;);                            &#125;                            // Keep the original instruction                            iterator.keep();                        &#125;                    &#125; while ((instruction = iterator.next()) !== null); // Process next instruction in the block                &#125;            &#125;);        &#125;,        onLeave: function (retval) &#123;            console.log(&quot;[+] &quot; + TARGET_MODULE_NAME + &quot;!&quot; + ptr(stalker_target_func_offset) + &quot; onLeave, TID:&quot;, this.tid);             // Stop stalking this thread when the function exits            Stalker.unfollow(this.tid);             // Clean up Stalker&#x27;s compiled code cache            Stalker.garbageCollect();        &#125;    &#125;);&#125;// Start the script execution by hooking the linkersetImmediate(function() &#123;    console.log(&quot;[i] Script starting for &quot; + module_name + &quot;...&quot;);    hook_linker_call_constructors();&#125;);console.log(&quot;[i] Script loaded. Waiting for &quot; + module_name + &quot; to be loaded...&quot;);\n\n接下来又遇到一个问题，在trace到sub_5AE5C内部的时候，会在随机某处地址断开trace。由于是随机断开的，没搞清楚到底是为什么？头疼。\n\n\n先通过下面这个脚本，hook上了sub_5AE5C，跑起来没问题。\nvar offset = 0x88060;var module_size = 0;var module_name = &quot;libbaiduprotect.so&quot;;var base_addr = null; // To store the base address of libbaiduprotect.so// Create an empty functionvar empty_func = new NativeCallback(function() &#123;    return 0;&#125;, &#x27;int&#x27;, [&#x27;pointer&#x27;]);function hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;);    let offset_call = 0x51BA8; // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset_call);    let listener = Interceptor.attach(call_constructors, &#123;        onEnter: function(args) &#123;            console.log(&#x27;[linker] Call_Constructors onEnter&#x27;);            let secmodule = Process.findModuleByName(module_name);            if (secmodule != null) &#123;                module_size = secmodule.size;                base_addr = secmodule.base; // Save the base address                console.log(&quot;libbaiduprotect.so base: &quot; + base_addr + &quot;, size: &quot; + module_size);                hook_target_func(base_addr);                listener.detach();            &#125;        &#125;    &#125;);&#125;function hook_target_func(baseaddr) &#123;    let target_addr = baseaddr.add(offset);    let listener = Interceptor.attach(target_addr, &#123;        onEnter: function(args) &#123;            console.log(&quot;Target function at &quot; + target_addr + &quot; entered&quot;);        &#125;,        onLeave: function(retval) &#123;            console.log(&quot;libbaiduprotect.so base address: &quot; + baseaddr);            hook_pthread_create();            hook_sub_5ae5c(baseaddr); // Hook sub_5AE5C after target function            listener.detach();        &#125;    &#125;);&#125;function hook_pthread_create() &#123;    let pthread_create_addr = Module.findExportByName(&quot;libc.so&quot;, &quot;pthread_create&quot;);    Interceptor.attach(pthread_create_addr, &#123;        onEnter: function(args) &#123;            let func_addr = args[2];            let target_func_addr = base_addr.add(0x3E9F0); // Calculate the target function address            if (func_addr.equals(target_func_addr)) &#123;                console.log(&quot;Replacing func_addr &quot; + func_addr + &quot; with empty function&quot;);                args[2] = empty_func; // Replace with the empty function                // hook_libart(); // Commented out as it was not provided            &#125; else &#123;                let module = Process.findModuleByAddress(func_addr);                if (module &amp;&amp; module.name === module_name) &#123;                    console.log(&quot;pthread_create called in libbaiduprotect.so, function address: &quot; + func_addr);                &#125;            &#125;        &#125;,        onLeave: function(retval) &#123;            // Optionally log return value        &#125;    &#125;);&#125;function hook_sub_5ae5c(baseaddr) &#123;    if (!baseaddr || baseaddr.isNull()) &#123;        console.error(&quot;[-] hook_sub_5ae5c: Invalid base address. Cannot proceed.&quot;);        return;    &#125;    let target_addr = baseaddr.add(0x5AE5C);    console.log(&quot;[+] Hooking sub_5AE5C at &quot; + target_addr);    Interceptor.attach(target_addr, &#123;        onEnter: function(args) &#123;            console.log(&quot;[sub_5AE5C] onEnter&quot;);            // Dump args[0] (pointer to _QWORD)            try &#123;                if (!args[0].isNull()) &#123;                    console.log(&quot;args[0] (*_QWORD at &quot; + args[0] + &quot;):&quot;);                    console.log(hexdump(args[0], &#123; length: 64, ansi: true &#125;));                &#125; else &#123;                    console.warn(&quot;args[0] is null&quot;);                &#125;            &#125; catch (e) &#123;                console.warn(&quot;Failed to hexdump args[0]: &quot; + e.message);            &#125;            // Dump args[2] (data + 8)            try &#123;                if (!args[2].isNull()) &#123;                    console.log(&quot;args[2] (data + 8 at &quot; + args[2] + &quot;):&quot;);                    console.log(hexdump(args[2], &#123; length: 64, ansi: true &#125;));                &#125; else &#123;                    console.warn(&quot;args[2] is null&quot;);                &#125;            &#125; catch (e) &#123;                console.warn(&quot;Failed to hexdump args[2]: &quot; + e.message);            &#125;            // Store pointers for comparison in onLeave            this.arg0 = args[0];            this.arg2 = args[2];        &#125;,        onLeave: function(retval) &#123;            console.log(&quot;[sub_5AE5C] onLeave, Return value: &quot; + retval);            // Dump args[0] again to check for changes            try &#123;                if (!this.arg0.isNull()) &#123;                    console.log(&quot;args[0] (*_QWORD at &quot; + this.arg0 + &quot;) after execution:&quot;);                    console.log(hexdump(this.arg0, &#123; length: 64, ansi: true &#125;));                &#125; else &#123;                    console.warn(&quot;args[0] is null in onLeave&quot;);                &#125;            &#125; catch (e) &#123;                console.warn(&quot;Failed to hexdump args[0] in onLeave: &quot; + e.message);            &#125;            // Dump args[2] again to check for changes            try &#123;                if (!this.arg2.isNull()) &#123;                    console.log(&quot;args[2] (data + 8 at &quot; + this.arg2 + &quot;) after execution:&quot;);                    console.log(hexdump(this.arg2, &#123; length: 64, ansi: true &#125;));                &#125; else &#123;                    console.warn(&quot;args[2] is null in onLeave&quot;);                &#125;            &#125; catch (e) &#123;                console.warn(&quot;Failed to hexdump args[2] in onLeave: &quot; + e.message);            &#125;        &#125;    &#125;);&#125;setImmediate(function() &#123;    console.log(&quot;[i] Script starting for &quot; + module_name + &quot;...&quot;);    hook_linker_call_constructors();&#125;);console.log(&quot;[i] Script loaded. Waiting for &quot; + module_name + &quot; to be loaded...&quot;);\n\n可以看到，after execution的args[2]中，存放的内容是一大片地址，将这些地址减去libbaiduprotect.so的基地址，可以发现这些地址都是vmp__funcs_256这个表上的地址。也就是说，经过函数sub_5ae5c，会从第一个参数中，获得到实现JNI函数所需要的的vmp指令集合列表。\n\n既然trace不了函数5ae5c，那就从sub_5ae5c的汇编代码分析吧。\n基本块1。\n\n基本块2。\n\n基本块3。\n\n基本块4。\n\n基本块5。\n\n基本块6。\n\n基本块7。\n\n\n基本块7的下一个块又是基本块4，也就是说，将上述流程写成伪代码的话，如下所示。\nfor(int index = 0; index &lt; 256; index++)&#123;\ta2 + (*(((byte*)a0) + 64 + index*4)) * 8 = *(a1 + index*8)&#125;\n\n和ida做一个对比，会发现ida的伪代码看不懂。\n\n通过这个伪代码，我们可以得知，a0是一个已知的数据源，它的64字节大小的offset偏移处，存放着解密后的vmp_code映射表，比方说，读取一个 a0 + 64 + index*4，命名为v1，然后将vmp_funcs_list的从0到255，把每一个元素，依次赋给 v1*8 + a2 的内存地址上，注意，这里的v1并不是逐增的。\n↑我把我的表述扔给gemini，哈哈哈，得到认可了，看来没分析错。\n\n我将函数sub_5ae5c命名为：from_DecodeVmpCode_map_to_SimulateSmaliCode。\n分析完它之后，不妨再分析sub_4A458，我想分析vmp_explain传入的参数的含义是什么。\nIDA的伪代码问题太大了，传入2个v19很明显没意义。\n\n\n基本块1。\n\n基本块2。\n\n基本块3，调用了sub_5cb98([[qword_BED18地址 + (vmp_method_code &amp; 0xFF0000)&gt;&gt;16]], vmp_method_code &amp; 0xFFFF)\n\n基本块4，sub_5cb98的操作如下。\n\n基本块5。\n\n\n基本块6。\n\n\n基本块7。\n\n\n基本块8。\n\n基本块9，sub_45EBC比较复杂，暂时先不分析，待会hook一下这个函数，可以不费吹灰之力获得——\n\n[[[qword_BED18地址 + (vmp_method_code &amp; 0xFF0000)&gt;&gt;16] + 0x38] + (vmp_method_code &amp; 0xFFFF)*8]\n\n[原SP-0x40]\n\nbundle数组的内容\n\nmalloc1的内容\n\nmalloc2的内容\n\n\n\n基本块10。\n\n\n基本块11。\n\n后面还要分析好多函数，暂时先分析到这。——2025&#x2F;05&#x2F;17。\n参考文章https://bbs.kanxue.com/thread-257926.htm#msg_header_h1_3\nhttps://bbs.kanxue.com/thread-257926.htm#msg_header_h1_2\n","tags":["安卓逆向、新手"]},{"title":"UnCrackable-Level2分析","url":"/2025/05/18/UnCrackable-Level2%E5%88%86%E6%9E%90/","content":"UnCrackable-Level2.apk直接安装+打开，又是解密。\n\n\n搜索Nope，定位到this.m.a(s)。\n\n\n在类MainActivity中，有一个私有对象m，m属于类CodeCheck，调用了函数a，最后调用了native层函数bar。\n\n\nnative层需要ida进行静态分析，这里将apk进行解压，取出其中的arm64架构的so库放入ida中，可以看到两个导出函数。\nJava_包名_类名_函数名，可以看出bar就是我们要找的函数。\n\n一眼看出，v7对应的字符串就是正确的secret。\n\n\n再看看导出的init函数，这里ida并没有给出JNIEnv和jobect，应该是反编译失误——这俩参数没用到，可能被优化了。\n\n\n在sub_918中，可以发现：fork出子进程，然后子进程通过ptrace附加到父进程，使得父进程无法其它调试器被再次附加，一个反调试技术。\n\n\nFrida通过Interceptor模块，可以支持对Native层函数的hook。\n下面这个脚本，先通过Module.findBaseAddress找到so模块的基地址，然后通过导出表符号Java_sg_vantagepoint_uncrackable2_MainActivity_init，找到它的函数地址，然后根据在文件中计算的文件偏移量，计算出要hook的无符号函数的地址。\nJava.perform(() =&gt; &#123;    const LIB_NAME = &#x27;libfoo.so&#x27;;    const EXPORT_SYMBOL = &#x27;Java_sg_vantagepoint_uncrackable2_MainActivity_init&#x27;;    const OFFSET = ptr(-1140);    function tryHook() &#123;        // 获得模块基地址        const moduleBase = Module.findBaseAddress(LIB_NAME);        if (!moduleBase) &#123;            console.log(`[!] $&#123;LIB_NAME&#125; 未加载，等待...`);            setTimeout(tryHook, 1000); // 每秒检查一次            return;        &#125;        console.log(`[+] 模块基地址: $&#123;moduleBase&#125;`);        // 通过符号名获得函数实际地址        const exportAddress = Module.getExportByName(LIB_NAME, EXPORT_SYMBOL);        if (!exportAddress) &#123;            console.error(`[!] 未找到导出函数 $&#123;EXPORT_SYMBOL&#125;`);            return;        &#125;        console.log(`[+] 导出函数地址: $&#123;exportAddress&#125;`);\t\t        // 根据偏移计算目标地址        const targetAddress = exportAddress.add(OFFSET);        console.log(`[+] 目标函数地址: $&#123;targetAddress&#125;`);        // 打印目标地址的前5个字节        const bytes = Memory.readByteArray(targetAddress, 5);        const byteArray = new Uint8Array(bytes);        const hexBytes = Array.from(byteArray).map(b =&gt; b.toString(16).padStart(2, &#x27;0&#x27;)).join(&#x27; &#x27;);        console.log(`[+] 前5个字节: $&#123;hexBytes&#125;`);        Interceptor.attach(targetAddress, &#123;            onEnter: function(args) &#123;                console.log(`\\n=== 函数调用开始 ===`);                if (Process.arch === &#x27;arm64&#x27;) &#123;                    console.log(`X0: $&#123;args[0]&#125;, X1: $&#123;args[1]&#125;, X2: $&#123;args[2]&#125;`);                &#125; else &#123;                    console.log(`R0: $&#123;args[0]&#125;, R1: $&#123;args[1]&#125;, R2: $&#123;args[2]&#125;`);                &#125;            &#125;,            onLeave: function(retval) &#123;                console.log(`返回值: $&#123;retval&#125;`);                console.log(`=== 函数调用结束 ===\\n`);            &#125;        &#125;);        console.log(`[√] Hook 安装成功`);    &#125;    setTimeout(tryHook, 1000); // 延迟1秒开始检查&#125;);\n\n然而还不够，即便hook住了这个函数，但这个函数早已经在MainActivity.onCreate阶段执行了，hook了也没用，因为已经执行过了一遍。\n针对执行时机的问题，有以下解决方法：\n1.使用spawn模式，默认的frida -U -f是“fork-and-attach”模式，可能错过早期逻辑。使用“spawn”模式可以在应用进程创建时注入Frida。\n如：frida -U -l script.js –no-pause -f com.example.app –spawn\n–spawn: 在进程创建时注入，而不是附加到已有进程。\n2.hook系统类System，然后对loadLibrary做手脚，如果加载的是其它库，不做处理；如果加载的是foo.so，则立马进行覆盖。这个hook的时机发生在静态初始化块执行之前。\nJava.perform(() =&gt; &#123;    const LIB_NAME = &#x27;libfoo.so&#x27;;    const EXPORT_SYMBOL = &#x27;Java_sg_vantagepoint_uncrackable2_MainActivity_init&#x27;;    const OFFSET = ptr(-1140);    // Hook System.loadLibrary    Java.use(&#x27;java.lang.System&#x27;).loadLibrary.implementation = function(libName) &#123;        console.log(`[+] 加载库: $&#123;libName&#125;`);        this.loadLibrary(libName); // 调用原始方法        if (libName === &#x27;foo&#x27;) &#123;            const moduleBase = Module.findBaseAddress(LIB_NAME);            if (!moduleBase) return;            const exportAddress = Module.getExportByName(LIB_NAME, EXPORT_SYMBOL);            const targetAddress = exportAddress.add(OFFSET);            Interceptor.replace(targetAddress, new NativeCallback(function() &#123;                console.log(`sub_918 被调用并覆盖`);                return 42;            &#125;, &#x27;int64&#x27;, []));            console.log(`[√] sub_918 已替换`);        &#125;    &#125;;&#125;);\n\n3.Hook MainActivity.onCreat。\n所以接下来这段脚本执行时机如下，在静态初始化块执行后（System.loadLibrary导入libfoo.so），在onCreate执行前（调用Java_sg_vantagepoint_uncrackable2_MainActivity_init之前），hook了类MainActivity，然后在它执行前，将sub_918的内容做了替换。\nJava.perform(() =&gt; &#123;    const LIB_NAME = &#x27;libfoo.so&#x27;;    const EXPORT_SYMBOL = &#x27;Java_sg_vantagepoint_uncrackable2_MainActivity_init&#x27;;    const OFFSET = ptr(-1140);    const MainActivity = Java.use(&#x27;sg.vantagepoint.uncrackable2.MainActivity&#x27;);    MainActivity.onCreate.implementation = function(savedInstanceState) &#123;        console.log(&#x27;[+] MainActivity.onCreate 被调用&#x27;);        // 在 onCreate 执行前替换 sub_918        const moduleBase = Module.findBaseAddress(LIB_NAME);        if (moduleBase) &#123;            const exportAddress = Module.getExportByName(LIB_NAME, EXPORT_SYMBOL);            const targetAddress = exportAddress.add(OFFSET);            Interceptor.replace(targetAddress, new NativeCallback(function() &#123;                console.log(`sub_918 被调用并覆盖`);                return 42;            &#125;, &#x27;int64&#x27;, []));            console.log(`[√] sub_918 已替换`);        &#125;        // 调用原始 onCreate        this.onCreate(savedInstanceState);    &#125;;&#125;);\n\n下图是安卓的初始化过程以及注入时机。\n\n\n\n\n之后尝试一下hook是否执行成功，先将脚本断掉，直接通过jeb调试进程。\n\n\n再试试通过frida进行hook后，能否attach上去调试。\n\n\n确实是attach上去了，但是手机上显示被检测到了调试，根据字符串搜索，发现问题来自于下图。\n\n\n有一个持续检测的进程，阿这，这么防着咱。。。\n只需要hook Debug.isDebuggerConnected()即可，让它一直返回false，这里就不写了。\n"},{"title":"UnCrackable-Level1分析","url":"/2025/05/18/UnCrackable-Level1%E5%88%86%E6%9E%90/","content":"UnCrackable-Level1.apk下载并安装，打开；一上来就被检测出root权限了。\n\n\n将apk丢入jeb中查看，通过ctrl + f搜索字符串。\n\n\nc.a()、c.b()、c.c()的逻辑如下图，我发现，在我的&#x2F;system&#x2F;bin中，确实有一个su。\n\n\n方案1，粗暴的解决方案，修改dex文件并重新签名。在onCreate的第一个if处，将判断结果改成false；\nJava.perform(function()&#123;  const root = Java.use(&quot;sg.vantagepoint.util.RootDetection&quot;);\troot.checkRoot1.implementation = function()&#123;\t\treturn false;\t&#125;\troot.checkRoot2.implementation = function()&#123;\t\treturn false;\t&#125;\troot.checkRoot3.implementation = function()&#123;\t\treturn false;\t&#125;&#125;);\n\n方案2，hook掉exit函数或者hook掉相关函数；\n方案3，面具magisk里直接屏蔽掉UnCrackable-Level1.apk的root权限，让它检测不到root。\n这里介绍一下第二个方法，js脚本如下，执行方法也如下，然后就绕过去了。\n# frida -U -f owasp.mstg.uncrackable1 -l .\\uncrackable-level1.jsJava.perform(function()&#123;    var temp = Java.use(&quot;java.lang.System&quot;); # 获得System类    # exit是静态函数，不需要实例化后再调用    # overload指定具体的重载版本    temp.exit.overload(&#x27;int&#x27;).implementation = function(arg0)&#123;        console.log(&quot;Exit called with &quot; + arg0);    &#125;;&#125;);\n\n\n通过jeb，可以发现在类a中，函数a会根据输入的内容进行比较，随后得出是否正确的答案。\n\n下面是写的一个js脚本，直接return true，或者通过sg.vantagepoint.a.a.a得到解密的明文。\n# 直接改为trueJava.perform(function() &#123;    // 获取目标类    var targetClass = Java.use(&#x27;sg.vantagepoint.uncrackable1.a&#x27;);        // Hook 静态方法 a(String)    targetClass.a.overload(&#x27;java.lang.String&#x27;).implementation = function(s) &#123;        console.log(&quot;\\n[*] 拦截验证方法调用&quot;);                // 打印原始输入        console.log(&quot;原始输入: &quot; + s);                // 调用原始方法获取结果        var result = this.a(s); // [!code focus]                // 打印原始验证结果        console.log(&quot;原始验证结果: &quot; + result);                // 强制返回 true（绕过验证）        console.log(&quot;[+] 强制返回 true&quot;);        return true;                // 若需保留原始逻辑，直接返回 result        // return result;    &#125;;&#125;);# 观察正确的输入Java.perform(function() &#123;    // 获取加密工具类    var crypto = Java.use(&#x27;sg.vantagepoint.a.a&#x27;);        // 获取验证类    var checker = Java.use(&#x27;sg.vantagepoint.uncrackable1.a&#x27;);        // Hook a() 方法获取密钥和密文    checker.a.overload(&#x27;java.lang.String&#x27;).implementation = function(s) &#123;        // 原始密文（Base64）        var ciphertext_b64 = &quot;5UJiFctbmgbDoLXmpL12mkno8HT4Lv8dlat8FxR2GOc=&quot;;                // 硬编码密钥（处理负数为无符号字节）        var key_bytes = [0x8D, 0x12, 0x76, 0x84, 0xCB, 0xC3, 0x7C, 0x17,                          0x61, 0x6D, 0x80, 0x6C, 0xF5, 0x04, 0x73, 0xCC];                // 将密钥转换为 Java byte[]        var jKey = Java.array(&#x27;byte&#x27;, key_bytes);                // Base64 解码密文        var ciphertext = Java.use(&#x27;android.util.Base64&#x27;).decode(ciphertext_b64, 0);                try &#123;            // 调用解密方法            var decrypted_bytes = crypto.a(jKey, ciphertext);                        // 转换为字符串            var plaintext = Java.use(&#x27;java.lang.String&#x27;).$new(decrypted_bytes);            console.log(&quot;\\n[+] 解密成功！Secret String: &quot; + plaintext);        &#125; catch(e) &#123;            console.log(&quot;[-] 解密失败: &quot; + e);        &#125;                // 返回原始验证结果（或强制返回 true）        return this.a(s);    &#125;;&#125;);\n\n执行，得到结果。\n\n"},{"title":"r2pay-v0.9分析","url":"/2025/05/18/r2pay-v0-9%E5%88%86%E6%9E%90/","content":"r2pay-v0.9.apk安装完后，一打开就闪退。\n通过adb logcat查看日志，筛选中下面的日志记录。\n02-28 10:34:38.788 11795 11795 I Magisk  : zygisk64: [re.pwnme] is on the denylist02-28 10:34:38.823 11795 11795 I re.pwnme: Late-enabling -Xcheck:jni02-28 10:34:38.845  1187  1204 I adbd    : jdwp connection from 1179502-28 10:34:38.867 11795 11795 D ProcessState: Binder ioctl to enable oneway spam detection failed: Invalid argument02-28 10:34:38.785     0     0 I binder  : 11795:11795 ioctl 40046210 7fe5e224b4 returned -2202-28 10:34:38.881 11795 11795 D CompatibilityChangeReporter: Compat change id reported: 171979766; UID 10137; state: DISABLED02-28 10:34:38.887 11795 11795 D ApplicationLoaders: Returning zygote-cached class loader: /system/framework/android.test.base.jar02-28 10:34:38.909 11795 11795 V GraphicsEnvironment: ANGLE Developer option for &#x27;re.pwnme&#x27; set to: &#x27;default&#x27;02-28 10:34:38.909 11795 11795 V GraphicsEnvironment: ANGLE GameManagerService for re.pwnme: false02-28 10:34:38.909 11795 11795 V GraphicsEnvironment: Neither updatable production driver nor prerelease driver is supported.02-28 10:34:38.911 11795 11795 D NetworkSecurityConfig: No Network Security Config specified, using platform default02-28 10:34:38.912 11795 11795 D NetworkSecurityConfig: No Network Security Config specified, using platform default02-28 10:34:39.391  2400  3117 W FrameTracker: Missing HWUI jank callback for vsyncId: 8485502-28 10:34:39.612 11795 11795 W re.pwnme: type=1400 audit(0.0:371): avc: denied &#123; read &#125; for name=&quot;cache&quot; dev=&quot;sda14&quot; ino=16 scontext=u:r:untrusted_app_29:s0:c137,c256,c512,c768 tcontext=u:object_r:cache_file:s0 tclass=lnk_file permissive=0 app=re.pwnme02-28 10:34:39.612 11795 11795 W re.pwnme: type=1400 audit(0.0:372): avc: denied &#123; read &#125; for name=&quot;cache&quot; dev=&quot;sda14&quot; ino=16 scontext=u:r:untrusted_app_29:s0:c137,c256,c512,c768 tcontext=u:object_r:cache_file:s0 tclass=lnk_file permissive=0 app=re.pwnme02-28 10:34:39.612 11795 11795 W re.pwnme: type=1400 audit(0.0:373): avc: denied &#123; read &#125; for name=&quot;cache&quot; dev=&quot;sda14&quot; ino=16 scontext=u:r:untrusted_app_29:s0:c137,c256,c512,c768 tcontext=u:object_r:cache_file:s0 tclass=lnk_file permissive=0 app=re.pwnme02-28 10:34:39.678 11795 11795 W re.pwnme: Accessing hidden method Landroid/view/View;-&gt;computeFitSystemWindows(Landroid/graphics/Rect;Landroid/graphics/Rect;)Z (unsupported, reflection, allowed)02-28 10:34:39.678 11795 11795 W re.pwnme: Accessing hidden method Landroid/view/ViewGroup;-&gt;makeOptionalFitsSystemWindows()V (unsupported, reflection, allowed)02-28 10:34:39.725 11795 11795 E RootBeer: b: a() [249] - com.topjohnwu.magisk ROOT management app detected!02-28 10:34:39.725 11795 11795 E QLog    : b: a() [249] - com.topjohnwu.magisk ROOT management app detected!02-28 10:34:39.726 11795 11795 D AndroidRuntime: Shutting down VM02-28 10:34:39.727 11795 11795 E AndroidRuntime: FATAL EXCEPTION: main02-28 10:34:39.727 11795 11795 E AndroidRuntime: Process: re.pwnme, PID: 1179502-28 10:34:39.727 11795 11795 E AndroidRuntime: java.lang.RuntimeException: Unable to start activity ComponentInfo&#123;re.pwnme/re.pwnme.MainActivity&#125;: java.lang.ArithmeticException: divide by zero02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:3707)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:3864)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:103)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.app.servertransaction.TransactionExecutor.executeCallbacks(TransactionExecutor.java:135)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:95)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2253)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.os.Handler.dispatchMessage(Handler.java:106)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.os.Looper.loopOnce(Looper.java:201)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.os.Looper.loop(Looper.java:288)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.app.ActivityThread.main(ActivityThread.java:7870)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at java.lang.reflect.Method.invoke(Native Method)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:548)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1003)02-28 10:34:39.727 11795 11795 E AndroidRuntime: Caused by: java.lang.ArithmeticException: divide by zero02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at re.pwnme.MainActivity.onCreate(SourceFile:38)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.app.Activity.performCreate(Activity.java:8057)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.app.Activity.performCreate(Activity.java:8037)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1341)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:3688)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        ... 12 more02-28 10:34:39.730  1045 11817 I DropBoxManagerService: add tag=data_app_crash isTagEnabled=true flags=0x202-28 10:34:39.730  1045  5059 W ActivityTaskManager:   Force finishing activity re.pwnme/.MainActivity02-28 10:34:39.737 11795 11795 I Process : Sending signal. PID: 11795 SIG: 9\n\n我把日志丢给grok进行分析，似乎是调用了RootBeer库进行root检测，发现了magisk，因此退出了。\n\n\n尝试搜索字符串 ROOT management app detected，这里的try catch就是用来检测root的，如果读包错误，就说明这个包不存在，不做任何处理；如果读到“危险”包，就会继续执行b.a.a.c.a.a，并将result置为true。\n\n\n追踪b.a.a.c.a.a进去看一下，发现就写了一个Log.e。\n\n查看方法b.a.a.b.a(List )的调用。\n\n\nIndex为0的方法b.a.a.b.a(String[] )如下，属于重载，可以看到，这里只是将字符串加入到packages里，并调用b.a.a.b.a(List )。\n\n而Index为1的方法b.a.a.b.b(String[] )如下，它调用了b.a.a.b.a(String[] )。\n\n之后又一直查看引用，找到b.a.a.j()，这里做了一堆检查root的内容。\n\n\n不如直接将函数j给hook了，也省得hook其它这么多函数，我观察了一下众多this.X，发现其中的this.e不仅仅在j()被调用，还在其它地方被调用。\n总结了一下，需要hook的函数如下：\nb.a.a.a()&#x2F;b.a.a.j()&#x2F;b.a.a.e()。\n首先hook方法a，一般来说，可以根据参数列表不同hook特定的、存在同名的方法，但这里要hook的方法a属于无参方法，而且存在两个无参方法a。\n下面是我找ds-r1生成的，不知道行不行得通，看得挺靠谱的，根据返回值类型来判断。（事后发现下面的脚本用不了，别学，这里作为错误示范）\nJava.perform(function() &#123;    var targetClass = Java.use(&quot;b.a.a.b&quot;);    var methods = targetClass.class.getDeclaredMethods();        methods.forEach(function(method) &#123;        if (method.getName() === &quot;a&quot; &amp;&amp; method.getParameterTypes().length === 0) &#123;            var returnType = method.getReturnType().getName();                        // Hook返回boolean的a方法            if (returnType === &quot;boolean&quot;) &#123;                method.implementation = function() &#123;                    console.log(&quot;Hooked boolean a() method&quot;);                    return this.a.apply(this, arguments);                &#125;;            &#125;            // Hook返回String数组的a方法            else if (returnType === &quot;[Ljava.lang.String;&quot;) &#123;                method.implementation = function() &#123;                    console.log(&quot;Hooked String[] a() method&quot;);                    return this.a.apply(this, arguments);                &#125;;            &#125;        &#125;    &#125;);&#125;);\n\n不过既然要hook的方法都在b.a.a类中，不妨直接将hook的方法补充进上面这个脚本里，执行后，又闪退了，不过这回查看日志，并没看到之前的那几条记录了。\n02-28 15:10:41.848  4531  4531 I crash_dump64: obtaining output fd from tombstoned, type: kDebuggerdTombstoneProto02-28 15:10:41.849   655   655 I tombstoned: received crash request for pid 452802-28 15:10:41.850  4531  4531 I crash_dump64: performing dump of process 4498 (target tid = 4528)02-28 15:10:41.871  4531  4531 E DEBUG   : failed to read /proc/uptime: Permission denied02-28 15:10:42.485     0     0 I logd    : logdr: UID=10137 GID=10137 PID=4531 n tail=0 logMask=8 pid=4498 start=0ns deadline=0ns02-28 15:10:42.486     0     0 I logd    : logdr: UID=10137 GID=10137 PID=4531 n tail=0 logMask=1 pid=4498 start=0ns deadline=0ns02-28 15:10:42.498  4531  4531 F DEBUG   : *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***02-28 15:10:42.498  4531  4531 F DEBUG   : Build fingerprint: &#x27;OnePlus/OnePlus6/OnePlus6:8.1.0/OPM1.171019.011/06140300:user/release-keys&#x27;02-28 15:10:42.498  4531  4531 F DEBUG   : Revision: &#x27;0&#x27;02-28 15:10:42.498  4531  4531 F DEBUG   : ABI: &#x27;arm64&#x27;02-28 15:10:42.498  4531  4531 F DEBUG   : Timestamp: 2025-02-28 15:10:41.870217324+080002-28 15:10:42.498  4531  4531 F DEBUG   : Process uptime: 0s02-28 15:10:42.498  4531  4531 F DEBUG   : Cmdline: com.google.android.videos02-28 15:10:42.498  4531  4531 F DEBUG   : pid: 4498, tid: 4528, name: re.pwnme  &gt;&gt;&gt; com.google.android.videos &lt;&lt;&lt;02-28 15:10:42.498  4531  4531 F DEBUG   : uid: 1013702-28 15:10:42.498  4531  4531 F DEBUG   : signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0xfaba497502-28 15:10:42.498  4531  4531 F DEBUG   :     x0  0000006fe4986670  x1  000000730a2a77cc  x2  00000071ceef6220  x3  0000006fe498661802-28 15:10:42.498  4531  4531 F DEBUG   :     x4  00000000000010b0  x5  0000000000000001  x6  0000000000000000  x7  000000000000000002-28 15:10:42.498  4531  4531 F DEBUG   :     x8  00000000000035b2  x9  00000000faba4975  x10 000000008ef93fe9  x11 000000006df6246c02-28 15:10:42.498  4531  4531 F DEBUG   :     x12 0000000000000001  x13 00000000fffffff6  x14 00000000cf86a786  x15 000000000000000102-28 15:10:42.499  4531  4531 F DEBUG   :     x16 000000730a2911f8  x17 000000730a20db40  x18 0000000000000000  x19 0000006fe498667002-28 15:10:42.499  4531  4531 F DEBUG   :     x20 0000000000000000  x21 0000006fe498acb0  x22 0000000000001192  x23 000000000000119202-28 15:10:42.499  4531  4531 F DEBUG   :     x24 0000006fe498acb0  x25 0000006fe498acb0  x26 0000006fe498aff8  x27 00000000000fc00002-28 15:10:42.499  4531  4531 F DEBUG   :     x28 0000006fe4892000  x29 0000006fe498ac4002-28 15:10:42.499  4531  4531 F DEBUG   :     lr  0000006fdffa2668  sp  0000006fe4986670  pc  0000006fdfe77f7c  pst 000000006000000002-28 15:10:42.499  4531  4531 F DEBUG   : backtrace:02-28 15:10:42.499  4531  4531 F DEBUG   :       #00 pc 0000000000038f7c  /data/app/~~IG0Dzbwr_V__IsLZxDqnLA==/re.pwnme-5cCb3aQP1IrcfKWzdCWgYQ==/lib/arm64/libnative-lib.so (BuildId: f87b3bd9fcae36e63939958f412d03a42e0ce406)02-28 15:10:42.499  4531  4531 F DEBUG   :       #01 pc 00000000000b1810  /apex/com.android.runtime/lib64/bionic/libc.so!libc.so (__pthread_start(void*)+264) (BuildId: 6bfaf10f10e5ff343703efae2f1bdbdb)02-28 15:10:42.499  4531  4531 F DEBUG   :       #02 pc 00000000000512f0  /apex/com.android.runtime/lib64/bionic/libc.so!libc.so (__start_thread+64) (BuildId: 6bfaf10f10e5ff343703efae2f1bdbdb)\n\n查看调用栈，锁定在libnative-lib.so，偏移量是38f7c，用ida打开后，访问那块地址，结果说函数太大，无法进行f5，没辙了，没啥思绪了，看看博客。\nhttps://blog.csdn.net/qq_61253776/article/details/140026070\n看来我的第一步分析是正确的，将函数j a e进行了hook，避免了java层的检测，但so层好难。\n接下来找博客一步一步做了。\nSo层的检测针对了root权限和frida注入，下面主要写分析过程。\n在re.pwnme.MainActivity类中，静态初始化块加载了native-lib，\n\n\n然后声明了其中的一个native函数并用于MainActivity的页面代码中。\n\n\n通过ida观察libnative-lib.so的export表，导出函数和全局变量都被加密了。\n\n点开.datadiv_decodexxxxxx，大部分这类函数只写了一个RET，对应的字节码是C0 03 5F D6。\n\n根据观察，其中的函数datadiv_decode4432700155380705947，它存在函数体，并且大部分操作似乎在做解密。大部分资料显示，这里是在做全局字符串的解密操作。\n\n\n除此之外，在.init_array段中，存在两个拥有函数体的函数，它们无法f5，反编译成c。\n\n\n\n过了java层后，会在so层的某处断开，地址是38f7c。\n\n在ida中来到38f7c，一路跟踪交叉引用，最后判定，这段代码属于sub_83DC。\n由于静态无法分析，只能动态分析了，博客中，这里使用了工具QBDI，QBDI是一个动态二进制插桩的DBI框架，可以追踪函数细节，如果只用frida的话，只能看到函数调用前的参数和调用后的结果。\n但QBDI咋用啊，wtf，教程也太少了。\n\n时隔多天，在分析完豆瓣后，再次看看这个apk如何分析。\n在分析豆瓣的过程中，学会了找退出点的一些方法。\n比如：hook函数pthread_create，线程在跑起来后，如果是检测frida的线程，就会杀死frida，所以可以观察哪个线程跑起来后，导致frida退出了。因为libc.so是系统库，加载先于frida的spawn模式，无需担心过早hook。\n对应的检测线程脚本如下，不是直接复制就能用，这里放在这仅供参考：\nfunction hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;);    let offset = 0x51BA8; // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset);    let listener = Interceptor.attach(call_constructors, &#123;        onEnter: function(args) &#123;            console.log(&#x27;hook_linker_call_constructors onEnter&#x27;);            let libnative_module = Process.findModuleByName(&quot;libnative-lib.so&quot;);            // 打印模块信息            if (libnative_module) &#123;                console.log(&quot;Module name: &quot; + libnative_module.name);                console.log(&quot;Base address: 0x&quot; + libnative_module.base.toString(16));                console.log(&quot;Size: &quot; + libnative_module.size);                console.log(&quot;Path: &quot; + libnative_module.path);                                check_pthread_create(libnative_module.base);                //hook_20954();                //hook_7a660();                listener.detach();            &#125;        &#125;    &#125;);&#125;function check_pthread_create(baseaddr)&#123;    /* 找到函数pthread_create的地址 */    var pthread_create = Module.findExportByName(&quot;libc.so&quot;, &quot;pthread_create&quot;);    if(pthread_create)&#123;        console.log(&quot;pthread_create is exist&quot;);    &#125;else&#123;        console.log(&quot;pthread_create is not exist&quot;);    &#125;    /* hook */    Interceptor.attach(pthread_create, &#123;        onEnter: function(args)&#123;            console.log(&quot;pthread_create is called&quot;);            console.log(&quot;arg2: 0x&quot; + (args[2] - baseaddr).toString(16));        &#125;    &#125;);&#125;\n\n之后应该就会看到几个函数的地址，然后尝试hook它们。\nfunction hook_20954()&#123;    let libnative_module = Process.findModuleByName(&quot;libnative-lib.so&quot;);    Interceptor.replace(libnative_module.base.add(0x20954), new NativeCallback(function () &#123;        console.log(`hook_20954 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; replace`);    &#125;, &#x27;void&#x27;, []));&#125;function hook_7a660()&#123;    let libnative_module = Process.findModuleByName(&quot;libnative-lib.so&quot;);    Interceptor.replace(libnative_module.base.add(0x7a660), new NativeCallback(function () &#123;        console.log(`hook_7a660 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; replace`);    &#125;, &#x27;void&#x27;, []));&#125;\n\n然后再次跑frida脚本，发现提示除以0的报错，这个报错不是在之前的java层解决了吗？\n下面这个脚本是错的，是我早期通过deepseek生成的，我还以为能用。\nfunction hook_java() &#123;        var targetClass = Java.use(&quot;b.a.a.b&quot;);        var methods = targetClass.class.getDeclaredMethods();        console.log(&quot;Methods found in b.a.a.b:&quot;);        methods.forEach(function(method) &#123;            if (method.getName() === &quot;a&quot; &amp;&amp; method.getParameterTypes().length === 0) &#123;                var returnType = method.getReturnType().getName();                console.log(&quot;Return type: &quot; + typeof returnType + &quot;, value: &quot; + returnType);                if (returnType === &quot;boolean&quot;) &#123;                    method.implementation = function() &#123;                        console.log(&quot;b.a.a.b.a() is called, res = &quot;, this.a());                        console.log(&quot;Hooked boolean a() method&quot;);                        return false;                    &#125;;                &#125;            &#125;            if (method.getName() === &quot;j&quot; &amp;&amp; method.getParameterTypes().length === 0) &#123;                var returnType = method.getReturnType().getName();                if (returnType === &quot;boolean&quot;) &#123;                    method.implementation = function() &#123;                        console.log(&quot;b.a.a.b.j() is called, res = &quot;, this.j());                        console.log(&quot;Hooked boolean j() method&quot;);                        return false;                    &#125;;                &#125;            &#125;            if (method.getName() === &quot;e&quot; &amp;&amp; method.getParameterTypes().length === 0) &#123;                var returnType = method.getReturnType().getName();                if (returnType === &quot;boolean&quot;) &#123;                    method.implementation = function() &#123;                        console.log(&quot;b.a.a.b.e() is called, res = &quot;, this.e());                        console.log(&quot;Hooked boolean e() method&quot;);                        return false;                    &#125;;                &#125;            &#125;        &#125;);&#125;\n\n将它修改成正常的、简单的脚本。\nfunction hook_java() &#123;    Java.perform(function() &#123;              var targetClass = Java.use(&quot;b.a.a.b&quot;);         targetClass.a.overload().implementation = function() &#123;            console.log(&quot;Hooked b.a.a.b.a()&quot;);            return false; // 强制返回 false        &#125;;        targetClass.j.overload().implementation = function() &#123;            console.log(&quot;Hooked b.a.a.b.j()&quot;);            return false;        &#125;;        targetClass.e.overload().implementation = function() &#123;            console.log(&quot;Hooked b.a.a.b.e()&quot;);            return false;        &#125;;    &#125;);&#125;\n\n最后整理出来的脚本如下，执行完后能正常跑apk了。\nfunction hook_java() &#123;    Java.perform(function() &#123;              var targetClass = Java.use(&quot;b.a.a.b&quot;);         targetClass.a.overload().implementation = function() &#123;            console.log(&quot;Hooked b.a.a.b.a()&quot;);            return false; // 强制返回 false        &#125;;        targetClass.j.overload().implementation = function() &#123;            console.log(&quot;Hooked b.a.a.b.j()&quot;);            return false;        &#125;;        targetClass.e.overload().implementation = function() &#123;            console.log(&quot;Hooked b.a.a.b.e()&quot;);            return false;        &#125;;    &#125;);&#125;function hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;);    let offset = 0x51BA8; // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset);    let listener = Interceptor.attach(call_constructors, &#123;        onEnter: function(args) &#123;            console.log(&#x27;hook_linker_call_constructors onEnter&#x27;);            let libnative_module = Process.findModuleByName(&quot;libnative-lib.so&quot;);            // 打印模块信息            if (libnative_module) &#123;                console.log(&quot;Module name: &quot; + libnative_module.name);                console.log(&quot;Base address: 0x&quot; + libnative_module.base.toString(16));                console.log(&quot;Size: &quot; + libnative_module.size);                console.log(&quot;Path: &quot; + libnative_module.path);                                check_pthread_create(libnative_module.base);                hook_20954();                hook_7a660();                listener.detach();            &#125;        &#125;    &#125;);&#125;function check_pthread_create(baseaddr)&#123;    /* 找到函数pthread_create的地址 */    var pthread_create = Module.findExportByName(&quot;libc.so&quot;, &quot;pthread_create&quot;);    if(pthread_create)&#123;        console.log(&quot;pthread_create is exist&quot;);    &#125;else&#123;        console.log(&quot;pthread_create is not exist&quot;);    &#125;    /* hook */    Interceptor.attach(pthread_create, &#123;        onEnter: function(args)&#123;            console.log(&quot;pthread_create is called&quot;);            console.log(&quot;arg2: 0x&quot; + (args[2] - baseaddr).toString(16));        &#125;    &#125;);&#125;function hook_20954()&#123;    let libnative_module = Process.findModuleByName(&quot;libnative-lib.so&quot;);    Interceptor.replace(libnative_module.base.add(0x20954), new NativeCallback(function () &#123;        console.log(`hook_20954 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; replace`);    &#125;, &#x27;void&#x27;, []));&#125;function hook_7a660()&#123;    let libnative_module = Process.findModuleByName(&quot;libnative-lib.so&quot;);    Interceptor.replace(libnative_module.base.add(0x7a660), new NativeCallback(function () &#123;        console.log(`hook_7a660 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; replace`);    &#125;, &#x27;void&#x27;, []));&#125;function Avoid_divide_by_zero()&#123;    let b = Java.use(&quot;b.a.a.b&quot;);    b[&quot;j&quot;].implementation = function () &#123;        return false    &#125;;&#125;hook_linker_call_constructors();setImmediate(hook_java);\n\n成功在豆瓣进修，hhhhhh。\n"},{"title":"UnCrackable-Level3分析","url":"/2025/05/18/UnCrackable-Level3%E5%88%86%E6%9E%90/","content":"UnCrackable-Level3.apk照常，安装并打开，被检测到了root，通过magisk进行root权限的隐藏。\n之后还是输入正确的密码。\n\n\n在输入错误的Secret后，会提示Nope…That’s not it. Try again.\n在Jeb中搜索这个字符串，发现关键点在check_code上。\n\n\ncheck_code调用了native层函数bar。\n\n\n在ida中，检索函数bar，一个很明显的xor解密，密钥的长度为24。\n\n为了获得正确的secret，需要将v8和qword_15038进行xor运算，得到最终的结果。\n不难看出，v8的值来自于sub_10E0，这里考虑对sub_10E0进行hook，然后查看v8的值。\n结果hook的过程遇到了反frida的检测，可以根据报错的调用栈定位到goodbye函数。\n\n\n追溯到源头，发现在sub_30D0处，调用了goodbye()，检测的逻辑是，通过读取映射到内存的文件名，只要发现frida等字段就退出。\n\n\n为了能够正常使用frida进行hook，有以下几种hook的方式，绕过反frida。\n1.hook函数sub_30D0。\n2.hook函数strstr。\nⅠ.先讲hook sub_30D0：观察过函数sub_30D0，发现它被写在了.init_array节里，这个节里面的函数，会在库加载的时候依次被调用，因此，如果想要hook这个函数，必须在System.loadLibray执行过程中——因为执行完后，frida就hook不了了；而若是还没执行，libfoo.so还没加载，当然hook不了。\n查阅了相关博客，so层的.init_array节里的函数，都是被模块linker64中的call_array调用的，所以要hook函数call_array，当下的核心目标是获得call_array在模块linker64中的偏移量。（方法随意，可以直接在ida中进行查看）\n在hook后，流程变成：遇到加载的so是libfoo.so，在完成了内存映射后，call_array还没有执行，这个时候去修改内存中sub_30D0的内容，之后正常执行call_array。\n    // 获取linker64模块的基地址    var linker64_module = Module.getBaseAddress(&quot;linker64&quot;);    //使用拦截器附加linker64模块的偏移地址    // 7D68B58764 - 7D68B38000 = 0x20764    Interceptor.attach(linker64_module.add(0x20764),&#123;        // 进入函数，代码检查参数args[3]指向的字符串是否匹配libfoo.so        onEnter:function(args) &#123;           if(args[0].readCString().match(&quot;libfoo.so&quot;)) &#123;                // 获取libfoo.so的基地址                var libfoo_module  = Module.findBaseAddress(&#x27;libfoo.so&#x27;);                console.log(&quot;获取libfoo.so的基地址==&gt;&quot;+libfoo_module)                Interceptor.replace(libfoo_module.add(0x30D0),new NativeCallback(function()&#123;                    return;                &#125;,&#x27;void&#x27;,[]));           &#125;    &#125;,onLeave:function(result)&#123;&#125;&#125;)\n\nⅡ.hook strstr就比较简单，判断strstr的第1个参数里有没有frida字段，如果有，之后的返回值直接强制返回。\n// 反frida检测Interceptor.attach(Module.findExportByName(&quot;libc.so&quot;, &quot;strstr&quot;), &#123;    onEnter: function(args) &#123;        this.haystack = args[0];        this.needle = args[1];        this.frida = false;        // 方法 1：使用 readCString（自动处理 NULL 结尾）        try &#123;            const haystack = this.haystack.isNull() ? &quot;&quot; : this.haystack.readCString();            if (haystack &amp;&amp; (haystack.includes(&quot;frida&quot;) || haystack.includes(&quot;xposed&quot;))) &#123;                this.frida = true;            &#125;        &#125; catch (e) &#123;            console.log(&quot;读取字符串失败:&quot;, e);        &#125;    &#125;,    onLeave: function(retval) &#123;        if (this.frida) &#123;            retval.replace(0);        &#125;        return retval;    &#125;&#125;);\n\nok，在解决了反frida后，继续对之前提到的sub_10E0进行解密，由于这个函数没有返回值，可以判断：这个函数会在v8所指向的地址处，修改24个字节。\n   function hookXor()&#123;           // hook xor的其中一个key       Interceptor.attach((Module.findBaseAddress(&quot;libfoo.so&quot;)).add(&quot;0x010E0&quot;), &#123;           onEnter: function(args)&#123;               console.log(&quot;onEnter: hook xor key&quot;);               this.key = args[0];           &#125;,                   onLeave: function(retval)&#123;               var key_ = new NativePointer(this.key);               var arr = key_.readByteArray(24);               console.log(arr);           &#125;       &#125;);   &#125;setTimeout(hookXor, 1000);\n\n这里为了避免hookXor未执行，特意延迟了1000ms再进行注入（方法比较简单）。\n还有其它方法，在保证加载了libfoo.so后立马进行hook，而不用等待1000ms。（同样是在加载器上做文章，不过这里hook的是System.loadLibrary）\nJava.perform(function() &#123;    const System = Java.use(&quot;java.lang.System&quot;);    const Runtime = Java.use(&quot;java.lang.Runtime&quot;);    const SystemLoad_2 = System.loadLibrary.overload(&quot;java.lang.String&quot;);    const VMStack = Java.use(&quot;dalvik.system.VMStack&quot;);    SystemLoad_2.implementation = function(library) &#123;        console.log(&quot;Loading dynamic library =&gt; &quot; + library);        try &#123;          const loaded =     Runtime.getRuntime().loadLibrary0( VMStack.getCallingClassLoader(), library);          if(library.includes(&quot;foo&quot;)) &#123;            //function that gets the xored value             Interceptor.attach(Module.findBaseAddress(&quot;libfoo.so&quot;).add(&#x27;0x00000fa0&#x27;),&#123;              onEnter: function(args)&#123;                console.log(&quot;getting other_key value&quot;);                this.other_key_address = args[0];              &#125;,              onLeave: function(retval)&#123;                var other_key = new NativePointer(this.other_key_address);                var arr = other_key.readByteArray(24);                console.log(arr);              &#125;            &#125;);          &#125;          return loaded;        &#125; catch(ex) &#123;          console.log(ex);          console.log(ex.stack);        &#125;    &#125;;&#125;);\n\n最后得到的结果如下，即：1d 08 11 13…\n\n\n同时，另一个密钥key是qword_15038，追踪后，发现是通过init函数进行初始化的，这个函数是一个jni函数，根据代码，可以发现它的值由java层传递。\n\n因此，另一个key的值是pizzapizzapizzapizzapizz。\n\n\n将两者做异或运算。\ndef xor_bytes(str1, bytes2):    &quot;&quot;&quot;    对两个24字节的数据进行逐字节的异或运算。    参数:    str1: 长度为24字节的字符串    bytes2: 长度为24字节的字节数组    返回:    result: 异或运算后的字节数组    &quot;&quot;&quot;    # 确保输入长度为24字节    if len(str1) != 24 or len(bytes2) != 24:        raise ValueError(&quot;输入必须是24字节长&quot;)    # 将字符串转换为字节数组    bytes1 = str1.encode(&#x27;utf-8&#x27;)    # 进行逐字节的异或运算    result = bytearray()    for b1, b2 in zip(bytes1, bytes2):        result.append(b1 ^ b2)    return result# 示例用法if __name__ == &quot;__main__&quot;:    # 输入字符串和字节数组    str_input = &quot;pizzapizzapizzapizzapizz&quot;  # 24字节字符串    bytes_input = bytes([0x1d, 0x08, 0x11, 0x13, 0x0f, 0x17, 0x49, 0x15, 0x0d, 0x00, 0x03, 0x19, 0x5a, 0x1d, 0x13, 0x15, 0x08, 0x0e, 0x5a, 0x00, 0x17, 0x08, 0x13, 0x14])  # 24字节的字节数组 [0, 1, 2, ..., 23]    # 执行异或运算    result = xor_bytes(str_input, bytes_input)    # 输出结果    print(&quot;异或运算结果:&quot;, result)    print(&quot;十六进制表示:&quot;, result.hex())\n\n\n\n阿这，这个解密出来的结果有点6。\n\n"},{"title":"unidbg初识","url":"/2025/05/18/unidbg%E5%88%9D%E8%AF%86/","content":"Frida和Unidbg最大的区别是，Unidbg是模拟程序执行，所以可以绕过检测，而Frida面临众多检测，需要学会反检测。\n其实在理解了Unidbg的原理之后，它还蛮简单的。\n模拟层级Unicorn模拟了底层cpu指令模拟，相当于一台裸机。当native代码调用到系统调用的指令（如x86的syscall、arch64的svc等），会将这些触发转发给AndroidEmulator进行处理。\nAndroidEmulator主要负责模拟安卓环境和系统环境和JNI交互，除此之外，它还负责处理Unicorn转发而来的系统调用。\n补环境实例讲解可以观察下面的一个需要补环境的代码。\npackage com.example.luodst;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.LibraryResolver;import com.github.unidbg.Module;import com.github.unidbg.arm.backend.Unicorn2Factory;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.*;import com.github.unidbg.linux.android.dvm.array.ByteArray;import com.github.unidbg.memory.Memory;import com.github.unidbg.virtualmodule.android.AndroidModule;import java.io.File;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.sql.SQLOutput;import java.util.ArrayList;import java.util.Enumeration;import java.util.List;import java.util.zip.ZipEntry;import java.util.zip.ZipFile;public class MainActivity extends AbstractJni &#123;    public static void main(String[] args) &#123;        MainActivity mainActivity = new MainActivity();        mainActivity.getHash();    &#125;\t// 模拟器创建    private final AndroidEmulator emulator;    // 创建java虚拟机\tprivate final VM vm;    private final Module module;    private MainActivity() &#123;        //1.创建Android模拟器实例        emulator = AndroidEmulatorBuilder                .for32Bit() // 32位虚拟机                .addBackendFactory(new Unicorn2Factory(true)) // 选择指令集，相当于选择哪台裸机，默认是unicorn                .setRootDir(new File(&quot;unidbg-android/src/test/java/com/example/luodst/rootfs&quot;)) // 设置文件系统根目录                .build(); // 创建        //2.获取操作内存的接口        Memory memory = emulator.getMemory();        //3.设置Android SDK 版本        LibraryResolver resolver = new AndroidResolver(23);        memory.setLibraryResolver(resolver); // 加载sdk里的java类（可能会添加hook）        //4.创建java虚拟机，导入apk文件        vm = emulator.createDalvikVM(new File(&quot;unidbg-android/src/test/java/com/example/luodst/files/DogPro.apk&quot;));        //5.是否打印日志        vm.setVerbose(true);        //6.将自定义的JNI处理逻辑绑定到java虚拟机上        vm.setJni(this);        // 为java环境模拟器和java虚拟机注册内存        new AndroidModule(emulator, vm).register(memory);        //7.加载目标so文件，true主动执行init init_array        DalvikModule dm = vm.loadLibrary(&quot;dogpro&quot;, true);        //8.将so文件对应的Module存入成员变量        module = dm.getModule();        //9.主动调用JNI_OnLoad        dm.callJNI_OnLoad(emulator);    &#125;    private void getHash() &#123;        DvmObject&lt;?&gt; dvmObject = vm.resolveClass(&quot;com/example/dogpro/MainActivity&quot;).newObject(null);        System.out.println(&quot;dvmObject = &quot;+ dvmObject.toString());        String input = &quot;unidbg-android/src/test/java/com/example/luodst/files/DogPro.apk&quot;;        DvmObject&lt;?&gt; ret = dvmObject.callJniMethodObject(emulator, &quot;getHash(Ljava/lang/String;)Ljava/lang/String;&quot;, input);        System.out.println(&quot;result ==&gt; &quot;+ret.getValue());    &#125;&#125;\n\n可以这么理解Unidbg补环境的过程，so文件作为elf二进制代码，可以在unicorn上面跑，但一些JNI函数，他们的参数列表需要JNI类型的数据，有时候甚至要调用一些Java层的函数（java层给native层数据时，数据类型是JNI类型），而Unidbg就是负责处理JNI交互的。\nUnidbg有自己的一套JNI类型，其内置的Java虚拟机中还内置了很多自定义的基本类型、引用类型的数据结果，如：外部虚拟机中的String类型，在Unidbg中是StringObject类型；外部的int、boolean类型，是Unidbg中的DvmInteger和DvmBoolean；除此之外，大部分引用类型在Unidbg都视作DvmClass类型（继承于DvmObject&lt;?&gt;类型），这些引用类型的对象都属于DvmObject&lt;?&gt;类型。\nDvmObject&lt;?&gt;：这是 Unidbg 中所有 Java 对象的基类，类似于真实 JVM 中的 java.lang.Object。它是一个泛型类，DvmObject&lt;T&gt; 的 T 通常表示对应的真实 Java 类型。例如，DvmObject&lt;String&gt; 表示一个 String 类型的对象。DvmClass：表示 Java 中的类对象（java.lang.Class 的模拟）。在 Unidbg 中，DvmClass 继承自 DvmObject&lt;Class&lt;?&gt;&gt;，用来表示类的元信息（如类名、方法、字段等）。\n\n\n一般情况下，不需要补环境，是因为unidbg的虚拟机中内置了很多DvmClass（解析于SDK），也内置了很多自己的处理函数，操作这些DvmObject&lt;?&gt;，但遇到一些尚未解析的DvmClass或者无法解析的DvmClass的函数，就会抛出错误，这个时候就需要为它补环境了。\n补环境的过程如下，简单来说，就是内置的类与函数不够用了，转而使用外部java虚拟机的类与函数，只将结果转换成DvmObject&lt;?&gt;返回给内部虚拟机。\n\n\n举个例子，下面这个报错是无法处理ZipFile的构造函数。\n\n一直定位追踪到下面这个函数，会发现没有针对于ZipFile类型的构造函数。\n@Overridepublic DvmObject&lt;?&gt; newObjectV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) &#123;    switch (signature) &#123;        case &quot;java/io/ByteArrayInputStream-&gt;&lt;init&gt;([B)V&quot;: &#123;            ByteArray array = vaList.getObjectArg(0);            assert array != null;            return vm.resolveClass(&quot;java/io/ByteArrayInputStream&quot;).newObject(new ByteArrayInputStream(array.value));        &#125;        case &quot;java/lang/String-&gt;&lt;init&gt;([B)V&quot;: &#123;            ByteArray array = vaList.getObjectArg(0);            assert array != null;            return new StringObject(vm, new String(array.value));        &#125;        case &quot;java/lang/String-&gt;&lt;init&gt;([BLjava/lang/String;)V&quot;: &#123;            ByteArray array = vaList.getObjectArg(0);            assert array != null;            StringObject charsetName = vaList.getObjectArg(1);            assert charsetName != null;            try &#123;                return new StringObject(vm, new String(array.value, charsetName.value));            &#125; catch (UnsupportedEncodingException e) &#123;                throw new IllegalStateException(e);            &#125;        &#125;        case &quot;javax/crypto/spec/SecretKeySpec-&gt;&lt;init&gt;([BLjava/lang/String;)V&quot;:&#123;            byte[] key = (byte[]) vaList.getObjectArg(0).value;            StringObject algorithm = vaList.getObjectArg(1);            assert algorithm != null;            SecretKeySpec secretKeySpec = new SecretKeySpec(key, algorithm.value);            return dvmClass.newObject(secretKeySpec);        &#125;        case &quot;java/lang/Integer-&gt;&lt;init&gt;(I)V&quot;: &#123;            int i = vaList.getIntArg(0);            return DvmInteger.valueOf(vm, i);        &#125;        case &quot;java/lang/Boolean-&gt;&lt;init&gt;(Z)V&quot;:&#123;            boolean b;            b = vaList.getIntArg(0) != 0;            return DvmBoolean.valueOf(vm, b);        &#125;    &#125;    throw new UnsupportedOperationException(signature);&#125;\n\n这个时候就需要为它补环境了，如何补呢？这里的ZipFile并不是基本数据类型，在项目中也没有为它进行解析。\n\n\n因此需要将这个ZipFile类型解析到Unidbg的虚拟机中，再为它创建一个对象进行返回。\n下面的代码中，vm.resolveClass负责解析ZipFile类，此时ZipFile类光荣的加入了Unidbg的虚拟机中，并重新定义为DvmObject&lt;ZipFile&gt;类，newObject返回了一个Unidbg内置的DvmObject&lt;ZipFile&gt;类对象。\n这样便解解决了一个环境问题。\n@Override   public DvmObject&lt;?&gt; newObjectV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) &#123;       switch (signature) &#123;           case &quot;java/util/zip/ZipFile-&gt;&lt;init&gt;(Ljava/lang/String;)V&quot;: &#123;               // 正确提取 String 参数               StringObject pathObj = vaList.getObjectArg(0); // 内部虚拟机的String               assert pathObj != null;               String filePath = pathObj.getValue(); // 获取实际java类型的String               try &#123;                   // 创建虚拟的 ZipFile 对象（需提前在虚拟文件系统中补文件）                   ZipFile zipFile = new ZipFile(filePath);                   return vm.resolveClass(&quot;java/util/zip/ZipFile&quot;).newObject(zipFile);               &#125; catch (IOException e) &#123;                   throw new RuntimeException(e);               &#125;           &#125;       &#125;       return super.newObjectV(vm, dvmClass, signature, vaList);   &#125;\n\n还有一个补环境的例子，下面是报错，报错理由是缺少ZipFile的entries操作。\njava.lang.UnsupportedOperationException: java/util/zip/ZipFile-&gt;entries()Ljava/util/Enumeration;\tat com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417)\tat com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)\tat com.github.unidbg.linux.android.dvm.DvmMethod.callObjectMethodV(DvmMethod.java:89)\tat com.github.unidbg.linux.android.dvm.DalvikVM$32.handle(DalvikVM.java:553)\n\n一开始的补法是这样的。\npublic DvmObject&lt;?&gt; callObjectMethodV(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VaList vaList) &#123;    switch (signature) &#123;        case &quot;java/util/zip/ZipFile-&gt;entries()Ljava/util/Enumeration;&quot;: &#123;            //拿操作的对象            ZipFile zipFile = (ZipFile) dvmObject.getValue();            //通过对象来调用方法            Enumeration&lt;? extends ZipEntry&gt; entries =  zipFile.entries();            return vm.resolveClass(&quot;java/util/Enumeration&quot;).newObject(entries);        &#125;    &#125;    return super.callObjectMethodV(vm, dvmObject, signature, vaList);&#125;\n\n但之后仍会报错，提示无法将DvmObject转换为Enumeration，为什么会出现这个问题？其实DvmObject&lt;Enumeration&gt;是我们补的一个类，但Unidbg中内置了一个Enumeration类，这个类不应该补的，因为负责与与native层交互的内置虚拟机，它默认是转换内置的Enumeration &#x3D;&gt; JNI类型，而我们导入的这个类型会被忽视。\n虽然如此，但return的这个对象很重要，这是我们通过外部虚拟机，要返回给内部虚拟机的一个Enumeration对象，如果我们返回的是它内置的com.github.unidbg.linux.android.dvm.Enumeration就没任何事，因为这是它缺少的对象，但我们返回的是com.github.unidbg.linux.android.dvm.DvmObject&lt;Enumeration&gt;，对象不一致，就要强转了，然后失败了。\njava.lang.ClassCastException: class com.github.unidbg.linux.android.dvm.DvmObject cannot be cast to class com.github.unidbg.linux.android.dvm.Enumeration (com.github.unidbg.linux.android.dvm.DvmObject and com.github.unidbg.linux.android.dvm.Enumeration are in unnamed module of loader &#x27;app&#x27;)\tat com.github.unidbg.linux.android.dvm.AbstractJni.callBooleanMethodV(AbstractJni.java:610)\tat com.github.unidbg.linux.android.dvm.AbstractJni.callBooleanMethodV(AbstractJni.java:603)\tat com.github.unidbg.linux.android.dvm.DvmMethod.callBooleanMethodV(DvmMethod.java:119)\tat com.github.unidbg.linux.android.dvm.DalvikVM$35.handle(DalvikVM.java:630)\n\n我的分析得到了grok的认可，哈哈哈哈。\n\n既然这样补不对，就需要看内置的Enumeration是如何创建的，可以看到，内置的Enumeration实现的俩函数，不过这里不是重点，重点是如何创建一个Enumeration对象。\n通过构造函数，可以看到，需要输入一个外部java中的List对象，对象里的元素是DvmObject对象即可。\n因此，我们需要创建一个List，然后把ZipFile对象里元素的类型（即ZipEntry）转换成DvmObject&lt;ZipEntry&gt;，然后再放入List中。\n\n\n这样就算补好了。\npublic DvmObject&lt;?&gt; callObjectMethodV(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VaList vaList) &#123;    switch (signature) &#123;        case &quot;java/util/zip/ZipFile-&gt;entries()Ljava/util/Enumeration;&quot;: &#123;            ZipFile zipFile = (ZipFile) dvmObject.getValue();            Enumeration&lt;? extends ZipEntry&gt; entries =  zipFile.entries();            //return vm.resolveClass(&quot;java/util/Enumeration&quot;).newObject(entries);            List&lt;DvmObject&lt;?&gt;&gt; objs = new ArrayList&lt;&gt;();            while (entries.hasMoreElements())&#123;                ZipEntry zipEntry = entries.nextElement();                objs.add(vm.resolveClass(&quot;java/util/zip/ZipEntry&quot;).newObject(zipEntry));            &#125;            return new com.github.unidbg.linux.android.dvm.Enumeration(vm, objs);        &#125;    &#125;    return super.callObjectMethodV(vm, dvmObject, signature, vaList);&#125;\n\n追踪读写/* 监控读写 */emulator.traceRead(module.base, module.base + module.size);emulator.traceWrite(module.base, module.base + module.size);\n\n读取内存/* 读取内存 */long targetAddr = module.base + 0xE0320;UnidbgPointer ptr = UnidbgPointer.pointer(emulator, targetAddr);byte[] data = ptr.getByteArray(0, 0xC0);Inspector.inspect(data, &quot;Dumped Memory at 0x&quot; + Long.toHexString(targetAddr));\n"},{"title":"v380pro apk的分析","url":"/2025/05/18/v380pro-apk%E7%9A%84%E5%88%86%E6%9E%90/","content":"v380摄像头的apk某加密数据包分析先展示成果，原始数据内容通过了gzip压缩、AES（CBC模式）加密、base64编码，反过来就可以进行解密了。\n\n先通过r0capture查看函数调用栈，然后在几个关键函数处，hook下来，打印对象值，看看具体是哪一块进行加密。发现call到a的过程中有一个加密。\n\n由于call函数的过程，涉及很多对象的初始化，数据其实也在其中进行初始化了，很难分析。\n\n这里因为打印某些对象的值（gson包），发现了加密后data属于BodyRequest的成员变量j。\n\n追踪这个j。\n\n判断j的赋值在Api.c(api)。这里又可以看到j的值由api.k得到的。\n\n继续追踪k。\n\n\n\n搜索了一下，Kalle是一个开源sdk，body函数是用来填充负载部分的。\n\n\n这里很容易就知道AES_KEY和IV。\n\n直接用工具。\n\n\n如果要尝试使用分析libapk0000.so，我觉得可以解密字符串，然后进行dump下来查看，大概就可以判断加密模式了，如果是自定义的加密模式，那可能真要逆向了。\n"},{"title":"某瓣字段_sig的分析","url":"/2025/05/18/%E6%9F%90%E7%93%A3%E5%AD%97%E6%AE%B5-sig%E7%9A%84%E5%88%86%E6%9E%90/","content":"豆瓣抓包先了解如何抓包，这次尝试分析某个参数的加解密过程。\n工具是：Charles 4.6.3。\n抓包的配置方式如下：\n1.将pc和op放在同一局域网下，pc上打开Charles，设置Proxy-&gt;Proxy Settings，填写端口并勾选，如下图所示。\n\n\n2.之后在op上，设置网络的代理，将手机的流量转发到手机的9999端口。\n\n\n3.为pc和手机装Charles的root证书，用于CA自签名。\n\n由于手机端的证书对文件名有要求，这个文件名需要通过计算获得，计算可以通过openssl x509 -subject_hash_old -in &lt;证书&gt;获得，下图是网图，它最后得到的文件名就是5cba21f7，然后后缀固定为.0，所以就是5cba21f7.0。\n\n4.在安卓7以上的版本，app只接受系统证书，不接受用户证书，所以需要将证书移至&#x2F;system&#x2F;etc&#x2F;security&#x2F;cacerts，之后重启手机。\n5.之后如图所示，设置ssl代理。\n\n之后就可以抓到包了。——上面只考虑了单向认证，如果是双向认证，有些app的包还是会显示unknown，那就要将app的证书和密钥填写至Charles中了，不过豆瓣是单向认证。\n分析根据访问不同的域名，进行区别。\n\n\n其中，参数_sig是请求签名，用于验证请求的完整性和合法性，通常由参数和密钥计算得出。\n\n这次要分析的就是如何得到这个_sig。——抓几次包，会发现每次发包的header中，就_sig的值一直在变化，所以如果想要写脚本来发包，伪造客户端，就要解决_sig构造的问题。\n通过搜索&quot;_sig&quot;，似乎找到了为_sig赋值的地方，将pair0.first经过一些规则（HTTP的规范）后，作为值赋给_sig。\n\n在setQueryParameter中会检查s是否为空，如果已存在，还会把它移除，重新进行签名。\n\n之后，我想hook上面的函数，结果遇到了frida检测。\n这次frida检测，我学到了以下几点：\n1.frida用旧一些的版本，最新的可能不稳定；\n2.把握好hook的时机，Interceptor.attach和Interceptor.replace的执行方式不同。attach是设置监控，监控目标地址，当执行到目标地址，才会启动对应的脚本内容；而replace是对目标地址立马进行替换，如果目标地址所在的模块尚未加载，会执行失败。\n以下是grok的回答。\n什么是“Hook 陷阱”？“Hook 陷阱”并不是一个官方术语，而是形象地描述了 Frida 在特定时机设置 Hook 的工作方式。简单来说，它就像在目标函数的调用路径上“埋下一个陷阱”，等待程序运行到那个位置时触发，而不是立即执行 Hook 逻辑。在 Frida 中，Hook 的实现主要通过 Interceptor 模块完成：    Interceptor.attach：附加到目标函数的入口和出口，分别在函数调用前（onEnter）和调用后（onLeave）执行自定义逻辑。    Interceptor.replace：直接替换目标函数的实现，用你定义的函数逻辑覆盖原始函数。“陷阱”的关键在于时机：    Hook 的设置（比如调用 Interceptor.attach 或 Interceptor.replace）是在你的 Frida JS 脚本运行时完成的。    Hook 的触发（比如执行 onEnter 或替换后的函数逻辑）则是在目标函数被实际调用时发生的。举个例子：javascriptInterceptor.attach(Module.getExportByName(&#x27;libc.so&#x27;, &#x27;open&#x27;), &#123;    onEnter: function(args) &#123;        console.log(&#x27;open 被调用了！&#x27;);    &#125;&#125;);    脚本运行时，Interceptor.attach 会“设置陷阱”，告诉 Frida 监控 open 函数。    但 onEnter 里的 console.log 并不会立即执行，而是等到程序调用 open 时才打印日志。这种“等待触发”的机制就是“Hook 陷阱”的核心。替换函数的时机：脚本运行后会第一时间替换吗？你提到：“将脚本跑起来后，它难道不是第一时间将 Native 层函数替换掉吗？”答案是不完全是。让我们详细分析一下。Frida 替换函数的工作原理使用 Interceptor.replace 可以替换 Native 层函数的实现。例如：javascriptInterceptor.replace(ptr(&#x27;0x12345678&#x27;), new NativeCallback(function() &#123;    console.log(&#x27;函数被替换了！&#x27;);    return 0;&#125;, &#x27;int&#x27;, []));    当脚本执行到 Interceptor.replace 时，Frida 会尝试将目标函数的地址替换为你的自定义函数。    但这有一个前提：目标函数所在的模块必须已经加载到内存中。时机的影响因素    模块是否已加载        如果你在脚本运行时要替换的函数属于某个动态加载的 .so 文件（比如 libexample.so），而这个文件在脚本启动时尚未加载，Frida 无法立即替换。        因为 Frida 需要知道模块的基址和函数的偏移量。如果 Process.findModuleByName(&#x27;libexample.so&#x27;) 返回 null，你就无法计算目标函数的地址，替换自然无法生效。    动态加载的场景        在 Android 中，很多 .so 文件是通过 dlopen（或 android_dlopen_ext）动态加载的。        如果你的目标函数在某个动态加载的模块中，你需要在模块加载后再执行替换操作。实际例子：你的代码可能的样子假设你想替换 libmsaoaidsec.so 中的某个函数 sub_1b924，代码可能是这样的：javascriptfunction hook_sub_1b924() &#123;    let module = Process.findModuleByName(&#x27;libmsaoaidsec.so&#x27;);    if (module) &#123;        let sub_1b924 = module.base.add(0x1b924);        Interceptor.replace(sub_1b924, new NativeCallback(function() &#123;            console.log(&#x27;sub_1b924 被替换了！&#x27;);            return 0;        &#125;, &#x27;int&#x27;, []));    &#125; else &#123;        console.log(&#x27;模块尚未加载！&#x27;);    &#125;&#125;    如果脚本运行时 libmsaoaidsec.so 还没加载，module 会是 null，替换不会生效。    你需要等待模块加载完成后再调用 hook_sub_1b924()。为什么不直接在脚本运行时替换？你可能会疑惑：为什么不直接在脚本启动时就完成所有替换？原因有以下几点：    模块未加载的问题        如上所述，如果目标模块没加载，Frida 无法找到函数地址，替换会失败。        解决办法是监控模块加载过程（比如 Hook android_dlopen_ext），在模块加载后再执行替换。    初始化逻辑的依赖        有些 .so 文件在加载后会执行初始化逻辑（比如通过 soinfo::call_constructors() 调用 .init 或 .init_array）。        如果你在初始化前替换函数，可能会干扰模块的正常初始化（比如反调试、校验逻辑），导致程序崩溃或行为异常。        通过在初始化开始前（比如 call_constructors 的 onEnter）替换函数，你可以更安全地介入。例如，一个常见的策略是：javascriptInterceptor.attach(Module.getExportByName(&#x27;libdl.so&#x27;, &#x27;android_dlopen_ext&#x27;), &#123;    onEnter: function(args) &#123;        this.onLeave = function(retval) &#123;            hook_sub_1b924(); // 在模块加载后替换函数        &#125;;    &#125;&#125;);    这里在 android_dlopen_ext 调用后（模块加载完成时）再执行替换，确保时机正确。总结：如何理解“Hook 陷阱”和替换时机    “Hook 陷阱”的含义        它是指在脚本运行时设置 Hook，但实际逻辑在目标函数调用时触发，就像“埋下陷阱”等待猎物。        比如通过 Interceptor.attach 设置的 onEnter 和 onLeave，都是在目标函数执行时才生效。    替换函数的时机        Interceptor.replace 在脚本运行时设置替换，但实际生效取决于模块是否加载。        如果目标函数所在的 .so 文件是动态加载的，你需要在模块加载后（比如通过 Hook android_dlopen_ext 或 soinfo::call_constructors()）再执行替换。    你的疑问解答        脚本运行后不会“第一时间”替换 Native 层函数，除非目标模块已经加载且函数地址可访问。        对于动态加载的模块，Frida 需要你手动控制替换时机，确保在正确的时间点介入。\n\n之后写的脚本如下。\nfunction hook_dlopen() &#123;    Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;),        &#123;            onEnter: function (args) &#123;                this.fileName = args[0].readCString()                console.log(`dlopen onEnter: $&#123;this.fileName&#125;`)                if (this.fileName !== undefined &amp;&amp; this.fileName.indexOf(&quot;libmsaoaidsec.so&quot;) &gt;= 0) &#123;                    hook_linker_call_constructors()                &#125;            &#125;, onLeave: function (retval) &#123;                console.log(`dlopen onLeave fileName: $&#123;this.fileName&#125;`)                if (this.fileName != null &amp;&amp; this.fileName.indexOf(&quot;libmsaoaidsec.so&quot;) &gt;= 0) &#123;                    let JNI_OnLoad = Module.getExportByName(this.fileName, &#x27;JNI_OnLoad&#x27;)                    Interceptor.attach(JNI_OnLoad, &#123;                        onLeave: function (retval) &#123;                            console.log(`JNI_OnLoad onLeave: $&#123;retval&#125;`)                        &#125;                        &#125;);                    console.log(`dlopen onLeave JNI_OnLoad: $&#123;JNI_OnLoad - Module.getBaseAddress(this.fileName)&#125;`)                &#125;            &#125;        &#125;    );&#125;function hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;)    let offset = 0x51BA8    // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset)    let listener = Interceptor.attach(call_constructors,&#123;        onEnter:function(args)&#123;            console.log(&#x27;hook_linker_call_constructors onEnter&#x27;)            let secmodule = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;)            if (secmodule != null)&#123;                // hook_pthred_create()                hook_sub_1c544() // 含检测                hook_sub_1b8d4()                // hook_sub_26e5c()                listener.detach()            &#125;        &#125;    &#125;)&#125;function hook_pthred_create()&#123;    console.log(&quot;libmsaoaidsec.so --- &quot; + Process.findModuleByName(&quot;libmsaoaidsec.so&quot;).base)    Interceptor.attach(Module.findExportByName(&#x27;libc.so&#x27;,&#x27;pthread_create&#x27;),&#123;        onEnter(args)&#123;            let func_addr = args[2]            console.log(`The thread Called function address is: $&#123;func_addr&#125;`)        &#125;    &#125;)&#125;function hook_sub_1c544() &#123;    let secmodule = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;)    Interceptor.replace(secmodule.base.add(0x1c544), new NativeCallback(function () &#123;      console.log(`hook_sub_1c544 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; replace`)    &#125;, &#x27;void&#x27;, [&quot;int64&quot;]));&#125;function hook_sub_1b8d4() &#123;    let secmodule = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;)    Interceptor.replace(secmodule.base.add(0x1b8d4), new NativeCallback(function () &#123;      console.log(`hook_sub_1b8d4 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; replace`)    &#125;, &#x27;void&#x27;, []));&#125;function hook_sub_26e5c() &#123;    let secmodule = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;)    Interceptor.replace(secmodule.base.add(0x26e5c), new NativeCallback(function () &#123;      console.log(`hook_sub_26e5c &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; replace`)      return 1;    &#125;, &#x27;int64&#x27;, []));&#125;setImmediate(hook_dlopen)\n\n逻辑算比较清楚，之后还剩下对业务函数的hook、利用_sig构造包。\n接着分析方法e0.d.A(Request request0)。\n\n然后写了这个函数，每次我将这个函数放到hook_dlopen的末尾，就无法正确hook上之前的3个线程。之后我发现，可以通过cmd行输入。\nfunction hook_sig()&#123;    Java.perform(function()&#123;        const clazz_d = Java.use(&quot;e0.d&quot;);        clazz_d.A.implementation = function (request) &#123;            console.log(`request-header: $&#123;request.header(&quot;Authorization&quot;)&#125;`);            return this.A(request);        &#125;    &#125;)&#125;\n\n结果如下。\n\n这里就获得了Authorization的值：93f4c257daea24dfbbde470790be6e9d。\n在方法d.z中，将url、method、authorization进行加密\n\n这里就不进去追踪了，直接获取返回值。\n直接获取了_sig和_ts的值。\nfunction hook_sig()&#123;    Java.perform(function()&#123;        const clazz_d = Java.use(&quot;e0.d&quot;);        clazz_d.A.implementation = function (request) &#123;            console.log(`request-header: $&#123;request.header(&quot;Authorization&quot;)&#125;`);            let res = this.A(request);            console.log(`Pair-first: $&#123;new String(res.first)&#125;\\nPair-second: $&#123;new String(res.second)&#125;`);            return res;        &#125;    &#125;)&#125;\n\n\n之后要利用并构造包的话，只需要添加上自己生成的_sig参数，这里用js脚本，模仿jeb的代码构造_sig，最终，完整的代码如下。\nvar url;var method;var authorization;function hook_dlopen() &#123;    let listener = Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;),        &#123;            onEnter: function (args) &#123;                this.fileName = args[0].readCString()                console.log(`dlopen onEnter: $&#123;this.fileName&#125;`)                if (this.fileName !== undefined &amp;&amp; this.fileName.indexOf(&quot;libmsaoaidsec.so&quot;) &gt;= 0) &#123;                    hook_linker_call_constructors()                    listener.detach()                &#125;            &#125;        &#125;    );    // hook_sig()&#125;function hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;)    let offset = 0x51BA8    // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset)    let listener = Interceptor.attach(call_constructors,&#123;        onEnter:function(args)&#123;            console.log(&#x27;hook_linker_call_constructors onEnter&#x27;)            let secmodule = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;)            if (secmodule != null)&#123;                // hook_pthred_create()                hook_sub_1c544()                hook_sub_1b8d4()                hook_sub_26e5c()                listener.detach()            &#125;        &#125;    &#125;)&#125;function hook_pthred_create()&#123;    console.log(&quot;libmsaoaidsec.so --- &quot; + Process.findModuleByName(&quot;libmsaoaidsec.so&quot;).base)    Interceptor.attach(Module.findExportByName(&#x27;libc.so&#x27;,&#x27;pthread_create&#x27;),&#123;        onEnter(args)&#123;            let func_addr = args[2]            console.log(`The thread Called function address is: $&#123;func_addr&#125;`)        &#125;    &#125;)&#125;function hook_sub_1c544() &#123;    let secmodule = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;)    Interceptor.replace(secmodule.base.add(0x1c544), new NativeCallback(function () &#123;      console.log(`hook_sub_1c544 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; replace`)    &#125;, &#x27;void&#x27;, [&quot;int64&quot;]));&#125;function hook_sub_1b8d4() &#123;    let secmodule = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;)    Interceptor.replace(secmodule.base.add(0x1b8d4), new NativeCallback(function () &#123;      console.log(`hook_sub_1b8d4 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; replace`)    &#125;, &#x27;void&#x27;, []));&#125;function hook_sub_26e5c() &#123;    let secmodule = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;)    Interceptor.replace(secmodule.base.add(0x26e5c), new NativeCallback(function () &#123;      console.log(`hook_sub_26e5c &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; replace`)      return 1;    &#125;, &#x27;int64&#x27;, []));&#125;function hook_sig()&#123;    Java.perform(function()&#123;        const clazz_d = Java.use(&quot;e0.d&quot;);        clazz_d.A.implementation = function (request) &#123;            authorization = request.header(&quot;Authorization&quot;);            authorization = authorization.substring(7);            url = request.url().toString();            method = request.method();            console.log(`request-header: $&#123;authorization&#125;`); // 打印Authorization            let res = this.A(request);            console.log(`Pair-first: $&#123;new String(res.first.value)&#125;\\nPair-second: $&#123;new String(res.second.value)&#125;`); // 打印Pair            // MySig，自己模仿流程写一个            getMySig();            return res;        &#125;    &#125;)&#125;function getMySig() &#123;    const HttpUrl = Java.use(&quot;okhttp3.HttpUrl&quot;);    const StringBuilder = Java.use(&quot;java.lang.StringBuilder&quot;);    const clazz_a = Java.use(&quot;android.support.v4.media.a&quot;);    const Uri = Java.use(&quot;android.net.Uri&quot;);    // 临时硬编码 s3    var s3 = Java.use(&quot;java.lang.String&quot;).$new(&quot;bf7dddc7c9cfe6f7&quot;);    if (!url || !method || !authorization) &#123;        console.error(&quot;url, method, or authorization is undefined&quot;);        return;    &#125;    var stringBuilder0 = clazz_a.g(method);    if (!stringBuilder0) &#123;        console.error(&quot;clazz_a.g(method) returned null&quot;);        return;    &#125;    var s4 = HttpUrl.parse(url).encodedPath();    if (!s4) &#123;        console.error(&quot;HttpUrl.parse failed&quot;);        return;    &#125;    var s5 = Uri.decode(s4);    if (s5.endsWith(&quot;/&quot;)) &#123;        s5 = clazz_a.e(s5, -1, 0);    &#125;    stringBuilder0.append(&quot;&amp;&quot;).append(Uri.encode(s5)).append(&quot;&amp;&quot;).append(authorization);    var v = Java.use(&quot;java.lang.System&quot;).currentTimeMillis().toString();    v = v.substring(0, v.length - 3);    stringBuilder0.append(&quot;&amp;&quot;).append(v);    var mac0 = Java.use(&quot;javax.crypto.Mac&quot;).getInstance(&quot;HmacSHA1&quot;);    mac0.init(Java.use(&quot;javax.crypto.spec.SecretKeySpec&quot;).$new(s3.getBytes(), &quot;HmacSHA1&quot;));    const Base64 = Java.use(&quot;android.util.Base64&quot;);    stringBuilder0.toString()    let strrr = stringBuilder0.toString();    console.log(`typeof strrr: $&#123;typeof strrr&#125;`);    let bytes = Java.use(&quot;java.lang.String&quot;).$new(strrr).getBytes();    console.log(`typeof Java.use(&quot;java.lang.String&quot;).$new(strrr): $&#123;typeof Java.use(&quot;java.lang.String&quot;).$new(strrr)&#125;`);    var res = mac0.doFinal(bytes);    var s6 = Base64.encodeToString(res, 2);    // 确保 s6 和 v 是正确的 Java 字符串    var pair = Java.use(&quot;android.util.Pair&quot;).$new(        s6, v);    console.log(`MySig: $&#123;pair.first&#125;`);    return pair;&#125;setImmediate(hook_dlopen)\n\n其中，有一个问题，如下代码卡了我很久。在我眼中，这里的strrr一定是一个js代理java的String类型，是一个属于java的字符串，但被frida自动转换成了JavaScript字符串，而JS字符串没有getBytes函数。\nstringBuilder0.toString()let strrr = stringBuilder0.toString();let bytes = Java.use(&quot;java.lang.String&quot;).$new(strrr).getBytes();// 原本写的是strrr.getBytes()\n\nhttps://reverseengineering.stackexchange.com/questions/32790/convert-string-to-byte-array-in-frida-js-script\n通过js的函数，typeof去查看区别，可以发现stringBuilder0.toString()的类型是string，而Java.use(“java.lang.String”).$new(strrr)的类型是object。\n\n至此，脚本也算是跑出了_sig签名。\n"},{"title":"类加载与脱壳机","url":"/2025/05/18/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E8%84%B1%E5%A3%B3%E6%9C%BA/","content":"自制脱壳机，将公开了源码的Fart6移植到Fart10，同时去除一些Fart特征。\nloadClass的过程loadClass的过程可以总结成：1.判断是否是当前类加载器加载了此类；2.若不是，让父加载器加载此类；3.若父加载器加载失败，由当前加载器加载。\n一般实现类加载，同时使用ClassLoader的实例调用loadClass。\n\n可以看到，ClassLoader.loadClass(String className)间接调用重载函数，resolve在这里不起作用，在JVM中，如果resolve为true，表示加载类之后是否需要立即进行链接操作中的解析步骤。（链接包括：验证、准备（分配空间）、解析），而在安卓虚拟机中，这里忽略resolve。\n\n\n1 findLoadedClass（ClassLoader）——查询当前加载器是否加载了目标类findLoadedClass是用来检查缓存的，这个方法会检查当前ClassLoader实例是否已经加载过名为className的类，每个ClassLoader实例都有一个缓存区，用来存放已经加载过的类。\n如果当前实例是启动类加载器，则将局部变量 loader 设为 null。这是因为查询启动类加载器加载的类通常需要通过 VM 的特殊 native 接口，并使用 null 来代表它。\n如果当前实例不是启动类加载器（比如是 AppClassLoader 或 PathClassLoader 等），则将 loader 设置为 this，即当前 ClassLoader 实例本身。\n\nfindLoadedClass（VMClassaLoader、JNI函数）这里的VMClassLoader.findLoadedClass是一个static的JNI函数，具体实现在native层，目录为：&#x2F;art&#x2F;runtime&#x2F;native&#x2F;java_lang_VMClassLoader.cc。\n这个 C++ 函数 VMClassLoader_findLoadedClass 的核心目的是：接收一个 Java 层的 ClassLoader 对象和一个类名字符串，然后在 ART 虚拟机内部的数据结构中查找，判断这个特定的 ClassLoader 是否已经加载并解析了具有该名称的类。如果找到了并且类是可用状态（已解析），就返回对应的 Java Class 对象 (jclass)；否则返回 nullptr。\n现在来简单解释一下下图的函数VMClassLoader_findLoadedClass。\n第31行，env是标准的JNI的接口，提供java与native之间的交互。soa可以理解为ART对JNI交互的封装与简化，它的底层还是使用env来工作，但自动管理线程状态，更安全、方便。\n第32行，将Java层的jobject javaLoader解码成ART内部表示的mirror::ClassaLoader*指针loader，这里的mirror是ART中表示Java堆对象的类的命名空间。\n第33行，将javaName从java的jstring转换成c&#x2F;c++使用的UTF-8编码字符串。\n第37行，获取ClassLinker实例，ClassLinker实例要负责类的加载、链接（验证、准备、解析）、初始化。所有类查找、类定义、解析相关的操作，都要经过ClassLinker。\n第38行，将点分格式的类名转换成虚拟机内部使用的描述符，即斜杠格式。\n第39行，将类描述符转换成唯一的哈希值。\n第40行，根据哈希值、loader、类描述符、当前的线程（soa.Self()返回线程Thread指针），来去找*唯一的类。\n这里重点关注LookupClass。\n\n\nLookupClass在LookupClass中。\n第一阶段，查主表。（缓存查找）\n使用 ReaderMutexLock 获取对 ClassLinker 内部类表的读取锁，保证线程安全。\n调用 LookupClassFromTableLocked 在主要的类表（包括 Zygote 预加载表 pre_zygote_class_table_ 和运行时表 class_table_）中查找。\n如果在表中找到了匹配的类 (result != nullptr)，就立即返回结果。锁会自动释放。\n第二阶段，查启动镜像（启动类加载器）。\n仅当第一阶段失败、查找的是启动类加载器 (class_loader == nullptr)、且需要查找镜像时，才执行这里。\n调用 LookupClassFromImage(descriptor) 尝试在 dex_caches_ 中查找。\n如果找到了 (result != nullptr): 调用 InsertClass 将其加入主类表（可能是 class_table_），起到缓存作用，然后返回找到的 result。\n如果还没找到 (result == nullptr): 增加查找镜像失败的计数器。如果失败次数超过阈值 (kMaxFailedDexCacheLookups)，则触发一个优化操作 MoveImageClassesToClassTable()，将所有启动镜像中的类都添加到主类表中，以加速后续查找。最后返回 nullptr。\n\nLookupClassFromTableLocked在LookupClassFromTableLocked中，pre_zygote_class_table_记录着预加载的类（Zygote进程在创建时，初始化了虚拟机并加载了一系列预加载的动态链接库，这些动态链接库里的类记录在这个预加载类表里）。而class_table_则是动态类表，它存储了 Zygote 之后由各种 ClassLoader 加载的类，以及从启动镜像（image）查找到并缓存起来的类。\n\nLookupClassFromImage函数LookupClassFromImage是从启动类加载器的dex_cache中找目标类，DexCache类用于关联DexFile对象。\n\n\n\n2 parent.loadClass——委托父加载器加载上述流程已经把如何寻找一个类讲得很详细了，接下来讲委派双亲机制。\n下图中，在findLoadedClass找不到className后，就会尝试执行parent.loadClass，让父加载器去加载，父加载器的执行流程也是：findLoadedClass、parent.loadClass、findClass。\n所以，这里不细讲委派机制（双亲委派机制不难），直接讲如何加载一个未加载的类。\n\n\n3 findClass——自己加载这里分析的是BaseDexClassLoader的findClass，一般整体壳都绕不开BaseDexClassLoader，BaseDexClassLoader的父类是ClassLoader，我们之前分析的findLoadedClass和parent.loadClass都是ClassLoader类中，loadClass里出现的函数。BaseDexClassLoader并没有实现自己的loadClass，所以loadClass都是从ClassLoader继承过来的。\n但ClassLoader的findClass已经被BaseDexClassLoader覆写了，我们这里就需要分析findClass。\nfindClass 函数的核心职责就是：在当前 ClassLoader 管理的一系列 Dex 文件中，按顺序查找指定的类，如果找到，就加载并定义它。\n下图中，pathList是个老熟人了。\n\npathList——属于类DexPathListpathList是BaseDexClassLoader声明的一个DexPathList类型的私有成员变量。\n\n关于DexPathList，从字面上来看，它是存储Dex路径列表的一个变量，从功能上来说，它存储的路径包括：apk的路径、dex的路径、jar的路径、class的路径等。然而，类DexPathList存储路径的列表（成员变量）叫dexElements，这一度让我以为——“一个Element实例代表一个Dex文件路径”，这个概念其实是错的。\n通过注释，其实可以知道，这个成员变量应该叫pathElements，结果因为Facebook app改了名字，What can I say。\n纠正一下上面的概念，这里的dexElements是一个Element数组，每个Element实例存储的是一个路径，这个路径要是指向apk，可能包含不止一个Dex，所以一个Element实例代表一个Dex文件路径的概念是错误的。\n\n\n接着看看DexPathList的findClass。\n可以看到，这里取出了每个Element实例，并取出了element.dexFile赋给dex，然后调用了dex.loadClassBinaryName去找目标类是否在当前的文件（apk&#x2F;dex&#x2F;jar&#x2F;class）中。\n\ndexElements——属于类Element类Element是定义在DexPathList的静态内部类，从成员变量中可以看出，它存储的类型有apk&#x2F;zip&#x2F;dex等，还有一个很关键的成员变量dexFile。\n\n\nmCookie——属于类DexFileDexFile的mCookie很重要，在native层中，通过相关函数的调用，可以利用mCookie去获取DexFile（可以理解为PathFile）里存放的所有Dex文件。\n\n\n阅读DexFile.java中的代码，会发现mCookie的值由jni函数openDexFileNative获得。\n\n\n\njava层openDexFileNative对应着native层的DexFile_openDexFileNative。\n第154-161行，将输入的jstring转换成c&#x2F;c++的const char*来使用。\n第163行，获取ART运行时的ClassLinker实例，打开Dex文件和处理OAT文件是ClassLinker的职责之一。\n第164行，创建一个std::vector，用于存放成功打开的DexFile对象。\n第165行，创建error_msgs用于收集打开过程中可能出现的错误信息。\n第167行，可以理解为OpenDexFilesFromOat将已打开的Dex文件(们)的内部句柄打包成一个long[]数组，返回给dex_files。\n第170行，将这些句柄从native类型转换成JNI类型，赋值给array，array会通过return赋给Java层的mCookie。\n\n\n于是我们知道了，mCookie是已打开的Dex文件们的句柄数组指针。\nloadClassBinaryName——属于类DexFile回到这张图，讲DexFile的loadClassBinaryName。\n\n直接跳转到defineClass。\n\n再跳转到defineClassNative。\n\n\ndefineClassNative是一个静态JNI函数。\n第220行，眼熟吧，将cookie转换回了dex_files句柄数组。\n第234行，遍历每一个打开的Dex文件句柄。\n第235行，通过函数FindClassDef，去每个Dex文件里寻找目标Class是否存在。\n第236行，如果存在，则通过ClassLinker的实例class_linker，对这个Dex文件进行注册，加入dex_caches。\n\nFindClassDef——找到类定义这个函数的核心目的是：在当前的 DexFile 对象所代表的 Dex 文件内部，根据给定的类描述符 (descriptor) 字符串和其哈希值，查找并返回对应的 DexFile::ClassDef 结构体指针。\n其中，第481-485行，在解析一个Dex文件，获得Class的数量。\n第486-499行，遍历类定义表，根据类定义结构的class_idx_是指向type索引表，这里通过描述符descriptor获取到了type_idx，然后和每个类的class_idx_进行比较，以此找出类。\n\n\n下图是ClassDef的结构。\n\n\nRegisterDexFile——将DexFile加入缓存dex_cache会被加入ClassLinker中的dex_caches_中（通过dex_caches_.push_back），ClassLinker会通过这个列表跟踪所有已注册的Dex缓存，建立了dex_cache和dex_file之间的连接（dex_cache-&gt;SetDexFile(&amp;dex_file)）。\n这个过程确保了每个被 ART 管理的 Dex 文件都有一个对应的 DexCache，并且 ClassLinker 能够找到并管理这些缓存。\n\n\nDefineClass——类的加载、链接、初始化这个函数是实际定义一个新类的核心逻辑。它接收一个在 dex_file 中找到的类定义 dex_class_def，以及要使用的 class_loader，然后负责创建对应的运行时 mirror::Class 对象，并执行加载和链接的关键步骤。\n\n\n第1816行-1829行，处理特殊的类。\n第1831-1841行，分配内存创建Class对象。\n第1842行，将DexFile对应的DexCache设置到Class对象中。\n第1844行，用ClassDef和ClassLoader信息填充Class对象。\n第1847-1850行，为String类专门进设置标志。——没深入分析。\n第1853-1854行，获得这个类的锁，防止并发初始化，记录当前线程为类的初始化线程。\n\n第1857行，根据描述符、Class对象.Get()、类描述符的hash值插入一个新加载的类到类表class_table_中。\n第1858-1862行，插入失败，说明被其它线程插入了，使用已存在的Class对象并确保它已经被解析。\n第1868-1876行，加载类的成员（字段和方法信息），如果失败，标志Class状态为Error。\n第1878-1879行，此时类状态应该为Loaded（成员已经加载，但父类&#x2F;接口未连接）。\n第1880行，加载并链接父类和接口。\n第1894行，执行链接（验证、准备、解析字段&#x2F;方法、设置vtable&#x2F;iftable等）。\n\n最后返回的是一个定义并链接好的Class对象。\n\n\n整个逻辑如下图所示。\n\n\n（注：说明一下，Java的DexFile类和C&#x2F;C++的DexFile类不一样，Java的DexFile通常指向一个APK文件或JAR文件或Dex文件等等，所以一个DexFile类可能会存储着许多个Dex文件；而C&#x2F;C++的DexFile类指向一个Dex文件）\n一个 Java DexFile 对象虽然是基于一个单一的源文件路径 (APK&#x2F;JAR) 创建的，但它内部通过 mCookie (一个 long[] 数组) 可以管理从该源文件或其对应的 OAT 文件中加载出来的一个或多个底层的 C++ art::DexFile 实例。这对于支持 Android 的 MultiDex 机制至关重要。\nFart的逻辑Fart脱壳的步骤主要分为3步：\n1.找到合适的点，通过DexFile结构脱下完整的dex；\n2.主动调用类中的每一个方法，并实现对CodeItem的dump；\n3.修复Dex。\n整体壳下图是Fart的第1点的逻辑。\n一个类的初始化函数是不会被直接编译成OAT代码的，而一个Java的Method，除了走OAT代码模式，就必须走解释器模式，解释器模式必须经过函数Execute，因此，可以在Execute里针对进行dump，以完成整个dex的dump。\n\n抽取壳下图是Fart的第2点逻辑。\n\n之后，又有人写了一个FartExt，逻辑如下。\n\n","tags":["安卓逆向 类加载 Fart"]},{"title":"算法逆向分析初识","url":"/2025/05/18/%E7%AE%97%E6%B3%95%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%88%9D%E8%AF%86/","content":"hellojni_2.0.7.apk目标：还原signs的加密算法。\n点击SIGN2按钮后，下面这个签名会发生改变。\n\n\n通过定位，发现这个签名是由JNI函数Java_com_example_hellojni_HelloJni_sign2生成的。\n进一步，对其中的sub_1CFF0进行hook，发现其第3个参数（从1开始算）便是签名。\n\n\nhook的代码如下，将其中的addr赋值为1CFF0即可。\nfunction hook_find_target_address(addr)&#123;    var base = Module.findBaseAddress(&quot;libhello-jni.so&quot;);    console.log(&quot;\\r\\nlibhello-jni.so Baseaddr: &quot; + base);    var target_addr = base.add(addr);    console.log(&quot;\\r\\nTarget Address: &quot; + target_addr);    // hook并打印参数和返回值    Interceptor.attach(target_addr, &#123;        onEnter(args)&#123;            this.arg0 = args[0];            this.arg1 = args[1];            this.arg2 = args[2];            console.log(&quot;\\r\\nsub_&quot; + addr.toString(16) + &quot;args: &quot;);            console.log(&quot;\\r\\ninput_str: \\r\\n&quot; + hexdump(this.arg0));            console.log(&quot;\\r\\ninput_str_length: &quot; + this.arg1);        &#125;,        onLeave(retval)&#123;            console.log(&quot;\\r\\noutput_str: \\r\\n&quot; + hexdump(this.arg2));        &#125;    &#125;)&#125;\n\n打印的结果如下图所示。\n\n\n为了方便分析，这里需要将input_str和input_str_length进行固定。\n如图所示，我将输入字符串固定为”1234567890abcdefg”。\nfunction hook_find_target_address(addr)&#123;    var base = Module.findBaseAddress(&quot;libhello-jni.so&quot;);    console.log(&quot;\\r\\nlibhello-jni.so Baseaddr: &quot; + base);    var target_addr = base.add(addr);    console.log(&quot;\\r\\nTarget Address: &quot; + target_addr);        // hook并打印参数和返回值    Interceptor.attach(target_addr, &#123;        onEnter(args)&#123;            // 保存原始参数值以便打印            this.arg0 = args[0];            this.arg1 = args[1];            this.arg2 = args[2];                        console.log(&quot;\\r\\nsub_&quot; + addr.toString(16) + &quot; args: &quot;);            console.log(&quot;\\r\\n原始input_str: \\r\\n&quot; + hexdump(this.arg0, &#123; length: parseInt(this.arg1) &#125;));            console.log(&quot;\\r\\ninput_str_length: &quot; + this.arg1);                        // 新字符串            var new_str = &quot;1234567890abcdefg&quot;;                        // 方法1：直接写入内存            Memory.writeUtf8String(args[0], new_str);                        // 方法2：如果需要写入二进制数据而不是UTF8字符串            // var bytes = [0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x00]; // &quot;1234567890abcdef\\0&quot;            // Memory.writeByteArray(args[0], bytes);                        var length = new_str.length;            args[1] = ptr(length);            this.args1 = args[1];            console.log(&quot;\\r\\n修改后的长度: &quot; + this.args1);            console.log(&quot;\\r\\n修改后input_str: \\r\\n&quot; + hexdump(args[0], &#123; length: parseInt(this.args1) &#125;));        &#125;,        onLeave(retval)&#123;            console.log(&quot;\\r\\noutput_str: \\r\\n&quot; + hexdump(this.arg2, &#123; length: parseInt(this.args1) &#125;));        &#125;    &#125;);&#125;\n\n\n\n在确保了输入字符串不变后，尝试使用IDA的trace，追踪函数sub_1CFF0。\n先注入frida、再注入IDA server——似乎不按这个顺序，先注入IDA再注入Frida，Frida会注入失败。\n我决定先退出Frida的hook，再进行追踪，因为我发现Frida要是已经hook了sub_1CFF0，在sub_1CFF0的函数开始的地方，会存在inline hook，跳转到Frida的跳床函数。\n\n\n通过IDA trace，走过的汇编指令会变成黄色。\n\n追踪到的内容如下图所示，第一栏的36EE是线程id，第二栏是地址，第三栏开始就是汇编指令了，如果汇编指令修改了寄存器，则会在汇编指令后面，显示寄存器被修改后的值。\n\n之后，我重新生成了一个trace记录，并记录了一下签名值。\n\n\n之后进行算法逆向。\n已知算法的输入是input_str &#x2F; input_str_length &#x2F; output_str，分别代表着X0、X1、X2。\n\n因为X2代表着output_str的内存地址，所以追踪X2，判断有哪些指令对地址0x00000079E1720D90上的内容进行了修改。\n\n\n查找到了34个对0x00000079E1720D90进行读写的位置。\n对其中一些指令进行还原，可以猜到。\nX8代表：当前正在操作output的第X8个字节，也代表循环次数；\nX5代表output的内存地址；\nX29[var_64]是一个固定字节数组。\nX29[var_68]也是一个固定字节数组。\n至于var_6C，最后还是追踪到var_68上。\n\n做了一些补充。\n\n一直追踪[X29,#var_64]。\n\n而一直追踪[X29,#var_68]，会发现需要追踪X2，继而追踪X2和X3，继而追踪X3和X7……\n最后追踪到[X29,#var_88]。\n\n最后发现，var_88这个变量是一个指针，它将地址给了X2，由X2去获取全局变量，也就是图中的xmmword_79A31EE7B0。\n\n至此，可以将全局变量及涉及到的寄存器改写成c。\n(解密的时候前8个字节和后8个字节的处理方式不同，可能还得逆，这里我直接贴别人逆好的代码)\n#include &lt;iostream&gt;#include &lt;cstring&gt;void enc_function(const char* input_str, int input_len, char* result) &#123;    const char* table_key1 = &quot;9d9107e02f0f07984956767ab1ac87e5&quot;;    const unsigned char table_key2[] = &#123;0x37, 0x92, 0x44, 0x68, 0xA5, 0x3D, 0xCC, 0x7F, 0xBB, 0xF, 0xD9, 0x88, 0xEE, 0x9A, 0xE9, 0x5A&#125;;    for (int i = 0; i &lt; input_len; ++i) &#123;        unsigned char X2 = input_str[i];        unsigned char key2 = table_key2[(i &amp; 0xF) &amp; 0xFFFFFFFF];        unsigned char W8 = 0xDA;        unsigned char W30 = 0x25;        unsigned char W2 = X2;        unsigned char W7 = W8 &amp; (~W2);        W2 = W2 &amp; 0x25;        W2 = W7 | W2;        unsigned char W3 = key2;        W7 = W8 &amp; (~W3);        W3 = W3 &amp; W30;        W3 = W7 | W3;        W2 = W2 ^ W3;        W3 = W2;        unsigned char key1 = table_key1[(i ^ 0xFFFFFFF8) &amp; i ];        W2 = key1;        W7 = key2;        W30 = key2;        unsigned char W1 = W2 &amp; (~W3);        W3 = W3 &amp; (~W2);        unsigned char W5 = W30 &amp; (~W2);        W2 = W2 &amp; (~W30);        W1 = W1 | W3;        W2 = W5 | W2;        W1 = W1 + W7;        W3 = W1 &amp; (~W2);        W1 = W2 &amp; (~W1);        W1 = W3 | W1;        result[i] = W1;    &#125;&#125;bool test_eq(const char* buf1, const char* buf2, int buf_len) &#123;    for (int i = 0; i &lt; buf_len; ++i) &#123;        if (buf1[i] != buf2[i]) &#123;            return false;        &#125;    &#125;    return true;&#125;int main() &#123;    const char* input = &quot;0123456789abcdef0123456789abcdef&quot;;    int len = strlen(input);    char* result = (char*)malloc(len);    memset(result, 0, len);    enc_function(input, len, result);    for (int i = 0; i &lt; len; ++i) &#123;        printf(&quot;%02x&quot;, (unsigned char)result[i]);    &#125;    printf(&quot;\\r\\n%x&quot;, test_eq(result, result, len));    free(result);    return 0;&#125;\n"}]