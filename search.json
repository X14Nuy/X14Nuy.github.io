[{"title":"UnCrackable-Level2分析","url":"/2025/05/18/UnCrackable-Level2%E5%88%86%E6%9E%90/","content":"UnCrackable-Level2.apk直接安装+打开，又是解密。\n\n\n搜索Nope，定位到this.m.a(s)。\n\n\n在类MainActivity中，有一个私有对象m，m属于类CodeCheck，调用了函数a，最后调用了native层函数bar。\n\n\nnative层需要ida进行静态分析，这里将apk进行解压，取出其中的arm64架构的so库放入ida中，可以看到两个导出函数。\nJava_包名_类名_函数名，可以看出bar就是我们要找的函数。\n\n一眼看出，v7对应的字符串就是正确的secret。\n\n\n再看看导出的init函数，这里ida并没有给出JNIEnv和jobect，应该是反编译失误——这俩参数没用到，可能被优化了。\n\n\n在sub_918中，可以发现：fork出子进程，然后子进程通过ptrace附加到父进程，使得父进程无法其它调试器被再次附加，一个反调试技术。\n\n\nFrida通过Interceptor模块，可以支持对Native层函数的hook。\n下面这个脚本，先通过Module.findBaseAddress找到so模块的基地址，然后通过导出表符号Java_sg_vantagepoint_uncrackable2_MainActivity_init，找到它的函数地址，然后根据在文件中计算的文件偏移量，计算出要hook的无符号函数的地址。\nJava.perform(() =&gt; &#123;    const LIB_NAME = &#x27;libfoo.so&#x27;;    const EXPORT_SYMBOL = &#x27;Java_sg_vantagepoint_uncrackable2_MainActivity_init&#x27;;    const OFFSET = ptr(-1140);    function tryHook() &#123;        // 获得模块基地址        const moduleBase = Module.findBaseAddress(LIB_NAME);        if (!moduleBase) &#123;            console.log(`[!] $&#123;LIB_NAME&#125; 未加载，等待...`);            setTimeout(tryHook, 1000); // 每秒检查一次            return;        &#125;        console.log(`[+] 模块基地址: $&#123;moduleBase&#125;`);        // 通过符号名获得函数实际地址        const exportAddress = Module.getExportByName(LIB_NAME, EXPORT_SYMBOL);        if (!exportAddress) &#123;            console.error(`[!] 未找到导出函数 $&#123;EXPORT_SYMBOL&#125;`);            return;        &#125;        console.log(`[+] 导出函数地址: $&#123;exportAddress&#125;`);\t\t        // 根据偏移计算目标地址        const targetAddress = exportAddress.add(OFFSET);        console.log(`[+] 目标函数地址: $&#123;targetAddress&#125;`);        // 打印目标地址的前5个字节        const bytes = Memory.readByteArray(targetAddress, 5);        const byteArray = new Uint8Array(bytes);        const hexBytes = Array.from(byteArray).map(b =&gt; b.toString(16).padStart(2, &#x27;0&#x27;)).join(&#x27; &#x27;);        console.log(`[+] 前5个字节: $&#123;hexBytes&#125;`);        Interceptor.attach(targetAddress, &#123;            onEnter: function(args) &#123;                console.log(`\\n=== 函数调用开始 ===`);                if (Process.arch === &#x27;arm64&#x27;) &#123;                    console.log(`X0: $&#123;args[0]&#125;, X1: $&#123;args[1]&#125;, X2: $&#123;args[2]&#125;`);                &#125; else &#123;                    console.log(`R0: $&#123;args[0]&#125;, R1: $&#123;args[1]&#125;, R2: $&#123;args[2]&#125;`);                &#125;            &#125;,            onLeave: function(retval) &#123;                console.log(`返回值: $&#123;retval&#125;`);                console.log(`=== 函数调用结束 ===\\n`);            &#125;        &#125;);        console.log(`[√] Hook 安装成功`);    &#125;    setTimeout(tryHook, 1000); // 延迟1秒开始检查&#125;);\n\n然而还不够，即便hook住了这个函数，但这个函数早已经在MainActivity.onCreate阶段执行了，hook了也没用，因为已经执行过了一遍。\n针对执行时机的问题，有以下解决方法：\n1.使用spawn模式，默认的frida -U -f是“fork-and-attach”模式，可能错过早期逻辑。使用“spawn”模式可以在应用进程创建时注入Frida。\n如：frida -U -l script.js –no-pause -f com.example.app –spawn\n–spawn: 在进程创建时注入，而不是附加到已有进程。\n2.hook系统类System，然后对loadLibrary做手脚，如果加载的是其它库，不做处理；如果加载的是foo.so，则立马进行覆盖。这个hook的时机发生在静态初始化块执行之前。\nJava.perform(() =&gt; &#123;    const LIB_NAME = &#x27;libfoo.so&#x27;;    const EXPORT_SYMBOL = &#x27;Java_sg_vantagepoint_uncrackable2_MainActivity_init&#x27;;    const OFFSET = ptr(-1140);    // Hook System.loadLibrary    Java.use(&#x27;java.lang.System&#x27;).loadLibrary.implementation = function(libName) &#123;        console.log(`[+] 加载库: $&#123;libName&#125;`);        this.loadLibrary(libName); // 调用原始方法        if (libName === &#x27;foo&#x27;) &#123;            const moduleBase = Module.findBaseAddress(LIB_NAME);            if (!moduleBase) return;            const exportAddress = Module.getExportByName(LIB_NAME, EXPORT_SYMBOL);            const targetAddress = exportAddress.add(OFFSET);            Interceptor.replace(targetAddress, new NativeCallback(function() &#123;                console.log(`sub_918 被调用并覆盖`);                return 42;            &#125;, &#x27;int64&#x27;, []));            console.log(`[√] sub_918 已替换`);        &#125;    &#125;;&#125;);\n\n3.Hook MainActivity.onCreat。\n所以接下来这段脚本执行时机如下，在静态初始化块执行后（System.loadLibrary导入libfoo.so），在onCreate执行前（调用Java_sg_vantagepoint_uncrackable2_MainActivity_init之前），hook了类MainActivity，然后在它执行前，将sub_918的内容做了替换。\nJava.perform(() =&gt; &#123;    const LIB_NAME = &#x27;libfoo.so&#x27;;    const EXPORT_SYMBOL = &#x27;Java_sg_vantagepoint_uncrackable2_MainActivity_init&#x27;;    const OFFSET = ptr(-1140);    const MainActivity = Java.use(&#x27;sg.vantagepoint.uncrackable2.MainActivity&#x27;);    MainActivity.onCreate.implementation = function(savedInstanceState) &#123;        console.log(&#x27;[+] MainActivity.onCreate 被调用&#x27;);        // 在 onCreate 执行前替换 sub_918        const moduleBase = Module.findBaseAddress(LIB_NAME);        if (moduleBase) &#123;            const exportAddress = Module.getExportByName(LIB_NAME, EXPORT_SYMBOL);            const targetAddress = exportAddress.add(OFFSET);            Interceptor.replace(targetAddress, new NativeCallback(function() &#123;                console.log(`sub_918 被调用并覆盖`);                return 42;            &#125;, &#x27;int64&#x27;, []));            console.log(`[√] sub_918 已替换`);        &#125;        // 调用原始 onCreate        this.onCreate(savedInstanceState);    &#125;;&#125;);\n\n下图是安卓的初始化过程以及注入时机。\n\n\n\n\n之后尝试一下hook是否执行成功，先将脚本断掉，直接通过jeb调试进程。\n\n\n再试试通过frida进行hook后，能否attach上去调试。\n\n\n确实是attach上去了，但是手机上显示被检测到了调试，根据字符串搜索，发现问题来自于下图。\n\n\n有一个持续检测的进程，阿这，这么防着咱。。。\n只需要hook Debug.isDebuggerConnected()即可，让它一直返回false，这里就不写了。\n"},{"title":"UnCrackable-Level1分析","url":"/2025/05/18/UnCrackable-Level1%E5%88%86%E6%9E%90/","content":"UnCrackable-Level1.apk下载并安装，打开；一上来就被检测出root权限了。\n\n\n将apk丢入jeb中查看，通过ctrl + f搜索字符串。\n\n\nc.a()、c.b()、c.c()的逻辑如下图，我发现，在我的&#x2F;system&#x2F;bin中，确实有一个su。\n\n\n方案1，粗暴的解决方案，修改dex文件并重新签名。在onCreate的第一个if处，将判断结果改成false；\nJava.perform(function()&#123;  const root = Java.use(&quot;sg.vantagepoint.util.RootDetection&quot;);\troot.checkRoot1.implementation = function()&#123;\t\treturn false;\t&#125;\troot.checkRoot2.implementation = function()&#123;\t\treturn false;\t&#125;\troot.checkRoot3.implementation = function()&#123;\t\treturn false;\t&#125;&#125;);\n\n方案2，hook掉exit函数或者hook掉相关函数；\n方案3，面具magisk里直接屏蔽掉UnCrackable-Level1.apk的root权限，让它检测不到root。\n这里介绍一下第二个方法，js脚本如下，执行方法也如下，然后就绕过去了。\n# frida -U -f owasp.mstg.uncrackable1 -l .\\uncrackable-level1.jsJava.perform(function()&#123;    var temp = Java.use(&quot;java.lang.System&quot;); # 获得System类    # exit是静态函数，不需要实例化后再调用    # overload指定具体的重载版本    temp.exit.overload(&#x27;int&#x27;).implementation = function(arg0)&#123;        console.log(&quot;Exit called with &quot; + arg0);    &#125;;&#125;);\n\n\n通过jeb，可以发现在类a中，函数a会根据输入的内容进行比较，随后得出是否正确的答案。\n\n下面是写的一个js脚本，直接return true，或者通过sg.vantagepoint.a.a.a得到解密的明文。\n# 直接改为trueJava.perform(function() &#123;    // 获取目标类    var targetClass = Java.use(&#x27;sg.vantagepoint.uncrackable1.a&#x27;);        // Hook 静态方法 a(String)    targetClass.a.overload(&#x27;java.lang.String&#x27;).implementation = function(s) &#123;        console.log(&quot;\\n[*] 拦截验证方法调用&quot;);                // 打印原始输入        console.log(&quot;原始输入: &quot; + s);                // 调用原始方法获取结果        var result = this.a(s); // [!code focus]                // 打印原始验证结果        console.log(&quot;原始验证结果: &quot; + result);                // 强制返回 true（绕过验证）        console.log(&quot;[+] 强制返回 true&quot;);        return true;                // 若需保留原始逻辑，直接返回 result        // return result;    &#125;;&#125;);# 观察正确的输入Java.perform(function() &#123;    // 获取加密工具类    var crypto = Java.use(&#x27;sg.vantagepoint.a.a&#x27;);        // 获取验证类    var checker = Java.use(&#x27;sg.vantagepoint.uncrackable1.a&#x27;);        // Hook a() 方法获取密钥和密文    checker.a.overload(&#x27;java.lang.String&#x27;).implementation = function(s) &#123;        // 原始密文（Base64）        var ciphertext_b64 = &quot;5UJiFctbmgbDoLXmpL12mkno8HT4Lv8dlat8FxR2GOc=&quot;;                // 硬编码密钥（处理负数为无符号字节）        var key_bytes = [0x8D, 0x12, 0x76, 0x84, 0xCB, 0xC3, 0x7C, 0x17,                          0x61, 0x6D, 0x80, 0x6C, 0xF5, 0x04, 0x73, 0xCC];                // 将密钥转换为 Java byte[]        var jKey = Java.array(&#x27;byte&#x27;, key_bytes);                // Base64 解码密文        var ciphertext = Java.use(&#x27;android.util.Base64&#x27;).decode(ciphertext_b64, 0);                try &#123;            // 调用解密方法            var decrypted_bytes = crypto.a(jKey, ciphertext);                        // 转换为字符串            var plaintext = Java.use(&#x27;java.lang.String&#x27;).$new(decrypted_bytes);            console.log(&quot;\\n[+] 解密成功！Secret String: &quot; + plaintext);        &#125; catch(e) &#123;            console.log(&quot;[-] 解密失败: &quot; + e);        &#125;                // 返回原始验证结果（或强制返回 true）        return this.a(s);    &#125;;&#125;);\n\n执行，得到结果。\n\n"},{"title":"r2pay-v0.9分析","url":"/2025/05/18/r2pay-v0-9%E5%88%86%E6%9E%90/","content":"r2pay-v0.9.apk安装完后，一打开就闪退。\n通过adb logcat查看日志，筛选中下面的日志记录。\n02-28 10:34:38.788 11795 11795 I Magisk  : zygisk64: [re.pwnme] is on the denylist02-28 10:34:38.823 11795 11795 I re.pwnme: Late-enabling -Xcheck:jni02-28 10:34:38.845  1187  1204 I adbd    : jdwp connection from 1179502-28 10:34:38.867 11795 11795 D ProcessState: Binder ioctl to enable oneway spam detection failed: Invalid argument02-28 10:34:38.785     0     0 I binder  : 11795:11795 ioctl 40046210 7fe5e224b4 returned -2202-28 10:34:38.881 11795 11795 D CompatibilityChangeReporter: Compat change id reported: 171979766; UID 10137; state: DISABLED02-28 10:34:38.887 11795 11795 D ApplicationLoaders: Returning zygote-cached class loader: /system/framework/android.test.base.jar02-28 10:34:38.909 11795 11795 V GraphicsEnvironment: ANGLE Developer option for &#x27;re.pwnme&#x27; set to: &#x27;default&#x27;02-28 10:34:38.909 11795 11795 V GraphicsEnvironment: ANGLE GameManagerService for re.pwnme: false02-28 10:34:38.909 11795 11795 V GraphicsEnvironment: Neither updatable production driver nor prerelease driver is supported.02-28 10:34:38.911 11795 11795 D NetworkSecurityConfig: No Network Security Config specified, using platform default02-28 10:34:38.912 11795 11795 D NetworkSecurityConfig: No Network Security Config specified, using platform default02-28 10:34:39.391  2400  3117 W FrameTracker: Missing HWUI jank callback for vsyncId: 8485502-28 10:34:39.612 11795 11795 W re.pwnme: type=1400 audit(0.0:371): avc: denied &#123; read &#125; for name=&quot;cache&quot; dev=&quot;sda14&quot; ino=16 scontext=u:r:untrusted_app_29:s0:c137,c256,c512,c768 tcontext=u:object_r:cache_file:s0 tclass=lnk_file permissive=0 app=re.pwnme02-28 10:34:39.612 11795 11795 W re.pwnme: type=1400 audit(0.0:372): avc: denied &#123; read &#125; for name=&quot;cache&quot; dev=&quot;sda14&quot; ino=16 scontext=u:r:untrusted_app_29:s0:c137,c256,c512,c768 tcontext=u:object_r:cache_file:s0 tclass=lnk_file permissive=0 app=re.pwnme02-28 10:34:39.612 11795 11795 W re.pwnme: type=1400 audit(0.0:373): avc: denied &#123; read &#125; for name=&quot;cache&quot; dev=&quot;sda14&quot; ino=16 scontext=u:r:untrusted_app_29:s0:c137,c256,c512,c768 tcontext=u:object_r:cache_file:s0 tclass=lnk_file permissive=0 app=re.pwnme02-28 10:34:39.678 11795 11795 W re.pwnme: Accessing hidden method Landroid/view/View;-&gt;computeFitSystemWindows(Landroid/graphics/Rect;Landroid/graphics/Rect;)Z (unsupported, reflection, allowed)02-28 10:34:39.678 11795 11795 W re.pwnme: Accessing hidden method Landroid/view/ViewGroup;-&gt;makeOptionalFitsSystemWindows()V (unsupported, reflection, allowed)02-28 10:34:39.725 11795 11795 E RootBeer: b: a() [249] - com.topjohnwu.magisk ROOT management app detected!02-28 10:34:39.725 11795 11795 E QLog    : b: a() [249] - com.topjohnwu.magisk ROOT management app detected!02-28 10:34:39.726 11795 11795 D AndroidRuntime: Shutting down VM02-28 10:34:39.727 11795 11795 E AndroidRuntime: FATAL EXCEPTION: main02-28 10:34:39.727 11795 11795 E AndroidRuntime: Process: re.pwnme, PID: 1179502-28 10:34:39.727 11795 11795 E AndroidRuntime: java.lang.RuntimeException: Unable to start activity ComponentInfo&#123;re.pwnme/re.pwnme.MainActivity&#125;: java.lang.ArithmeticException: divide by zero02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:3707)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:3864)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:103)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.app.servertransaction.TransactionExecutor.executeCallbacks(TransactionExecutor.java:135)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:95)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2253)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.os.Handler.dispatchMessage(Handler.java:106)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.os.Looper.loopOnce(Looper.java:201)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.os.Looper.loop(Looper.java:288)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.app.ActivityThread.main(ActivityThread.java:7870)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at java.lang.reflect.Method.invoke(Native Method)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:548)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1003)02-28 10:34:39.727 11795 11795 E AndroidRuntime: Caused by: java.lang.ArithmeticException: divide by zero02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at re.pwnme.MainActivity.onCreate(SourceFile:38)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.app.Activity.performCreate(Activity.java:8057)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.app.Activity.performCreate(Activity.java:8037)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1341)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:3688)02-28 10:34:39.727 11795 11795 E AndroidRuntime:        ... 12 more02-28 10:34:39.730  1045 11817 I DropBoxManagerService: add tag=data_app_crash isTagEnabled=true flags=0x202-28 10:34:39.730  1045  5059 W ActivityTaskManager:   Force finishing activity re.pwnme/.MainActivity02-28 10:34:39.737 11795 11795 I Process : Sending signal. PID: 11795 SIG: 9\n\n我把日志丢给grok进行分析，似乎是调用了RootBeer库进行root检测，发现了magisk，因此退出了。\n\n\n尝试搜索字符串 ROOT management app detected，这里的try catch就是用来检测root的，如果读包错误，就说明这个包不存在，不做任何处理；如果读到“危险”包，就会继续执行b.a.a.c.a.a，并将result置为true。\n\n\n追踪b.a.a.c.a.a进去看一下，发现就写了一个Log.e。\n\n查看方法b.a.a.b.a(List )的调用。\n\n\nIndex为0的方法b.a.a.b.a(String[] )如下，属于重载，可以看到，这里只是将字符串加入到packages里，并调用b.a.a.b.a(List )。\n\n而Index为1的方法b.a.a.b.b(String[] )如下，它调用了b.a.a.b.a(String[] )。\n\n之后又一直查看引用，找到b.a.a.j()，这里做了一堆检查root的内容。\n\n\n不如直接将函数j给hook了，也省得hook其它这么多函数，我观察了一下众多this.X，发现其中的this.e不仅仅在j()被调用，还在其它地方被调用。\n总结了一下，需要hook的函数如下：\nb.a.a.a()&#x2F;b.a.a.j()&#x2F;b.a.a.e()。\n首先hook方法a，一般来说，可以根据参数列表不同hook特定的、存在同名的方法，但这里要hook的方法a属于无参方法，而且存在两个无参方法a。\n下面是我找ds-r1生成的，不知道行不行得通，看得挺靠谱的，根据返回值类型来判断。（事后发现下面的脚本用不了，别学，这里作为错误示范）\nJava.perform(function() &#123;    var targetClass = Java.use(&quot;b.a.a.b&quot;);    var methods = targetClass.class.getDeclaredMethods();        methods.forEach(function(method) &#123;        if (method.getName() === &quot;a&quot; &amp;&amp; method.getParameterTypes().length === 0) &#123;            var returnType = method.getReturnType().getName();                        // Hook返回boolean的a方法            if (returnType === &quot;boolean&quot;) &#123;                method.implementation = function() &#123;                    console.log(&quot;Hooked boolean a() method&quot;);                    return this.a.apply(this, arguments);                &#125;;            &#125;            // Hook返回String数组的a方法            else if (returnType === &quot;[Ljava.lang.String;&quot;) &#123;                method.implementation = function() &#123;                    console.log(&quot;Hooked String[] a() method&quot;);                    return this.a.apply(this, arguments);                &#125;;            &#125;        &#125;    &#125;);&#125;);\n\n不过既然要hook的方法都在b.a.a类中，不妨直接将hook的方法补充进上面这个脚本里，执行后，又闪退了，不过这回查看日志，并没看到之前的那几条记录了。\n02-28 15:10:41.848  4531  4531 I crash_dump64: obtaining output fd from tombstoned, type: kDebuggerdTombstoneProto02-28 15:10:41.849   655   655 I tombstoned: received crash request for pid 452802-28 15:10:41.850  4531  4531 I crash_dump64: performing dump of process 4498 (target tid = 4528)02-28 15:10:41.871  4531  4531 E DEBUG   : failed to read /proc/uptime: Permission denied02-28 15:10:42.485     0     0 I logd    : logdr: UID=10137 GID=10137 PID=4531 n tail=0 logMask=8 pid=4498 start=0ns deadline=0ns02-28 15:10:42.486     0     0 I logd    : logdr: UID=10137 GID=10137 PID=4531 n tail=0 logMask=1 pid=4498 start=0ns deadline=0ns02-28 15:10:42.498  4531  4531 F DEBUG   : *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***02-28 15:10:42.498  4531  4531 F DEBUG   : Build fingerprint: &#x27;OnePlus/OnePlus6/OnePlus6:8.1.0/OPM1.171019.011/06140300:user/release-keys&#x27;02-28 15:10:42.498  4531  4531 F DEBUG   : Revision: &#x27;0&#x27;02-28 15:10:42.498  4531  4531 F DEBUG   : ABI: &#x27;arm64&#x27;02-28 15:10:42.498  4531  4531 F DEBUG   : Timestamp: 2025-02-28 15:10:41.870217324+080002-28 15:10:42.498  4531  4531 F DEBUG   : Process uptime: 0s02-28 15:10:42.498  4531  4531 F DEBUG   : Cmdline: com.google.android.videos02-28 15:10:42.498  4531  4531 F DEBUG   : pid: 4498, tid: 4528, name: re.pwnme  &gt;&gt;&gt; com.google.android.videos &lt;&lt;&lt;02-28 15:10:42.498  4531  4531 F DEBUG   : uid: 1013702-28 15:10:42.498  4531  4531 F DEBUG   : signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0xfaba497502-28 15:10:42.498  4531  4531 F DEBUG   :     x0  0000006fe4986670  x1  000000730a2a77cc  x2  00000071ceef6220  x3  0000006fe498661802-28 15:10:42.498  4531  4531 F DEBUG   :     x4  00000000000010b0  x5  0000000000000001  x6  0000000000000000  x7  000000000000000002-28 15:10:42.498  4531  4531 F DEBUG   :     x8  00000000000035b2  x9  00000000faba4975  x10 000000008ef93fe9  x11 000000006df6246c02-28 15:10:42.498  4531  4531 F DEBUG   :     x12 0000000000000001  x13 00000000fffffff6  x14 00000000cf86a786  x15 000000000000000102-28 15:10:42.499  4531  4531 F DEBUG   :     x16 000000730a2911f8  x17 000000730a20db40  x18 0000000000000000  x19 0000006fe498667002-28 15:10:42.499  4531  4531 F DEBUG   :     x20 0000000000000000  x21 0000006fe498acb0  x22 0000000000001192  x23 000000000000119202-28 15:10:42.499  4531  4531 F DEBUG   :     x24 0000006fe498acb0  x25 0000006fe498acb0  x26 0000006fe498aff8  x27 00000000000fc00002-28 15:10:42.499  4531  4531 F DEBUG   :     x28 0000006fe4892000  x29 0000006fe498ac4002-28 15:10:42.499  4531  4531 F DEBUG   :     lr  0000006fdffa2668  sp  0000006fe4986670  pc  0000006fdfe77f7c  pst 000000006000000002-28 15:10:42.499  4531  4531 F DEBUG   : backtrace:02-28 15:10:42.499  4531  4531 F DEBUG   :       #00 pc 0000000000038f7c  /data/app/~~IG0Dzbwr_V__IsLZxDqnLA==/re.pwnme-5cCb3aQP1IrcfKWzdCWgYQ==/lib/arm64/libnative-lib.so (BuildId: f87b3bd9fcae36e63939958f412d03a42e0ce406)02-28 15:10:42.499  4531  4531 F DEBUG   :       #01 pc 00000000000b1810  /apex/com.android.runtime/lib64/bionic/libc.so!libc.so (__pthread_start(void*)+264) (BuildId: 6bfaf10f10e5ff343703efae2f1bdbdb)02-28 15:10:42.499  4531  4531 F DEBUG   :       #02 pc 00000000000512f0  /apex/com.android.runtime/lib64/bionic/libc.so!libc.so (__start_thread+64) (BuildId: 6bfaf10f10e5ff343703efae2f1bdbdb)\n\n查看调用栈，锁定在libnative-lib.so，偏移量是38f7c，用ida打开后，访问那块地址，结果说函数太大，无法进行f5，没辙了，没啥思绪了，看看博客。\nhttps://blog.csdn.net/qq_61253776/article/details/140026070\n看来我的第一步分析是正确的，将函数j a e进行了hook，避免了java层的检测，但so层好难。\n接下来找博客一步一步做了。\nSo层的检测针对了root权限和frida注入，下面主要写分析过程。\n在re.pwnme.MainActivity类中，静态初始化块加载了native-lib，\n\n\n然后声明了其中的一个native函数并用于MainActivity的页面代码中。\n\n\n通过ida观察libnative-lib.so的export表，导出函数和全局变量都被加密了。\n\n点开.datadiv_decodexxxxxx，大部分这类函数只写了一个RET，对应的字节码是C0 03 5F D6。\n\n根据观察，其中的函数datadiv_decode4432700155380705947，它存在函数体，并且大部分操作似乎在做解密。大部分资料显示，这里是在做全局字符串的解密操作。\n\n\n除此之外，在.init_array段中，存在两个拥有函数体的函数，它们无法f5，反编译成c。\n\n\n\n过了java层后，会在so层的某处断开，地址是38f7c。\n\n在ida中来到38f7c，一路跟踪交叉引用，最后判定，这段代码属于sub_83DC。\n由于静态无法分析，只能动态分析了，博客中，这里使用了工具QBDI，QBDI是一个动态二进制插桩的DBI框架，可以追踪函数细节，如果只用frida的话，只能看到函数调用前的参数和调用后的结果。\n但QBDI咋用啊，wtf，教程也太少了。\n\n时隔多天，在分析完豆瓣后，再次看看这个apk如何分析。\n在分析豆瓣的过程中，学会了找退出点的一些方法。\n比如：hook函数pthread_create，线程在跑起来后，如果是检测frida的线程，就会杀死frida，所以可以观察哪个线程跑起来后，导致frida退出了。因为libc.so是系统库，加载先于frida的spawn模式，无需担心过早hook。\n对应的检测线程脚本如下，不是直接复制就能用，这里放在这仅供参考：\nfunction hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;);    let offset = 0x51BA8; // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset);    let listener = Interceptor.attach(call_constructors, &#123;        onEnter: function(args) &#123;            console.log(&#x27;hook_linker_call_constructors onEnter&#x27;);            let libnative_module = Process.findModuleByName(&quot;libnative-lib.so&quot;);            // 打印模块信息            if (libnative_module) &#123;                console.log(&quot;Module name: &quot; + libnative_module.name);                console.log(&quot;Base address: 0x&quot; + libnative_module.base.toString(16));                console.log(&quot;Size: &quot; + libnative_module.size);                console.log(&quot;Path: &quot; + libnative_module.path);                                check_pthread_create(libnative_module.base);                //hook_20954();                //hook_7a660();                listener.detach();            &#125;        &#125;    &#125;);&#125;function check_pthread_create(baseaddr)&#123;    /* 找到函数pthread_create的地址 */    var pthread_create = Module.findExportByName(&quot;libc.so&quot;, &quot;pthread_create&quot;);    if(pthread_create)&#123;        console.log(&quot;pthread_create is exist&quot;);    &#125;else&#123;        console.log(&quot;pthread_create is not exist&quot;);    &#125;    /* hook */    Interceptor.attach(pthread_create, &#123;        onEnter: function(args)&#123;            console.log(&quot;pthread_create is called&quot;);            console.log(&quot;arg2: 0x&quot; + (args[2] - baseaddr).toString(16));        &#125;    &#125;);&#125;\n\n之后应该就会看到几个函数的地址，然后尝试hook它们。\nfunction hook_20954()&#123;    let libnative_module = Process.findModuleByName(&quot;libnative-lib.so&quot;);    Interceptor.replace(libnative_module.base.add(0x20954), new NativeCallback(function () &#123;        console.log(`hook_20954 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; replace`);    &#125;, &#x27;void&#x27;, []));&#125;function hook_7a660()&#123;    let libnative_module = Process.findModuleByName(&quot;libnative-lib.so&quot;);    Interceptor.replace(libnative_module.base.add(0x7a660), new NativeCallback(function () &#123;        console.log(`hook_7a660 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; replace`);    &#125;, &#x27;void&#x27;, []));&#125;\n\n然后再次跑frida脚本，发现提示除以0的报错，这个报错不是在之前的java层解决了吗？\n下面这个脚本是错的，是我早期通过deepseek生成的，我还以为能用。\nfunction hook_java() &#123;        var targetClass = Java.use(&quot;b.a.a.b&quot;);        var methods = targetClass.class.getDeclaredMethods();        console.log(&quot;Methods found in b.a.a.b:&quot;);        methods.forEach(function(method) &#123;            if (method.getName() === &quot;a&quot; &amp;&amp; method.getParameterTypes().length === 0) &#123;                var returnType = method.getReturnType().getName();                console.log(&quot;Return type: &quot; + typeof returnType + &quot;, value: &quot; + returnType);                if (returnType === &quot;boolean&quot;) &#123;                    method.implementation = function() &#123;                        console.log(&quot;b.a.a.b.a() is called, res = &quot;, this.a());                        console.log(&quot;Hooked boolean a() method&quot;);                        return false;                    &#125;;                &#125;            &#125;            if (method.getName() === &quot;j&quot; &amp;&amp; method.getParameterTypes().length === 0) &#123;                var returnType = method.getReturnType().getName();                if (returnType === &quot;boolean&quot;) &#123;                    method.implementation = function() &#123;                        console.log(&quot;b.a.a.b.j() is called, res = &quot;, this.j());                        console.log(&quot;Hooked boolean j() method&quot;);                        return false;                    &#125;;                &#125;            &#125;            if (method.getName() === &quot;e&quot; &amp;&amp; method.getParameterTypes().length === 0) &#123;                var returnType = method.getReturnType().getName();                if (returnType === &quot;boolean&quot;) &#123;                    method.implementation = function() &#123;                        console.log(&quot;b.a.a.b.e() is called, res = &quot;, this.e());                        console.log(&quot;Hooked boolean e() method&quot;);                        return false;                    &#125;;                &#125;            &#125;        &#125;);&#125;\n\n将它修改成正常的、简单的脚本。\nfunction hook_java() &#123;    Java.perform(function() &#123;              var targetClass = Java.use(&quot;b.a.a.b&quot;);         targetClass.a.overload().implementation = function() &#123;            console.log(&quot;Hooked b.a.a.b.a()&quot;);            return false; // 强制返回 false        &#125;;        targetClass.j.overload().implementation = function() &#123;            console.log(&quot;Hooked b.a.a.b.j()&quot;);            return false;        &#125;;        targetClass.e.overload().implementation = function() &#123;            console.log(&quot;Hooked b.a.a.b.e()&quot;);            return false;        &#125;;    &#125;);&#125;\n\n最后整理出来的脚本如下，执行完后能正常跑apk了。\nfunction hook_java() &#123;    Java.perform(function() &#123;              var targetClass = Java.use(&quot;b.a.a.b&quot;);         targetClass.a.overload().implementation = function() &#123;            console.log(&quot;Hooked b.a.a.b.a()&quot;);            return false; // 强制返回 false        &#125;;        targetClass.j.overload().implementation = function() &#123;            console.log(&quot;Hooked b.a.a.b.j()&quot;);            return false;        &#125;;        targetClass.e.overload().implementation = function() &#123;            console.log(&quot;Hooked b.a.a.b.e()&quot;);            return false;        &#125;;    &#125;);&#125;function hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;);    let offset = 0x51BA8; // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset);    let listener = Interceptor.attach(call_constructors, &#123;        onEnter: function(args) &#123;            console.log(&#x27;hook_linker_call_constructors onEnter&#x27;);            let libnative_module = Process.findModuleByName(&quot;libnative-lib.so&quot;);            // 打印模块信息            if (libnative_module) &#123;                console.log(&quot;Module name: &quot; + libnative_module.name);                console.log(&quot;Base address: 0x&quot; + libnative_module.base.toString(16));                console.log(&quot;Size: &quot; + libnative_module.size);                console.log(&quot;Path: &quot; + libnative_module.path);                                check_pthread_create(libnative_module.base);                hook_20954();                hook_7a660();                listener.detach();            &#125;        &#125;    &#125;);&#125;function check_pthread_create(baseaddr)&#123;    /* 找到函数pthread_create的地址 */    var pthread_create = Module.findExportByName(&quot;libc.so&quot;, &quot;pthread_create&quot;);    if(pthread_create)&#123;        console.log(&quot;pthread_create is exist&quot;);    &#125;else&#123;        console.log(&quot;pthread_create is not exist&quot;);    &#125;    /* hook */    Interceptor.attach(pthread_create, &#123;        onEnter: function(args)&#123;            console.log(&quot;pthread_create is called&quot;);            console.log(&quot;arg2: 0x&quot; + (args[2] - baseaddr).toString(16));        &#125;    &#125;);&#125;function hook_20954()&#123;    let libnative_module = Process.findModuleByName(&quot;libnative-lib.so&quot;);    Interceptor.replace(libnative_module.base.add(0x20954), new NativeCallback(function () &#123;        console.log(`hook_20954 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; replace`);    &#125;, &#x27;void&#x27;, []));&#125;function hook_7a660()&#123;    let libnative_module = Process.findModuleByName(&quot;libnative-lib.so&quot;);    Interceptor.replace(libnative_module.base.add(0x7a660), new NativeCallback(function () &#123;        console.log(`hook_7a660 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; replace`);    &#125;, &#x27;void&#x27;, []));&#125;function Avoid_divide_by_zero()&#123;    let b = Java.use(&quot;b.a.a.b&quot;);    b[&quot;j&quot;].implementation = function () &#123;        return false    &#125;;&#125;hook_linker_call_constructors();setImmediate(hook_java);\n\n成功在豆瓣进修，hhhhhh。\n"},{"title":"UnCrackable-Level3分析","url":"/2025/05/18/UnCrackable-Level3%E5%88%86%E6%9E%90/","content":"UnCrackable-Level3.apk照常，安装并打开，被检测到了root，通过magisk进行root权限的隐藏。\n之后还是输入正确的密码。\n\n\n在输入错误的Secret后，会提示Nope…That’s not it. Try again.\n在Jeb中搜索这个字符串，发现关键点在check_code上。\n\n\ncheck_code调用了native层函数bar。\n\n\n在ida中，检索函数bar，一个很明显的xor解密，密钥的长度为24。\n\n为了获得正确的secret，需要将v8和qword_15038进行xor运算，得到最终的结果。\n不难看出，v8的值来自于sub_10E0，这里考虑对sub_10E0进行hook，然后查看v8的值。\n结果hook的过程遇到了反frida的检测，可以根据报错的调用栈定位到goodbye函数。\n\n\n追溯到源头，发现在sub_30D0处，调用了goodbye()，检测的逻辑是，通过读取映射到内存的文件名，只要发现frida等字段就退出。\n\n\n为了能够正常使用frida进行hook，有以下几种hook的方式，绕过反frida。\n1.hook函数sub_30D0。\n2.hook函数strstr。\nⅠ.先讲hook sub_30D0：观察过函数sub_30D0，发现它被写在了.init_array节里，这个节里面的函数，会在库加载的时候依次被调用，因此，如果想要hook这个函数，必须在System.loadLibray执行过程中——因为执行完后，frida就hook不了了；而若是还没执行，libfoo.so还没加载，当然hook不了。\n查阅了相关博客，so层的.init_array节里的函数，都是被模块linker64中的call_array调用的，所以要hook函数call_array，当下的核心目标是获得call_array在模块linker64中的偏移量。（方法随意，可以直接在ida中进行查看）\n在hook后，流程变成：遇到加载的so是libfoo.so，在完成了内存映射后，call_array还没有执行，这个时候去修改内存中sub_30D0的内容，之后正常执行call_array。\n    // 获取linker64模块的基地址    var linker64_module = Module.getBaseAddress(&quot;linker64&quot;);    //使用拦截器附加linker64模块的偏移地址    // 7D68B58764 - 7D68B38000 = 0x20764    Interceptor.attach(linker64_module.add(0x20764),&#123;        // 进入函数，代码检查参数args[3]指向的字符串是否匹配libfoo.so        onEnter:function(args) &#123;           if(args[0].readCString().match(&quot;libfoo.so&quot;)) &#123;                // 获取libfoo.so的基地址                var libfoo_module  = Module.findBaseAddress(&#x27;libfoo.so&#x27;);                console.log(&quot;获取libfoo.so的基地址==&gt;&quot;+libfoo_module)                Interceptor.replace(libfoo_module.add(0x30D0),new NativeCallback(function()&#123;                    return;                &#125;,&#x27;void&#x27;,[]));           &#125;    &#125;,onLeave:function(result)&#123;&#125;&#125;)\n\nⅡ.hook strstr就比较简单，判断strstr的第1个参数里有没有frida字段，如果有，之后的返回值直接强制返回。\n// 反frida检测Interceptor.attach(Module.findExportByName(&quot;libc.so&quot;, &quot;strstr&quot;), &#123;    onEnter: function(args) &#123;        this.haystack = args[0];        this.needle = args[1];        this.frida = false;        // 方法 1：使用 readCString（自动处理 NULL 结尾）        try &#123;            const haystack = this.haystack.isNull() ? &quot;&quot; : this.haystack.readCString();            if (haystack &amp;&amp; (haystack.includes(&quot;frida&quot;) || haystack.includes(&quot;xposed&quot;))) &#123;                this.frida = true;            &#125;        &#125; catch (e) &#123;            console.log(&quot;读取字符串失败:&quot;, e);        &#125;    &#125;,    onLeave: function(retval) &#123;        if (this.frida) &#123;            retval.replace(0);        &#125;        return retval;    &#125;&#125;);\n\nok，在解决了反frida后，继续对之前提到的sub_10E0进行解密，由于这个函数没有返回值，可以判断：这个函数会在v8所指向的地址处，修改24个字节。\n   function hookXor()&#123;           // hook xor的其中一个key       Interceptor.attach((Module.findBaseAddress(&quot;libfoo.so&quot;)).add(&quot;0x010E0&quot;), &#123;           onEnter: function(args)&#123;               console.log(&quot;onEnter: hook xor key&quot;);               this.key = args[0];           &#125;,                   onLeave: function(retval)&#123;               var key_ = new NativePointer(this.key);               var arr = key_.readByteArray(24);               console.log(arr);           &#125;       &#125;);   &#125;setTimeout(hookXor, 1000);\n\n这里为了避免hookXor未执行，特意延迟了1000ms再进行注入（方法比较简单）。\n还有其它方法，在保证加载了libfoo.so后立马进行hook，而不用等待1000ms。（同样是在加载器上做文章，不过这里hook的是System.loadLibrary）\nJava.perform(function() &#123;    const System = Java.use(&quot;java.lang.System&quot;);    const Runtime = Java.use(&quot;java.lang.Runtime&quot;);    const SystemLoad_2 = System.loadLibrary.overload(&quot;java.lang.String&quot;);    const VMStack = Java.use(&quot;dalvik.system.VMStack&quot;);    SystemLoad_2.implementation = function(library) &#123;        console.log(&quot;Loading dynamic library =&gt; &quot; + library);        try &#123;          const loaded =     Runtime.getRuntime().loadLibrary0( VMStack.getCallingClassLoader(), library);          if(library.includes(&quot;foo&quot;)) &#123;            //function that gets the xored value             Interceptor.attach(Module.findBaseAddress(&quot;libfoo.so&quot;).add(&#x27;0x00000fa0&#x27;),&#123;              onEnter: function(args)&#123;                console.log(&quot;getting other_key value&quot;);                this.other_key_address = args[0];              &#125;,              onLeave: function(retval)&#123;                var other_key = new NativePointer(this.other_key_address);                var arr = other_key.readByteArray(24);                console.log(arr);              &#125;            &#125;);          &#125;          return loaded;        &#125; catch(ex) &#123;          console.log(ex);          console.log(ex.stack);        &#125;    &#125;;&#125;);\n\n最后得到的结果如下，即：1d 08 11 13…\n\n\n同时，另一个密钥key是qword_15038，追踪后，发现是通过init函数进行初始化的，这个函数是一个jni函数，根据代码，可以发现它的值由java层传递。\n\n因此，另一个key的值是pizzapizzapizzapizzapizz。\n\n\n将两者做异或运算。\ndef xor_bytes(str1, bytes2):    &quot;&quot;&quot;    对两个24字节的数据进行逐字节的异或运算。    参数:    str1: 长度为24字节的字符串    bytes2: 长度为24字节的字节数组    返回:    result: 异或运算后的字节数组    &quot;&quot;&quot;    # 确保输入长度为24字节    if len(str1) != 24 or len(bytes2) != 24:        raise ValueError(&quot;输入必须是24字节长&quot;)    # 将字符串转换为字节数组    bytes1 = str1.encode(&#x27;utf-8&#x27;)    # 进行逐字节的异或运算    result = bytearray()    for b1, b2 in zip(bytes1, bytes2):        result.append(b1 ^ b2)    return result# 示例用法if __name__ == &quot;__main__&quot;:    # 输入字符串和字节数组    str_input = &quot;pizzapizzapizzapizzapizz&quot;  # 24字节字符串    bytes_input = bytes([0x1d, 0x08, 0x11, 0x13, 0x0f, 0x17, 0x49, 0x15, 0x0d, 0x00, 0x03, 0x19, 0x5a, 0x1d, 0x13, 0x15, 0x08, 0x0e, 0x5a, 0x00, 0x17, 0x08, 0x13, 0x14])  # 24字节的字节数组 [0, 1, 2, ..., 23]    # 执行异或运算    result = xor_bytes(str_input, bytes_input)    # 输出结果    print(&quot;异或运算结果:&quot;, result)    print(&quot;十六进制表示:&quot;, result.hex())\n\n\n\n阿这，这个解密出来的结果有点6。\n\n"},{"title":"unidbg初识","url":"/2025/05/18/unidbg%E5%88%9D%E8%AF%86/","content":"Frida和Unidbg最大的区别是，Unidbg是模拟程序执行，所以可以绕过检测，而Frida面临众多检测，需要学会反检测。\n其实在理解了Unidbg的原理之后，它还蛮简单的。\n模拟层级Unicorn模拟了底层cpu指令模拟，相当于一台裸机。当native代码调用到系统调用的指令（如x86的syscall、arch64的svc等），会将这些触发转发给AndroidEmulator进行处理。\nAndroidEmulator主要负责模拟安卓环境和系统环境和JNI交互，除此之外，它还负责处理Unicorn转发而来的系统调用。\n补环境实例讲解可以观察下面的一个需要补环境的代码。\npackage com.example.luodst;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.LibraryResolver;import com.github.unidbg.Module;import com.github.unidbg.arm.backend.Unicorn2Factory;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.*;import com.github.unidbg.linux.android.dvm.array.ByteArray;import com.github.unidbg.memory.Memory;import com.github.unidbg.virtualmodule.android.AndroidModule;import java.io.File;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.sql.SQLOutput;import java.util.ArrayList;import java.util.Enumeration;import java.util.List;import java.util.zip.ZipEntry;import java.util.zip.ZipFile;public class MainActivity extends AbstractJni &#123;    public static void main(String[] args) &#123;        MainActivity mainActivity = new MainActivity();        mainActivity.getHash();    &#125;\t// 模拟器创建    private final AndroidEmulator emulator;    // 创建java虚拟机\tprivate final VM vm;    private final Module module;    private MainActivity() &#123;        //1.创建Android模拟器实例        emulator = AndroidEmulatorBuilder                .for32Bit() // 32位虚拟机                .addBackendFactory(new Unicorn2Factory(true)) // 选择指令集，相当于选择哪台裸机，默认是unicorn                .setRootDir(new File(&quot;unidbg-android/src/test/java/com/example/luodst/rootfs&quot;)) // 设置文件系统根目录                .build(); // 创建        //2.获取操作内存的接口        Memory memory = emulator.getMemory();        //3.设置Android SDK 版本        LibraryResolver resolver = new AndroidResolver(23);        memory.setLibraryResolver(resolver); // 加载sdk里的java类（可能会添加hook）        //4.创建java虚拟机，导入apk文件        vm = emulator.createDalvikVM(new File(&quot;unidbg-android/src/test/java/com/example/luodst/files/DogPro.apk&quot;));        //5.是否打印日志        vm.setVerbose(true);        //6.将自定义的JNI处理逻辑绑定到java虚拟机上        vm.setJni(this);        // 为java环境模拟器和java虚拟机注册内存        new AndroidModule(emulator, vm).register(memory);        //7.加载目标so文件，true主动执行init init_array        DalvikModule dm = vm.loadLibrary(&quot;dogpro&quot;, true);        //8.将so文件对应的Module存入成员变量        module = dm.getModule();        //9.主动调用JNI_OnLoad        dm.callJNI_OnLoad(emulator);    &#125;    private void getHash() &#123;        DvmObject&lt;?&gt; dvmObject = vm.resolveClass(&quot;com/example/dogpro/MainActivity&quot;).newObject(null);        System.out.println(&quot;dvmObject = &quot;+ dvmObject.toString());        String input = &quot;unidbg-android/src/test/java/com/example/luodst/files/DogPro.apk&quot;;        DvmObject&lt;?&gt; ret = dvmObject.callJniMethodObject(emulator, &quot;getHash(Ljava/lang/String;)Ljava/lang/String;&quot;, input);        System.out.println(&quot;result ==&gt; &quot;+ret.getValue());    &#125;&#125;\n\n可以这么理解Unidbg补环境的过程，so文件作为elf二进制代码，可以在unicorn上面跑，但一些JNI函数，他们的参数列表需要JNI类型的数据，有时候甚至要调用一些Java层的函数（java层给native层数据时，数据类型是JNI类型），而Unidbg就是负责处理JNI交互的。\nUnidbg有自己的一套JNI类型，其内置的Java虚拟机中还内置了很多自定义的基本类型、引用类型的数据结果，如：外部虚拟机中的String类型，在Unidbg中是StringObject类型；外部的int、boolean类型，是Unidbg中的DvmInteger和DvmBoolean；除此之外，大部分引用类型在Unidbg都视作DvmClass类型（继承于DvmObject&lt;?&gt;类型），这些引用类型的对象都属于DvmObject&lt;?&gt;类型。\nDvmObject&lt;?&gt;：这是 Unidbg 中所有 Java 对象的基类，类似于真实 JVM 中的 java.lang.Object。它是一个泛型类，DvmObject&lt;T&gt; 的 T 通常表示对应的真实 Java 类型。例如，DvmObject&lt;String&gt; 表示一个 String 类型的对象。DvmClass：表示 Java 中的类对象（java.lang.Class 的模拟）。在 Unidbg 中，DvmClass 继承自 DvmObject&lt;Class&lt;?&gt;&gt;，用来表示类的元信息（如类名、方法、字段等）。\n\n\n一般情况下，不需要补环境，是因为unidbg的虚拟机中内置了很多DvmClass（解析于SDK），也内置了很多自己的处理函数，操作这些DvmObject&lt;?&gt;，但遇到一些尚未解析的DvmClass或者无法解析的DvmClass的函数，就会抛出错误，这个时候就需要为它补环境了。\n补环境的过程如下，简单来说，就是内置的类与函数不够用了，转而使用外部java虚拟机的类与函数，只将结果转换成DvmObject&lt;?&gt;返回给内部虚拟机。\n\n\n举个例子，下面这个报错是无法处理ZipFile的构造函数。\n\n一直定位追踪到下面这个函数，会发现没有针对于ZipFile类型的构造函数。\n@Overridepublic DvmObject&lt;?&gt; newObjectV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) &#123;    switch (signature) &#123;        case &quot;java/io/ByteArrayInputStream-&gt;&lt;init&gt;([B)V&quot;: &#123;            ByteArray array = vaList.getObjectArg(0);            assert array != null;            return vm.resolveClass(&quot;java/io/ByteArrayInputStream&quot;).newObject(new ByteArrayInputStream(array.value));        &#125;        case &quot;java/lang/String-&gt;&lt;init&gt;([B)V&quot;: &#123;            ByteArray array = vaList.getObjectArg(0);            assert array != null;            return new StringObject(vm, new String(array.value));        &#125;        case &quot;java/lang/String-&gt;&lt;init&gt;([BLjava/lang/String;)V&quot;: &#123;            ByteArray array = vaList.getObjectArg(0);            assert array != null;            StringObject charsetName = vaList.getObjectArg(1);            assert charsetName != null;            try &#123;                return new StringObject(vm, new String(array.value, charsetName.value));            &#125; catch (UnsupportedEncodingException e) &#123;                throw new IllegalStateException(e);            &#125;        &#125;        case &quot;javax/crypto/spec/SecretKeySpec-&gt;&lt;init&gt;([BLjava/lang/String;)V&quot;:&#123;            byte[] key = (byte[]) vaList.getObjectArg(0).value;            StringObject algorithm = vaList.getObjectArg(1);            assert algorithm != null;            SecretKeySpec secretKeySpec = new SecretKeySpec(key, algorithm.value);            return dvmClass.newObject(secretKeySpec);        &#125;        case &quot;java/lang/Integer-&gt;&lt;init&gt;(I)V&quot;: &#123;            int i = vaList.getIntArg(0);            return DvmInteger.valueOf(vm, i);        &#125;        case &quot;java/lang/Boolean-&gt;&lt;init&gt;(Z)V&quot;:&#123;            boolean b;            b = vaList.getIntArg(0) != 0;            return DvmBoolean.valueOf(vm, b);        &#125;    &#125;    throw new UnsupportedOperationException(signature);&#125;\n\n这个时候就需要为它补环境了，如何补呢？这里的ZipFile并不是基本数据类型，在项目中也没有为它进行解析。\n\n\n因此需要将这个ZipFile类型解析到Unidbg的虚拟机中，再为它创建一个对象进行返回。\n下面的代码中，vm.resolveClass负责解析ZipFile类，此时ZipFile类光荣的加入了Unidbg的虚拟机中，并重新定义为DvmObject&lt;ZipFile&gt;类，newObject返回了一个Unidbg内置的DvmObject&lt;ZipFile&gt;类对象。\n这样便解解决了一个环境问题。\n@Override   public DvmObject&lt;?&gt; newObjectV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) &#123;       switch (signature) &#123;           case &quot;java/util/zip/ZipFile-&gt;&lt;init&gt;(Ljava/lang/String;)V&quot;: &#123;               // 正确提取 String 参数               StringObject pathObj = vaList.getObjectArg(0); // 内部虚拟机的String               assert pathObj != null;               String filePath = pathObj.getValue(); // 获取实际java类型的String               try &#123;                   // 创建虚拟的 ZipFile 对象（需提前在虚拟文件系统中补文件）                   ZipFile zipFile = new ZipFile(filePath);                   return vm.resolveClass(&quot;java/util/zip/ZipFile&quot;).newObject(zipFile);               &#125; catch (IOException e) &#123;                   throw new RuntimeException(e);               &#125;           &#125;       &#125;       return super.newObjectV(vm, dvmClass, signature, vaList);   &#125;\n\n还有一个补环境的例子，下面是报错，报错理由是缺少ZipFile的entries操作。\njava.lang.UnsupportedOperationException: java/util/zip/ZipFile-&gt;entries()Ljava/util/Enumeration;\tat com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417)\tat com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)\tat com.github.unidbg.linux.android.dvm.DvmMethod.callObjectMethodV(DvmMethod.java:89)\tat com.github.unidbg.linux.android.dvm.DalvikVM$32.handle(DalvikVM.java:553)\n\n一开始的补法是这样的。\npublic DvmObject&lt;?&gt; callObjectMethodV(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VaList vaList) &#123;    switch (signature) &#123;        case &quot;java/util/zip/ZipFile-&gt;entries()Ljava/util/Enumeration;&quot;: &#123;            //拿操作的对象            ZipFile zipFile = (ZipFile) dvmObject.getValue();            //通过对象来调用方法            Enumeration&lt;? extends ZipEntry&gt; entries =  zipFile.entries();            return vm.resolveClass(&quot;java/util/Enumeration&quot;).newObject(entries);        &#125;    &#125;    return super.callObjectMethodV(vm, dvmObject, signature, vaList);&#125;\n\n但之后仍会报错，提示无法将DvmObject转换为Enumeration，为什么会出现这个问题？其实DvmObject&lt;Enumeration&gt;是我们补的一个类，但Unidbg中内置了一个Enumeration类，这个类不应该补的，因为负责与与native层交互的内置虚拟机，它默认是转换内置的Enumeration &#x3D;&gt; JNI类型，而我们导入的这个类型会被忽视。\n虽然如此，但return的这个对象很重要，这是我们通过外部虚拟机，要返回给内部虚拟机的一个Enumeration对象，如果我们返回的是它内置的com.github.unidbg.linux.android.dvm.Enumeration就没任何事，因为这是它缺少的对象，但我们返回的是com.github.unidbg.linux.android.dvm.DvmObject&lt;Enumeration&gt;，对象不一致，就要强转了，然后失败了。\njava.lang.ClassCastException: class com.github.unidbg.linux.android.dvm.DvmObject cannot be cast to class com.github.unidbg.linux.android.dvm.Enumeration (com.github.unidbg.linux.android.dvm.DvmObject and com.github.unidbg.linux.android.dvm.Enumeration are in unnamed module of loader &#x27;app&#x27;)\tat com.github.unidbg.linux.android.dvm.AbstractJni.callBooleanMethodV(AbstractJni.java:610)\tat com.github.unidbg.linux.android.dvm.AbstractJni.callBooleanMethodV(AbstractJni.java:603)\tat com.github.unidbg.linux.android.dvm.DvmMethod.callBooleanMethodV(DvmMethod.java:119)\tat com.github.unidbg.linux.android.dvm.DalvikVM$35.handle(DalvikVM.java:630)\n\n我的分析得到了grok的认可，哈哈哈哈。\n\n既然这样补不对，就需要看内置的Enumeration是如何创建的，可以看到，内置的Enumeration实现的俩函数，不过这里不是重点，重点是如何创建一个Enumeration对象。\n通过构造函数，可以看到，需要输入一个外部java中的List对象，对象里的元素是DvmObject对象即可。\n因此，我们需要创建一个List，然后把ZipFile对象里元素的类型（即ZipEntry）转换成DvmObject&lt;ZipEntry&gt;，然后再放入List中。\n\n\n这样就算补好了。\npublic DvmObject&lt;?&gt; callObjectMethodV(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VaList vaList) &#123;    switch (signature) &#123;        case &quot;java/util/zip/ZipFile-&gt;entries()Ljava/util/Enumeration;&quot;: &#123;            ZipFile zipFile = (ZipFile) dvmObject.getValue();            Enumeration&lt;? extends ZipEntry&gt; entries =  zipFile.entries();            //return vm.resolveClass(&quot;java/util/Enumeration&quot;).newObject(entries);            List&lt;DvmObject&lt;?&gt;&gt; objs = new ArrayList&lt;&gt;();            while (entries.hasMoreElements())&#123;                ZipEntry zipEntry = entries.nextElement();                objs.add(vm.resolveClass(&quot;java/util/zip/ZipEntry&quot;).newObject(zipEntry));            &#125;            return new com.github.unidbg.linux.android.dvm.Enumeration(vm, objs);        &#125;    &#125;    return super.callObjectMethodV(vm, dvmObject, signature, vaList);&#125;\n\n追踪读写/* 监控读写 */emulator.traceRead(module.base, module.base + module.size);emulator.traceWrite(module.base, module.base + module.size);\n\n读取内存/* 读取内存 */long targetAddr = module.base + 0xE0320;UnidbgPointer ptr = UnidbgPointer.pointer(emulator, targetAddr);byte[] data = ptr.getByteArray(0, 0xC0);Inspector.inspect(data, &quot;Dumped Memory at 0x&quot; + Long.toHexString(targetAddr));\n"},{"title":"v380pro apk的分析","url":"/2025/05/18/v380pro-apk%E7%9A%84%E5%88%86%E6%9E%90/","content":"v380摄像头的apk某加密数据包分析先展示成果，原始数据内容通过了gzip压缩、AES（CBC模式）加密、base64编码，反过来就可以进行解密了。\n\n先通过r0capture查看函数调用栈，然后在几个关键函数处，hook下来，打印对象值，看看具体是哪一块进行加密。发现call到a的过程中有一个加密。\n\n由于call函数的过程，涉及很多对象的初始化，数据其实也在其中进行初始化了，很难分析。\n\n这里因为打印某些对象的值（gson包），发现了加密后data属于BodyRequest的成员变量j。\n\n追踪这个j。\n\n判断j的赋值在Api.c(api)。这里又可以看到j的值由api.k得到的。\n\n继续追踪k。\n\n\n\n搜索了一下，Kalle是一个开源sdk，body函数是用来填充负载部分的。\n\n\n这里很容易就知道AES_KEY和IV。\n\n直接用工具。\n\n\n如果要尝试使用分析libapk0000.so，我觉得可以解密字符串，然后进行dump下来查看，大概就可以判断加密模式了，如果是自定义的加密模式，那可能真要逆向了。\n"},{"title":"某瓣字段_sig的分析","url":"/2025/05/18/%E6%9F%90%E7%93%A3%E5%AD%97%E6%AE%B5-sig%E7%9A%84%E5%88%86%E6%9E%90/","content":"豆瓣抓包先了解如何抓包，这次尝试分析某个参数的加解密过程。\n工具是：Charles 4.6.3。\n抓包的配置方式如下：\n1.将pc和op放在同一局域网下，pc上打开Charles，设置Proxy-&gt;Proxy Settings，填写端口并勾选，如下图所示。\n\n\n2.之后在op上，设置网络的代理，将手机的流量转发到手机的9999端口。\n\n\n3.为pc和手机装Charles的root证书，用于CA自签名。\n\n由于手机端的证书对文件名有要求，这个文件名需要通过计算获得，计算可以通过openssl x509 -subject_hash_old -in &lt;证书&gt;获得，下图是网图，它最后得到的文件名就是5cba21f7，然后后缀固定为.0，所以就是5cba21f7.0。\n\n4.在安卓7以上的版本，app只接受系统证书，不接受用户证书，所以需要将证书移至&#x2F;system&#x2F;etc&#x2F;security&#x2F;cacerts，之后重启手机。\n5.之后如图所示，设置ssl代理。\n\n之后就可以抓到包了。——上面只考虑了单向认证，如果是双向认证，有些app的包还是会显示unknown，那就要将app的证书和密钥填写至Charles中了，不过豆瓣是单向认证。\n分析根据访问不同的域名，进行区别。\n\n\n其中，参数_sig是请求签名，用于验证请求的完整性和合法性，通常由参数和密钥计算得出。\n\n这次要分析的就是如何得到这个_sig。——抓几次包，会发现每次发包的header中，就_sig的值一直在变化，所以如果想要写脚本来发包，伪造客户端，就要解决_sig构造的问题。\n通过搜索&quot;_sig&quot;，似乎找到了为_sig赋值的地方，将pair0.first经过一些规则（HTTP的规范）后，作为值赋给_sig。\n\n在setQueryParameter中会检查s是否为空，如果已存在，还会把它移除，重新进行签名。\n\n之后，我想hook上面的函数，结果遇到了frida检测。\n这次frida检测，我学到了以下几点：\n1.frida用旧一些的版本，最新的可能不稳定；\n2.把握好hook的时机，Interceptor.attach和Interceptor.replace的执行方式不同。attach是设置监控，监控目标地址，当执行到目标地址，才会启动对应的脚本内容；而replace是对目标地址立马进行替换，如果目标地址所在的模块尚未加载，会执行失败。\n以下是grok的回答。\n什么是“Hook 陷阱”？“Hook 陷阱”并不是一个官方术语，而是形象地描述了 Frida 在特定时机设置 Hook 的工作方式。简单来说，它就像在目标函数的调用路径上“埋下一个陷阱”，等待程序运行到那个位置时触发，而不是立即执行 Hook 逻辑。在 Frida 中，Hook 的实现主要通过 Interceptor 模块完成：    Interceptor.attach：附加到目标函数的入口和出口，分别在函数调用前（onEnter）和调用后（onLeave）执行自定义逻辑。    Interceptor.replace：直接替换目标函数的实现，用你定义的函数逻辑覆盖原始函数。“陷阱”的关键在于时机：    Hook 的设置（比如调用 Interceptor.attach 或 Interceptor.replace）是在你的 Frida JS 脚本运行时完成的。    Hook 的触发（比如执行 onEnter 或替换后的函数逻辑）则是在目标函数被实际调用时发生的。举个例子：javascriptInterceptor.attach(Module.getExportByName(&#x27;libc.so&#x27;, &#x27;open&#x27;), &#123;    onEnter: function(args) &#123;        console.log(&#x27;open 被调用了！&#x27;);    &#125;&#125;);    脚本运行时，Interceptor.attach 会“设置陷阱”，告诉 Frida 监控 open 函数。    但 onEnter 里的 console.log 并不会立即执行，而是等到程序调用 open 时才打印日志。这种“等待触发”的机制就是“Hook 陷阱”的核心。替换函数的时机：脚本运行后会第一时间替换吗？你提到：“将脚本跑起来后，它难道不是第一时间将 Native 层函数替换掉吗？”答案是不完全是。让我们详细分析一下。Frida 替换函数的工作原理使用 Interceptor.replace 可以替换 Native 层函数的实现。例如：javascriptInterceptor.replace(ptr(&#x27;0x12345678&#x27;), new NativeCallback(function() &#123;    console.log(&#x27;函数被替换了！&#x27;);    return 0;&#125;, &#x27;int&#x27;, []));    当脚本执行到 Interceptor.replace 时，Frida 会尝试将目标函数的地址替换为你的自定义函数。    但这有一个前提：目标函数所在的模块必须已经加载到内存中。时机的影响因素    模块是否已加载        如果你在脚本运行时要替换的函数属于某个动态加载的 .so 文件（比如 libexample.so），而这个文件在脚本启动时尚未加载，Frida 无法立即替换。        因为 Frida 需要知道模块的基址和函数的偏移量。如果 Process.findModuleByName(&#x27;libexample.so&#x27;) 返回 null，你就无法计算目标函数的地址，替换自然无法生效。    动态加载的场景        在 Android 中，很多 .so 文件是通过 dlopen（或 android_dlopen_ext）动态加载的。        如果你的目标函数在某个动态加载的模块中，你需要在模块加载后再执行替换操作。实际例子：你的代码可能的样子假设你想替换 libmsaoaidsec.so 中的某个函数 sub_1b924，代码可能是这样的：javascriptfunction hook_sub_1b924() &#123;    let module = Process.findModuleByName(&#x27;libmsaoaidsec.so&#x27;);    if (module) &#123;        let sub_1b924 = module.base.add(0x1b924);        Interceptor.replace(sub_1b924, new NativeCallback(function() &#123;            console.log(&#x27;sub_1b924 被替换了！&#x27;);            return 0;        &#125;, &#x27;int&#x27;, []));    &#125; else &#123;        console.log(&#x27;模块尚未加载！&#x27;);    &#125;&#125;    如果脚本运行时 libmsaoaidsec.so 还没加载，module 会是 null，替换不会生效。    你需要等待模块加载完成后再调用 hook_sub_1b924()。为什么不直接在脚本运行时替换？你可能会疑惑：为什么不直接在脚本启动时就完成所有替换？原因有以下几点：    模块未加载的问题        如上所述，如果目标模块没加载，Frida 无法找到函数地址，替换会失败。        解决办法是监控模块加载过程（比如 Hook android_dlopen_ext），在模块加载后再执行替换。    初始化逻辑的依赖        有些 .so 文件在加载后会执行初始化逻辑（比如通过 soinfo::call_constructors() 调用 .init 或 .init_array）。        如果你在初始化前替换函数，可能会干扰模块的正常初始化（比如反调试、校验逻辑），导致程序崩溃或行为异常。        通过在初始化开始前（比如 call_constructors 的 onEnter）替换函数，你可以更安全地介入。例如，一个常见的策略是：javascriptInterceptor.attach(Module.getExportByName(&#x27;libdl.so&#x27;, &#x27;android_dlopen_ext&#x27;), &#123;    onEnter: function(args) &#123;        this.onLeave = function(retval) &#123;            hook_sub_1b924(); // 在模块加载后替换函数        &#125;;    &#125;&#125;);    这里在 android_dlopen_ext 调用后（模块加载完成时）再执行替换，确保时机正确。总结：如何理解“Hook 陷阱”和替换时机    “Hook 陷阱”的含义        它是指在脚本运行时设置 Hook，但实际逻辑在目标函数调用时触发，就像“埋下陷阱”等待猎物。        比如通过 Interceptor.attach 设置的 onEnter 和 onLeave，都是在目标函数执行时才生效。    替换函数的时机        Interceptor.replace 在脚本运行时设置替换，但实际生效取决于模块是否加载。        如果目标函数所在的 .so 文件是动态加载的，你需要在模块加载后（比如通过 Hook android_dlopen_ext 或 soinfo::call_constructors()）再执行替换。    你的疑问解答        脚本运行后不会“第一时间”替换 Native 层函数，除非目标模块已经加载且函数地址可访问。        对于动态加载的模块，Frida 需要你手动控制替换时机，确保在正确的时间点介入。\n\n之后写的脚本如下。\nfunction hook_dlopen() &#123;    Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;),        &#123;            onEnter: function (args) &#123;                this.fileName = args[0].readCString()                console.log(`dlopen onEnter: $&#123;this.fileName&#125;`)                if (this.fileName !== undefined &amp;&amp; this.fileName.indexOf(&quot;libmsaoaidsec.so&quot;) &gt;= 0) &#123;                    hook_linker_call_constructors()                &#125;            &#125;, onLeave: function (retval) &#123;                console.log(`dlopen onLeave fileName: $&#123;this.fileName&#125;`)                if (this.fileName != null &amp;&amp; this.fileName.indexOf(&quot;libmsaoaidsec.so&quot;) &gt;= 0) &#123;                    let JNI_OnLoad = Module.getExportByName(this.fileName, &#x27;JNI_OnLoad&#x27;)                    Interceptor.attach(JNI_OnLoad, &#123;                        onLeave: function (retval) &#123;                            console.log(`JNI_OnLoad onLeave: $&#123;retval&#125;`)                        &#125;                        &#125;);                    console.log(`dlopen onLeave JNI_OnLoad: $&#123;JNI_OnLoad - Module.getBaseAddress(this.fileName)&#125;`)                &#125;            &#125;        &#125;    );&#125;function hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;)    let offset = 0x51BA8    // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset)    let listener = Interceptor.attach(call_constructors,&#123;        onEnter:function(args)&#123;            console.log(&#x27;hook_linker_call_constructors onEnter&#x27;)            let secmodule = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;)            if (secmodule != null)&#123;                // hook_pthred_create()                hook_sub_1c544() // 含检测                hook_sub_1b8d4()                // hook_sub_26e5c()                listener.detach()            &#125;        &#125;    &#125;)&#125;function hook_pthred_create()&#123;    console.log(&quot;libmsaoaidsec.so --- &quot; + Process.findModuleByName(&quot;libmsaoaidsec.so&quot;).base)    Interceptor.attach(Module.findExportByName(&#x27;libc.so&#x27;,&#x27;pthread_create&#x27;),&#123;        onEnter(args)&#123;            let func_addr = args[2]            console.log(`The thread Called function address is: $&#123;func_addr&#125;`)        &#125;    &#125;)&#125;function hook_sub_1c544() &#123;    let secmodule = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;)    Interceptor.replace(secmodule.base.add(0x1c544), new NativeCallback(function () &#123;      console.log(`hook_sub_1c544 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; replace`)    &#125;, &#x27;void&#x27;, [&quot;int64&quot;]));&#125;function hook_sub_1b8d4() &#123;    let secmodule = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;)    Interceptor.replace(secmodule.base.add(0x1b8d4), new NativeCallback(function () &#123;      console.log(`hook_sub_1b8d4 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; replace`)    &#125;, &#x27;void&#x27;, []));&#125;function hook_sub_26e5c() &#123;    let secmodule = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;)    Interceptor.replace(secmodule.base.add(0x26e5c), new NativeCallback(function () &#123;      console.log(`hook_sub_26e5c &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; replace`)      return 1;    &#125;, &#x27;int64&#x27;, []));&#125;setImmediate(hook_dlopen)\n\n逻辑算比较清楚，之后还剩下对业务函数的hook、利用_sig构造包。\n接着分析方法e0.d.A(Request request0)。\n\n然后写了这个函数，每次我将这个函数放到hook_dlopen的末尾，就无法正确hook上之前的3个线程。之后我发现，可以通过cmd行输入。\nfunction hook_sig()&#123;    Java.perform(function()&#123;        const clazz_d = Java.use(&quot;e0.d&quot;);        clazz_d.A.implementation = function (request) &#123;            console.log(`request-header: $&#123;request.header(&quot;Authorization&quot;)&#125;`);            return this.A(request);        &#125;    &#125;)&#125;\n\n结果如下。\n\n这里就获得了Authorization的值：93f4c257daea24dfbbde470790be6e9d。\n在方法d.z中，将url、method、authorization进行加密\n\n这里就不进去追踪了，直接获取返回值。\n直接获取了_sig和_ts的值。\nfunction hook_sig()&#123;    Java.perform(function()&#123;        const clazz_d = Java.use(&quot;e0.d&quot;);        clazz_d.A.implementation = function (request) &#123;            console.log(`request-header: $&#123;request.header(&quot;Authorization&quot;)&#125;`);            let res = this.A(request);            console.log(`Pair-first: $&#123;new String(res.first)&#125;\\nPair-second: $&#123;new String(res.second)&#125;`);            return res;        &#125;    &#125;)&#125;\n\n\n之后要利用并构造包的话，只需要添加上自己生成的_sig参数，这里用js脚本，模仿jeb的代码构造_sig，最终，完整的代码如下。\nvar url;var method;var authorization;function hook_dlopen() &#123;    let listener = Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;),        &#123;            onEnter: function (args) &#123;                this.fileName = args[0].readCString()                console.log(`dlopen onEnter: $&#123;this.fileName&#125;`)                if (this.fileName !== undefined &amp;&amp; this.fileName.indexOf(&quot;libmsaoaidsec.so&quot;) &gt;= 0) &#123;                    hook_linker_call_constructors()                    listener.detach()                &#125;            &#125;        &#125;    );    // hook_sig()&#125;function hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;)    let offset = 0x51BA8    // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset)    let listener = Interceptor.attach(call_constructors,&#123;        onEnter:function(args)&#123;            console.log(&#x27;hook_linker_call_constructors onEnter&#x27;)            let secmodule = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;)            if (secmodule != null)&#123;                // hook_pthred_create()                hook_sub_1c544()                hook_sub_1b8d4()                hook_sub_26e5c()                listener.detach()            &#125;        &#125;    &#125;)&#125;function hook_pthred_create()&#123;    console.log(&quot;libmsaoaidsec.so --- &quot; + Process.findModuleByName(&quot;libmsaoaidsec.so&quot;).base)    Interceptor.attach(Module.findExportByName(&#x27;libc.so&#x27;,&#x27;pthread_create&#x27;),&#123;        onEnter(args)&#123;            let func_addr = args[2]            console.log(`The thread Called function address is: $&#123;func_addr&#125;`)        &#125;    &#125;)&#125;function hook_sub_1c544() &#123;    let secmodule = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;)    Interceptor.replace(secmodule.base.add(0x1c544), new NativeCallback(function () &#123;      console.log(`hook_sub_1c544 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; replace`)    &#125;, &#x27;void&#x27;, [&quot;int64&quot;]));&#125;function hook_sub_1b8d4() &#123;    let secmodule = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;)    Interceptor.replace(secmodule.base.add(0x1b8d4), new NativeCallback(function () &#123;      console.log(`hook_sub_1b8d4 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; replace`)    &#125;, &#x27;void&#x27;, []));&#125;function hook_sub_26e5c() &#123;    let secmodule = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;)    Interceptor.replace(secmodule.base.add(0x26e5c), new NativeCallback(function () &#123;      console.log(`hook_sub_26e5c &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; replace`)      return 1;    &#125;, &#x27;int64&#x27;, []));&#125;function hook_sig()&#123;    Java.perform(function()&#123;        const clazz_d = Java.use(&quot;e0.d&quot;);        clazz_d.A.implementation = function (request) &#123;            authorization = request.header(&quot;Authorization&quot;);            authorization = authorization.substring(7);            url = request.url().toString();            method = request.method();            console.log(`request-header: $&#123;authorization&#125;`); // 打印Authorization            let res = this.A(request);            console.log(`Pair-first: $&#123;new String(res.first.value)&#125;\\nPair-second: $&#123;new String(res.second.value)&#125;`); // 打印Pair            // MySig，自己模仿流程写一个            getMySig();            return res;        &#125;    &#125;)&#125;function getMySig() &#123;    const HttpUrl = Java.use(&quot;okhttp3.HttpUrl&quot;);    const StringBuilder = Java.use(&quot;java.lang.StringBuilder&quot;);    const clazz_a = Java.use(&quot;android.support.v4.media.a&quot;);    const Uri = Java.use(&quot;android.net.Uri&quot;);    // 临时硬编码 s3    var s3 = Java.use(&quot;java.lang.String&quot;).$new(&quot;bf7dddc7c9cfe6f7&quot;);    if (!url || !method || !authorization) &#123;        console.error(&quot;url, method, or authorization is undefined&quot;);        return;    &#125;    var stringBuilder0 = clazz_a.g(method);    if (!stringBuilder0) &#123;        console.error(&quot;clazz_a.g(method) returned null&quot;);        return;    &#125;    var s4 = HttpUrl.parse(url).encodedPath();    if (!s4) &#123;        console.error(&quot;HttpUrl.parse failed&quot;);        return;    &#125;    var s5 = Uri.decode(s4);    if (s5.endsWith(&quot;/&quot;)) &#123;        s5 = clazz_a.e(s5, -1, 0);    &#125;    stringBuilder0.append(&quot;&amp;&quot;).append(Uri.encode(s5)).append(&quot;&amp;&quot;).append(authorization);    var v = Java.use(&quot;java.lang.System&quot;).currentTimeMillis().toString();    v = v.substring(0, v.length - 3);    stringBuilder0.append(&quot;&amp;&quot;).append(v);    var mac0 = Java.use(&quot;javax.crypto.Mac&quot;).getInstance(&quot;HmacSHA1&quot;);    mac0.init(Java.use(&quot;javax.crypto.spec.SecretKeySpec&quot;).$new(s3.getBytes(), &quot;HmacSHA1&quot;));    const Base64 = Java.use(&quot;android.util.Base64&quot;);    stringBuilder0.toString()    let strrr = stringBuilder0.toString();    console.log(`typeof strrr: $&#123;typeof strrr&#125;`);    let bytes = Java.use(&quot;java.lang.String&quot;).$new(strrr).getBytes();    console.log(`typeof Java.use(&quot;java.lang.String&quot;).$new(strrr): $&#123;typeof Java.use(&quot;java.lang.String&quot;).$new(strrr)&#125;`);    var res = mac0.doFinal(bytes);    var s6 = Base64.encodeToString(res, 2);    // 确保 s6 和 v 是正确的 Java 字符串    var pair = Java.use(&quot;android.util.Pair&quot;).$new(        s6, v);    console.log(`MySig: $&#123;pair.first&#125;`);    return pair;&#125;setImmediate(hook_dlopen)\n\n其中，有一个问题，如下代码卡了我很久。在我眼中，这里的strrr一定是一个js代理java的String类型，是一个属于java的字符串，但被frida自动转换成了JavaScript字符串，而JS字符串没有getBytes函数。\nstringBuilder0.toString()let strrr = stringBuilder0.toString();let bytes = Java.use(&quot;java.lang.String&quot;).$new(strrr).getBytes();// 原本写的是strrr.getBytes()\n\nhttps://reverseengineering.stackexchange.com/questions/32790/convert-string-to-byte-array-in-frida-js-script\n通过js的函数，typeof去查看区别，可以发现stringBuilder0.toString()的类型是string，而Java.use(“java.lang.String”).$new(strrr)的类型是object。\n\n至此，脚本也算是跑出了_sig签名。\n"},{"title":"类加载与脱壳机","url":"/2025/05/18/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E8%84%B1%E5%A3%B3%E6%9C%BA/","content":"自制脱壳机，将公开了源码的Fart6移植到Fart10，同时去除一些Fart特征。\nloadClass的过程loadClass的过程可以总结成：1.判断是否是当前类加载器加载了此类；2.若不是，让父加载器加载此类；3.若父加载器加载失败，由当前加载器加载。\n一般实现类加载，同时使用ClassLoader的实例调用loadClass。\n\n可以看到，ClassLoader.loadClass(String className)间接调用重载函数，resolve在这里不起作用，在JVM中，如果resolve为true，表示加载类之后是否需要立即进行链接操作中的解析步骤。（链接包括：验证、准备（分配空间）、解析），而在安卓虚拟机中，这里忽略resolve。\n\n\n1 findLoadedClass（ClassLoader）——查询当前加载器是否加载了目标类findLoadedClass是用来检查缓存的，这个方法会检查当前ClassLoader实例是否已经加载过名为className的类，每个ClassLoader实例都有一个缓存区，用来存放已经加载过的类。\n如果当前实例是启动类加载器，则将局部变量 loader 设为 null。这是因为查询启动类加载器加载的类通常需要通过 VM 的特殊 native 接口，并使用 null 来代表它。\n如果当前实例不是启动类加载器（比如是 AppClassLoader 或 PathClassLoader 等），则将 loader 设置为 this，即当前 ClassLoader 实例本身。\n\nfindLoadedClass（VMClassaLoader、JNI函数）这里的VMClassLoader.findLoadedClass是一个static的JNI函数，具体实现在native层，目录为：&#x2F;art&#x2F;runtime&#x2F;native&#x2F;java_lang_VMClassLoader.cc。\n这个 C++ 函数 VMClassLoader_findLoadedClass 的核心目的是：接收一个 Java 层的 ClassLoader 对象和一个类名字符串，然后在 ART 虚拟机内部的数据结构中查找，判断这个特定的 ClassLoader 是否已经加载并解析了具有该名称的类。如果找到了并且类是可用状态（已解析），就返回对应的 Java Class 对象 (jclass)；否则返回 nullptr。\n现在来简单解释一下下图的函数VMClassLoader_findLoadedClass。\n第31行，env是标准的JNI的接口，提供java与native之间的交互。soa可以理解为ART对JNI交互的封装与简化，它的底层还是使用env来工作，但自动管理线程状态，更安全、方便。\n第32行，将Java层的jobject javaLoader解码成ART内部表示的mirror::ClassaLoader*指针loader，这里的mirror是ART中表示Java堆对象的类的命名空间。\n第33行，将javaName从java的jstring转换成c&#x2F;c++使用的UTF-8编码字符串。\n第37行，获取ClassLinker实例，ClassLinker实例要负责类的加载、链接（验证、准备、解析）、初始化。所有类查找、类定义、解析相关的操作，都要经过ClassLinker。\n第38行，将点分格式的类名转换成虚拟机内部使用的描述符，即斜杠格式。\n第39行，将类描述符转换成唯一的哈希值。\n第40行，根据哈希值、loader、类描述符、当前的线程（soa.Self()返回线程Thread指针），来去找*唯一的类。\n这里重点关注LookupClass。\n\n\nLookupClass在LookupClass中。\n第一阶段，查主表。（缓存查找）\n使用 ReaderMutexLock 获取对 ClassLinker 内部类表的读取锁，保证线程安全。\n调用 LookupClassFromTableLocked 在主要的类表（包括 Zygote 预加载表 pre_zygote_class_table_ 和运行时表 class_table_）中查找。\n如果在表中找到了匹配的类 (result != nullptr)，就立即返回结果。锁会自动释放。\n第二阶段，查启动镜像（启动类加载器）。\n仅当第一阶段失败、查找的是启动类加载器 (class_loader == nullptr)、且需要查找镜像时，才执行这里。\n调用 LookupClassFromImage(descriptor) 尝试在 dex_caches_ 中查找。\n如果找到了 (result != nullptr): 调用 InsertClass 将其加入主类表（可能是 class_table_），起到缓存作用，然后返回找到的 result。\n如果还没找到 (result == nullptr): 增加查找镜像失败的计数器。如果失败次数超过阈值 (kMaxFailedDexCacheLookups)，则触发一个优化操作 MoveImageClassesToClassTable()，将所有启动镜像中的类都添加到主类表中，以加速后续查找。最后返回 nullptr。\n\nLookupClassFromTableLocked在LookupClassFromTableLocked中，pre_zygote_class_table_记录着预加载的类（Zygote进程在创建时，初始化了虚拟机并加载了一系列预加载的动态链接库，这些动态链接库里的类记录在这个预加载类表里）。而class_table_则是动态类表，它存储了 Zygote 之后由各种 ClassLoader 加载的类，以及从启动镜像（image）查找到并缓存起来的类。\n\nLookupClassFromImage函数LookupClassFromImage是从启动类加载器的dex_cache中找目标类，DexCache类用于关联DexFile对象。\n\n\n\n2 parent.loadClass——委托父加载器加载上述流程已经把如何寻找一个类讲得很详细了，接下来讲委派双亲机制。\n下图中，在findLoadedClass找不到className后，就会尝试执行parent.loadClass，让父加载器去加载，父加载器的执行流程也是：findLoadedClass、parent.loadClass、findClass。\n所以，这里不细讲委派机制（双亲委派机制不难），直接讲如何加载一个未加载的类。\n\n\n3 findClass——自己加载这里分析的是BaseDexClassLoader的findClass，一般整体壳都绕不开BaseDexClassLoader，BaseDexClassLoader的父类是ClassLoader，我们之前分析的findLoadedClass和parent.loadClass都是ClassLoader类中，loadClass里出现的函数。BaseDexClassLoader并没有实现自己的loadClass，所以loadClass都是从ClassLoader继承过来的。\n但ClassLoader的findClass已经被BaseDexClassLoader覆写了，我们这里就需要分析findClass。\nfindClass 函数的核心职责就是：在当前 ClassLoader 管理的一系列 Dex 文件中，按顺序查找指定的类，如果找到，就加载并定义它。\n下图中，pathList是个老熟人了。\n\npathList——属于类DexPathListpathList是BaseDexClassLoader声明的一个DexPathList类型的私有成员变量。\n\n关于DexPathList，从字面上来看，它是存储Dex路径列表的一个变量，从功能上来说，它存储的路径包括：apk的路径、dex的路径、jar的路径、class的路径等。然而，类DexPathList存储路径的列表（成员变量）叫dexElements，这一度让我以为——“一个Element实例代表一个Dex文件路径”，这个概念其实是错的。\n通过注释，其实可以知道，这个成员变量应该叫pathElements，结果因为Facebook app改了名字，What can I say。\n纠正一下上面的概念，这里的dexElements是一个Element数组，每个Element实例存储的是一个路径，这个路径要是指向apk，可能包含不止一个Dex，所以一个Element实例代表一个Dex文件路径的概念是错误的。\n\n\n接着看看DexPathList的findClass。\n可以看到，这里取出了每个Element实例，并取出了element.dexFile赋给dex，然后调用了dex.loadClassBinaryName去找目标类是否在当前的文件（apk&#x2F;dex&#x2F;jar&#x2F;class）中。\n\ndexElements——属于类Element类Element是定义在DexPathList的静态内部类，从成员变量中可以看出，它存储的类型有apk&#x2F;zip&#x2F;dex等，还有一个很关键的成员变量dexFile。\n\n\nmCookie——属于类DexFileDexFile的mCookie很重要，在native层中，通过相关函数的调用，可以利用mCookie去获取DexFile（可以理解为PathFile）里存放的所有Dex文件。\n\n\n阅读DexFile.java中的代码，会发现mCookie的值由jni函数openDexFileNative获得。\n\n\n\njava层openDexFileNative对应着native层的DexFile_openDexFileNative。\n第154-161行，将输入的jstring转换成c&#x2F;c++的const char*来使用。\n第163行，获取ART运行时的ClassLinker实例，打开Dex文件和处理OAT文件是ClassLinker的职责之一。\n第164行，创建一个std::vector，用于存放成功打开的DexFile对象。\n第165行，创建error_msgs用于收集打开过程中可能出现的错误信息。\n第167行，可以理解为OpenDexFilesFromOat将已打开的Dex文件(们)的内部句柄打包成一个long[]数组，返回给dex_files。\n第170行，将这些句柄从native类型转换成JNI类型，赋值给array，array会通过return赋给Java层的mCookie。\n\n\n于是我们知道了，mCookie是已打开的Dex文件们的句柄数组指针。\nloadClassBinaryName——属于类DexFile回到这张图，讲DexFile的loadClassBinaryName。\n\n直接跳转到defineClass。\n\n再跳转到defineClassNative。\n\n\ndefineClassNative是一个静态JNI函数。\n第220行，眼熟吧，将cookie转换回了dex_files句柄数组。\n第234行，遍历每一个打开的Dex文件句柄。\n第235行，通过函数FindClassDef，去每个Dex文件里寻找目标Class是否存在。\n第236行，如果存在，则通过ClassLinker的实例class_linker，对这个Dex文件进行注册，加入dex_caches。\n\nFindClassDef——找到类定义这个函数的核心目的是：在当前的 DexFile 对象所代表的 Dex 文件内部，根据给定的类描述符 (descriptor) 字符串和其哈希值，查找并返回对应的 DexFile::ClassDef 结构体指针。\n其中，第481-485行，在解析一个Dex文件，获得Class的数量。\n第486-499行，遍历类定义表，根据类定义结构的class_idx_是指向type索引表，这里通过描述符descriptor获取到了type_idx，然后和每个类的class_idx_进行比较，以此找出类。\n\n\n下图是ClassDef的结构。\n\n\nRegisterDexFile——将DexFile加入缓存dex_cache会被加入ClassLinker中的dex_caches_中（通过dex_caches_.push_back），ClassLinker会通过这个列表跟踪所有已注册的Dex缓存，建立了dex_cache和dex_file之间的连接（dex_cache-&gt;SetDexFile(&amp;dex_file)）。\n这个过程确保了每个被 ART 管理的 Dex 文件都有一个对应的 DexCache，并且 ClassLinker 能够找到并管理这些缓存。\n\n\nDefineClass——类的加载、链接、初始化这个函数是实际定义一个新类的核心逻辑。它接收一个在 dex_file 中找到的类定义 dex_class_def，以及要使用的 class_loader，然后负责创建对应的运行时 mirror::Class 对象，并执行加载和链接的关键步骤。\n\n\n第1816行-1829行，处理特殊的类。\n第1831-1841行，分配内存创建Class对象。\n第1842行，将DexFile对应的DexCache设置到Class对象中。\n第1844行，用ClassDef和ClassLoader信息填充Class对象。\n第1847-1850行，为String类专门进设置标志。——没深入分析。\n第1853-1854行，获得这个类的锁，防止并发初始化，记录当前线程为类的初始化线程。\n\n第1857行，根据描述符、Class对象.Get()、类描述符的hash值插入一个新加载的类到类表class_table_中。\n第1858-1862行，插入失败，说明被其它线程插入了，使用已存在的Class对象并确保它已经被解析。\n第1868-1876行，加载类的成员（字段和方法信息），如果失败，标志Class状态为Error。\n第1878-1879行，此时类状态应该为Loaded（成员已经加载，但父类&#x2F;接口未连接）。\n第1880行，加载并链接父类和接口。\n第1894行，执行链接（验证、准备、解析字段&#x2F;方法、设置vtable&#x2F;iftable等）。\n\n最后返回的是一个定义并链接好的Class对象。\n\n\n整个逻辑如下图所示。\n\n\n（注：说明一下，Java的DexFile类和C&#x2F;C++的DexFile类不一样，Java的DexFile通常指向一个APK文件或JAR文件或Dex文件等等，所以一个DexFile类可能会存储着许多个Dex文件；而C&#x2F;C++的DexFile类指向一个Dex文件）\n一个 Java DexFile 对象虽然是基于一个单一的源文件路径 (APK&#x2F;JAR) 创建的，但它内部通过 mCookie (一个 long[] 数组) 可以管理从该源文件或其对应的 OAT 文件中加载出来的一个或多个底层的 C++ art::DexFile 实例。这对于支持 Android 的 MultiDex 机制至关重要。\nFart的逻辑Fart脱壳的步骤主要分为3步：\n1.找到合适的点，通过DexFile结构脱下完整的dex；\n2.主动调用类中的每一个方法，并实现对CodeItem的dump；\n3.修复Dex。\n整体壳下图是Fart的第1点的逻辑。\n一个类的初始化函数是不会被直接编译成OAT代码的，而一个Java的Method，除了走OAT代码模式，就必须走解释器模式，解释器模式必须经过函数Execute，因此，可以在Execute里针对进行dump，以完成整个dex的dump。\n\n抽取壳下图是Fart的第2点逻辑。\n\n之后，又有人写了一个FartExt，逻辑如下。\n\n","tags":["安卓逆向 类加载 Fart"]},{"title":"算法逆向分析初识","url":"/2025/05/18/%E7%AE%97%E6%B3%95%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%88%9D%E8%AF%86/","content":"hellojni_2.0.7.apk目标：还原signs的加密算法。\n点击SIGN2按钮后，下面这个签名会发生改变。\n\n\n通过定位，发现这个签名是由JNI函数Java_com_example_hellojni_HelloJni_sign2生成的。\n进一步，对其中的sub_1CFF0进行hook，发现其第3个参数（从1开始算）便是签名。\n\n\nhook的代码如下，将其中的addr赋值为1CFF0即可。\nfunction hook_find_target_address(addr)&#123;    var base = Module.findBaseAddress(&quot;libhello-jni.so&quot;);    console.log(&quot;\\r\\nlibhello-jni.so Baseaddr: &quot; + base);    var target_addr = base.add(addr);    console.log(&quot;\\r\\nTarget Address: &quot; + target_addr);    // hook并打印参数和返回值    Interceptor.attach(target_addr, &#123;        onEnter(args)&#123;            this.arg0 = args[0];            this.arg1 = args[1];            this.arg2 = args[2];            console.log(&quot;\\r\\nsub_&quot; + addr.toString(16) + &quot;args: &quot;);            console.log(&quot;\\r\\ninput_str: \\r\\n&quot; + hexdump(this.arg0));            console.log(&quot;\\r\\ninput_str_length: &quot; + this.arg1);        &#125;,        onLeave(retval)&#123;            console.log(&quot;\\r\\noutput_str: \\r\\n&quot; + hexdump(this.arg2));        &#125;    &#125;)&#125;\n\n打印的结果如下图所示。\n\n\n为了方便分析，这里需要将input_str和input_str_length进行固定。\n如图所示，我将输入字符串固定为”1234567890abcdefg”。\nfunction hook_find_target_address(addr)&#123;    var base = Module.findBaseAddress(&quot;libhello-jni.so&quot;);    console.log(&quot;\\r\\nlibhello-jni.so Baseaddr: &quot; + base);    var target_addr = base.add(addr);    console.log(&quot;\\r\\nTarget Address: &quot; + target_addr);        // hook并打印参数和返回值    Interceptor.attach(target_addr, &#123;        onEnter(args)&#123;            // 保存原始参数值以便打印            this.arg0 = args[0];            this.arg1 = args[1];            this.arg2 = args[2];                        console.log(&quot;\\r\\nsub_&quot; + addr.toString(16) + &quot; args: &quot;);            console.log(&quot;\\r\\n原始input_str: \\r\\n&quot; + hexdump(this.arg0, &#123; length: parseInt(this.arg1) &#125;));            console.log(&quot;\\r\\ninput_str_length: &quot; + this.arg1);                        // 新字符串            var new_str = &quot;1234567890abcdefg&quot;;                        // 方法1：直接写入内存            Memory.writeUtf8String(args[0], new_str);                        // 方法2：如果需要写入二进制数据而不是UTF8字符串            // var bytes = [0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x00]; // &quot;1234567890abcdef\\0&quot;            // Memory.writeByteArray(args[0], bytes);                        var length = new_str.length;            args[1] = ptr(length);            this.args1 = args[1];            console.log(&quot;\\r\\n修改后的长度: &quot; + this.args1);            console.log(&quot;\\r\\n修改后input_str: \\r\\n&quot; + hexdump(args[0], &#123; length: parseInt(this.args1) &#125;));        &#125;,        onLeave(retval)&#123;            console.log(&quot;\\r\\noutput_str: \\r\\n&quot; + hexdump(this.arg2, &#123; length: parseInt(this.args1) &#125;));        &#125;    &#125;);&#125;\n\n\n\n在确保了输入字符串不变后，尝试使用IDA的trace，追踪函数sub_1CFF0。\n先注入frida、再注入IDA server——似乎不按这个顺序，先注入IDA再注入Frida，Frida会注入失败。\n我决定先退出Frida的hook，再进行追踪，因为我发现Frida要是已经hook了sub_1CFF0，在sub_1CFF0的函数开始的地方，会存在inline hook，跳转到Frida的跳床函数。\n\n\n通过IDA trace，走过的汇编指令会变成黄色。\n\n追踪到的内容如下图所示，第一栏的36EE是线程id，第二栏是地址，第三栏开始就是汇编指令了，如果汇编指令修改了寄存器，则会在汇编指令后面，显示寄存器被修改后的值。\n\n之后，我重新生成了一个trace记录，并记录了一下签名值。\n\n\n之后进行算法逆向。\n已知算法的输入是input_str &#x2F; input_str_length &#x2F; output_str，分别代表着X0、X1、X2。\n\n因为X2代表着output_str的内存地址，所以追踪X2，判断有哪些指令对地址0x00000079E1720D90上的内容进行了修改。\n\n\n查找到了34个对0x00000079E1720D90进行读写的位置。\n对其中一些指令进行还原，可以猜到。\nX8代表：当前正在操作output的第X8个字节，也代表循环次数；\nX5代表output的内存地址；\nX29[var_64]是一个固定字节数组。\nX29[var_68]也是一个固定字节数组。\n至于var_6C，最后还是追踪到var_68上。\n\n做了一些补充。\n\n一直追踪[X29,#var_64]。\n\n而一直追踪[X29,#var_68]，会发现需要追踪X2，继而追踪X2和X3，继而追踪X3和X7……\n最后追踪到[X29,#var_88]。\n\n最后发现，var_88这个变量是一个指针，它将地址给了X2，由X2去获取全局变量，也就是图中的xmmword_79A31EE7B0。\n\n至此，可以将全局变量及涉及到的寄存器改写成c。\n(解密的时候前8个字节和后8个字节的处理方式不同，可能还得逆，这里我直接贴别人逆好的代码)\n#include &lt;iostream&gt;#include &lt;cstring&gt;void enc_function(const char* input_str, int input_len, char* result) &#123;    const char* table_key1 = &quot;9d9107e02f0f07984956767ab1ac87e5&quot;;    const unsigned char table_key2[] = &#123;0x37, 0x92, 0x44, 0x68, 0xA5, 0x3D, 0xCC, 0x7F, 0xBB, 0xF, 0xD9, 0x88, 0xEE, 0x9A, 0xE9, 0x5A&#125;;    for (int i = 0; i &lt; input_len; ++i) &#123;        unsigned char X2 = input_str[i];        unsigned char key2 = table_key2[(i &amp; 0xF) &amp; 0xFFFFFFFF];        unsigned char W8 = 0xDA;        unsigned char W30 = 0x25;        unsigned char W2 = X2;        unsigned char W7 = W8 &amp; (~W2);        W2 = W2 &amp; 0x25;        W2 = W7 | W2;        unsigned char W3 = key2;        W7 = W8 &amp; (~W3);        W3 = W3 &amp; W30;        W3 = W7 | W3;        W2 = W2 ^ W3;        W3 = W2;        unsigned char key1 = table_key1[(i ^ 0xFFFFFFF8) &amp; i ];        W2 = key1;        W7 = key2;        W30 = key2;        unsigned char W1 = W2 &amp; (~W3);        W3 = W3 &amp; (~W2);        unsigned char W5 = W30 &amp; (~W2);        W2 = W2 &amp; (~W30);        W1 = W1 | W3;        W2 = W5 | W2;        W1 = W1 + W7;        W3 = W1 &amp; (~W2);        W1 = W2 &amp; (~W1);        W1 = W3 | W1;        result[i] = W1;    &#125;&#125;bool test_eq(const char* buf1, const char* buf2, int buf_len) &#123;    for (int i = 0; i &lt; buf_len; ++i) &#123;        if (buf1[i] != buf2[i]) &#123;            return false;        &#125;    &#125;    return true;&#125;int main() &#123;    const char* input = &quot;0123456789abcdef0123456789abcdef&quot;;    int len = strlen(input);    char* result = (char*)malloc(len);    memset(result, 0, len);    enc_function(input, len, result);    for (int i = 0; i &lt; len; ++i) &#123;        printf(&quot;%02x&quot;, (unsigned char)result[i]);    &#125;    printf(&quot;\\r\\n%x&quot;, test_eq(result, result, len));    free(result);    return 0;&#125;\n"},{"title":"实现对目标函数行为分析的脚本（frida）","url":"/2025/05/19/%E5%AE%9E%E7%8E%B0%E5%AF%B9%E7%9B%AE%E6%A0%87%E5%87%BD%E6%95%B0%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90%E7%9A%84%E8%84%9A%E6%9C%AC%EF%BC%88frida%EF%BC%89/","content":"Frida_BehaviorTrace场景：在native层遇到一个特别复杂的函数时，比方说被vmp保护的函数，若是难以通过静态分析工具去分析它的逻辑，那可以尝试hook一些libc的函数、JNI的函数观察它的行为。ps：这个脚本就做了这么一个事情。\n使用方法1.根据自己的需求，修改hook时机，当前脚本的hook时机是：linker64的call_constructor执行前。\n2.选定完hook时机后，调用hook_main_target_function_for_tracing()。ps：我之所以选择在执行完sub_88060再执行，是因为sub_88060会对某些函数进行解密，请大家自行修改。\n3.修改目标so和目标函数————修改TARGET_MODULE_NAME和TARGET_FUNCTION_OFFSET。\n4.添加要关注的自定义函数的偏移————往CUSTOM_FUNCTION_OFFSETS添加想要关注的自定义函数。\n5.添加要关注的libc的函数，修改参数解析的代码————往LIBC_FUNCTIONS_TO_HOOK添加要关注的libc函数，同时修改参数解析。\n6.添加要关注的JNI函数，修改参数解析部分的代码———往函数hook_libart()中添加要关注的JNI函数，同样，注意修改参数解析。\n7.启动脚本————frida -U -f &lt;包名&gt; -l trace_behavior.js\n使用案例比方说，我要追踪libbaiduprotect.so的sub_409E0，追踪它的行为。\n\nsub_409E0调用了sub_29030、sub_290DC…还调用了一些JNI函数。\n在我根据使用方法修改了脚本后，执行的效果是这样的。\n\n缩进代表函数调用的层级关系，这样子可以清晰看见目标函数执行了哪些自定义函数、Libc、JNI函数。\n结语链接：https://github.com/X14Nuy/Frida_BehaviorTrace\n大模型真厉害，一下子把我的思路变成代码了，哈哈哈。\n"},{"title":"某咖啡app协议字段分析——sign、q","url":"/2025/05/21/%E6%9F%90%E5%92%96%E5%95%A1app%E5%8D%8F%E8%AE%AE%E5%AD%97%E6%AE%B5%E5%88%86%E6%9E%90%E2%80%94%E2%80%94sign%E3%80%81q/","content":"分析流程首先打开JEB观察分析结果，看到存在com.qihoo.util，说明是数字壳。\n从Manifest可以知道，包名是com.lucky.luckyclient。\n接下来先进行脱壳，我之前刷了一个aosp10的脱壳机，正好试试。\n脱壳将app装入脱壳机，在某个指定文件中输入该app的包名，等待脱壳完毕即可。\n\n将脱完后的内容放入jadx，已经可以看到很多java层的代码了。\n\n\n接下来尝试抓包，我抓包工具还挺多的，reqable或Charles都行，试试Charles好了。\n抓包先观察电脑ip。\n\n\n将手机连上同一个局域网，并将代理设置为主机的ip，端口则填Charles监听的端口。——因此，代理地址是192.168.1.188:9999。\n\n\n\n\n要分析的这个请求是为了获得AuthCode（授权码），根据网上的博客，接下来开始分析sign和q字段的加密流程。\n\n\n分析加密流程sign在jadx直接搜索sign，观察是否能直接找到关于字段sign的代码，事实证明，并不可以。\n\n一般在开发中，存储字段会使用到标准sdk的HashMap，因此，接下来可以hook HashMap的put，观察进程是否会调用HashMap.put将sign字段存储起来。\nfunction call_HashMap() &#123;    Java.perform(function () &#123;        var hashMap = Java.use(&quot;java.util.HashMap&quot;);        hashMap.put.implementation = function (a, b) &#123;            if (a != null &amp;&amp; a.equals(&quot;sign&quot;)) &#123; console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new()))                console.log(&quot;hashMap.put: &quot;, a, b);            &#125;            return this.put(a, b);        &#125;    &#125;)&#125;\n\n打印的结果如下。\n\n很自然地，通过调用方法栈，我们下一个分析的点就是 getRequestParams。\n将 com.lucky.lib.http2.AbstractLcRequest.getRequestParams 拿到jadx中搜一搜。\n\n\n结合我们之前打印的结果，StubApp.getString2 在把字符串解密后，返回值字符串。\nhook一下，查看返回值，代码如下。\nfunction get_str(num)&#123;    Java.perform(function()&#123;        const StubApp = Java.use(&quot;com.stub.StubApp&quot;);        console.log(&quot;[num] &quot;, num, &quot; -&gt; &quot;, &quot;[decrypt_str] &quot;, StubApp.getString2(num));    &#125;)&#125;\n\n打印的结果如下。\n\n\n在jadx中加点注释。\n\n我们的目标是 sign，它的值是这样得来的，也就是说，要先获得cid、uid、q的值。\nC9267r.m20563a(cid, uid, q2)\n\n直接写脚本获取cid、uid、q，我们的目标是分析 sign 的加密流程。\nJava.perform(function() &#123;    const R = Java.use(&quot;com.lucky.lib.http2.r&quot;);    R.a.implementation = function(cid, uid, q)&#123;        console.log(&quot;[cid] &quot;, cid);        console.log(&quot;[uid] &quot;, uid);        console.log(&quot;[q] &quot;, q);        var res = this.a(cid, uid, q);        return res;    &#125;&#125;);\n\n执行后报错了，说是找不到类 com.lucky.lib.http2.r，可能是因为Frida使用的类加载器不对？经过尝试，这个类并不是一开始就加载的类，类未加载的时候hook不上。\nfunction get_cid_uid_q()&#123;    Java.perform(function() &#123;        Java.enumerateClassLoaders(&#123;            onMatch: function(loader) &#123;                try &#123;                    // 尝试使用当前 loader 加载类，不要设置全局 loader                    const R = Java.use(&quot;com.lucky.lib.http2.r&quot;, &#123; classLoader: loader &#125;);                    // console.log(&quot;[SUCCESS] Found com.lucky.lib.http2.r with loader: &quot; + loader);                        R.a.overload(&#x27;java.lang.String&#x27;, &#x27;java.lang.String&#x27;, &#x27;java.lang.String&#x27;).implementation = function(cid, uid, q) &#123;                        console.log(&quot;[Hooked R.a] Reached!&quot;);                        console.log(&quot;[cid] &quot;, cid);                        console.log(&quot;[uid] &quot;, uid);                        console.log(&quot;[q] &quot;, q);                            // 暂时不要调用原始方法，先看hook本身是否稳定                        //console.log(&quot;Original method R.a will not be called for now to test stability.&quot;);                        var res = this.a(cid, uid, q);                        console.log(&quot;[res from &quot; + loader + &quot;] &quot;, res);                        return res;                            // 根据原始方法的返回类型返回一个默认值，如果是void则不需要返回                        // 如果不知道返回类型，可以暂时返回 null                        return null;                    &#125;;                    // 如果希望只hook一次，可以在这里添加逻辑停止枚举或标记已hook                &#125; catch (e) &#123;                    console.log(&quot;[FAIL] Could not find com.lucky.lib.http2.r with loader: &quot; + loader);                    // 如果错误不是 ClassNotFoundException，打印出来看看                    if (!e.message.includes(&quot;java.lang.ClassNotFoundException&quot;)) &#123;                        console.error(&quot;Error while trying to use class with loader &quot; + loader + &quot;: &quot; + e);                    &#125;                &#125;            &#125;,            onComplete: function() &#123;                console.log(&quot;Class loader enumeration complete.&quot;);            &#125;        &#125;);    &#125;);&#125;setImmediate(get_cid_uid_q);\n\n等待一段时间，等到类加载了再进行hook即可。\n\ncid、uid基本是不变的（除非换账号、删缓存），唯一会变的是q。\n\n之后分析的时候，需要将q固定，这里先不动它。\n点进 C9267r.m20563a(cid, uid, q2) 查看，大致逻辑可以总结成下面这个式子，key和value代入uid、cid、q即可。\nC9247c.f237976b.m20087a(&quot;&lt;key&gt;=&lt;value&gt;;&lt;key&gt;=&lt;value&gt;;&lt;key&gt;=&lt;value&gt;;&quot;);\n\n\n点进 C9247c.f237976b.m20087a 查看。\n\n观察 this.f237669e.mo15913a ，this代表对象，f237669e 是this对象的接口对象，通过这个接口对象调用接口中声明的方法。\n\n\n\n\n如果想hook一个接口或者抽象方法，需要找到实现的地方进行hook，这跟frida是如何hook java层方法的原理有关。——简单来说，一个Java方法对应一个ArtMethod，我们要找到实现Java方法的ArtMethod，抽象方法和接口都没有实际的CodeItem。\n因此，我们要找到实现了这个接口的类，但是，这又有一个问题，CryptoHelper似乎并没有继承其它的类，没有间接实现接口的可能；那还有两个可能：一是赋值的时候用匿名类，在赋值的时候，同时实现了接口；二是定义一个实现好了接口的类，然后作为参数传能够给赋值 f237669e 的方法。\n\n交叉引用这个接口对象 f237669e，可以注意到，只有构造函数和方法m20086a可能为接口对象赋值了。\n\n交叉引用方法m20086a，会发现：没有任何被Java层代码调用的地方，那这个函数可能是在native层被调用了（通过FindClass、CallStaticMethod等函数调用），所以在jadx中查不到。\n接着交叉引用构造函数，这回有收获了。\n\n分别去查看C8118a、C9123b等类，查看它们关于接口的实现方式，结果如下。\nC8118a的实现。\n\n\n可以注意到，有点像base64编码（但标准的base64没有_符号），去试试解码。——试了后发现，都是不可显示的字符，用Hex也没看出什么特征。\n\n\n之后发现，这里面的_需要换成&#x2F;，不过之后再说吧。\nC9123b的实现。\n\n\nC9234b的实现有点绕。\n继续追踪f237975a。\n\n\n根据交叉引用，它只会通过方法m20437c得到值，因此继续追踪方法m20437c。\n\n\n查看成员变量f238026j，进行交叉引用。\n\n\n发现它只会在方法m20538g进行调用，继续交叉引用。\n\n\n因此，C9234b的实现是这样的。\n\n\nC11110a的实现。\n\nC11112c的实现。\n\n回到方法 m20087a。\nmd5_crypt( str.getBytes(), num)，这里的num是0&#x2F;1&#x2F;2中的一个，大概率是1，因为根据上述解密，似乎其它的类似base64编码的字节码，在解码后是不可视的字节码？无法和coffee、tea进行比较。\n\n这里的md5_crypt是native函数，不妨hook一下，看看i2的值是什么。\n\n\n代码如下。\nfunction hook_md5_crypt()&#123;    Java.perform(function() &#123;        const CryptoHelper = Java.use(&quot;com.luckincoffee.safeboxlib.CryptoHelper&quot;);        CryptoHelper.md5_crypt.implementation = function(arr, i2)&#123;            console.log(`--- md5_crypt called ---`);            console.log(`[i2] $&#123;i2&#125;`);            console.log(`[bArr] byte array of length $&#123;arr.length&#125;`);            // 遍历字节数组，并尝试转换为ASCII字符            let hexString = &#x27;&#x27;;            let asciiString = &#x27;&#x27;;            const bytesPerLine = 16; // 每行显示的字节数，方便查看            for (let i = 0; i &lt; arr.length; i++) &#123;                const byte = arr[i];                // 将有符号字节转换为无符号整数 (0-255)                const unsignedByte = byte &amp; 0xff;                // 将字节值转换为十六进制字符串，方便对比                hexString += unsignedByte.toString(16).padStart(2, &#x27;0&#x27;) + &#x27; &#x27;;                // 判断是否为可打印的ASCII字符 (通常范围是 32 到 126)                if (unsignedByte &gt;= 32 &amp;&amp; unsignedByte &lt;= 126) &#123;                    asciiString += String.fromCharCode(unsignedByte);                &#125; else &#123;                    // 如果不是可打印字符，用点或其他符号代替                    asciiString += &#x27;.&#x27;;                &#125;                // 每隔 bytesPerLine 打印一行，或者在数组结束时打印剩余部分                if ((i + 1) % bytesPerLine === 0 || i === arr.length - 1) &#123;                    // 为了对齐，给较短的行添加空格填充                     while (hexString.length &lt; bytesPerLine * 3) &#123; // 2 chars + 1 space per byte                        hexString += &#x27; &#x27;;                    &#125;                    console.log(`  $&#123;hexString&#125; | $&#123;asciiString&#125;`);                    hexString = &#x27;&#x27;;                    asciiString = &#x27;&#x27;;                &#125;            &#125;            console.log(`--- Calling original md5_crypt ---`);            // 调用原始的 native 方法并返回结果            const result = this.md5_crypt(arr, i2);             console.log(`--- Original md5_crypt returned ---`);            return result;        &#125;;    &#125;);&#125;setImmediate(hook_md5_crypt);\n\n如果多截几张图，就会发现，i2基本恒为1，符合我们的猜测，bArr数组其实就是cid、q、uid放在一块。\n\n\n接下来进入native层分析md5_crypt对应的函数，将libcryptoDD.so放入IDA中。\n\n进来后，先来看看导出表，我们的目标大概率是android_native_md5。\n同时，发现存在很多.datadiv_decodexxxxxx的函数，应该是解密字符串用的。\n\n基本都在.init_array段上，先不着急分析了，先写个脚本，将解密后的so文件进行dump，这样便于之后的分析。\n\n最后一个datadiv函数的地址是0x1B61C。可以在hook这个函数的onLeave回调进行dump。\n我靠，我写好了脚本，尝试了好多遍为什么一dump就“非法指令”退出，突然想起来，”libcryptoDD.so”是32位的so，不仅要修改linker64 -&gt; linker，还需要修改call_constructor的偏移量。\n但似乎改了后，还是会崩溃，那就应该是有反调了，但我没注意反调在哪，跑了挺久，也没退出，可能是对某些关键函数的hook做了检测吧，之后再去找找看。\n\n既然这样，不在第一时间dump了，等so文件稳定了再dump。\nvar module_name = &quot;libcryptoDD.so&quot;; // 可选：目标库名称，用于过滤function hook_dlopen() &#123;    var dlopenPtr = Module.findExportByName(null, &quot;dlopen&quot;);    if (!dlopenPtr) &#123;        console.error(&quot;[!] dlopen not found.&quot;);        return;    &#125;    console.log(&quot;[+] Hooking dlopen at &quot; + dlopenPtr);    Interceptor.attach(dlopenPtr, &#123;        onEnter: function(args) &#123;            var libraryPath = Memory.readUtf8String(args[0]);            console.log(&quot;[dlopen] Loading library: &quot; + libraryPath);            if (libraryPath.includes(module_name)) &#123;                console.log(&quot;[!] Target library &quot; + module_name + &quot; loaded, exiting...&quot;);                Process.exit(0);            &#125;        &#125;    &#125;);&#125;function hook_android_dlopen_ext() &#123;    var androidDlopenExtPtr = Module.findExportByName(null, &quot;android_dlopen_ext&quot;);    if (!androidDlopenExtPtr) &#123;        console.error(&quot;[!] android_dlopen_ext not found.&quot;);        return;    &#125;    console.log(&quot;[+] Hooking android_dlopen_ext at &quot; + androidDlopenExtPtr);    Interceptor.attach(androidDlopenExtPtr, &#123;        onEnter: function(args) &#123;            var libraryPath = Memory.readUtf8String(args[0]);            var flags = args[1].toInt32();            console.log(&quot;[android_dlopen_ext] Loading library: &quot; + libraryPath + &quot;, flags: 0x&quot; + flags.toString(16));            if (libraryPath.includes(module_name)) &#123;                console.log(&quot;[!] Target library &quot; + module_name + &quot; loaded, exiting...&quot;);                Process.exit(0);            &#125;        &#125;    &#125;);&#125;function main() &#123;    Java.perform(function() &#123;        hook_dlopen();        hook_android_dlopen_ext();        console.log(&quot;[*] Hooking dlopen and android_dlopen_ext initialized.&quot;);    &#125;);&#125;function dump_so(so_name)&#123;    let secmodule = Process.findModuleByName(so_name);    console.log(&quot;[name] &quot;, so_name);    console.log(&quot;[base] &quot;, secmodule.base.toString(16));    console.log(&quot;[size] &quot;, secmodule.size.toString(16));    dump(secmodule.base, secmodule.size);&#125;function dump(begin_addr, dump_size)&#123;    // console.log(&quot;[name] &quot;, module_name);    // console.log(&quot;[base] &quot;, begin_addr);    // console.log(&quot;[size] &quot;, &quot;0x&quot; + dump_size.toString(16));    var file_path = &quot;/data/data/com.lucky.luckyclient/zzc_0x&quot; + begin_addr.toString(16) + &quot;_0x&quot; + dump_size.toString(16) + &quot;.so&quot;;    var file_handle = new File(file_path, &quot;wb&quot;);    if (file_handle &amp;&amp; file_handle != null) &#123;        Memory.protect(ptr(begin_addr), dump_size, &#x27;rwx&#x27;);        var libso_buffer = ptr(begin_addr).readByteArray(dump_size);        file_handle.write(libso_buffer);        file_handle.flush();        file_handle.close();        console.log(&quot;[dump] &quot;, file_path);    &#125;&#125;setImmediate(main);\n\n执行结果如下图所示。\n\n然后将它pull出来，用修复工具修复（别用soFixer，可能导入表是乱的），展示一下修复后两个so文件的区别，明显可以看到，有一些字符串已经解密了。\n\n继续分析这个so文件，写一个脚本hook上RegisterNatives，判断一下md5_crypt对应的native函数地址是哪个。\n还没打印到那一步，就已经退出了。\n我尝试hook了libc标准库的常见函数，如：open、openat、strstr等函数，没发现对frida检测。\n\n还有一个问题，无法实现对call_constructor的hook，根据调用栈，会发现报错源来自frida的agent，是frida版本的问题吗？\n\n之后再来分析，先去分析数字免费壳，再来分析这个付费壳。\n\n\n之后我发现，换了一个方式hook RegisterNatives就能打印md5_crypt的注册地址了？\n// 获取 RegisterNatives 函数的内存地址，并赋值给addrRegisterNatives。function main()&#123;    var addrRegisterNatives = null;    var symbols = Module.enumerateSymbolsSync(&quot;libart.so&quot;);    for (var i = 0; i &lt; symbols.length; i++) &#123;        var symbol = symbols[i];        if (symbol.name.indexOf(&quot;art&quot;) &gt;= 0 &amp;&amp;            symbol.name.indexOf(&quot;JNI&quot;) &gt;= 0 &amp;&amp;            symbol.name.indexOf(&quot;RegisterNatives&quot;) &gt;= 0 &amp;&amp;            symbol.name.indexOf(&quot;CheckJNI&quot;) &lt; 0) &#123;            addrRegisterNatives = symbol.address;            console.log(&quot;RegisterNatives is at &quot;, symbol.address, symbol.name);            break        &#125;    &#125;    if (addrRegisterNatives) &#123;        Interceptor.attach(addrRegisterNatives, &#123;            onEnter: function (args) &#123;                var env = args[0];        // jni对象                var java_class = args[1]; // 类                var class_name = Java.vm.tryGetEnv().getClassName(java_class);                var taget_class = &quot;com.luckincoffee.safeboxlib.CryptoHelper&quot;;   //111 某个类中动态注册的so                if (class_name === taget_class) &#123;                    console.log(&quot;\\n[RegisterNatives] method_count:&quot;, args[3]);                    var methods_ptr = ptr(args[2]);                    var method_count = parseInt(args[3]);                    for (var i = 0; i &lt; method_count; i++) &#123;                        // Java中函数名字的                        var name_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3));                        // 参数和返回值类型                        var sig_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize));                        // C中的函数内存地址                        var fnPtr_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize * 2));                        var name = Memory.readCString(name_ptr);                        var sig = Memory.readCString(sig_ptr);                        var find_module = Process.findModuleByAddress(fnPtr_ptr);                        // 地址、偏移量、基地址                        var offset = ptr(fnPtr_ptr).sub(find_module.base);                        console.log(&#x27;class_name:&#x27;,class_name,&quot;name:&quot;, name, &quot;sig:&quot;, sig,&#x27;module_name:&#x27;,find_module.name ,&quot;offset:&quot;, offset);                    &#125;                &#125;            &#125;        &#125;);    &#125;&#125;setImmediate(main)// 动态注册函数地址// frida -U -f com.lucky.luckyclient -l hook_so_register.js  \n\n原先的脚本如下，区别在于：上面这个脚本在RegiterNatives的地方加了个taget_class的限制，那问题应该是注册了太多函数，导致打印崩溃了（？），先不管，之后分析壳的时候再看。\nfunction find_RegisterNatives(params) &#123;    let symbols = Module.enumerateSymbolsSync(&quot;libart.so&quot;);    let addrRegisterNatives = null;    for (let i = 0; i &lt; symbols.length; i++) &#123;        let symbol = symbols[i];                //_ZN3art3JNI15RegisterNativesEP7_JNIEnvP7_jclassPK15JNINativeMethodi        if (symbol.name.indexOf(&quot;art&quot;) &gt;= 0 &amp;&amp;                symbol.name.indexOf(&quot;JNI&quot;) &gt;= 0 &amp;&amp;                 symbol.name.indexOf(&quot;RegisterNatives&quot;) &gt;= 0 &amp;&amp;                 symbol.name.indexOf(&quot;CheckJNI&quot;) &lt; 0) &#123;            addrRegisterNatives = symbol.address;            console.log(&quot;RegisterNatives is at &quot;, symbol.address, symbol.name);            hook_RegisterNatives(addrRegisterNatives)        &#125;    &#125;&#125;function hook_RegisterNatives(addrRegisterNatives) &#123;    if (addrRegisterNatives != null) &#123;        Interceptor.attach(addrRegisterNatives, &#123;            onEnter: function (args) &#123;                console.log(&quot;[RegisterNatives] method_count:&quot;, args[3]);                let java_class = args[1];                let class_name = Java.vm.tryGetEnv().getClassName(java_class);                //console.log(class_name);                let methods_ptr = ptr(args[2]);                let method_count = parseInt(args[3]);                for (let i = 0; i &lt; method_count; i++) &#123;                    let name_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3));                    let sig_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize));                    let fnPtr_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize * 2));                    let name = Memory.readCString(name_ptr);                    let sig = Memory.readCString(sig_ptr);                    let symbol = DebugSymbol.fromAddress(fnPtr_ptr)                    console.log(&quot;[RegisterNatives] java_class:&quot;, class_name, &quot;name:&quot;, name, &quot;sig:&quot;, sig, &quot;fnPtr:&quot;, fnPtr_ptr,  &quot; fnOffset:&quot;, symbol, &quot; callee:&quot;, DebugSymbol.fromAddress(this.returnAddress));                &#125;            &#125;        &#125;);    &#125;&#125;setImmediate(find_RegisterNatives);\n\n打印的结果如下，md5_crypt对应着的地址是sub_1a981。\n\n我开了两个IDA对照着看，因为dump下来的文件虽然恢复了某些代码，但IDA的反汇编的伪代码也变了，没原来的so好读。\n根据对sub_1a981的分析，发现输入数据和输入数据的长度在sub_13E3C进行调用，sub_13E3C的函数名是md5。\n\n\nv24很有可能就是md5的返回值，可以写个脚本试试。\nfunction hook_md5()&#123;    var module_base = Module.findBaseAddress(&quot;libcryptoDD.so&quot;);    Interceptor.attach(module_base.add(0x13E3c), &#123;        onEnter: function(args)&#123;            this.data = args[0];            this.data_len = args[1];            this.digest = args[2];            console.log(&quot;[data]:\\n&quot;, hexdump(args[0], &#123;length: args[1]&#125;));        &#125;, onLeave: function(retval)&#123;            console.log(&quot;[digest]:\\n&quot;, hexdump(args[2], &#123;length: 64&#125;));        &#125;    &#125;);&#125;\n\n肯定是有反调，不然这种程度的hook，不至于引起进程崩溃。\n\n接下来用unidbg模拟执行。\n代码如下，从这套代码中，可以学会如何下断点（甚至是动调），如何模拟一个native层函数的执行。下断点的方式有2种，一是Unidbg提供的接口断点，二是Unicorn提供的断点，代码里都有涉及。\npackage com.luckincoffee.safeboxlib;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.Emulator;import com.github.unidbg.Module;import com.github.unidbg.arm.backend.Unicorn2Factory;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.*;import com.github.unidbg.linux.android.dvm.array.ByteArray;import com.github.unidbg.linux.android.dvm.jni.ProxyClassFactory;import com.github.unidbg.memory.Memory;import com.github.unidbg.utils.Inspector;import com.github.unidbg.arm.context.RegisterContext;import com.github.unidbg.debugger.BreakPointCallback;import com.github.unidbg.debugger.Debugger;import com.sun.jna.Pointer;import unicorn.ArmConst;import java.io.*;import java.nio.charset.StandardCharsets;import java.util.ArrayList;import java.util.List;public class CryptoHelper extends AbstractJni &#123;    private final AndroidEmulator emulator;    private final DvmClass cCryptoHelper;    private final VM vm;    private final Module module;    public CryptoHelper() &#123;        emulator = AndroidEmulatorBuilder.for32Bit()                .addBackendFactory(new Unicorn2Factory(true))                .setProcessName(&quot;com.lucky.luckyclient&quot;)                .build();        Memory memory = emulator.getMemory();        memory.setLibraryResolver(new AndroidResolver(23));        vm = emulator.createDalvikVM(new File(&quot;../file/rx.apk&quot;));        vm.setJni(this);        vm.setDvmClassFactory(new ProxyClassFactory());        vm.setVerbose(true);        DalvikModule dm = vm.loadLibrary(new File(&quot;unidbg-android/src/test/resources/example_binaries/armeabi-v7a/libcryptoDD.so&quot;), true);        module = dm.getModule();        cCryptoHelper = vm.resolveClass(&quot;com/luckincoffee/safeboxlib/CryptoHelper&quot;);        dm.callJNI_OnLoad(emulator);    &#125;    private void md5_hook() &#123;        Debugger debugger = emulator.attach();        // Hook md5 function at 0x13E3C: md5(indata_jarray, initial_len, v25)        debugger.addBreakPoint(module.base + 0x14D6E, new BreakPointCallback() &#123;            @Override            public boolean onHit(Emulator&lt;?&gt; emulator, long address) &#123;//                System.out.println(&quot;Breakpoint hit: md5 at 0x&quot; + Long.toHexString(address));//                RegisterContext context = emulator.getContext();////                // Parameters: ARM32 registers R0-R2//                long jarray = context.getLongArg(0); // R0: indata_jarray (jbyteArray)//                long initial_len = context.getLongArg(1); // R1: initial_len (jint)//                long v25 = context.getLongArg(2); // R2: v25 (pointer, possibly jbyteArray)////                System.out.println(&quot;md5 Parameters: jarray=0x&quot; + Long.toHexString(jarray) +//                        &quot;, initial_len=&quot; + initial_len +//                        &quot;, v25=0x&quot; + Long.toHexString(v25));////                // Parse input jbyteArray//                if (jarray != 0) &#123;//                    ByteArray byteArray = (ByteArray) vm.getObject((int) jarray);//                    if (byteArray != null) &#123;//                        Inspector.inspect(byteArray.getValue(), &quot;Input jbyteArray&quot;);//                    &#125;//                &#125;////                // Parse v25 (assuming it&#x27;s a pointer to output buffer)//                if (v25 != 0) &#123;//                    Pointer cipherText = context.getPointerArg(2);//                    Inspector.inspect(cipherText.getByteArray(0, 32), &quot;cipherText&quot;);//                &#125;////                // Continue execution, return false to stop at breakpoint for manual debugging                return false;            &#125;        &#125;);//        debugger.addBreakPoint(module.base + 0x1AB92, new BreakPointCallback() &#123;//            @Override//            public boolean onHit(Emulator&lt;?&gt; emulator, long address) &#123;//                System.out.println(&quot;Breakpoint hit: END at 0x&quot; + Long.toHexString(address));//                return true;//            &#125;//        &#125;);////        // Hook doMD5sign function at 0x14D54: doMD5sign(v41, initial_len + 20, &amp;v53)//        debugger.addBreakPoint(module.base + 0x14D54, new BreakPointCallback() &#123;//            @Override//            public boolean onHit(Emulator&lt;?&gt; emulator, long address) &#123;//                System.out.println(&quot;Breakpoint hit: doMD5sign at 0x&quot; + Long.toHexString(address));//                RegisterContext context = emulator.getContext();////                // Parameters: ARM32 registers R0-R2//                long v41 = context.getLongArg(0); // R0: v41 (possibly jbyteArray)//                long len = context.getLongArg(1); // R1: initial_len + 20 (jint)//                long v53 = context.getLongArg(2); // R2: &amp;v53 (pointer to output buffer)////                System.out.println(&quot;doMD5sign Parameters: v41=0x&quot; + Long.toHexString(v41) +//                        &quot;, len=&quot; + len +//                        &quot;, v53=0x&quot; + Long.toHexString(v53));////                // Parse v41 (assuming it&#x27;s a jbyteArray)//                if (v41 != 0) &#123;//                    ByteArray byteArray = (ByteArray) vm.getObject((int) v41);//                    if (byteArray != null) &#123;//                        Inspector.inspect(byteArray.getValue(), &quot;Input v41 (jbyteArray)&quot;);//                    &#125;//                &#125;////                // Parse v53 (output buffer)//                if (v53 != 0) &#123;//                    Pointer cipherText = context.getPointerArg(2);//                    Inspector.inspect(cipherText.getByteArray(0, 32), &quot;cipherText&quot;);//                &#125;////                // Continue execution//                return true;//            &#125;//        &#125;);//        // Add return hook using CodeHook to capture return value//        emulator.getBackend().hook_add_new(new com.github.unidbg.hook.HookListener() &#123;//            @Override//            public void hook(unicorn.Unicorn u, long address, int size, Object user) &#123;//                // Not used for entry hook in this case//            &#125;////            @Override//            public void onReturn(unicorn.Unicorn u, long address, int size, Object user) &#123;//                if (address == module.base + 0x13E3C) &#123;//                    long retValue = u.reg_read(ArmConst.UC_ARM_REG_R0).longValue();//                    System.out.println(&quot;md5 returned: 0x&quot; + Long.toHexString(retValue));//                    if (retValue != 0) &#123;//                        ByteArray retByteArray = (ByteArray) vm.getObject((int) retValue);//                        if (retByteArray != null) &#123;//                            Inspector.inspect(retByteArray.getValue(), &quot;md5 return jbyteArray&quot;);//                        &#125;//                    &#125;//                &#125; else if (address == module.base + 0x14D54) &#123;//                    long retValue = u.reg_read(ArmConst.UC_ARM_REG_R0).longValue();//                    System.out.println(&quot;doMD5sign returned: 0x&quot; + Long.toHexString(retValue));//                    if (retValue != 0) &#123;//                        ByteArray retByteArray = (ByteArray) vm.getObject((int) retValue);//                        if (retByteArray != null) &#123;//                            Inspector.inspect(retByteArray.getValue(), &quot;doMD5sign return jbyteArray&quot;);//                        &#125;//                    &#125;//                &#125;//            &#125;//        &#125;, module.base + 0x13E3C, module.base + 0x14D54, null);    &#125;    private void call_md5() &#123;        List&lt;Object&gt; args = new ArrayList&lt;&gt;(10);        args.add(vm.getJNIEnv());        args.add(0);        String my_bytes = &quot;cid=1;uid=1;q=1;&quot;;        args.add(vm.addLocalObject(new ByteArray(vm, my_bytes.getBytes())));        args.add(1);        Number retNum = module.callFunction(emulator, 0x1a981, args.toArray());        ByteArray retByteArr = (ByteArray) vm.getObject(retNum.intValue());        String md5result = new String(retByteArr.getValue(), StandardCharsets.UTF_8);        System.out.println(&quot;md5 result = &quot; + md5result);    &#125;    private void call_hooked_function() &#123;        List&lt;Object&gt; args = new ArrayList&lt;&gt;(10);        args.add(vm.addLocalObject(new ByteArray(vm, &quot;test_hook&quot;.getBytes())));        args.add(16); // initial_len        args.add(vm.addLocalObject(new ByteArray(vm, new byte[32]))); // v25: empty buffer        Number retNum = module.callFunction(emulator, 0x13E3C, args.toArray());        ByteArray retByteArr = (ByteArray) vm.getObject(retNum.intValue());        if (retByteArr != null) &#123;            String result = new String(retByteArr.getValue(), StandardCharsets.UTF_8);            System.out.println(&quot;md5 function result = &quot; + result);        &#125;    &#125;//    private void call_doMD5sign() &#123;//        List&lt;Object&gt; args = new ArrayList&lt;&gt;(10);//        args.add(vm.addLocalObject(new ByteArray(vm, &quot;test_doMD5sign&quot;.getBytes())));//        args.add(34); // initial_len + 20//        args.add(vm.addLocalObject(new ByteArray(vm, new byte[32]))); // v53: empty buffer//        Number retNum = module.callFunction(emulator, 0x14D54, args.toArray());//        ByteArray retByteArr = (ByteArray) vm.getObject(retNum.intValue());//        if (retByteArr != null) &#123;//            String result = new String(retByteArr.getValue(), StandardCharsets.UTF_8);//            System.out.println(&quot;doMD5sign function result = &quot; + result);//        &#125;//    &#125;    public void destroy() throws IOException &#123;        emulator.close();    &#125;    public static void main(String[] args) &#123;        CryptoHelper cryptoHelper = new CryptoHelper();        cryptoHelper.md5_hook();        cryptoHelper.call_md5();//        cryptoHelper.call_hooked_function();//        cryptoHelper.call_doMD5sign();        try &#123;            cryptoHelper.destroy();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n注意，上述关于断点处的代码，return true（或者是false）代表着是否要动调，false代表着要动调，Unidbg会模拟程序执行到那，然后停住（有点类似于gdb），等待用户输入指令。\n根据之前的分析，我们知道，md5_crypt对应的native层函数是 android_native_md5。\n根据对这个函数的分析，会发现传入的“cid&#x3D;1;uid&#x3D;1;q&#x3D;1”（unidbg中固定了输入值）最终会传入函数 doMD5sign。\n\n根据动调，比较java层得到的返回值和doMD5sign在函数退出时，digest指向的值，两者是一样的，因此这里的digest就是我们要的 android_native_md5 最后的返回值。不过注意，我们固定输入的initial_msg后，标准的md5返回值和digest里面的值是不一样的，这说明魔改了。\n在doMD5sign中，可以发现还有个函数叫md5，对这个函数进行hook（frida用不了，用unidbg的hook），在函数执行前，打印寄存器r0、r1、r2的值（r2指向一块buf），然后在md5执行完后，查看buf的内容。\n会发现，这个buf的内容是标准的md5结果。\n操作如下——\n固定输入。\n\n下断点。\n\n\nr0 &#x3D; 0x12248000，r1 &#x3D; 36，r2 &#x3D; 0xe4fff5d8。\n\n查看r0指向的字符串，会发现除了固定的输入，还加了IV，因此r1是36，而非我们固定输入的长度。\n\n\n当前的mr2。\n\n给0x12014d72下断点，然后按c执行，继续跑。\n\n此时程序跑完了md5，再来看看buf里的内容。\n\n\n这里的9eed….正是标准的md5结果。\n\n\n接下来就是看doMD5sign是如何魔改的，魔改的主要逻辑在 bytesToInt。按顺序，每次操作md5结果的4个字节，将每个字节都放大了好多，然后最终通过或操作，组成一个很大的数字，由于是signed int类型，有可能是负数，一旦是负数，就取绝对值。\n\n然后将取过绝对值的这个很大的数字化作字符串，存入缓冲区。——这里的byte_E0021指向字符串%d，可以在解密后的so文件看出来。\n\n\n\n既然知道算法了，接下来就写个python脚本复现一下，这里踩了个坑，python的整型是很大的，因此一般不会出现负数，而c&#x2F;c++中，32位的数若是很大，可能会溢出成负数，所以这里需要根据0x8000 0000判断当前得到的整型若是化成32位，是否是负数，若是，则转成正数，即减去0x1 0000 0000。\nimport hashlibdef bytesToInt(src, offset):    if len(src) &lt; offset + 4:        raise ValueError(f&quot;Source array too short for offset &#123;offset&#125;&quot;)    if v9_unsigned &gt;= 0x80000000: # 检查是否是负数（在C语言中）        v9_signed = v9_unsigned - 0x100000000 # 转换为正确的补码负值    else:        v9_signed = v9_unsigned    return v9_signeddef doMD5sign(initial_msg):    # Calculate MD5 hash (16 bytes)    md5_hash = hashlib.md5(initial_msg).digest()    # Process 4 blocks (offsets 0, 4, 8, 12)    offsets = [0, 4, 8, 12]    strings = []    for offset in offsets:        raw_int_value = bytesToInt(md5_hash, offset) # 获取有符号的整数值                # 按照IDA伪代码的逻辑，在转为字符串前取绝对值        # 对应IDA伪代码中的 &#x27;if ( vX &lt; 0 ) vY = -vX;&#x27;        abs_value = abs(raw_int_value)                 # 将绝对值转换为字符串        strings.append(str(abs_value))        print(f&quot;Offset &#123;offset&#125;: raw_int_value = &#123;raw_int_value&#125;, abs_value = &#123;abs_value&#125;&quot;)        # Concatenate strings    result = &quot;&quot;.join(strings)        # Simulate malloc and qmemcpy    digest = result    length = len(digest)        print(f&quot;Final digest: &#123;digest&#125;&quot;)    print(f&quot;Length: &#123;length&#125;&quot;)        return length, digestif __name__ == &quot;__main__&quot;:    initial_msg = b&quot;cid=1;uid=1;q=1;dJLdCJiVnDvM9JUpsom9&quot;        try:        length, digest = doMD5sign(initial_msg)    except ValueError as e:        print(f&quot;Error: &#123;e&#125;&quot;)\n\n脚本跑完的结果如下。\n\n\n而Unidbg模拟的结果如下。\n\n\n至此，sign分析结束了。\nps：unidbg之前没怎么用过，这个动调、断点还挺好用的，之后整理一套使用手册。\nq用之前写的hook HashMap的脚本，试试能不能找到q的加密点。\nfunction call_HashMap() &#123;    Java.perform(function () &#123;        var hashMap = Java.use(&quot;java.util.HashMap&quot;);        hashMap.put.implementation = function (a, b) &#123;            if (a != null &amp;&amp; a.equals(&quot;q&quot;)) &#123; console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new()))                console.log(&quot;hashMap.put: &quot;, a, b);            &#125;            return this.put(a, b);        &#125;    &#125;)&#125;\n\n看来跟sign一样，都是这么存储字段的。\n注意到，字段q的最后一个字节是&#x3D;，那很有可能是base64（猜测，base64没有_和-）。\n\n先从com.lucky.lib.http2.r.a看起，又是这个函数，需要追踪str3的值从何而来。\n\n\n写个脚本hook getRequestParams，并且hook AbstractC3710a.toJSONString，打印一下这个q2字符串的内容。\n\n\n这个类是之后加载的，需要加载之后再hook。\n\n打印的内容有些多。\n\n然后将内容传入方法 C9247c.m20436b，再传入 f237976b.m20089c。\n\n\n在 f237976b.m20089c 中，走localAESWork4Api(str.getBytes(), 0)。\n\nlocalAESWork4Api是CryptoHelper中的JNI函数，也注册在libcryptoDD.so。\n根据符号名，可以看出来是aes白盒加密。\n\n在 android_native_wbaes_jni 中，可以找到函数 wbaes_decrypt_ecb，说明是aes的ecb模式加密，ecb模式没有IV。\n\n\n虚假控制流有点多，要不直接trace算了？再等等好了。\n本次逆向的主要目标，就是掌握AES加密及白盒AES的破解方法之一——DFA。\n先根据这篇博客回顾一下，AES加密的流程。\nhttps://xiaoeeyu.github.io/2024/02/29/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-AES/\n以AES128为例，原理简单来说，如下。\n​\t输入：128位明文 + 128位密钥。\n​\t密钥扩展：生成11个128位（4x4字节）轮密钥。\n​\t初始轮：明文与第一个轮密钥异或。\n​\t普通轮：执行9轮（SubBytes（查表替换） → ShiftRows（字节循环左移） → MixColumns（列混合，矩阵乘法） → AddRoundKey（密钥异或））。\n​\t最终轮：执行1轮（SubBytes（查表替换） → ShiftRows（字节循环左移） → AddRoundKey（密钥异或））。\n​\t输出：128位密文。\n其中，查表替换的S盒是固定的，而且只有一个，通过脚本，搜索S盒的特征就可以找到了。\n交叉引用SBox。\n\n有2个函数调用了SBox。\nsub_63A0，很明显的SubBytes特征。\n*result &#x3D; *((_BYTE *)RijnDael_AES_LONG_SBox + (*result &amp; 0xF0) + (*result &amp; 0xF))\n等同于：result[i] &#x3D; SBox[result[i]]。\n\n还有一处是sub_5C58，这个特征不太明显阿。有点像SubBytes，又有点像移位操作。\n这毕竟不是标准AES，属于白盒AE，拿到了代码也不知道密钥在哪。\nint __fastcall sub_5C58(unsigned int a1)&#123;  return (*((unsigned __int8 *)&amp;RijnDael_AES_LONG_SBox[4 * ((a1 &gt;&gt; 4) &amp; 0xF000000F)] + (a1 &amp; 0xF)) | (*((unsigned __int8 *)RijnDael_AES_LONG_SBox + ((a1 &gt;&gt; 8) &amp; 0xF0) + ((a1 &gt;&gt; 8) &amp; 0xFF00000F)) &lt;&lt; 8) | (*((unsigned __int8 *)&amp;RijnDael_AES_LONG_SBox[4 * ((a1 &gt;&gt; 20) &amp; 0xFFFFF00F)] + (HIWORD(a1) &amp; 0xFFFF000F)) &lt;&lt; 16)) ^ (*((unsigned __int8 *)RijnDael_AES_LONG_SBox + (HIBYTE(a1) &amp; 0xF0) + (HIBYTE(a1) &amp; 0xF)) &lt;&lt; 24);&#125;\n\n接下来，学习其它的博客，试试如何获得白盒AES的密钥，下面这个文章把DFA原理讲得很明白。\nhttps://blog.quarkslab.com/differential-fault-analysis-on-white-box-aes-implementations.html\n总结一下我的理解：\n找到第8轮列混淆之后、第9轮列混淆之前（第十轮没有列混淆），然后修改1个字节（比特翻转，或者多修改点），这个修改的影响会被第9轮列混淆进行扩大，扩大到最终影响了输出的4个字节。\n根据数学关系，可以列4个等式。\nO和O’都是已知的，Z代表S-盒输入的差（A+X，即A异或X），根据对Y的假设，可以找到可能满足4个等式的Y0、Y1、Y2、Y3的候选者。\n\n\n再通过Y的候选者和已知的O，去获得可能的K（轮密钥的某个字节）的候选者。\n\n\n搞清楚DFA的原理以后，第一步，找到第8轮列混淆之后、第9轮列混淆之前进行故障注入。\n回到 android_native_wbaes，看看有没有什么特征函数。——找到了一个行位移的函数。为了确保它是我们要找的行位移函数，试试它有没有执行10次，并且打印v42的内容，判断是否每次都有行位移的操作。\n通过Unidbg完成上述的操作。\n\n\n下述是代码片段，num是我添加的成员变量。\nprivate void call_aes() &#123;        List&lt;Object&gt; args = new ArrayList&lt;&gt;(10);        // JNIEnv*        args.add(vm.getJNIEnv());        // jclass        args.add(0);        // 固定输入        String my_bytes = &quot;&#123;\\&quot;type\\&quot;:1&#125;&quot;;        args.add(vm.addLocalObject(new ByteArray(vm, my_bytes.getBytes())));        // 模式        args.add(0);        // 函数android_native_wbaes的偏移量0x1b1cd        Number retNum = module.callFunction(emulator, 0x1b1cd, args.toArray());        ByteArray retByteArr = (ByteArray) vm.getObject(retNum.intValue());        // 打印        byte[] resultBytes = retByteArr.getValue();        StringBuilder hexString = new StringBuilder();        for (byte b : resultBytes) &#123;            hexString.append(String.format(&quot;%02X&quot;, b &amp; 0xFF));        &#125;        System.out.println(&quot;q result (hex) = &quot; + hexString.toString());    &#125;    private void q_hook() &#123;        Debugger debugger = emulator.attach();        // Hook wbShiftRows function at 0x14F98        debugger.addBreakPoint(module.base + 0x14F98, new BreakPointCallback() &#123;            @Override            public boolean onHit(Emulator&lt;?&gt; emulator, long address) &#123;                num += 1;                System.out.println(&quot;wbShiftRows has been called: &quot; + num);                return true;            &#125;        &#125;);    &#125;\n\n可以看到，打印了10次，符合我们的预期。\n\n\n尝试打印每一次执行行位移之前的状态矩阵。\nprivate void q_hook() &#123;        Debugger debugger = emulator.attach();        // Hook wbShiftRows function at 0x14F98        debugger.addBreakPoint(module.base + 0x14F98, new BreakPointCallback() &#123;            @Override            public boolean onHit(Emulator&lt;?&gt; emulator, long address) &#123;                num += 1;                System.out.println(&quot;wbShiftRows has been called: &quot; + num);                // 获取寄存器上下文                RegisterContext context = emulator.getContext();                // R0 通常是第一个参数（状态矩阵的指针）                Pointer stateMatrix = context.getPointerArg(0);                if (stateMatrix != null) &#123;                    // 读取 16 字节状态矩阵                    byte[] stateBytes = stateMatrix.getByteArray(0, 16);                    // 转为十六进制                    StringBuilder hexString = new StringBuilder();                    for (byte b : stateBytes) &#123;                        hexString.append(String.format(&quot;%02X &quot;, b &amp; 0xFF));                    &#125;                    System.out.println(&quot;wbShiftRows state matrix (hex): &quot; + hexString.toString());                &#125;                return true; // 继续执行            &#125;        &#125;);    &#125;\n\n\n\n下面是q正常情况下的结果。——2FF0E1B44B413D51A083E55259E2179F\n\n\n修改第9次行位移的某个字节，收集10次差分故障攻击的结果。\n\n收集了16个错误的结果。\n2F1BE1B4E6413D51A083E56059E21A9F\n2FF0E1A84B41C451A0B1E55215E2179F\nE7F0E1B44B413DE3A0837A525924179F\n2FF0A8B44B2F3D511A83E55259E217C6\nDCF0E1B44B413DBEA08316525911179F\n2F68E1B436413D51A083E5CF59E2769F\n96F0E1B44B413DACA083AB5259EA179F\n89F0E1B44B413DE7A0831C525944179F\n42F0E1B44B413D1CA083D9525974179F\n2FF07FB44B6E3D514683E55259E21747\n17F0E1B44B413D6CA0838A5259F3179F\n2FF069B44BAA3D510283E55259E21754\nD8F0E1B44B413D36A0834452590B179F\n8AF0E1B44B413D27A0839752591E179F\n24F0E1B44B413DB1A0839C5259E9179F\n2FF0E16A4B414151A0A4E55293E2179F\n接下来使用大佬写的攻击，通过差分结果、正常结果，还原轮密钥，项目地址：\nhttps://github.com/SideChannelMarvels/JeanGrey/tree/master/phoenixAES\n编写脚本得到第10轮子密钥。\n#!/usr/bin/env python3import phoenixAESwith open(&#x27;tracefile&#x27;, &#x27;wb&#x27;) as t:    t.write(&quot;&quot;&quot;    2FF0E1B44B413D51A083E55259E2179F    2F1BE1B4E6413D51A083E56059E21A9F    2FF0E1A84B41C451A0B1E55215E2179F    E7F0E1B44B413DE3A0837A525924179F    2FF0A8B44B2F3D511A83E55259E217C6    DCF0E1B44B413DBEA08316525911179F    2F68E1B436413D51A083E5CF59E2769F    96F0E1B44B413DACA083AB5259EA179F    89F0E1B44B413DE7A0831C525944179F    42F0E1B44B413D1CA083D9525974179F    2FF07FB44B6E3D514683E55259E21747    17F0E1B44B413D6CA0838A5259F3179F    2FF069B44BAA3D510283E55259E21754    D8F0E1B44B413D36A0834452590B179F    8AF0E1B44B413D27A0839752591E179F    24F0E1B44B413DB1A0839C5259E9179F    2FF0E16A4B414151A0A4E55293E2179F&quot;&quot;&quot;.encode(&#x27;utf8&#x27;))phoenixAES.crack_file(&#x27;tracefile&#x27;)\n\n结果是：869D92BBB700D0D25BD9FD3E224B5DF2。\n\n\n再用另一个大佬，从轮密钥还原原密钥。\nhttps://github.com/SideChannelMarvels/Stark\n需要自己编译源代码，编译完后，还原原密钥！\n\n\n至此，成功把密钥DFA出来了，下面这个结果和Unidbg模拟的一模一样。\n\n\n心得体会以下是我从这次分析中，认为自己需要加强的点：\n1.学习绕过反调；（分析壳）\n2.学习Unidbg的用法，包括hook、补环境、补系统调用等操作；（读相关博客等）\n3.利用符号执行，去除控制流平坦化；\n4.学习Binary ninja。\n"},{"title":"360免费壳分析复现","url":"/2025/05/27/360%E5%85%8D%E8%B4%B9%E5%A3%B3%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0/","content":"数字免费壳用的是大佬 oacia 加固的apk，需要的可以去大佬的博客中下载~\n将apk丢入jeb中，查看AndroidManifest.xml。\n\n\n从整体壳开始看起，一般整体壳会在App类中重写方法attachBaseContext和onCreate，在这两个方法中，实现自脱壳。\n先看attachBaseContext。\n分析\n通过反射，访问类**”android.content.pm.PackageParser$Package”**，设置构造方法为可访问。\n\n\n通过反射，获取当前线程的ActivityThread实例，然后设置mHiddenApiWarningShown字段为true，避免了日志中出现使用隐藏api时的警告信息。\n\nStubApp是一个静态类，存储加固相关的全局状态。\nStubApp.a保存上下文，供加固逻辑使用；StubApp.c保存当前对象实例（App类实例），确保只初始化一次。\n\n在函数com.qihoo.util.a.a()中，通过下述3种方式判断当前的架构，若是x86架构，则返回true，然后加载X86Bridge；反之相反。\n\n检查 Build.SUPPORTED_32_BIT_ABIS 系统属性。\n\n读取 &#x2F;system&#x2F;build.prop 文件中的 ro.product.cpu.abi 属性。\n\n检查 &#x2F;system&#x2F;bin&#x2F;ls 的 ELF 文件头，判断其架构。\n\n\n\ncom.qihoo.util.a.a(…)会检测…&#x2F;assets&#x2F;libjiagu.so和…&#x2F;.jiagu&#x2F;libjiagu.so是否完全一样，如果不一样，以assets的so为主，会把assets的so覆写.jiagu的so，假如之后我们patch了…&#x2F;.jiagu的so文件进行重打包，将不会有效果；libjiagu_64.so同等”待遇”。\n\n随后来到方法interface5，跳转到native层执行。\n\n\n不必多说，这个interface5肯定是在libjiaguxxx.so中注册的。\n使用下面这个脚本跑一下试试。\nfunction find_RegisterNatives(params) &#123;    let symbols = Module.enumerateSymbolsSync(&quot;libart.so&quot;);    let addrRegisterNatives = null;    for (let i = 0; i &lt; symbols.length; i++) &#123;        let symbol = symbols[i];                //_ZN3art3JNI15RegisterNativesEP7_JNIEnvP7_jclassPK15JNINativeMethodi        if (symbol.name.indexOf(&quot;art&quot;) &gt;= 0 &amp;&amp;                symbol.name.indexOf(&quot;JNI&quot;) &gt;= 0 &amp;&amp;                 symbol.name.indexOf(&quot;RegisterNatives&quot;) &gt;= 0 &amp;&amp;                 symbol.name.indexOf(&quot;CheckJNI&quot;) &lt; 0) &#123;            addrRegisterNatives = symbol.address;            console.log(&quot;RegisterNatives is at &quot;, symbol.address, symbol.name);            hook_RegisterNatives(addrRegisterNatives)        &#125;    &#125;&#125;function hook_RegisterNatives(addrRegisterNatives) &#123;    if (addrRegisterNatives != null) &#123;        Interceptor.attach(addrRegisterNatives, &#123;            onEnter: function (args) &#123;                console.log(&quot;[RegisterNatives] method_count:&quot;, args[3]);                let java_class = args[1];                let class_name = Java.vm.tryGetEnv().getClassName(java_class);                //console.log(class_name);                let methods_ptr = ptr(args[2]);                let method_count = parseInt(args[3]);                for (let i = 0; i &lt; method_count; i++) &#123;                    let name_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3));                    let sig_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize));                    let fnPtr_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize * 2));                    let name = Memory.readCString(name_ptr);                    let sig = Memory.readCString(sig_ptr);                    let symbol = DebugSymbol.fromAddress(fnPtr_ptr)                    console.log(&quot;[RegisterNatives] java_class:&quot;, class_name, &quot;name:&quot;, name, &quot;sig:&quot;, sig, &quot;fnPtr:&quot;, fnPtr_ptr,  &quot; fnOffset:&quot;, symbol, &quot; callee:&quot;, DebugSymbol.fromAddress(this.returnAddress), &quot;\\n&quot;);                &#125;            &#125;        &#125;);    &#125;&#125;setImmediate(find_RegisterNatives);\n\n结果如图，暂时忽视那个Bad access….目标函数在libjiagu_64.so offset为0x11be00的位置。\n\n先不着急分析interface5，先走完libjiagu_64.so的初始化，用IDA打开assets下的libjiagu_a64.so。\n打开一看，天塌了，导入表、导出表全是空的。\n使用System.loadLibray加载一个so文件的流程是这样的（大致操作应该没问题，如果细节有误，就是我学术不精）。\n\n动态链接器会映射这个so文件的PT_LOAD段到内存中；\n\n解析so文件，映射所有其他依赖的共享库；\n\n完成符号解析、动态重定位等操作；\n\n动态库初始化：init_proc -&gt; .init_array(函数指针) -&gt; JNI_OnLoad；\n\n完成加载，等待调用。\n\n\n一般来说，一个普通的so文件是没有start的（注意，_start和_dl_start不是一个函数），只有可执行文件有，而libjiagu_64.so的导出表有start，而且只有一个start，甚至被标记为了main_entry。但对于so文件来说，main_entry应该是用不着的。\n\n上述种种特征说明，它不是一个普通的so文件，而是一个类似于自加载器的so文件，壳so负责将加固后的so文件解密，解析并加载，然后链接重定位。\n那么问题来了，何时进行加载、何时重定位呢？\n得先找到壳的程序入口点。\n按照我们的常规思路，先去看看有没有函数叫init_proc（旧版本的才有的函数，一般情况下已经见不到这个函数）、再看init_array上有没有函数指针列表、最后找JNI_OnLoad。\n结果，在IDA中看不到init_proc、init_array节、JNI_OnLoad。\n后来，我通过readelf -a读到了INIT_ARRAY的偏移。\n\n跳转到0x2d760，没有看到函数指针。\n\n\n360壳对so文件的结构字段做了很多修改，有一些字段是用来观察so文件结构的，他们属于对动态链接器加载流程不构成影响的字段，这些字段要么给删了，要么给加密了。\n事实上，完全可以从内存中dump一个已经加载好的so文件，但我想看看一般这种情况要如何进行下一步分析。\n重新理一下思路——360壳对ELF文件做了手脚，通过工具无法查看某些字段的信息，但对于动态链接器来说，它依旧可以正确调用init_array上的函数和JNI_OnLoad。\n因此，下一个切入点是：动态链接器是如何获得到init_array和JNI_OnLoad地址的。\n动态链接器找init_array节地址的流程是这样的：\n\n查找.dynamic节的位置，.dynamic节是一个由Elf_Dyn结构体组成的数组，每个Elf_Dyn包含2个主要成员。\n\nd_tag：一个标记（tag），表示这个条目的类型，比如，当前这个条目指向符号表或重定位表等。\nd_un：一个联合体，根据d_tag的不同，它可以是一个值，或者指向一个虚拟地址。\n\n\n查找特定的d_tag，对于.init_array来说，有2个相关的d_tag标记。\n\nd_tag &#x3D;&#x3D; DT_INIT_ARRAY，此时d_un包含了.init_array节的偏移地址。\nd_tag &#x3D;&#x3D; DT_INIT_ARRAYSZ，此时d_un包含了.init_array节的总大小。（以字节为单位）\n\n\n动态链接器会找到.init_array的位置，并根据.init_array的大小，得到函数指针的数目，执行上面的函数指针。\n\n\n实操如下。\n通过010editor，找到节头表，然后根据节头表找到.dynamic节的偏移。\n\n\n下面这个网址，给出了d_tag的值与含义。\nhttps://docs.oracle.com/cd/E23824_01/html/819-0690/chapter6-42444.html\n\n一个Elf_Dyn元素占16个字节，前8个字节是d_tag，后8个字节是d_un。\n接下来，在010editor中，从0x1DAD0开始，搜索d_tag &#x3D;&#x3D; 25（0x19）或27（0x1B）的地方。\n翻译一下，.init_array的地址是0x2D760，和之前readelf看到的一样；而.init_array的大小是0x10字节，可以存放2个函数指针。\n\n我们之前跳转到了0x2D760，发现.init_array上没有任何内容，这2个函数指针是哪里来的？突然想起来，在一个so文件加载的流程中，会先进行动态重定位，那大概率是在重定位的过程，为.init_array赋了2个函数指针。\n重定位表（RELA类型）相关的d_tag如下：\n\nDT_RELA：此时d_un指向了重定位表的地址。\nDT_RELASZ：此时d_un指定了重定位表的总大小。\nDT_RELAENT：此时d_un指定了每个重定位条目的大小（一般24字节）。\n\n而重定位表（RELA类型）中的每个元素的结构（Elf_Rela）是这样的：\n\nr_offset：需要修改的、需要重定位的地址偏移量。（字节）\nr_info：这个成员变量包含2个信息——高4字节表示符号表索引，指向动态符号表（.dynsym）中的符号条目，该符号的地址将用于重定位计算；低4字节表示修正规则，用于判断执行哪种类型的地址修正操作。\nr_addend：一个显式的加数，一个有符号的常量，它会参与重定位的计算中，比如说：写入r_offset的位置的值可能是符号地址 + r_addend。\n\n而如果是REL类型的重定位表，相关的d_tag则是少了一个A，比如说，DT_REL、DT_RELSZ、DT_RELENT。\n而REL类型重定位表每个元素的的结构只有：r_offset和r_info。\n接下来是实操。\n通过 readelf -r libjiagu_a64.so –use-dynamic，可以获得重定位表表项的信息。\n第一条表项，是不是很眼熟？正是我们.init_array的地址，（除此之外，没找到0x2d768），由于r_info的低32位是0403，代表修正操作是R_AARCH64_RELATIV，这个修正规则的符号索引通常是0（指向空符号），因为这种重定位规则是相对于模块自身的加载基址，不依赖于其他特定符号。\n因此，.init_array的第一个函数指针是sub_98a0。\n\n别着急找JNI_OnLoad，还没完，突然注意到RELA表中，第二项的Type也是R_AARCH64_RELATIV，并且r_addend是0x2e20，这不正是我们之前看到的start函数的地址吗？\n它被存放到了0x2d770的位置，这个地址离.init_array就差16个字节。\n\n还记得我们之前使用readelf -a读到了.init_array的地址，其实当时还读到了.fini_array的地址。\n\n也就是说，这个start是.fini_array上的函数指针，很有迷惑性，.fini_array上的函数指针，是当程序退出的时候执行的，却取名叫了start。\n至此，我们找到了.init_array上的函数指针：sub_98a0。\n下一步，动态链接器是如何找到JNI_OnLoad的呢？\n动态链接器在执行完.init_array上函数指针的函数后，会调用dlsym(handle, “JNI_OnLoad”)，用于在库中查找一个名为”JNI_OnLoad”的导出符号，具体来说，dlsym()回到库的动态符号表(.dynsym)中搜索这个名称，如果找到了这个符号，就会返回这个符号的内存地址，由Dalvik&#x2F;ART虚拟机传递JavaVM*指针和一个保留参数并执行这个指向JNI_OnLoad的函数。\n实操如下。\n通过.dynamic的节表找到.dynamic节在文件中的偏移。\n通过010editor，找到节头表（动态链接器会根据PHT来找，节表在装载过程可有可无），然后根据节头表找到.dynamic节的偏移。\n\n\n然后从0x1DAD0的位置，寻找d_tag &#x3D;&#x3D; DT_SYMTAB（0x6）的表项。\n\n可以从d_un知道，动态符号表的偏移是0x4E8。\n\n**动态符号表（.dynsym）**每个元素的结构（Elf64_Sym）是这样的。\n\n一共24个字节。\nst_name：4个字节，表示相对于动态字符串表起始地址（.dynstr）中的偏移，如果该值为0，表示该符号没有名称。\nst_info：1个字节，表示符号的类型和绑定属性（根据这1个字节的不同位区分），类型：函数还是对象；绑定属性：全局还是局部。\nst_other：1个字节，定义符号的可见性。\nst_shndx：2个字节，符号相关的节头表索引，指明了该符号定义在哪个节区（特殊值有：未定义符号-SHN_UNDEF、绝对符号-SHN_ABS）。\nst_value：8个字节，符号的值，通常是符号的虚拟地址。\nst_size：8个字节，符号关联的数据的大小，以字节为单位，例如：函数体的大小或者数据对象的大小。\n\n而动态字符串表（.dynstr）里面，全部放着字符串，动态符号表的st_name的索引，对应着动态字符串表首地址的偏移量。\n在动态符号表中，每个数据对象占24（0x18）个字节，我们假设JNI_OnLoad这个字符串一定存在于.dynstr里，先去计算它相对于.dynstr的首地址的偏移量。\n找动态字符串表有个快捷的方式，直接在IDA中shift + f12，起始地址是0xFB0。\n\n\n然后搜索”JNI_OnLoad”，先考虑第1个JNI_OnLoad的偏移吧，如果根据第1个的偏移找不到，再考虑第2个。（仅仅根据字符串，无法通过交叉引用追踪到JNI_OnLoad的函数地址）\n\n计算偏移，得出0x230。\n\n接下来，从动态符号表（从0x4E8开始找）中，每次查看24字节的前4个字节，寻找0x230，然后根据st_value，找到符号的虚拟地址。——由于是小端排序，可以直接在010editor搜索，30 02。\n\n\n根据st_value在结构体中的偏移量，st_value &#x3D; 0x8AFC。\n\n接下来我们去看看0x8AFC符不符合JNI_OnLoad的特征。\n\n\n其中，sub_8C74里面有关于JNI_OnLoad字符串的出现。\nsub_4c70像不像dlsym？dlsym根据动态链接库操作句柄(pHandle)与符号(symbol)，返回符号对应的地址，也就是一个函数指针，为什么有2个JNI_OnLoad呢？我猜测是壳so加载了一个so（暂且叫做主so），而这个主so负责JNI动态注册，简单来说，壳so的JNI_OnLoad调用了主so的JNI_OnLoad。\n\n至此，做个小总结，.init_array节上有函数指针sub_98a0，而壳so的JNI_OnLoad地址是0x8AFC，为了验证猜想，我们可以dump一个内存中加载好的libjiagu_64.so进行验证。\n通过frida进行dump。\nfunction my_hook_dlopen(soName = &#x27;&#x27;) &#123;    Interceptor.attach(Module.getExportByName(null, &quot;android_dlopen_ext&quot;),        &#123;            onEnter: function (args) &#123;                var pathptr = args[0];                if (pathptr !== undefined &amp;&amp; pathptr != null) &#123;                    var path = ptr(pathptr).readCString();                    if (path.indexOf(soName) &gt;= 0) &#123;                        console.log(&quot;准备加载&quot;)                        this.is_can_hook = true;                    &#125;                &#125;            &#125;,            onLeave: function (retval) &#123;                if (this.is_can_hook) &#123;                    dump_so(&quot;libjiagu_64.so&quot;);                &#125;            &#125;        &#125;    );&#125;function dump_so(so_name) &#123;    console.log(so_name)    var libso = Process.getModuleByName(so_name);    console.log(&quot;[name]:&quot;, libso.name);    console.log(&quot;[base]:&quot;, libso.base);    console.log(&quot;[size]:&quot;, ptr(libso.size));    console.log(&quot;[path]:&quot;, libso.path);    var file_path = &quot;/data/data/com.oacia.apk_protect/&quot; + libso.name + &quot;_&quot; + libso.base + &quot;_&quot; + ptr(libso.size) + &quot;.so&quot;;    var file_handle = new File(file_path, &quot;wb&quot;);    if (file_handle &amp;&amp; file_handle != null) &#123;        Memory.protect(ptr(libso.base), libso.size, &#x27;rwx&#x27;);        var libso_buffer = ptr(libso.base).readByteArray(libso.size);        file_handle.write(libso_buffer);        file_handle.flush();        file_handle.close();        console.log(&quot;[dump]:&quot;, file_path);    &#125;&#125;setImmediate(my_hook_dlopen(&quot;libjiagu_64.so&quot;));\n\n然后使用elf修复工具进行修复，再用ida打开，这回导入、导出表的内容恢复了。\n\n\n来查看.init_array和JNI_OnLoad的地址。\n\n\n\n下图是壳so的JNI_OnLoad。\n\n下图是主so的JNI_OnLoad。\n\n\n暂且就不去分析sub_98a0和壳so的JNI_OnLoad的代码了，应该是修复导入、导出表，执行JNI_OnLoad、反调等操作。接下来会使用frida对这一块内容进行分析。\n\n注意到，在frida注入代码，dump了so文件之后，进程会立即退出。\n\n\nhook了android_dlopen_ext，发现进程在加载了libjiagu_64.so后就退出了，说明检测frida的代码大概率在这个so文件里。\n\n通过hook发现，libjiagu_64.so的某段代码一直在检测maps文件，应该是这里在检测调试器。\n解决办法：可以hook函数open，每当要执行函数open时，判断目标文件是否为maps文件，如果是，重定位到一个不存在的文件。\n\n\nhook的脚本如下。\nfunction my_hook_dlopen(soName = &#x27;&#x27;) &#123;    Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;),        &#123;            onEnter: function (args) &#123;                var pathptr = args[0];                if (pathptr !== undefined &amp;&amp; pathptr != null) &#123;                    var path = ptr(pathptr).readCString();                    if (path.indexOf(soName) &gt;= 0) &#123;                        this.is_can_hook = true;                    &#125;                &#125;            &#125;,            onLeave: function (retval) &#123;                if (this.is_can_hook) &#123;                    hook_proc_self_maps();                &#125;            &#125;        &#125;    );&#125;function hook_proc_self_maps() &#123;    const openPtr = Module.getExportByName(null, &#x27;open&#x27;);    const open = new NativeFunction(openPtr, &#x27;int&#x27;, [&#x27;pointer&#x27;, &#x27;int&#x27;]);    var fakePath = &quot;/data/data/com.oacia.apk_protect/maps&quot;;    Interceptor.replace(openPtr, new NativeCallback(function (pathnameptr, flag) &#123;        var pathname = Memory.readUtf8String(pathnameptr);        console.log(&quot;open&quot;, pathname);        if (pathname.indexOf(&quot;maps&quot;) &gt;= 0) &#123;            console.log(&quot;find&quot;,pathname,&quot;,redirect to&quot;,fakePath);            var filename = Memory.allocUtf8String(fakePath);            return open(filename, flag);        &#125;        var fd = open(pathnameptr, flag);        return fd;    &#125;, &#x27;int&#x27;, [&#x27;pointer&#x27;, &#x27;int&#x27;]));&#125;setImmediate(my_hook_dlopen,&quot;libjiagu&quot;);\n\n虽然还是退出了，但这次有了新的收获，可以看到打开了3个dex文件。\n\n\n用010editor打开，发现第一个dex处于加密状态，而其它的dex是空的。\n\n为了判断是哪里的代码open了dex文件，可以打印一下堆栈，常规的打印堆栈的方式是加下面这句代码，但我们前面将maps文件重定位了，所以不能使用DebugSymbol.fromAddress（用到了maps文件）了，得自己实现一个函数。\nconsole.log(&#x27;RegisterNatives called from:\\\\n&#x27; + Thread.backtrace(this.context, Backtracer.FUZZY).map(DebugSymbol.fromAddress).join(&#x27;\\\\n&#x27;) + &#x27;\\\\n&#x27;);\n\n修改后的完整代码如下。\nfunction addr_in_so(addr)&#123;    var process_Obj_Module_Arr = Process.enumerateModules();    for(var i = 0; i &lt; process_Obj_Module_Arr.length; i++) &#123;        if(addr&gt;process_Obj_Module_Arr[i].base &amp;&amp; addr&lt;process_Obj_Module_Arr[i].base.add(process_Obj_Module_Arr[i].size))&#123;            console.log(addr.toString(16),&quot;is in&quot;,process_Obj_Module_Arr[i].name,&quot;offset: 0x&quot;+(addr-process_Obj_Module_Arr[i].base).toString(16));        &#125;    &#125;&#125;function hook_proc_self_maps() &#123;    const openPtr = Module.getExportByName(null, &#x27;open&#x27;);    const open = new NativeFunction(openPtr, &#x27;int&#x27;, [&#x27;pointer&#x27;, &#x27;int&#x27;]);    var fakePath = &quot;/data/data/com.oacia.apk_protect/maps_nonexistent&quot;;    Interceptor.replace(openPtr, new NativeCallback(function (pathnameptr, flag) &#123;        var pathname = Memory.readUtf8String(pathnameptr);        console.log(&quot;open&quot;,pathname);//,Process.getCurrentThreadId()        if (pathname.indexOf(&quot;maps&quot;) &gt;= 0) &#123;            console.log(&quot;find&quot;,pathname+&quot;, redirect to&quot;,fakePath);            var filename = Memory.allocUtf8String(fakePath);            return open(filename, flag);        &#125;        if (pathname.indexOf(&quot;dex&quot;) &gt;= 0) &#123;            Thread.backtrace(this.context, Backtracer.FUZZY).map(addr_in_so);        &#125;        var fd = open(pathnameptr, flag);        return fd;    &#125;, &#x27;int&#x27;, [&#x27;pointer&#x27;, &#x27;int&#x27;]));&#125;function my_hook_dlopen(soName=&#x27;&#x27;) &#123;    Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;),        &#123;            onEnter: function (args) &#123;                var pathptr = args[0];                if (pathptr !== undefined &amp;&amp; pathptr != null) &#123;                    var path = ptr(pathptr).readCString();                    //console.log(path);                    if (path.indexOf(soName) &gt;= 0) &#123;                        this.is_can_hook = true;                    &#125;                &#125;            &#125;,            onLeave: function (retval) &#123;                if (this.is_can_hook) &#123;                    hook_proc_self_maps();                &#125;            &#125;        &#125;    );&#125;setImmediate(my_hook_dlopen,&#x27;libjiagu&#x27;);\n\n可以看到3个dex文件被打开时的调用栈了，鉴于3个dex文件的调用栈基本一样，大概率是在一个循环中依次加载的。\n\n\n\n\n来到0x19b780，发现都是0，应该是在加载完dex文件后，将这块空间清空了。\n\n\n为了分析这块代码的逻辑，需要在open dex文件的时候，将so文件dump下来。\nvar hook_once = 0;function my_hook_dlopen(soName = &#x27;&#x27;) &#123;    Interceptor.attach(Module.getExportByName(null, &quot;android_dlopen_ext&quot;),        &#123;            onEnter: function (args) &#123;                var pathptr = args[0];                if (pathptr !== undefined &amp;&amp; pathptr != null) &#123;                    var path = ptr(pathptr).readCString();                    if (path.indexOf(soName) &gt;= 0) &#123;                        console.log(&quot;准备加载&quot;)                        this.is_can_hook = true;                    &#125;                &#125;            &#125;,            onLeave: function (retval) &#123;                if (this.is_can_hook) &#123;                    // 获得open的地址                    const openPtr = Module.getExportByName(null, &#x27;open&#x27;);                    // 准备替换的open                    const open = new NativeFunction(openPtr, &#x27;int&#x27;, [&#x27;pointer&#x27;, &#x27;int&#x27;]);                    // hook                    Interceptor.replace(openPtr, new NativeCallback(function (pathnameptr, flag) &#123;                        var pathname = Memory.readUtf8String(pathnameptr);                        console.log(&quot;open&quot;, pathname);//,Process.getCurrentThreadId()                        if (pathname.indexOf(&quot;maps&quot;) &gt;= 0) &#123;                            var fakePath = &quot;/data/data/com.oacia.apk_protect/maps_nonexistent&quot;;                            console.log(&quot;find&quot;,pathname+&quot;, redirect to&quot;,fakePath);                            var filename = Memory.allocUtf8String(fakePath);                            return open(filename, flag);                        &#125;                        if (pathname.indexOf(&quot;/data/data/com.oacia.apk_protect/.jiagu/classes&quot;) &gt;= 0) &#123;                            if(hook_once == 0)&#123;                                dump_so(&quot;libjiagu_64.so&quot;);                                hook_once = 1;                            &#125;                        &#125;                        var fd = open(pathnameptr, flag);                        return fd;                    &#125;, &#x27;int&#x27;, [&#x27;pointer&#x27;, &#x27;int&#x27;]));                &#125;            &#125;        &#125;    );&#125;function dump_so(so_name) &#123;    console.log(so_name)    var libso = Process.getModuleByName(so_name);    console.log(&quot;[name]:&quot;, libso.name);    console.log(&quot;[base]:&quot;, libso.base);    console.log(&quot;[size]:&quot;, ptr(libso.size));    console.log(&quot;[path]:&quot;, libso.path);    var file_path = &quot;/data/data/com.oacia.apk_protect/&quot; + libso.name + &quot;_&quot; + libso.base + &quot;_&quot; + ptr(libso.size) + &quot;.so&quot;;    var file_handle = new File(file_path, &quot;wb&quot;);    if (file_handle &amp;&amp; file_handle != null) &#123;        Memory.protect(ptr(libso.base), libso.size, &#x27;rwx&#x27;);        var libso_buffer = ptr(libso.base).readByteArray(libso.size);        file_handle.write(libso_buffer);        file_handle.flush();        file_handle.close();        console.log(&quot;[dump]:&quot;, file_path);    &#125;&#125;setImmediate(my_hook_dlopen(&quot;libjiagu_64.so&quot;));\n\n脚本执行结果。\n\n\n 修复之后，用IDA打开，定位到0x19b780。\n\n\n可以使用winmerge查看两个文件的区别。分析被抽空的数据，是从哪里开始抽空的\n\n往上滚动，直到0xe7000，两边的文件才基本一模一样。\n\n注意到，0xe7000存放的是.ELF，这是ELF文件的魔数。也就是说，壳so里面藏了一个so（主so）。\n使用下面这个脚本，将壳so里的ELF文件读出来，放入010editor查看。\nwith open(&#x27;libjiagu_64.so_0x6f71613000_0x274000.so&#x27;,&#x27;rb&#x27;) as f:    s=f.read()with open(&#x27;libjiagu_0xe7000.so&#x27;,&#x27;wb&#x27;) as f:    f.write(s[0xe7000::])\n\n除了ELF头，段头表和节表都被加密了。\n\n因此，IDA无法对这个ELF文件进行正常的分析。\n根据前人的分析，壳ELF会对加密的主ELF进行解密，并且自己实现了linker，对主ELF进行解析，再将解析结果赋值到soinfo结构体中，然后调用dlopen进行手动加载。\n先简单介绍一下什么是dlopen、dlsym和soinfo。\ndlopen (Dynamic Load Open)\n\n是什么：dlopen 是一个标准 C 库函数（定义在 dlfcn.h 中，通常由 libdl.so 提供）。它允许程序在运行时（而不是在程序启动时）显式地加载指定的共享对象（SO文件）到其地址空间。\n作用：当程序调用 dlopen(&quot;path/to/your_library.so&quot;, flags) 时，它会请求动态链接器加载这个库。如果加载成功，dlopen 会返回一个“句柄 (handle)”，后续可以使用这个句柄通过 dlsym 查找库中的符号（函数或变量），或者通过 dlclose卸载该库。\n谁调用它：应用程序代码可以直接调用 dlopen 来实现插件系统、按需加载功能模块等。在Java&#x2F;Kotlin层面，System.loadLibrary() 或 System.load() 在底层通常也是通过调用 dlopen 来加载JNI库的。\n\nsoinfo (Shared Object Information)\n\n是什么：soinfo 是Android动态链接器内部使用的一个非常重要的数据结构。对于加载到进程中的每一个SO文件，动态链接器都会在内部创建一个对应的 soinfo 实例来管理它。其他类Unix系统的动态链接器也会有类似的内部结构来跟踪已加载的库，但 soinfo 这个名称特指Android的实现（源于Bionic C库的链接器）。\n作用：soinfo结构体存储了关于一个已加载SO文件的所有关键运行时信息，例如：\n库的名称和完整路径。\n库在内存中的加载基地址 (base address) 和大小。\n指向其ELF动态段 (.dynamic section) 的指针。\n指向其动态符号表 (.dynsym)、字符串表 (.dynstr)、哈希表 (.hash 或 .gnu.hash) 的指针。\n重定位表的信息。\n依赖的其他 soinfo 实例的列表。\n库的句柄 (handle)、引用计数。\n初始化状态（例如，构造函数&#x2F;.init_array 是否已运行）。\n标志位（例如，是否是主可执行程序、是否是PIE等）。\n\n\n\n应用程序通过dlopen函数请求加载一个so文件，dlopen会将这个请求传递给动态链接器linker，动态链接器linker负责实际执行加载so文件的所有底层工作（查找文件、映射内存、解析依赖、重定位符号、运行初始化代码等）。在加载so文件的过程中，动态链接器会为这个新加载的so文件创建一个soinfo结构体实例，这个soinfo包含了管理该so所需的所有元数据和状态信息。\n而当后续调用dlsym查找该库某个符号时，链接器会查阅对应soinfo中记录的符号表等信息——dlopen获得的handle，实际上就是soinfo结构体实例的指针。\n因此，可以理解壳ELF的行为：对主ELF文件进行解析、映射、重定位…创建soinfo结构实例，然后供dlsym使用，获得符号的地址。\n主so是壳so加载起来的，但要是连依赖项也由壳处理，就过于麻烦了，所以前人分析会用到dlopen，于是进行交叉引用追踪。\n在函数sub_3C94中，用到了dlopen，同时会发现，这里的代码和aosp源码的预链接十分相似，下图是sub_3C94的代码。\n\n下图是AOSP源码中的预链接（直接用oacia大佬的图）。\n\n\n添加前人准备好的关于soinfo的结构体，然后将参数a1类型改成soinfo *。\n// ELF64 启用该宏#define __LP64__ 1// ELF32 启用该宏//#define __work_around_b_24465209__ 1/* https://android.googlesource.com/platform/bionic/+/master/linker/Android.bp架构为 32 位 定义__work_around_b_24465209__宏arch: &#123;    arm: &#123;cflags: [&quot; D__work_around_b_24465209__&quot;],&#125;,    x86: &#123;cflags: [&quot; D__work_around_b_24465209__&quot;],&#125;,&#125;*/// 定义 ELF 文件的基本类型，根据架构决定使用 ELF32 或 ELF64 类型#if defined(__LP64__)    #define ElfW(type) Elf64_ ## type#else    #define ElfW(type) Elf32_ ## type#endif// 32 位和 64 位重定位和符号表数据结构// Elf32 和 Elf64 基本类型typedef signed char __s8;typedef unsigned char __u8;typedef signed short __s16;typedef unsigned short __u16;typedef signed int __s32;typedef unsigned int __u32;typedef signed long long __s64;typedef unsigned long long __u64;// 32 位 ELF 基本类型typedef __u32 Elf32_Addr;typedef __u16 Elf32_Half;typedef __u32 Elf32_Off;typedef __s32 Elf32_Sword;typedef __u32 Elf32_Word;// 64 位 ELF 基本类型typedef __u64 Elf64_Addr;typedef __u16 Elf64_Half;typedef __s16 Elf64_SHalf;typedef __u64 Elf64_Off;typedef __s32 Elf64_Sword;typedef __u32 Elf64_Word;typedef __u64 Elf64_Xword;typedef __s64 Elf64_Sxword;// 动态段数据结构（Elf32 和 Elf64）typedef struct dynamic &#123;    Elf32_Sword d_tag;    union &#123;        Elf32_Sword d_val;        Elf32_Addr d_ptr;    &#125; d_un;&#125; Elf32_Dyn;typedef struct &#123;    Elf64_Sxword d_tag; /* entry tag value */    union &#123;        Elf64_Xword d_val;        Elf64_Addr d_ptr;    &#125; d_un;&#125; Elf64_Dyn;// 重定位数据结构（Elf32 和 Elf64）typedef struct elf32_rel &#123;    Elf32_Addr r_offset;    Elf32_Word r_info;&#125; Elf32_Rel;typedef struct elf64_rel &#123;    Elf64_Addr r_offset; /* Location at which to apply the action */    Elf64_Xword r_info;  /* index and type of relocation */&#125; Elf64_Rel;typedef struct elf32_rela &#123;    Elf32_Addr r_offset;    Elf32_Word r_info;    Elf32_Sword r_addend;&#125; Elf32_Rela;typedef struct elf64_rela &#123;    Elf64_Addr r_offset;  /* Location at which to apply the action */    Elf64_Xword r_info;   /* index and type of relocation */    Elf64_Sxword r_addend; /* Constant addend used to compute value */&#125; Elf64_Rela;// 符号表数据结构（Elf32 和 Elf64）typedef struct elf32_sym &#123;    Elf32_Word st_name;    Elf32_Addr st_value;    Elf32_Word st_size;    unsigned char st_info;    unsigned char st_other;    Elf32_Half st_shndx;&#125; Elf32_Sym;typedef struct elf64_sym &#123;    Elf64_Word st_name;     /* Symbol name, index in string tbl */    unsigned char st_info;  /* Type and binding attributes */    unsigned char st_other; /* No defined meaning, 0 */    Elf64_Half st_shndx;    /* Associated section index */    Elf64_Addr st_value;    /* Value of the symbol */    Elf64_Xword st_size;    /* Associated symbol size */&#125; Elf64_Sym;// ELF 文件头数据结构（Elf32 和 Elf64）#define EI_NIDENT 16typedef struct elf32_hdr &#123;    unsigned char e_ident[EI_NIDENT];    Elf32_Half e_type;    Elf32_Half e_machine;    Elf32_Word e_version;    Elf32_Addr e_entry; /* Entry point */    Elf32_Off e_phoff;    Elf32_Off e_shoff;    Elf32_Word e_flags;    Elf32_Half e_ehsize;    Elf32_Half e_phentsize;    Elf32_Half e_phnum;    Elf32_Half e_shentsize;    Elf32_Half e_shnum;    Elf32_Half e_shstrndx;&#125; Elf32_Ehdr;typedef struct elf64_hdr &#123;    unsigned char e_ident[EI_NIDENT]; /* ELF &quot;magic number&quot; */    Elf64_Half e_type;    Elf64_Half e_machine;    Elf64_Word e_version;    Elf64_Addr e_entry;  /* Entry point virtual address */    Elf64_Off e_phoff;   /* Program header table file offset */    Elf64_Off e_shoff;   /* Section header table file offset */    Elf64_Word e_flags;    Elf64_Half e_ehsize;    Elf64_Half e_phentsize;    Elf64_Half e_phnum;    Elf64_Half e_shentsize;    Elf64_Half e_shnum;    Elf64_Half e_shstrndx;&#125; Elf64_Ehdr;// 程序头数据结构（Elf32 和 Elf64）typedef struct elf32_phdr &#123;    Elf32_Word p_type;    Elf32_Off p_offset;    Elf32_Addr p_vaddr;    Elf32_Addr p_paddr;    Elf32_Word p_filesz;    Elf32_Word p_memsz;    Elf32_Word p_flags;    Elf32_Word p_align;&#125; Elf32_Phdr;typedef struct elf64_phdr &#123;    Elf64_Word p_type;    Elf64_Word p_flags;    Elf64_Off p_offset;  /* Segment file offset */    Elf64_Addr p_vaddr;  /* Segment virtual address */    Elf64_Addr p_paddr;  /* Segment physical address */    Elf64_Xword p_filesz; /* Segment size in file */    Elf64_Xword p_memsz;  /* Segment size in memory */    Elf64_Xword p_align;  /* Segment alignment, file &amp; memory */&#125; Elf64_Phdr;// 节头数据结构（Elf32 和 Elf64）typedef struct elf32_shdr &#123;    Elf32_Word sh_name;    Elf32_Word sh_type;    Elf32_Word sh_flags;    Elf32_Addr sh_addr;    Elf32_Off sh_offset;    Elf32_Word sh_size;    Elf32_Word sh_link;    Elf32_Word sh_info;    Elf32_Word sh_addralign;    Elf32_Word sh_entsize;&#125; Elf32_Shdr;typedef struct elf64_shdr &#123;    Elf64_Word sh_name;       /* Section name, index in string tbl */    Elf64_Word sh_type;       /* Type of section */    Elf64_Xword sh_flags;     /* Miscellaneous section attributes */    Elf64_Addr sh_addr;       /* Section virtual addr at execution */    Elf64_Off sh_offset;      /* Section file offset */    Elf64_Xword sh_size;      /* Size of section in bytes */    Elf64_Word sh_link;       /* Index of another section */    Elf64_Word sh_info;       /* Additional section information */    Elf64_Xword sh_addralign; /* Section alignment */    Elf64_Xword sh_entsize;   /* Entry size if section holds table */&#125; Elf64_Shdr;// 动态链接信息结构（Android 特有）typedef void (*linker_dtor_function_t)();typedef void (*linker_ctor_function_t)(int, char**, char**);#if defined(__work_around_b_24465209__)#define SOINFO_NAME_LEN 128#endif// Android 中的 soinfo 结构体，用于表示动态链接库信息struct soinfo &#123;    #if defined(__work_around_b_24465209__)    char old_name_[SOINFO_NAME_LEN];    #endif    const ElfW(Phdr)* phdr;    size_t phnum;    ElfW(Addr) base;    size_t size;    ElfW(Dyn)* dynamic;    soinfo* next;    uint32_t flags_;    const char* strtab_;    ElfW(Sym)* symtab_;    size_t nbucket_;    size_t nchain_;    uint32_t* bucket_;    uint32_t* chain_;    #if !defined(__LP64__)    ElfW(Addr)** unused4; // DO NOT USE, maintained for compatibility    #endif    #if defined(USE_RELA)    ElfW(Rela)* plt_rela_;    size_t plt_rela_count_;    ElfW(Rela)* rela_;    size_t rela_count_;    #else    ElfW(Rel)* plt_rel_;    size_t plt_rel_count_;    ElfW(Rel)* rel_;    size_t rel_count_;    #endif    linker_ctor_function_t* preinit_array_;    size_t preinit_array_count_;    linker_ctor_function_t* init_array_;    size_t init_array_count_;    linker_dtor_function_t* fini_array_;    size_t fini_array_count_;    linker_ctor_function_t init_func_;    linker_dtor_function_t fini_func_;    size_t ref_count_;    link_map link_map_head;    bool constructors_called;    ElfW(Addr) load_bias;    bool has_text_relocations;    bool has_DT_SYMBOLIC;&#125;;\n\n如果是一个标准的soinfo结构，不会出现a1[1]，只能说壳ELF的soinfo魔改了。\n\n简单分析一下sub_3C94做了什么：\n\n构建soinfo实例，从一些硬编码的信息中，将soinfo实例进行初始化；\n加载主so的依赖库；\n\n这些硬编码信息的偏移量是从a1获得的。\n\n\nsub_49F0调用了sub_3C94。\n\n\nv5的值与v1有关，v1的值与a1有关，a1的值来自sub_49f0的调用者——sub_4B54。\n\n\na1的值与a2有关，但在函数sub_6128中，a2的值是由a1得来的，因此，还得继续追踪sub_4B54的调用者。\n\nsub_4B54有2个调用者，其中，sub_8c74很眼熟。\n\n0x8AFC是JNI_OnLoad的函数地址，其实之前交叉引用sub_8C74的时候，发现没有函数引用sub_8C74，但JNI_OnLoad的伪代码里突然发现了sub_8c74。\n\n\n通过汇编代码，可以看到，BL指令的下一条指令就是sub_8C74，这种方式的调用可能让IDA无法正常分析了。\n\n\n言归正传，也就是说，当壳so被加载起来后，会通过JNI_OnLoad，最终将主so进行解析并加载。\n回到sub_3C94的调用者——sub_49F0。\n只有当sub_3C94的返回值是奇数，才能进一步执行sub_4918，而sub_3C94的作用我们前面分析过了（将主so的元数据填到soinfo实例，然后加载主so的依赖），这里的sub_4918大概率是进一步完成主so的加载。\n\n\n看到关于dynamic的字眼，大概率是重定位阶段。\n\n点进sub_4000。\n\n看到0x403，有点眼熟，搜了一下之前的内容，果然，v8是r_info的低32位，代表重定位过程，地址的修正规则，进一步说明当前函数是在进行重定位了。\n\n一般情况下，动态链接器会先对处理通用重定位（.rela.dyn或.rel.dyn），再处理 PLT 重定位（.rela.plt或.rel.plt）。\n\n再进入sub_5e6c观察。\n\n观察到0x38（56个字节），刚好是一个段表的大小。\n\n调用了mprotect。\n\n\n基本可以确定，大概率是在处理各个LOAD段。\n将begin_addr_pht_1类型改成elf64_phdr，IDA的伪代码将会更加清晰，下图是我分析后的sub_5E6C。\n\n0x6474E552换成十进制是1685382482，可以通过010Editor知道其含义是PT_GNU_RELRO。\n\n\nsub_5E6C 函数在处理 PT_GNU_RELRO 段。它的作用就是在“主SO”的重定位完成后，找到所有标记为 PT_GNU_RELRO 的程序段，并将这些段在内存中的对应区域设置为只读。这是ELF动态链接中的一个标准安全步骤，称为RELRO (Relocation Read-Only)，目的是保护那些在重定位后不应再被修改的数据段（如部分GOT表、.data.rel.ro段）免遭篡改。\n既然，这里将RELRO的段设置成了只读，说明这个时候，所有的PHT都应该处于解密状态，尝试在这个时候读取PHT，将它们dump下来。\n第1个参数代表程序头表（们）的起始地址，第2个参数代表数量，第3个参数还没分析。\n\n使用frida脚本进行dump，需要注意，sub_5E6C是在壳so的JNI_OnLoad调用的，如果hook android_dlopen_ext，在onLeave回调时，hook sub_5E6C，那时就太晚了，JNI_OnLoad都执行完了，不会触发Interceptor.attach的trap。\n因此，得hook call_constructors，在onEnter时进一步hook sub_5E6C，这个hook的时机是：壳so的内容映射到了内存中，但尚未执行init_proc、.init_array上的函数、JNI_OnLoad，这个时机就很完美。\n// 针对 call_constructors 进行 Hookfunction hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;);    let offset_call = 0x51BA8; // 你手机的 linker64 中 call_constructors 的偏移量    let call_constructors = linker64_base_addr.add(offset_call);    let listener = Interceptor.attach(call_constructors, &#123;        onEnter: function(args) &#123;            let secmodule = Process.findModuleByName(&quot;libjiagu_64.so&quot;); // 目标 SO 文件            if (secmodule != null) &#123;                // Hook 目标函数 sub_5E6C                console.log(&quot;[+] &quot;, &quot;Module libjiagu_64.so base_addr: &quot;, secmodule.base.toString(16));                hook_target_func(secmodule.base);                listener.detach(); // Hook 完成后解除            &#125;        &#125;    &#125;);&#125;// Hook 目标函数 sub_5E6Cfunction hook_target_func(baseaddr) &#123;    // sub_5E6C 的偏移    let target_offset = 0x5E6C;    let target_func = baseaddr.add(target_offset);    Interceptor.attach(target_func, &#123;        onEnter: function(args) &#123;            console.log(&#x27;[+] Hooking sub_5E6C at:&#x27;, target_func);            // 获取参数            let begin_addr_pht = args[0]; // 第一个 PHT 条目的地址            let nums_pht = args[1]; // PHT 条目数量            console.log(&#x27;[+] PHT Parameters:&#x27;);            console.log(&#x27;  - begin_addr_pht:&#x27;, begin_addr_pht);            console.log(&#x27;  - nums_pht:&#x27;, nums_pht);            console.log(&#x27;  - a3: 0x&#x27; + args[2].toString(16))            // 验证 PHT 条目数量            if (nums_pht &lt; 1) &#123;                console.log(&#x27;[-] Invalid PHT count:&#x27;, nums_pht);                return;            &#125;            // 计算 PHT 结束地址            let pht_size_per_entry = 56; // Elf64_Phdr 的大小为 56 字节            let end_addr_pht = begin_addr_pht.add(nums_pht * pht_size_per_entry);            // 准备保存 PHT 数据            let pht_data = Memory.alloc(nums_pht * pht_size_per_entry);            Memory.copy(pht_data, begin_addr_pht, nums_pht * pht_size_per_entry);            // 保存到文件            let file_path = &#x27;/data/data/com.oacia.apk_protect/pht_decrypt.bin&#x27;;            let file = new File(file_path, &#x27;wb&#x27;);            if (file &amp;&amp; file !== null) &#123;                file.write(pht_data.readByteArray(nums_pht * pht_size_per_entry));                file.flush();                file.close();                console.log(&#x27;[+] PHT dumped to:&#x27;, file_path);            &#125; else &#123;                console.log(&#x27;[-] Failed to open file:&#x27;, file_path);            &#125;        &#125;,        onLeave: function(retval) &#123;            console.log(&#x27;[+] sub_5E6C returned:&#x27;, retval);        &#125;    &#125;);&#125;// 启动 HooksetImmediate(hook_linker_call_constructors);\n\n结果如下（忽视掉进程终止^_^）。\n可以发现：0x70089b4000 - 0x70088cd000 &#x3D; 0xe7000，而之前我们的分析中，偏移量0xe7000处是主so的起始地址，所以这里的a3是主so在内存中的基址。\n同时，也可以看出来解密后的PHT的存放地址，和主so的ELF头并不在内存上相连（在之后的操作后就明白了，这里PHT的地址是堆的地址，主so的PHT是垃圾数据），与ELF头相连的PHT是垃圾数据填充的，或者说是加密的。\n\n将文件pull出来观察，看样子确实解密了。\n\n\n修改到之前脱掉的主so里去，现在可以清晰看到段表的内容了。\n\n至此，拿到了解密后的PHT，也知道了sub_5E6C的参数意义。\n问题又来了，既然参数的意义分别是：第1个参数代表程序头表（们）的起始地址，第2个参数代表数量，第3个参数代表主so的基址。\n\n而soinfo的结构体是这样的。\n\n\n按理来说，soinfo偏移量为0的地方就是PHT的地址，而这里的a1-&gt;link_map_head.l_next实则指向了((byte*) a1) + 232，这说明在成员变量const Elf64_Phdr *phdr的前面，还有232字节，这232字节应该是360壳自定义的。\n\n添加后，第1个参数的位置对了，但第2个参数和第3个参数还是错的，说明还需要插入一些字节。\n\n正常情况应该是这样。\nsub_5E6C(a1-&gt;phdr, a1-&gt;phnum, a1-&gt;base)\n\n为了知道壳ELF是怎么解密出来的，大佬oacia写了一个IDA插件：stalker_trace_so，这个脚本可以追踪native函数的执行顺序，但似乎不分线程，而且也没有调用关系，下图是截的大佬oacia博客的图。\n\n\n我对这个脚本进行了二开，让打印更美观一点，而且要展示调用关系。\n修改后，打印的内容好看了很多，能清晰地看到调用链。\n[ONEPLUS A6003::com.oacia.apk_protect ]-&gt; start Stalker on thread 11793Stalker started![180 ms] [TID:11793] ENTER: JNI_OnLoad  [180 ms] [TID:11793] ENTER: .interpreter_wrap_int64_t    [180 ms] [TID:11793] ENTER: interpreter_wrap_int64_t      [181 ms] [TID:11793] ENTER: ._Znwm      [181 ms] [TID:11793] EXIT: ._Znwm    [181 ms] [TID:11793] EXIT: interpreter_wrap_int64_t    [182 ms] [TID:11793] ENTER: sub_13908      [182 ms] [TID:11793] ENTER: ._Znam      [182 ms] [TID:11793] EXIT: ._Znam      [184 ms] [TID:11793] ENTER: sub_11220        [184 ms] [TID:11793] ENTER: .memset        [185 ms] [TID:11793] EXIT: .memset        [186 ms] [TID:11793] ENTER: sub_9DD8        [186 ms] [TID:11793] EXIT: sub_9DD8      [187 ms] [TID:11793] EXIT: sub_11220      [190 ms] [TID:11793] ENTER: sub_E3E0      [190 ms] [TID:11793] EXIT: sub_E3E0      [190 ms] [TID:11793] ENTER: .calloc      [191 ms] [TID:11793] EXIT: .calloc    [191 ms] [TID:11793] EXIT: sub_13908  [191 ms] [TID:11793] EXIT: .interpreter_wrap_int64_t[193 ms] [TID:11793] EXIT: JNI_OnLoad[204 ms] [TID:11793] ENTER: .malloc  [204 ms] [TID:11793] ENTER: .free  [204 ms] [TID:11793] EXIT: .free[207 ms] [TID:11793] EXIT: .malloc[208 ms] [TID:11793] ENTER: sub_E648[209 ms] [TID:11793] EXIT: sub_E648[209 ms] [TID:11793] ENTER: ._ZdaPv[213 ms] [TID:11793] EXIT: ._ZdaPv[213 ms] [TID:11793] ENTER: sub_C918[213 ms] [TID:11793] EXIT: sub_C918[214 ms] [TID:11793] ENTER: sub_9988[214 ms] [TID:11793] EXIT: sub_9988[214 ms] [TID:11793] ENTER: sub_9964[214 ms] [TID:11793] EXIT: sub_9964[215 ms] [TID:11793] ENTER: sub_9AC4[216 ms] [TID:11793] EXIT: sub_9AC4[216 ms] [TID:11793] ENTER: .ffi_prep_cif  [216 ms] [TID:11793] ENTER: ffi_prep_cif    [217 ms] [TID:11793] ENTER: .ffi_prep_cif_machdep      [217 ms] [TID:11793] ENTER: ffi_prep_cif_machdep      [218 ms] [TID:11793] EXIT: ffi_prep_cif_machdep      [218 ms] [TID:11793] ENTER: .ffi_call        [218 ms] [TID:11793] ENTER: ffi_call          [218 ms] [TID:11793] ENTER: sub_1674C          [219 ms] [TID:11793] EXIT: sub_1674C          [219 ms] [TID:11793] ENTER: .ffi_call_SYSV            [219 ms] [TID:11793] ENTER: ffi_call_SYSV              [219 ms] [TID:11793] ENTER: sub_167BC                [220 ms] [TID:11793] ENTER: sub_1647C                [220 ms] [TID:11793] EXIT: sub_1647C                [220 ms] [TID:11793] ENTER: sub_163DC                [220 ms] [TID:11793] EXIT: sub_163DC              [221 ms] [TID:11793] EXIT: sub_167BC            [221 ms] [TID:11793] EXIT: ffi_call_SYSV            [221 ms] [TID:11793] ENTER: sub_9900            [222 ms] [TID:11793] EXIT: sub_9900          [222 ms] [TID:11793] EXIT: .ffi_call_SYSV        [222 ms] [TID:11793] EXIT: ffi_call      [222 ms] [TID:11793] EXIT: .ffi_call    [223 ms] [TID:11793] EXIT: .ffi_prep_cif_machdep    [224 ms] [TID:11793] ENTER: sub_94BC      [224 ms] [TID:11793] ENTER: .dladdr      [226 ms] [TID:11793] EXIT: .dladdr    [226 ms] [TID:11793] EXIT: sub_94BC  [226 ms] [TID:11793] EXIT: ffi_prep_cif[226 ms] [TID:11793] EXIT: .ffi_prep_cif[226 ms] [TID:11793] ENTER: .strstr[227 ms] [TID:11793] EXIT: .strstr[231 ms] [TID:11793] ENTER: .setenv[232 ms] [TID:11793] EXIT: .setenv[235 ms] [TID:11793] ENTER: _Z9__arm_a_1P7_JavaVMP7_JNIEnvPvRi[239 ms] [TID:11793] EXIT: _Z9__arm_a_1P7_JavaVMP7_JNIEnvPvRi[241 ms] [TID:11793] ENTER: sub_9E58  [242 ms] [TID:11793] ENTER: sub_999C  [242 ms] [TID:11793] EXIT: sub_999C[242 ms] [TID:11793] EXIT: sub_9E58[242 ms] [TID:11793] ENTER: sub_10964  [243 ms] [TID:11793] ENTER: j_._ZdlPv_1    [243 ms] [TID:11793] ENTER: ._ZdlPv      [245 ms] [TID:11793] ENTER: sub_96E0      [246 ms] [TID:11793] EXIT: sub_96E0    [246 ms] [TID:11793] EXIT: ._ZdlPv    [246 ms] [TID:11793] ENTER: sub_8000      [246 ms] [TID:11793] ENTER: .strncpy      [247 ms] [TID:11793] EXIT: .strncpy      [247 ms] [TID:11793] ENTER: sub_60E0      [247 ms] [TID:11793] EXIT: sub_60E0      [247 ms] [TID:11793] ENTER: sub_6544      [248 ms] [TID:11793] EXIT: sub_6544      [248 ms] [TID:11793] ENTER: sub_4B54        [248 ms] [TID:11793] ENTER: sub_6128        [248 ms] [TID:11793] EXIT: sub_6128        [248 ms] [TID:11793] ENTER: _ZN9__arm_c_19__arm_c_0Ev        [250 ms] [TID:11793] EXIT: _ZN9__arm_c_19__arm_c_0Ev        [250 ms] [TID:11793] ENTER: sub_A3EC          [250 ms] [TID:11793] ENTER: sub_99CC            [250 ms] [TID:11793] ENTER: sub_9944            [250 ms] [TID:11793] EXIT: sub_9944          [251 ms] [TID:11793] EXIT: sub_99CC        [251 ms] [TID:11793] EXIT: sub_A3EC      [252 ms] [TID:11793] EXIT: sub_4B54    [254 ms] [TID:11793] EXIT: sub_8000  [254 ms] [TID:11793] EXIT: j_._ZdlPv_1[254 ms] [TID:11793] EXIT: sub_10964[257 ms] [TID:11793] ENTER: sub_6484  [257 ms] [TID:11793] ENTER: sub_6590    [257 ms] [TID:11793] ENTER: .memcpy    [258 ms] [TID:11793] EXIT: .memcpy    [258 ms] [TID:11793] ENTER: sub_6698      [260 ms] [TID:11793] ENTER: sub_9FFC      [261 ms] [TID:11793] EXIT: sub_9FFC    [268 ms] [TID:11793] EXIT: sub_6698    [268 ms] [TID:11793] ENTER: j_._ZdlPv_3      [268 ms] [TID:11793] ENTER: j_._ZdlPv_2        [269 ms] [TID:11793] ENTER: j_._ZdlPv_0          [269 ms] [TID:11793] ENTER: sub_A3A0            [269 ms] [TID:11793] ENTER: sub_9A90            [269 ms] [TID:11793] EXIT: sub_9A90          [269 ms] [TID:11793] EXIT: sub_A3A0        [270 ms] [TID:11793] EXIT: j_._ZdlPv_0      [270 ms] [TID:11793] EXIT: j_._ZdlPv_2      [270 ms] [TID:11793] ENTER: sub_5F20      [271 ms] [TID:11793] EXIT: sub_5F20    [271 ms] [TID:11793] EXIT: j_._ZdlPv_3    [271 ms] [TID:11793] ENTER: sub_6044    [276 ms] [TID:11793] EXIT: sub_6044  [276 ms] [TID:11793] EXIT: sub_6590  [276 ms] [TID:11793] ENTER: sub_3574    [276 ms] [TID:11793] ENTER: .uncompress    [279 ms] [TID:11793] EXIT: .uncompress  [279 ms] [TID:11793] EXIT: sub_3574[281 ms] [TID:11793] EXIT: sub_6484[316 ms] [TID:11793] ENTER: sub_49F0  [316 ms] [TID:11793] ENTER: sub_5400  [316 ms] [TID:11793] EXIT: sub_5400  [316 ms] [TID:11793] ENTER: sub_5478    [316 ms] [TID:11793] ENTER: sub_5B08    [318 ms] [TID:11793] EXIT: sub_5B08  [320 ms] [TID:11793] EXIT: sub_5478  [320 ms] [TID:11793] ENTER: sub_5650  [321 ms] [TID:11793] EXIT: sub_5650  [321 ms] [TID:11793] ENTER: sub_580C    [322 ms] [TID:11793] ENTER: .mprotect    [322 ms] [TID:11793] EXIT: .mprotect  [324 ms] [TID:11793] EXIT: sub_580C[324 ms] [TID:11793] EXIT: sub_49F0[325 ms] [TID:11793] ENTER: .strlen[325 ms] [TID:11793] EXIT: .strlen[325 ms] [TID:11793] ENTER: sub_3C94  [327 ms] [TID:11793] ENTER: .dlopen  [328 ms] [TID:11793] EXIT: .dlopen[330 ms] [TID:11793] EXIT: sub_3C94[352 ms] [TID:11793] ENTER: sub_4918  [353 ms] [TID:11793] ENTER: sub_4000    [353 ms] [TID:11793] ENTER: sub_41B4      [354 ms] [TID:11793] ENTER: sub_35AC      [355 ms] [TID:11793] EXIT: sub_35AC    [355 ms] [TID:11793] EXIT: sub_41B4    [356 ms] [TID:11793] ENTER: .dlsym    [357 ms] [TID:11793] EXIT: .dlsym  [358 ms] [TID:11793] EXIT: sub_4000[359 ms] [TID:11793] EXIT: sub_4918[369 ms] [TID:11793] ENTER: sub_5E6C[370 ms] [TID:11793] EXIT: sub_5E6C[370 ms] [TID:11793] ENTER: sub_5444[370 ms] [TID:11793] EXIT: sub_5444[386 ms] [TID:11793] ENTER: sub_633C[386 ms] [TID:11793] EXIT: sub_633C[386 ms] [TID:11793] ENTER: sub_8130  [387 ms] [TID:11793] ENTER: sub_4C70  [387 ms] [TID:11793] EXIT: sub_4C70[388 ms] [TID:11793] EXIT: sub_8130[388 ms] [TID:11793] ENTER: sub_825C[389 ms] [TID:11793] EXIT: sub_825C[389 ms] [TID:11793] ENTER: sub_8B50[390 ms] [TID:11793] EXIT: sub_8B50[390 ms] [TID:11793] ENTER: sub_8ED4[391 ms] [TID:11793] EXIT: sub_8ED4[391 ms] [TID:11793] ENTER: sub_8430[394 ms] [TID:11793] EXIT: sub_8430[395 ms] [TID:11793] ENTER: interpreter_wrap_int64_t_bridge  [397 ms] [TID:11793] ENTER: sub_9D60  [398 ms] [TID:11793] EXIT: sub_9D60[398 ms] [TID:11793] EXIT: interpreter_wrap_int64_t_bridge[780 ms] [TID:11793] ENTER: sub_166C4[781 ms] [TID:11793] EXIT: sub_166C4[782 ms] [TID:11793] ENTER: .puts[787 ms] [TID:11793] EXIT: .puts[1642 ms] [TID:11793] ENTER: sub_115AA0[1643 ms] [TID:11793] EXIT: sub_115AA0[1781 ms] [TID:11793] ENTER: _Z9__arm_a_2PcmS_Rii[1790 ms] [TID:11793] EXIT: _Z9__arm_a_2PcmS_Rii[2069 ms] [TID:11793] ENTER: .ffi_prep_cif_var  [2070 ms] [TID:11793] ENTER: ffi_prep_cif_var  [2070 ms] [TID:11793] EXIT: ffi_prep_cif_var[2070 ms] [TID:11793] EXIT: .ffi_prep_cif_var\n\n脚本链接：Call_Trace，如果觉得好用，麻烦点个星星，┭┮﹏┭┮这对我找工作真的很重要。——脚本是有局限的，在github里写了，如果只想要观察调用顺序而不需要调用关系，可以把打印内容的EXIT全部去掉，再把缩进也去掉，这样就恢复成原来oacia大佬的脚本了。由于这是360壳，有些调用不是标准的RET退栈，所以调用关系可能会有问题。\n继续分析。\n\n\n在解压缩操作附近的函数进行查看，发现存在RC4加密。\n下面这个是标准RC4的KSA步骤。\n\n\n修改一下变量名，简单明了，和标准RC4一模一样，如果想得到密钥的值，hook sub_5F20，然后得到第1个参数的值即可。\n\nhook rc4的密钥脚本如下。\n// 针对 call_constructors 进行 Hookfunction hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;);    let offset_call = 0x51BA8; // 你手机的 linker64 中 call_constructors 的偏移量    let call_constructors = linker64_base_addr.add(offset_call);    let listener = Interceptor.attach(call_constructors, &#123;        onEnter: function(args) &#123;            let secmodule = Process.findModuleByName(&quot;libjiagu_64.so&quot;); // 目标 SO 文件            if (secmodule != null) &#123;                // Hook 目标函数 sub_5E6C                console.log(&quot;[+] &quot;, &quot;Module libjiagu_64.so base_addr: &quot;, secmodule.base.toString(16));                hook_target_func(secmodule.base);                listener.detach(); // Hook 完成后解除            &#125;        &#125;    &#125;);&#125;// Hook 目标函数 sub_5f20function hook_target_func(baseaddr) &#123;    // sub_5E6C 的偏移    let target_offset = 0x5f20;    let target_func = baseaddr.add(target_offset);    Interceptor.attach(target_func, &#123;        onEnter: function(args) &#123;            console.log(&#x27;[+] Hooking sub_5f20 at:&#x27;, target_func);            console.log(&quot;rc4 key:&quot;);            console.log(hexdump(args[0], &#123;length: 64&#125;));        &#125;,        onLeave: function(retval) &#123;            console.log(&#x27;[+] sub_5f20 returned:&#x27;, retval);        &#125;    &#125;);&#125;// 启动 HooksetImmediate(hook_linker_call_constructors);\n\n结果如下图所示，提取密钥，如果之后要用就方便了。0x76,0x55,0x56,0x34,0x23,0x91,0x23,0x53,0x56,0x74。\n\n\n按理来说，在ksa之后，应该会调用rc4的PRGA算法，然后进行rc4解密，再进行压缩，所以这里继续追踪sub_6044和sub_3574进行查看。\n\n先看sub_3574，这里直接调用了uncompress，那大概率sub_6044就是rc4_PRGA算法。\n\n\n标准的RC4_PRGA算法是这样的。\n\n\n而sub_6044是这样的。\n\n修改变量名后，如下图所示。\n\n在进行rc4解密后，主so的内容仍然是不可用的，还需要进行解压缩。sub_6044的下一个函数调用是sub_3574，而sub_3574直接调用uncompress，然后发现uncompress位于导入表，那大概率就是zlib库的uncompress了。\n下面是uncompress的函数签名。\nint uncompress(Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen);\n根据这个函数签名，我们可以hook它，得到解压缩后的内容。\n但在hook uncompress之前，先hook rc4_prga，通过它，可以获得加密主so的地址和内容的大小。\n脚本如下。\n// 针对 call_constructors 进行 Hookfunction hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;);    let offset_call = 0x51BA8; // 手机的 linker64 中 call_constructors 的偏移量    let call_constructors = linker64_base_addr.add(offset_call);    let listener = Interceptor.attach(call_constructors, &#123;        onEnter: function(args) &#123;            let secmodule = Process.findModuleByName(&quot;libjiagu_64.so&quot;); // 目标 SO 文件            if (secmodule != null) &#123;                // Hook 目标函数 sub_6044                console.log(&quot;[+] &quot;, &quot;Module libjiagu_64.so base_addr: &quot;, secmodule.base.toString(16));                hook_target_func(secmodule.base);                listener.detach(); // Hook 完成后解除            &#125;        &#125;    &#125;);&#125;// Hook 目标函数 sub_6044function hook_target_func(baseaddr) &#123;    // sub_6044 的偏移    let target_offset = 0x6044;    let target_func = baseaddr.add(target_offset);    Interceptor.attach(target_func, &#123;        onEnter: function(args) &#123;            console.log(&#x27;[+] Hooking sub_6044 at:&#x27;, target_func);            console.log(&quot;encrypt 主elf addr:&quot;, &quot;0x&quot; + (args[0] - baseaddr).toString(16));            console.log(&quot;encrypt 主elf size:&quot;, &quot;0x&quot; + args[1].toString(16));            console.log(&quot;解密前:&quot;);            this.arg0 = args[0];            console.log(hexdump(args[0], &#123;length: 64&#125;));        &#125;,        onLeave: function(retval) &#123;            console.log(&quot;解密后:&quot;);            console.log(hexdump(this.arg0, &#123;length: 64&#125;))        &#125;    &#125;);&#125;// 启动 HooksetImmediate(hook_linker_call_constructors);\n\n打印结果如下。\n\n0x74783ff0肯定不是一个正常的偏移量，估计做过转移（比如malloc申请空间，存到别的地方去了），真正的主so加密数据应该是在壳so的某个偏移。\n尝试在壳so文件搜索加密前的内容——用010editor在文件中在搜索 01 18 25 e7…\n可以发现，加密数据存放于libjiagu_64_after_open_fixed.so的0x2e270的位置，这是我之前趁着open(“…&#x2F;xxx.dex”)的时候dump下来的libjiagu_a64.so。\n\n\n而在assets目录下的libjiagu_a64.so中，这段加密内容位于0x1E270的位置。\n\n\n估计是加载过程中对齐的缘故，又或者是360壳把把主so的基址设在了64K位置（0x10000）。\n如果之后我们想直接从壳so中获得主so，用的是0x1E270，但分析的时候，继续用0x2e270。\n\n对这个变量名交叉引用，只有函数sub_8000引用了它。\n可以发现，0xB8010正是sub_6044第2个参数的值，代表着RC4加密后主so的大小。\n\n\n接着hook uncompress，由于uncompress是系统库的函数，不需要考虑360壳做手脚，直接hook。\n// 针对 call_constructors 进行 Hookfunction hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;);    let offset_call = 0x51BA8; // 手机的 linker64 中 call_constructors 的偏移量    let call_constructors = linker64_base_addr.add(offset_call);    let listener = Interceptor.attach(call_constructors, &#123;        onEnter: function(args) &#123;            let secmodule = Process.findModuleByName(&quot;libjiagu_64.so&quot;); // 目标 SO 文件            if (secmodule != null) &#123;                // Hook 目标函数 sub_6044                console.log(&quot;[+] &quot;, &quot;Module libjiagu_64.so base_addr: &quot;, secmodule.base.toString(16));                hook_target_func(secmodule.base);                listener.detach(); // Hook 完成后解除            &#125;        &#125;    &#125;);&#125;// Hook 目标函数 sub_6044function hook_target_func(baseaddr) &#123;    // sub_6044 的偏移    let target_offset = 0x6044;    let target_func = baseaddr.add(target_offset);    Interceptor.attach(target_func, &#123;        onEnter: function(args) &#123;            console.log(&#x27;[+] Hooking sub_6044 at:&#x27;, target_func);            console.log(&quot;encrypt 主elf在内存中的实际位置:&quot;, &quot;0x&quot; + args[0].toString(16));            console.log(&quot;encrypt 主elf在rc4加密后的大小:&quot;, &quot;0x&quot; + args[1].toString(16));            console.log(&quot;解密前:&quot;);            this.arg0 = args[0];            console.log(hexdump(args[0], &#123;length: 64&#125;));        &#125;,        onLeave: function(retval) &#123;            console.log(&quot;解密后:&quot;);            console.log(hexdump(this.arg0, &#123;length: 64&#125;))        &#125;    &#125;);&#125;function hook_uncompress_res()&#123;    Interceptor.attach(Module.findExportByName(null, &quot;uncompress&quot;), &#123;        onEnter: function (args) &#123;            console.log(&quot;hook uncompress&quot;)            console.log(&quot;解压缩前:&quot;)            console.log(hexdump(args[2], &#123;              offset: 0,// 相对偏移              length: 64,//dump 的大小              header: true,              ansi: true            &#125;));            console.log(&quot;解压缩前的大小:&quot;,args[3])        &#125;,        onLeave: function (ret) &#123;        &#125;    &#125;);&#125;// 启动 HooksetImmediate(function()&#123;    hook_linker_call_constructors();    hook_uncompress_res();&#125;);\n\n打印的结果如下。\n很容易猜到，rc4解密后的数据的前4个字节用来表示解压后的主so的大小（0x1a0eb9）。\n\n现在我们已经知道了主so的位置（0x1e270）、加密的算法与密钥（rc4和”0x76,0x55,0x56,0x34,0x23,0x91,0x23,0x53,0x56,0x74”）、解压用的函数及解压后的大小（zlib的uncompress和0x1a0eb9），现在可以很轻易地从壳so中直接得到主so解密的内容。\n写脚本脱下来看看——这边直接抄了oacia大佬的。\nimport zlibimport structdef RC4(data, key):    S = list(range(256))    j = 0    out = []    # KSA Phase    for i in range(256):        j = (j + S[i] + key[i % len(key)]) % 256        S[i], S[j] = S[j], S[i]    # PRGA Phase    i = j = 0    for ch in data:        i = (i + 1) % 256        j = (j + S[i]) % 256        S[i], S[j] = S[j], S[i]        out.append(ch ^ S[(S[i] + S[j]) % 256])    return outdef RC4decrypt(ciphertext, key):    return RC4(ciphertext, key)wrap_elf_start = 0x1e270wrap_elf_size = 0xb8010key = b&quot;vUV4#\\x91#SVt&quot;with open(&#x27;com.oacia.apk_protect/assets/libjiagu_a64.so&#x27;,&#x27;rb&#x27;) as f:    wrap_elf = f.read()# 对密文进行解密dec_compress_elf = RC4decrypt(wrap_elf[wrap_elf_start:wrap_elf_start+wrap_elf_size], key)dec_elf = zlib.decompress(bytes(dec_compress_elf[4::]))with open(&#x27;wrap_elf&#x27;,&#x27;wb&#x27;) as f:    f.write(dec_elf)\n\n将得到的wrap_elf放到010editor查看，一大堆D3。\n\n\n往下面看，发现存在ELF文件的特征，而ELF文件之前导出都是D3。\n\n\n可以将这里理解为2段数据，part1为D3相关的加密，part2为ELF文件头（可能还有其它内容）。\n这里对wrap_elf进行切割。\nwith open(&#x27;wrap_elf&#x27;, &#x27;rb&#x27;) as f:    wrap_elf = f.read()ELF_magic = bytes([0x7F, 0x45, 0x4C, 0x46])for i in range(len(wrap_elf) - len(ELF_magic) + 1):    if wrap_elf[i:i + len(ELF_magic)] == ELF_magic:        print(hex(i))        with open(&#x27;wrap_elf_part1&#x27;, &#x27;wb&#x27;) as f:            f.write(wrap_elf[0:i])        with open(&#x27;wrap_elf_part2&#x27;, &#x27;wb&#x27;) as f:            f.write(wrap_elf[i::])        break\n\n打开wrap_elf_part2，发现PHT填充了一堆垃圾数据（可能是加密数据，但我更倾向于PHT放在了别的地方）。\n\n往下分析，要进行重定位的话，要么是part2的PHT解密了，要么是PHT放在了其它地方。\n\n对其中的函数进行分析。\n\n一般加载一个so的时候，申请mmap空间之前需要有PHT，先读取PHT上写着的LOAD加载地址、大小、对齐方式等，再调用mmap进行申请。\n因此，sub_5B08大概率在获得正确的PHT，点进来一看，发现存在常量0x38，刚好是一个PHT的大小，更说明猜测是对的了。\n\n\npht_buffer与xor_key进行异或，异或的xor_key来自于a2+16。\n\n\nhook一下，查看xor_key的内容是多少。\n// 针对 call_constructors 进行 Hookfunction hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;);    let offset_call = 0x51BA8; // 手机的 linker64 中 call_constructors 的偏移量    let call_constructors = linker64_base_addr.add(offset_call);    let listener = Interceptor.attach(call_constructors, &#123;        onEnter: function(args) &#123;            let secmodule = Process.findModuleByName(&quot;libjiagu_64.so&quot;); // 目标 SO 文件            if (secmodule != null) &#123;                console.log(&quot;[+] &quot;, &quot;Module libjiagu_64.so base_addr: &quot;, secmodule.base.toString(16));                hook_target_func(secmodule.base);                listener.detach(); // Hook 完成后解除            &#125;        &#125;    &#125;);&#125;function hook_target_func(baseaddr) &#123;    let target_offset = 0x5B08;    let target_func = baseaddr.add(target_offset);    Interceptor.attach(target_func, &#123;        onEnter: function(args) &#123;            console.log(&quot;[xor_key]:&quot;, &quot;0x&quot;+args[1].add(16).readPointer().readU8().toString(16));        &#125;    &#125;);&#125;// 启动 HooksetImmediate(function()&#123;    hook_linker_call_constructors();&#125;);\n\n脚本执行结果是0xd3，说明真正的PHT很可能就是part1解密后的内容。\n\n除了异或，解密的循环还有arm64的neon运算。\nNEON 是 ARM 架构的 SIMD 扩展，提供一组专用的寄存器和指令，用于并行处理多个数据元素。\n下面两个链接介绍了sub_5B08中出现的vdupq_n_s8和veorq_s8。\nhttps://developer.arm.com/architectures/instruction-sets/intrinsics/#q=vdupq_n_s8\nhttps://developer.arm.com/architectures/instruction-sets/intrinsics/#q=veorq_s8\n简单来说，一个字节一个字节的异或效率太低，而neon可以一次性异或16个字节。——根本不影响阅读。\n\n\n分析了一下，突然意识到v2似乎指向part2。\n\n打印一下看看。（脚本就不提供了，跟查看xor_key的脚本差不多）\n下面这内容不就是part1的内容？\n\n也就是说，part1的第1个字节是xor_key，接下来的4个字节是长度（0x150），再接下来的0x150个字节是待异或的内容，注意到，我们之前分析的主so有6个pht，每个pht大小是0x38，加起来不就是0x150个字节吗？所以说，part1的前0x155字节与pht相关。\n\n整理了一下，假如每次要处理的数据量都很小，那每次的处理数据的方式都是逐字节异或，然后goto到下一块要处理的数据，整个sub_5B08有4个这样子的结构，因此有4块数据。\n数据的分布结构是这样的：xor_key（1个字节）、data1_len（4个字节）、data1、data2_len（4个字节）、data2、data3_len（4个字节）、data3、data4_len、data4。\n之前提过，soinfo中存在一些360壳的字段，而在sub_5B08可以推测一些字段了。\n关于data1的相关字段。\n\n\n关于data2的相关字段。\n\n\n关于data3的相关字段。\n\n\n关于data4的相关字段。\n\n\n最后还有elf的相关字段，这里的v16、v27、v38、pht_total_size有3个是数据的大小，还有有一个是基址；17是1个字节的xor_key和4个4字节的data_len。\n想想wrap_elf，part1基本都是0xD3，而part2是ELF文件，不难想出，a1的第152个字节指向elf起始地址。\n\n原先的soinfo是这样的。前232字节由于不知道是什么，直接当成一个char数组，暂时没做处理。\n\n\n根据分析，可以这么设置。\n\n\n但是想了想，似乎不太合适，这样子先入为主地认为之前的那个数据结构是soinfo了，虽然的确很像，如果如上图这么设置，pht_buffer和phdr是同一个意思，应该不会这么设计。\n依照其它人的博客的意思，老老实实创建当前这个结构体即可，不要往soinfo去想，因为一开始的soinfo也是猜测。\n因此，这里的Four_Section不需要凑232个字节了，只需要满足偏移量在对应的地方即可，结构体应该如下。\n\n\n既然sub_5B08的第1个参数是Four_Section，查看它的引用函数，传参的那个变量的类型也应该是Four_Section。\n\n继续查看引用sub_5478函数，将v14变量的类型改成Four_Section*，然后发现不对，存在2个问题。\n\nv14的类型是Four_Section*，为什么还要取地址再转成(Four_Section*)？\nv7_1[29] &#x3D; v9，v9 &#x3D; v16，但v16的值呢？\n\n\n针对上述两个问题，其实说明v14的类型取错了。\n\n这里的v15-v23找不到赋值的地方，它们很有可能是和v14作为一个完整的结构体对象，一起作为参数赋值的，而我们这边将v14设置成指针类型，导致将v14与v15-v23进行了切割。只需要把v14的指针符号去掉即可。\n\n\n再根据下图的逻辑，定义新的结构体。v7_1申请了0x1E0个空间，因此，我们需要创建的结构体大小应该也是0x1E0。\n\n创建的结构体是这样的，注：168个字节中，可能有好几个成员变量类型。\n\n其实到这一步，也能看出之前想的soinfo是错误的，因此要回到用到了soinfo的地方，把类型改成FourSection_t，然后观察section2&#x2F;3&#x2F;4到底是什么。\nsub_3c94是设置重定位表、符号表等内容的函数，可以看出来section4存放的是.dynamic节（一般DT_DYNAMIC只含一个.dynamic节）。\n\n\n\n而在函数sub_4918中，我们判断第1次调用sub_4000是进行常规重定位（对数据和指令的重定位），第2次调用sub_4000是进行plt重定位（大部分情况是对符号的重定位）。\n\n快有点模糊d_tag和r_info的区别了…这里的0x402和0x403分别是R_AARCH64_JUMP_SLOT、R_AARCH64_RELATIVE，是一种计算修正地址的规则，而这种规则分别常用于.rela.plt和.rela.dyn，因此认为这里的section3和2分别指向.rela.dyn和.rela.plt。\n区分.rela.plt和.rela.dyn的方式是d_tag，d_tag &#x3D;&#x3D; DT_RELA是后者，d_tag &#x3D;&#x3D; DT_JMPREL是前者。\n\n至此，重命名一下。\n\n\n总结一下释放主so的流程：\n\nwrap_elf位于assets&#x2F;libjiagu_a64.so的0x1e270的位置。\n\nwrap_elf经过rc4解密（密钥：b”vUV4#\\x91#SVt”）后，是一个长度为0xb8010的压缩数据A，真正参与解压的数据是A[4:]，也就是说，参与解压的数据的大小是0xb800C，前4个字节描述了解压后数据的大小。\n\n解压后的数据视作wrap_elf，而wrap_elf里分为part1和part2两部分，part1被0xD3异或加密，part2指向一个ELF文件，但PHT、.dynamic节的等内容均被垃圾数据占满。\n\npart1里有4组数据，它的数据结构是这样：xor_key（1个字节）、data1_len（4个字节）、data1、data2_len（4个字节）、data2、data3_len（4个字节）、data3、data4_len、data4；\n\ndata1-data4分别是被0xD3异或加密的PHT、.rela.plt、.rela.dyn、.dynamic。\n\n\n需要注意，0x1e270是在壳so文件里wrap_elf的偏移，而在内存中，wrap_elf的偏移来到了0x2e270，原0x1e270被清空了；之后的主so加载的基址是0xe7000。\n通过下面这个脚本，可以从壳so里直接获得4个解密后的section。\nimport copyimport zlibdef RC4(data, key):    S = list(range(256))    j = 0    out = []    # KSA Phase    for i in range(256):        j = (j + S[i] + key[i % len(key)]) % 256        S[i], S[j] = S[j], S[i]    # PRGA Phase    i = j = 0    for ch in data:        i = (i + 1) % 256        j = (j + S[i]) % 256        S[i], S[j] = S[j], S[i]        out.append(ch ^ S[(S[i] + S[j]) % 256])    return outdef RC4decrypt(ciphertext, key):    return RC4(ciphertext, key)wrap_elf_start = 0x1e270wrap_elf_size = 0xb8010key = b&quot;vUV4#\\x91#SVt&quot;with open(&#x27;com.oacia.apk_protect/assets/libjiagu_a64.so&#x27;, &#x27;rb&#x27;) as f:    wrap_elf = f.read()# 对密文进行解密dec_compress_elf = RC4decrypt(wrap_elf[wrap_elf_start:wrap_elf_start + wrap_elf_size], key)dec_elf = zlib.decompress(bytes(dec_compress_elf[4::]))with open(&#x27;wrap_elf&#x27;, &#x27;wb&#x27;) as f:    f.write(dec_elf)class part:    def __init__(self):        self.name = &quot;&quot;        self.value = b&#x27;&#x27;        self.offset = 0        self.size = 0index = 1extra_part = [part() for _ in range(7)]seg = [&quot;phdr&quot;, &quot;.rela.plt&quot;, &quot;.rela.dyn&quot;, &quot;.dynamic&quot;]v_xor = dec_elf[0]for i in range(4):    size = int.from_bytes(dec_elf[index:index + 4], &#x27;little&#x27;)    index += 4    extra_part[i + 1].name = seg[i]    extra_part[i + 1].value = bytes(map(lambda x: x ^ v_xor, dec_elf[index:index + size]))    extra_part[i + 1].size = size    index += sizefor p in extra_part:    if p.value!=b&#x27;&#x27;:        filename = f&quot;libjiagu.so_&#123;hex(p.size)&#125;_&#123;p.name&#125;&quot;        print(f&quot;[&#123;p.name&#125;] get &#123;filename&#125;, size: &#123;hex(p.size)&#125;&quot;)        with open(filename,&#x27;wb&#x27;) as f:            f.write(p.value)\n\n至于修复，很简单，把part2的主so放到010editor，用得到的4个section进行覆盖就行。\n\n覆盖pht，其它的覆盖方法，需要找.dynamic节，然后得到.rela.plt和.rela.dyn节的偏移是多少，这里不过多赘述。\n\n\n在修复之后，基址设为0xe7000。\n\n\n在获得主so文件之后，下一个主线任务就是找到主dex是如何加载并被解密的，然后获取主dex。\n之前我们在hook函数open的时候，发现open会打开dex文件，通过打印调用函数栈，我们发现主so位于偏移量为0xE7000的位置，现在回顾一下在打开dex文件时的函数调用栈。\n\n\n这里看到的调用栈其实只是部分，因为主so的函数列表并没有添加到壳so生成的脚本里，我之前写的脚本并没有测试过，所以这里还是用大佬oacia的吧。\n在IDA中打开主so，然后使用插件stalker_trace_so，然后将主so的函数列表插回壳so的脚本里，这是佬oacia的截图。\n\n这里我将名字改成keke了hhhhh。\n\n然后插入1个判断即可。\n\n前面在大量地执行壳so的函数，后面基本都在调用主so的函数。\n\n\n在主so中搜索0x19b780，发现这个指令位于函数sub_19B760中，然后在trace.log中，发现没找到sub_19B760，应该是因为没hook maps文件，进程检测到frida，提前退出了。\n在hook了maps文件后，发现获得的日志信息反而变少了。\n[ONEPLUS A6003::com.oacia.apk_protect ]-&gt; start Stalker!Stalker end![keke] call1:JNI_OnLoad[keke] call2:.interpreter_wrap_int64_t[keke] call3:interpreter_wrap_int64_t[keke] call4:._Znwm[keke] call5:sub_13908[keke] call6:._Znam[keke] call7:sub_11220[keke] call8:.memset[keke] call9:sub_9DD8[keke] call10:sub_E3E0[keke] call11:.calloc[keke] call12:.malloc[keke] call13:.free[keke] call14:sub_E648[keke] call15:._ZdaPv[keke] call16:sub_C918[keke] call17:sub_9988[keke] call18:sub_9964[keke] call19:sub_9AC4[keke] call20:.ffi_prep_cif[keke] call21:ffi_prep_cif[keke] call22:.ffi_prep_cif_machdep[keke] call23:ffi_prep_cif_machdep[keke] call24:.ffi_call[keke] call25:ffi_call[keke] call26:sub_1674C[keke] call27:.ffi_call_SYSV[keke] call28:ffi_call_SYSV[keke] call29:sub_167BC[keke] call30:sub_1647C[keke] call31:sub_163DC[keke] call32:sub_9900[keke] call33:sub_94BC[keke] call34:.dladdr[keke] call35:.strstr[keke] call36:.setenv[keke] call37:_Z9__arm_a_1P7_JavaVMP7_JNIEnvPvRi[keke] call38:sub_9E58[keke] call39:sub_999C[keke] call40:sub_10964[keke] call41:j_._ZdlPv_1[keke] call42:._ZdlPv[keke] call43:sub_96E0[keke] call44:sub_8000[keke] call45:.strncpy[keke] call46:sub_60E0[keke] call47:sub_6544[keke] call48:sub_4B54[keke] call49:sub_6128[keke] call50:_ZN9__arm_c_19__arm_c_0Ev[keke] call51:sub_A3EC[keke] call52:sub_99CC[keke] call53:sub_9944[keke] call54:sub_6484[keke] call55:sub_6590[keke] call56:.memcpy[keke] call57:sub_6698[keke] call58:sub_9FFC[keke] call59:j_._ZdlPv_3[keke] call60:j_._ZdlPv_2[keke] call61:j_._ZdlPv_0[keke] call62:sub_A3A0[keke] call63:sub_9A90[keke] call64:sub_5F20[keke] call65:sub_6044[keke] call66:sub_3574[keke] call67:.uncompress[keke] call68:sub_49F0[keke] call69:sub_5400[keke] call70:sub_5478[keke] call71:sub_5B08[keke] call72:sub_5650[keke] call73:sub_580C[keke] call74:.mprotect[keke] call75:.strlen[keke] call76:sub_3C94[keke] call77:.dlopen[keke] call78:sub_4918[keke] call79:sub_4000[keke] call80:sub_41B4[keke] call81:sub_35AC[keke] call82:.dlsym[keke] call83:sub_5E6C[keke] call84:sub_5444[main] call85:sub_11603C[main] call86:j__Znwm[main] call87:_Znwm[main] call88:malloc[main] call89:__cxa_atexit[main] call90:sub_1160B4[main] call91:sub_1160C4[main] call92:strlen[main] call93:memcpy[main] call94:sub_1161FC[main] call95:sub_1164AC[main] call96:sub_1164D8[main] call97:sub_116528[main] call98:sub_1165C8[main] call99:sub_1A32C0[main] call100:sub_1A3150[main] call101:sub_1A3204[main] call102:sub_1166FC[main] call103:sub_116728[main] call104:sub_116750[main] call105:sub_116830[main] call106:sub_116BA0[keke] call107:sub_633C[keke] call108:sub_8130[keke] call109:sub_4C70[keke] call110:sub_825C[keke] call111:sub_8B50[keke] call112:sub_8ED4[keke] call113:sub_8430[main] call114:JNI_OnLoad[main] call115:j_interpreter_wrap_int64_t[main] call116:interpreter_wrap_int64_t[keke] call117:interpreter_wrap_int64_t_bridge[keke] call118:sub_9D60[main] call119:sub_1B3F0C[main] call120:gettimeofday[main] call121:sub_11BD9C[main] call122:sub_1182D8[main] call123:sub_123970[main] call124:sub_1B6448[main] call125:getenv[main] call126:sub_11F130[main] call127:sub_12047C[main] call128:j__ZdlPv[main] call129:_ZdlPv[main] call130:free[main] call131:sub_1427E8[main] call132:dlopen[main] call133:sub_11BDA8[main] call134:sub_11BE58[main] call135:sub_11F69C[main] call136:sub_117BE0[main] call137:sub_117CA0[main] call138:fopenopen /proc/self/mapsfind /proc/self/maps, redirect to /data/data/com.oacia.apk_protect/maps_nonexistent[main] call139:sub_117E90[main] call140:sub_14285C[main] call141:sub_1429CC[main] call142:sub_11C1AC[main] call143:sub_11C1B4[main] call144:sub_11C210[keke] call145:sub_166C4[keke] call146:.puts[main] call147:sub_123324[main] call148:sub_1205A0[main] call149:sub_11F768[main] call150:memcmp[main] call151:opendir[main] call152:closedir[main] call153:sub_11859C[main] call154:sub_11C268[main] call155:sub_11C300[main] call156:sub_117B68[main] call157:sub_1186B8[main] call158:sub_143964[main] call159:sub_1B66A8[main] call160:pthread_mutex_lock[main] call161:sub_142EA0[main] call162:sub_143A38[main] call163:sub_11CF8C[main] call164:sub_131D58[main] call165:sub_1B66D0[main] call166:pthread_mutex_unlock[main] call167:sub_1178E8[main] call168:sub_13D70C[main] call169:sub_19F984[main] call170:sub_11F1C8[main] call171:atoi[main] call172:sub_12D2F8[main] call173:sub_17ABE8[main] call174:sub_172660[main] call175:sub_13BFF0[main] call176:sub_172AA4[main] call177:sub_13BD80[main] call178:sub_13BE2C[main] call179:sub_13BE4C[main] call180:memmove[main] call181:sub_13BE64[main] call182:sub_172D78[main] call183:sub_13E510[main] call184:sub_1926F0[main] call185:sub_13DB7C[main] call186:sub_1B7A08[main] call187:sub_1B7ABC[main] call188:pthread_cond_broadcastopen /proc/self/mapsfind /proc/self/maps, redirect to /data/data/com.oacia.apk_protect/maps_nonexistentopen /proc/self/mapsfind /proc/self/maps, redirect to /data/data/com.oacia.apk_protect/maps_nonexistent[main] call189:sub_12FA34[main] call190:sub_120664[main] call191:sub_1332B8[main] call192:sub_13E0F8open /proc/self/mapsfind /proc/self/maps, redirect to /data/data/com.oacia.apk_protect/maps_nonexistent[main] call193:sub_12743C[main] call194:sub_124C68[main] call195:sub_125DC4[main] call196:sub_124510[main] call197:sub_126888[main] call198:strdup[main] call199:sub_126920[main] call200:sub_122180[main] call201:sub_11BC1C[main] call202:sub_13DF34[main] call203:getpid[main] call204:memset[main] call205:snprintfopen /proc/25453/mapsfind /proc/25453/maps, redirect to /data/data/com.oacia.apk_protect/maps_nonexistent[main] call206:sub_124FA0[main] call207:sub_1B6498[main] call208:sub_1A0C88[main] call209:sub_217444[main] call210:sub_2175E0[main] call211:read[main] call212:strncmp[main] call213:close[main] call214:sub_1B578C[main] call215:j___self_lseek[main] call216:__self_lseek[main] call217:sub_1B586C[main] call218:j_j___read_self[main] call219:j___read_self[main] call220:__read_self[main] call221:sub_1B6528[main] call222:sub_1B6578[main] call223:mmap[main] call224:sub_1B5B50[main] call225:calloc[main] call226:memchr[main] call227:sub_1B5D04[main] call228:sub_1B5EC4[main] call229:sub_1B6270[main] call230:sub_1B6180[main] call231:sub_1B6678[main] call232:inflateInit2_[main] call233:inflate[main] call234:inflateEnd[main] call235:sub_1B6540[main] call236:munmap[main] call237:sub_1B56F8[main] call238:sub_19BC9C[main] call239:sub_19CCD4open /proc/self/mapsfind /proc/self/maps, redirect to /data/data/com.oacia.apk_protect/maps_nonexistent[main] call240:sub_12D470[main] call241:sub_142FE0[main] call242:sub_143008[main] call243:sub_142ABC[main] call244:sub_143848[main] call245:sub_143B48[main] call246:sub_143088[main] call247:sub_1222D0[main] call248:sub_14316C[main] call249:sub_142954[keke] call250:_Z9__arm_a_2PcmS_Rii[main] call251:sub_142894[main] call252:sub_1428BC[main] call253:sub_127DCC[main] call254:sub_14292C[main] call255:sub_121B78[main] call256:sub_121BE0[main] call257:sub_123CE8[main] call258:sub_123BC0[main] call259:sub_11959C[main] call260:sub_1AC170[main] call261:pthread_create[main] call262:sub_1AC210[main] call263:sub_1B5DE4[main] call264:sub_1B60E8[main] call265:sub_19F7C4[main] call266:sub_1B2DC8[main] call267:sub_1B1CE8open /proc/self/mapsfind /proc/self/maps, redirect to /data/data/com.oacia.apk_protect/maps_nonexistent[main] call268:sub_1B0974[main] call269:sub_1AFE6C[main] call270:sub_126ED8[main] call271:sub_1AFE8C[main] call272:sub_1AFE90[main] call273:sub_1AB87C[main] call274:sub_1B26D4[main] call275:sub_1B26F4[main] call276:sub_1B27C8[keke] call277:.ffi_prep_cif_var[keke] call278:ffi_prep_cif_var[main] call279:sub_1AAF48[main] call280:sub_1AAF54[main] call281:sub_2162D4[main] call282:sub_1B2898[main] call283:sub_1B2918[main] call284:sub_1ABE90[main] call285:sub_13E0ECProcess terminated\n\n根据对日志的分析，发现有3个函数是zlib库中用来解压缩的函数——inflateInit2_、inflate、inflateEnd，大概率是用来解压dex文件的。\n对inflateInit2_进行交叉引用，发现2个引用。\n\n根据日志，先查看sub_1B6270。\n\n\n注意到，inflate的参数是s和4。\n\n根据函数签名，可以知道s是z_streamp类型，需要在IDA中添加相应的结构体。\n\n结构体如下，Bytef可以改成Byte*，指针都是8个字节，感觉不用太担心具体类型。\n#  define z_const consttypedef unsigned char  Byte;  /* 8 bits */typedef unsigned int   uInt;  /* 16 bits or more */typedef unsigned long  uLong; /* 32 bits or more */typedef struct z_stream_s &#123;    z_const Bytef *next_in;     /* next input byte */    uInt     avail_in;  /* number of bytes available at next_in */    uLong    total_in;  /* total number of input bytes read so far */    Bytef    *next_out; /* next output byte will go here */    uInt     avail_out; /* remaining free space at next_out */    uLong    total_out; /* total number of bytes output so far */&#125; z_stream;\n\n接下来hook inflate，看看解压缩后的数据是什么，这里有个问题，在主so还没解密时是hook不了的，大佬oacia给了一个思路：哦统计inflate调用的次数，壳ELF在调用uncompress的时候会执行1次inflate，而解压dex的时候就是第2次。\n大佬的思路很好，学习到了，但是不知道为什么大佬的脚本hook的是汇编层指令的地址（可能会报错），而非函数序言地址，直接在onLeave回调时不一样可以dump和打印吗，还可以少定义一个函数。\n下面是从佬博客标注的代码，不全。\nfunction dump_memory(start,size,filename) &#123;    var file_path = &quot;/data/data/com.oacia.apk_protect/&quot; + filename;    var file_handle = new File(file_path, &quot;wb&quot;);    if (file_handle &amp;&amp; file_handle != null) &#123;        var libso_buffer = start.readByteArray(size.toUInt32());        file_handle.write(libso_buffer);        file_handle.flush();        file_handle.close();        console.log(&quot;[dump]:&quot;, file_path);    &#125;&#125;function hook_zlib_result()&#123;    var module = Process.findModuleByName(&quot;libjiagu_64.so&quot;);    Interceptor.attach(module.base.add(0x1B63F0), &#123;        // fd, buff, len        onEnter: function (args) &#123;            console.log(&quot;inflate result&quot;)            console.log(hexdump(next_in, &#123;              offset: 0,// 相对偏移              length: 0x50,//dump 的大小              header: true,              ansi: true            &#125;));            console.log(hexdump(next_out, &#123;              offset: 0,// 相对偏移              length: 0x50,//dump 的大小              header: true,              ansi: true            &#125;));            dump_memory(next_out,avail_out,&quot;dex001&quot;)        &#125;,        onLeave: function (ret) &#123;        &#125;    &#125;);&#125;var zlib_count=0;var next_in,avail_in,next_out,avail_out;function hook_zlib()&#123;    Interceptor.attach(Module.findExportByName(null, &quot;inflate&quot;), &#123;        // fd, buff, len        onEnter: function (args) &#123;            zlib_count+=1            if(zlib_count&gt;1)&#123;                hook_zlib_result();            &#125;            next_in=ptr(args[0].add(0x0).readS64());            avail_in=ptr(args[0].add(0x8).readS64());            next_out=ptr(args[0].add(0x18).readS64());            avail_out=ptr(args[0].add(0x20).readS64());            console.log(hexdump(next_in, &#123;              offset: 0,// 相对偏移              length: 0x50,//dump 的大小              header: true,              ansi: true            &#125;));            console.log(args[1]);        &#125;,        onLeave: function (ret) &#123;        &#125;    &#125;);&#125;\n\n下面是我对佬代码做的删减及必要的补充。\nfunction dump_memory(start,size,filename) &#123;    var file_path = &quot;/data/data/com.oacia.apk_protect/&quot; + filename;    var file_handle = new File(file_path, &quot;wb&quot;);    if (file_handle &amp;&amp; file_handle != null) &#123;        var libso_buffer = start.readByteArray(size.toUInt32());        file_handle.write(libso_buffer);        file_handle.flush();        file_handle.close();        console.log(&quot;[dump]:&quot;, file_path);    &#125;&#125;var zlib_count=0;var next_in,avail_in,next_out,avail_out;function hook_zlib()&#123;    Interceptor.attach(Module.findExportByName(null, &quot;inflate&quot;), &#123;        // fd, buff, len        onEnter: function (args) &#123;            zlib_count+=1            console.log(&quot;[inflate calls]&quot;, zlib_count);            next_in=ptr(args[0].add(0x0).readS64());            avail_in=ptr(args[0].add(0x8).readS64());            next_out=ptr(args[0].add(0x18).readS64());            avail_out=ptr(args[0].add(0x20).readS64());            console.log(hexdump(next_in, &#123;              offset: 0,// 相对偏移              length: 0x64,//dump 的大小              header: true,              ansi: true            &#125;));        &#125;,        onLeave: function (ret) &#123;            if(zlib_count&gt;1)&#123;                console.log(&quot;inflate result&quot;)                console.log(hexdump(next_out, &#123;                  offset: 0,// 相对偏移                  length: 0x50,//dump 的大小                  header: true,                  ansi: true                &#125;));                dump_memory(next_out,avail_out,&quot;dex001&quot;)            &#125;        &#125;    &#125;);&#125;function my_hook_dlopen(soName=&#x27;&#x27;) &#123;    Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;),        &#123;            onEnter: function (args) &#123;                var pathptr = args[0];                if (pathptr !== undefined &amp;&amp; pathptr != null) &#123;                    var path = ptr(pathptr).readCString();                    //console.log(path);                    if (path.indexOf(soName) &gt;= 0) &#123;                        this.is_can_hook = true;                    &#125;                &#125;            &#125;,            onLeave: function (retval) &#123;                if (this.is_can_hook) &#123;                    hook_proc_self_maps();                    hook_zlib();                &#125;            &#125;        &#125;    );&#125;function hook_proc_self_maps() &#123;    const openPtr = Module.getExportByName(null, &#x27;open&#x27;);    const open = new NativeFunction(openPtr, &#x27;int&#x27;, [&#x27;pointer&#x27;, &#x27;int&#x27;]);    var fakePath = &quot;/data/data/com.oacia.apk_protect/maps_nonexistent&quot;;    Interceptor.replace(openPtr, new NativeCallback(function (pathnameptr, flag) &#123;        var pathname = Memory.readUtf8String(pathnameptr);        console.log(&quot;open&quot;,pathname);//,Process.getCurrentThreadId()                if (pathname.indexOf(&quot;maps&quot;) &gt;= 0) &#123;            console.log(&quot;find&quot;,pathname+&quot;, redirect to&quot;,fakePath);            var filename = Memory.allocUtf8String(fakePath);            return open(filename, flag);        &#125;        var fd = open(pathnameptr, flag);        return fd;    &#125;, &#x27;int&#x27;, [&#x27;pointer&#x27;, &#x27;int&#x27;]));&#125;setImmediate(function()&#123;    my_hook_dlopen(&#x27;libjiagu&#x27;);&#125;);\n\n执行效果如下，解压后的数据似乎是一个dex文件？\n\n\n难蚌，为什么解压后的数据与原dex完全相同。\n\n博主根据原apk、加固后的apk，通过比较大小，发现壳dex的末尾附带了一大串加密数据，既然当前的sub_1B6270解压出了和原dex一样的数据A，说明接下来该对这个数据A的末尾进行解密了。\n观察sub_1B6270，会发现，return是用来判断函数sub_1B6270是否执行成功的。\n\n\na3将缓冲区的地址传给了s.next_out，解压后的数据在a3，缓冲区的长度为v19。\n\n\n追踪sub_1B6270，判断a3是在哪申请的缓冲区，根据日志，选择sub_1A0C88。\n\nv10拿到了装有原dex的缓冲区，然后赋给了a3。\n\n根据日志，这里选择追踪函数sub_124FA0。\n\n这里返回值用来判断是否执行成功，s1获得了原dex。\n\ns1会给v27传递一些信息，此后s1没出现过了。\n\n对sub_19BC9C进行分析。\n\n内部状态初始化：对 a1 指向的内存区域进行清零和内部指针设置。\n\nDEX文件处理：解析传入的 s1（壳dex文件），识别其具体类型（DEX, ODEX, CDEX），并调整 a1 中的指针以指向有效的DEX数据区域。这使得后续代码可以通过 a1 方便地访问DEX内容。\n\n构建JNI类型映射：在 a1 结构的某个区域（从偏移 0x138 开始）构建一个从JNI短类型签名到完整Java类名的映射表。这个映射表是执行JNI操作（如方法调用、字段访问）时进行类型匹配和转换的基础。\n\n\n 看来也没有壳dex末尾的加密数据进行解密，继续交叉引用sub_124FA0，结合日志，下一个追踪的函数是sub_1332B8。\n\n\n\n调用链应该是这样的，除此之外，暂时没什么成果。\nsub_1332B8-&gt;sub_124FA0-&gt;sub_1A0C88-&gt;sub_1B6270-&gt;inflate\n\n回到函数open打开classes.dex时的函数调用栈，如下图。\n\n\n\n\n查看函数0x19b780的引用，发现有2次引用来自sub_1332b8，根据上面2个图，结合0x134680 &#x3D;&#x3D; 0x1332b8 + 0x13c4 + 0x4和0x134598 &#x3D;&#x3D; 0x1332b8 + 0x12dC + 0x4。\n\n所以classes.dex对应的sub_19b760，在sub_1332B8+12DC处被调用。\n而classes2.dex和classes3.dex对应的sub_19b760，在subsub_1332B8+13C4处被调用。\n\n注意到，壳dex的中注入的加密数据位于0x3198h处，而大小是0x41FD18。\n\n尝试hook一下sub_19b760，观察buffer和buffer_size是否有符合壳dex末尾加密数据的特征。\n大佬没给脚本，自己写一个脚本吧。\n考虑到sub_19b760是主so中的函数，如果hook得太早，主so还没有加载，这样hook不上，甚至可能会有报错；如果hook太晚，sub_19b70可能执行完了。\n所以需要找一个时机，主so已经加载完，并且sub_19b70还没清空的时机——其实拿inflate第2次执行的时机就行。\nfunction my_hook_dlopen(soName=&#x27;&#x27;) &#123;    Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;),        &#123;            onEnter: function (args) &#123;                var pathptr = args[0];                if (pathptr !== undefined &amp;&amp; pathptr != null) &#123;                    var path = ptr(pathptr).readCString();                    //console.log(path);                    if (path.indexOf(soName) &gt;= 0) &#123;                        this.is_can_hook = true;                    &#125;                &#125;            &#125;,            onLeave: function (retval) &#123;                if (this.is_can_hook) &#123;                    hook_proc_self_maps();                    hook_zlib();                &#125;            &#125;        &#125;    );&#125;function hook_proc_self_maps() &#123;    const openPtr = Module.getExportByName(null, &#x27;open&#x27;);    const open = new NativeFunction(openPtr, &#x27;int&#x27;, [&#x27;pointer&#x27;, &#x27;int&#x27;]);    var fakePath = &quot;/data/data/com.oacia.apk_protect/maps_nonexistent&quot;;    Interceptor.replace(openPtr, new NativeCallback(function (pathnameptr, flag) &#123;        var pathname = Memory.readUtf8String(pathnameptr);        console.log(&quot;open&quot;,pathname);//,Process.getCurrentThreadId()                if (pathname.indexOf(&quot;maps&quot;) &gt;= 0) &#123;            console.log(&quot;find&quot;,pathname+&quot;, redirect to&quot;,fakePath);            var filename = Memory.allocUtf8String(fakePath);            return open(filename, flag);        &#125;        var fd = open(pathnameptr, flag);        return fd;    &#125;, &#x27;int&#x27;, [&#x27;pointer&#x27;, &#x27;int&#x27;]));&#125;var zlib_count = 0;function hook_zlib()&#123;    Interceptor.attach(Module.findExportByName(null, &quot;inflate&quot;), &#123;        // fd, buff, len        onEnter: function (args) &#123;            zlib_count = zlib_count + 1;        &#125;,        onLeave: function (ret) &#123;            // 此时的sub_19b760已经解密完成，而且没有被清空            if(zlib_count == 2)&#123;                hook_sub_19b760();            &#125;        &#125;    &#125;);&#125;function hook_sub_19b760()&#123;    const module = Process.findModuleByName(&quot;libjiagu_64.so&quot;);    console.log(&quot;[so base]&quot;, &quot;0x&quot; + module.base.toString(16))    Interceptor.attach(module.base.add(0x19b760), &#123;        onEnter: function(args)&#123;            console.log(&quot;[path]&quot;, args[0].readCString());            console.log(&quot;[buffer] size =&quot;, &quot;0x&quot;+args[2].toString(16));            console.log(hexdump(args[1], &#123;length: 64&#125;));        &#125;    &#125;)&#125;setImmediate(function()&#123;    my_hook_dlopen(&#x27;libjiagu&#x27;);&#125;);\n\n执行结果如下，可以看到，打开的classes.dex正是壳dex末尾的注入数据，连大小都是0x41fd18。\n\n在sub_1332B8中，打开了classes.dex，已经确定了sub_19B760的3个参数的内容是什么，追踪dex_buffer。\n\ndex_buffer会作为参数传递给sub_128D44。\n\n\n转到汇编层，可以看到j_interpreter_wrap_int64_t的参数不应该是0。\n\n根据寄存器的大小，修改成下面这样。\n\n接着，通过stalker_trace_so的日志可以发现，函数sub_128D44没执行。博主在这个问题上的解决办法是：在调用sub_128D44的位置，再调用一次trace_so()。\n\n博主给出了脚本的片段，如下图所示。\n\n我试验了一下，进程还是退出了，可能是我hook的时机不对，干脆先把反调过了，然后再执行stalker_trace_so，使用下面这个脚本可以找到哪里调用了pthread_create。\nfunction check_pthread_create() &#123;    var pthread_create_addr = Module.findExportByName(null, &#x27;pthread_create&#x27;);    var pthread_create = new NativeFunction(pthread_create_addr, &quot;int&quot;, [&quot;pointer&quot;, &quot;pointer&quot;, &quot;pointer&quot;, &quot;pointer&quot;]);    Interceptor.replace(pthread_create_addr, new NativeCallback(function (parg0, parg1, parg2, parg3) &#123;        var so_name = Process.findModuleByAddress(parg2).name;        var so_path = Process.findModuleByAddress(parg2).path;        var so_base = Module.getBaseAddress(so_name);        var offset = parg2 - so_base;        var PC = 0;        if ((so_name.indexOf(&quot;jiagu&quot;) &gt; -1)) &#123;            console.log(&quot;======&quot;)            console.log(&quot;find thread func offset&quot;, so_name, offset.toString(16));            Thread.backtrace(this.context, Backtracer.ACCURATE).map(addr_in_so);            var check_list = []//1769036,1771844            if (check_list.indexOf(offset)!==-1) &#123;                console.log(&quot;check bypass&quot;)            &#125; else &#123;                PC = pthread_create(parg0, parg1, parg2, parg3);            &#125;        &#125; else &#123;            PC = pthread_create(parg0, parg1, parg2, parg3);        &#125;        return PC;    &#125;, &quot;int&quot;, [&quot;pointer&quot;, &quot;pointer&quot;, &quot;pointer&quot;, &quot;pointer&quot;]))&#125;function addr_in_so(addr)&#123;    var process_Obj_Module_Arr = Process.enumerateModules();    for(var i = 0; i &lt; process_Obj_Module_Arr.length; i++) &#123;        if(addr&gt;process_Obj_Module_Arr[i].base &amp;&amp; addr&lt;process_Obj_Module_Arr[i].base.add(process_Obj_Module_Arr[i].size))&#123;            console.log(addr.toString(16),&quot;is in&quot;,process_Obj_Module_Arr[i].name,&quot;offset: 0x&quot;+(addr-process_Obj_Module_Arr[i].base).toString(16));        &#125;    &#125;&#125;setImmediate(function()&#123;    check_pthread_create();&#125;);\n\n\n\n由于无法判断是哪个线程检测了frida，这里并不方便把目标线程函数替换为空。\n先来0x17710看看，并没有看到pthread_create，这里的X24里面应该存放了pthread_create的地址。\n\n\n大佬oacia在这里写得有些模糊。这里X24不一定是pthread_create，还有可能是其它的函数，通过这种动态跳转的方式，避免在静态调试工具中暴露易被检测的函数。\n大佬在这里一个一个改x0-x6，emmm，先判断X24跳转的函数是什么，然后查看对应的寄存器会更好吧。\n这里借着大佬已经分析出的解决方案——修改x6指向的字符串，去思考为什么是修改x6。\n之前我们hook maps文件，是因为存在读maps文件的操作，但要如何逐行检测frida呢？是靠strstr吗？这里的x6说明了参数的数目之多，strstr可没那么多参数。\n我写了个脚本，hook x6寄存器，并根据x24跳转的地址，根据它的偏移量，计算跳转的目标函数是什么。\nfunction anti_frida_check() &#123;    var module = Process.findModuleByName(&quot;libjiagu_64.so&quot;);    if (!module) &#123;        // console.log(&quot;[anti_frida_check] libjiagu_64.so not found.&quot;);        return;    &#125;    Interceptor.attach(module.base.add(0x1770C), &#123;        onEnter: function (args) &#123;            try &#123;                // 确保 X6 是一个有效的指针再尝试读取                if (this.context.x6 &amp;&amp; !this.context.x6.isNull()) &#123;                    var s = null;                    try &#123;                        s = this.context.x6.readCString();                    &#125; catch (readError) &#123;                        // console.log(&quot;[anti_frida_check] Error reading string from X6: &quot; + readError.message);                        return; // 如果无法读取字符串，则不继续                    &#125;                    if (s &amp;&amp; (s.indexOf(&#x27;frida&#x27;) !== -1 ||                              s.indexOf(&#x27;gum-js-loop&#x27;) !== -1 ||                              s.indexOf(&#x27;gmain&#x27;) !== -1 ||                              s.indexOf(&#x27;linjector&#x27;) !== -1 ||                              s.indexOf(&#x27;/proc/&#x27;) !== -1)) &#123;                                                console.log(&quot;\\n==================================================&quot;);                        console.log(&quot;[+] Frida-related string detected in X6!&quot;);                        console.log(&quot;    Original string (s) from X6: \\&quot;&quot; + s + &quot;\\&quot;&quot;);                                                console.log(&quot;--- Register Dump (X0-X6) ---&quot;);                        console.log(&quot;    X0: &quot; + this.context.x0);                        console.log(&quot;    X1: &quot; + this.context.x1);                        console.log(&quot;    X2: &quot; + this.context.x2);                        console.log(&quot;    X3: &quot; + this.context.x3);                        console.log(&quot;    X4: &quot; + this.context.x4);                        console.log(&quot;    X5: &quot; + this.context.x5);                        console.log(&quot;    X6: &quot; + this.context.x6 + &quot; (Pointer value)&quot;);                        console.log(&quot;--- X24 Analysis ---&quot;);                        var x24_val = this.context.x24;                        console.log(&quot;    X24 points to address: &quot; + x24_val);                        if (x24_val &amp;&amp; !x24_val.isNull()) &#123;                            var symbolInfo = DebugSymbol.fromAddress(x24_val);                            if (symbolInfo &amp;&amp; symbolInfo.name) &#123;                                var moduleName = symbolInfo.moduleName || &quot;unknown module&quot;;                                var moduleBase = Module.findBaseAddress(moduleName) || ptr(0);                                var symbolOffset = symbolInfo.address.sub(moduleBase); // Offset of symbol from module base                                var pcOffsetFromSymbolStart = x24_val.sub(symbolInfo.address); // Offset of PC from symbol start                                console.log(&quot;    -&gt; Resolved Symbol: &quot; + symbolInfo.name);                                console.log(&quot;       Module: &quot; + moduleName + &quot; (Base: &quot; + moduleBase + &quot;)&quot;);                                console.log(&quot;       Symbol Address: &quot; + symbolInfo.address + &quot; (Offset in module: 0x&quot; + symbolOffset.toString(16) + &quot;)&quot;);                                console.log(&quot;       X24 is +0x&quot; + pcOffsetFromSymbolStart.toString(16) + &quot; bytes from symbol start.&quot;);                            &#125; else &#123;                                // 如果 DebugSymbol 未直接找到名称，尝试通过 ModuleMap 查找模块                                var moduleDetails = Process.findModuleByAddress(x24_val);                                if (moduleDetails) &#123;                                    console.log(&quot;    -&gt; Address is within module: &quot; + moduleDetails.name);                                    console.log(&quot;       Module Base: &quot; + moduleDetails.base);                                    console.log(&quot;       Offset from module base: 0x&quot; + x24_val.sub(moduleDetails.base).toString(16));                                &#125; else &#123;                                    console.log(&quot;    -&gt; Could not resolve X24 to a specific function or module.&quot;);                                &#125;                            &#125;                        &#125; else &#123;                            console.log(&quot;    -&gt; X24 is null or its value is invalid.&quot;);                        &#125;                        console.log(&quot;==================================================\\n&quot;);                    &#125;                &#125;            &#125; catch (e) &#123;                // 捕获外部 try-catch 的错误，例如 this.context 访问问题（虽然不太可能）                // console.log(&quot;[anti_frida_check] General error in onEnter: &quot; + e.message);            &#125;        &#125;,        onLeave: function (ret) &#123;        &#125;    &#125;);&#125;function my_hook_dlopen(soName = &#x27;&#x27;) &#123;    Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;),        &#123;            onEnter: function (args) &#123;                var pathptr = args[0];                if (pathptr !== undefined &amp;&amp; pathptr != null &amp;&amp; !pathptr.isNull()) &#123; // 添加 !pathptr.isNull() 检查                    var path = &quot;&quot;;                    try &#123;                        path = ptr(pathptr).readCString();                    &#125; catch (e) &#123;                        // console.log(&quot;Error reading SO path: &quot; + e.message);                        return;                    &#125;                                        if (path &amp;&amp; soName &amp;&amp; path.indexOf(soName) &gt;= 0) &#123; // 确保 soName 也有效                        this.is_can_hook = true;                    &#125;                &#125;            &#125;,            onLeave: function (retval) &#123;                if (this.is_can_hook) &#123;                    // console.log(&quot;[my_hook_dlopen] Detected &quot; + (soName || &quot;target SO&quot;) + &quot;. Attaching anti_frida_check.&quot;);                    anti_frida_check();                    this.is_can_hook = false; // 重置标志，避免重复附加                &#125;            &#125;        &#125;    );&#125;setImmediate(function() &#123;    // 你可以在这里指定要监控的 soName，例如 &#x27;libjiagu_64.so&#x27;    // 如果不指定，或者指定空字符串，my_hook_dlopen 默认的 soName=&#x27;&#x27;    // path.indexOf(&#x27;&#x27;) 总是返回0（为真），这会导致对每个dlopen都尝试设置anti_frida_check    // 建议明确指定 soName 来提高目标性，例如：    // my_hook_dlopen(&#x27;libjiagu_64.so&#x27;);     // 如果你希望保持原样，对所有SO加载（dlopen）后都调用 anti_frida_check（如果 libjiagu_64.so 已加载）    // 那么下面的调用是正确的，但请注意 anti_frida_check 内部会找 libjiagu_64.so    my_hook_dlopen(&#x27;libjiagu_64.so&#x27;); // 修改此处，明确指定目标SO，使anti_frida_check只在该SO加载后执行一次&#125;);\n\n执行结果如下，那应该很好猜了，sscanf是用来逐行解析maps文件的，然后比较对应的字段，判断是否有frida的痕迹。\n\n\n接下来，只要将x6替换掉即可，博主给出了代码，添加一下执行时机即可使用，在这里就不写了。\nfunction anti_frida_check()&#123;    var module = Process.findModuleByName(&quot;libjiagu_64.so&quot;);    Interceptor.attach(module.base.add(0x1770C), &#123;        onEnter: function (args) &#123;            try&#123;                var s = this.context.x6.readCString();                if (s.indexOf(&#x27;frida&#x27;)!==-1 ||                    s.indexOf(&#x27;gum-js-loop&#x27;)!==-1 ||                    s.indexOf(&#x27;gmain&#x27;)!==-1 ||                    s.indexOf(&#x27;linjector&#x27;)!==-1 ||                    s.indexOf(&#x27;/proc/&#x27;)!==-1)&#123;                    //console.log(s)                    Memory.protect(this.context.x0, Process.pointerSize, &#x27;rwx&#x27;);                    var replace_str=&quot;&quot;                    for(var i=0;i&lt;s.length;i++)&#123;                        replace_str+=&quot;0&quot;                    &#125;                    this.context.x0.writeUtf8String(replace_str);                &#125;            &#125;            catch (e)&#123;            &#125;        &#125;,        onLeave: function (ret) &#123;        &#125;    &#125;);&#125;\n\n\n现在再试试能不能使用stalker_trace_so追踪所有函数了。\n成功了，这回能够一直trace下去了，哈哈哈哈哈哈哈: &#x2F;\n\n顺着stalker_trace_so，沿着0x128D44继续往下分析，直到分析sub_18FEA8，这个函数内部存在大量的字符。\n先hook这个函数的参数看看。\n\n\n打印了3次，有理由去怀疑它与3个dex文件相关，感觉a1是数字、a2是地址、a3是大小，a4是地址，a5又是大小，a6暂时不知道。\n\n\n修改一下，a2和a3分别代表着解密后的dex文件和文件大小。\n\n根据oacia大佬的说明，函数sub_18FEA8里的字符串解密后，与dex文件的加载有关，这里就不深入了，主要还是关心dex文件是如何解密的。\n我还是觉得sub_128d44很可疑，只输入一个加密的dex，加密的dex又不能提取什么信息，除了解密，还能干嘛？如果要解密，必须读取加密dex，所以可以在加密dex设置读写断点。\n让gemini帮我写一个，脚本过于丑陋，就不外露了。\n下面是打印结果。\n\n注意到，打印出来的内容基都是read的操作，而没有写的操作，说明解密后的dex放到了内存的另一个地方。——20250526-20:51，明天再看，看了一天了有点累了。\n——早上好~现在是20250527-09:04，继续分析。\n通过上图的hook，可以知道libjiagu_64.so偏移0xd364的位置访问了加密dex，而且这个偏移一眼是壳代码，偏移为0xd364的指令位于函数sub_C918内。\n然而查看stalker_trace_so，发现sub_128D44后面没有跟着sub_C918，为什么？我的猜测如下：脚本hook的时机不对，frida_stalker_so hook的时机是当android_dlopen_ext检测到库libjiagu_64.so时，在onLeave回调时调用trace_so，对所有在func_addr列表上的地址进行追踪，然而，主so在没加载的时候，主so某些函数尚未解密，此时frida-stalker插的桩似乎并不有效，总之，可能会引起问题。\n尝试验证一下：在第二次inflate的时候开始执行trace_so，第二次inflate的时候，主so应该是解密完成的。\n下图是打印结果，看来猜对了。\n\n\nhook一下sub_c918，根据观察，a1总为0，a2和a3应该是地址，a4不知道是什么；而且我明明写了onLeave回调，但这里没触发，说明函数sub_C918内访问了加密dex并调用了解密函数。\n\n\nhook一下，查看执行到0xd364时，X19和X24的值。\n也就是说x19 + x24 &#x3D;&#x3D; 0x7009ee4ce4，而[0x7009ee4ce4]的值为0x707aa982e0，0x707aa982e0刚好是0x707aa872d8 + 8的位置，因此访问了加密dex的缓冲区，触发了断点。\n\n\n\n把脚本改了一下，验证一下，结果如下。\n\n和在010editor中加密dex的第2个8字节一样，说明思路是对的——但是注意，这里的汇编指令是STR W0，也就是传了4个字节，而非8个字节。\n\n光看sub_c918，没发现解密内容。\n\n\n而且似乎只访问了上图的内容，然后做了一个内存移动的操作，从将dex加密的第3个4字节从[x19, x24]移到[x19, x21]。\n\n根据stalker_frida_so，继续往下分析其它的函数，寻找加密点。\n在sub_143008发现了加解密的代码。\nvaddq_s8，批量进行加法；veorq_s8，批量进行异或。\n\n\nhook sub_143008的形参。\n\n结果如下。\n\narg1不知道是什么。\narg2指向着压缩的dex的第12个字节开始的地址。\n\narg2 &#x3D;&#x3D; 0x41e，这不正是偏移0xD364处的指令，所读取那4个字节吗？\n\n解密一下，发现是配置信息。\n\n\n解密算法是：（加密字节 + 0x70）^0x36，但这仅仅针对0x41E个字节，并不足以解密整个dex文件。\n接下来，大佬的思路是：在调用链中，发现用到了pthread_mutex_lock函数，说明有多个线程，当前的frida-stalker追踪的是某一线程，有可能是其它的线程完成了对dex的解密。\n\n\n查看sub_143848、sub_1B66A8，看看是哪个函数调用了锁。\n\n\n既然函数sub_143848涉及到锁，说明会有多个线程调用sub_143848，因此对函数sub_143848进行hook。\n照着博客的代码，改了一下脚本，追踪非主线程的线程，只trace一次。\n\n\n打印结果如下，和大佬博客的一模一样。\n\n\n然后大佬发现sub_1A1D84是一个解密函数。\n但是！其实我在主线程的trace.log中也看到了这个函数，可能是大佬没注意吧？\nsub_1A1D84是一个典型的RC4算法函数，一眼a2是密钥，a3是长度。\n\n\nhook一下，获得密钥的内容。长16字节，内容是：0x68,0x76,0x99,0x72,0x96,0x60,0x9f,0x63,0x96,0x2c,0x98,0x30,0xc2,0x36,0x51,0x42\n\n与sub_1A1D84的下一个函数调用是sub_1A1E74，明显的rc4解密。\nhook一下，查看函数sub_1A1E74在对什么进行解密。\n第一个加密内容如下所示。\n\n将f7 4f e8 0e 62 19作为搜索关键词，在壳dex中进行搜索。\n蓝色部分是不知道什么作用的8个字节，蓝色与红色直接是加密内容的长度，也就是0x10949f，红色部分是加密内容，因此，可以判断sub_1A1E74在对壳dex尾部的加密数据进行逐段解密。\n\n同时注意到，先前先加0x70，再异或0x36的加密内容，同样源于壳dex的末尾，同样前8个字节不知道是什么，然后4个字节代表加密内容大小，0x31A4 + 0x41E &#x3D;&#x3D; 0x35C2，正好是上面那段加密内容的起始部分。\n\n因此，可以猜测壳dex有多个段被加密，数据结构是这样的：不知道什么作用的8个字节 + 加密内容长度（4个字节） + 加密内容 + 不知道什么作用的8个字节…….\n计算一下下一段加密内容的起始地址：0x10949F + 0x35CE &#x3D;&#x3D; 0x10CA6D，下一个加密内容的长度是0x31a3028，这个长度明显不肯，说明关于壳dex的数据结构猜测有问题，说明存在其它的加密方式。\n\n观察我们的打印日志，只有f7 4f e8 0e 62开头encrypt_data在壳dex中，其它的加密内容，并没有出现在壳dex中。统计一下，有3个f7 4f e8 0e 62开头encrypt_data，还有3个长度为0x6400的encrypt_data，会不会代表着3个dex文件及其加密组件呢？\n\n\n把这3个内容解密看看，然而并没有出现dex的魔术。\n\n\n总结一下，这3个rc加密的内容，分别在偏移0x35CE , 0x3A93AD , 0x417064的位置。\n看了一眼博主的分析，好像确实是这样！\n所以，加密dex的数据结构应该是这个样子：未知8个字节、配置信息长度（4字节）、配置信息、加密内容个数（4个字节）、加密内容1的总长度（4个字节）、加密内容1需要rc4解密的长度（4个字节）、加密内容1、加密内容2的总长度（4个字节）、加密内容2需要rc4解密的长度（4个字节）、加密内容2、加密内容3的总长度（4个字节）、加密内容3需要rc4解密的长度（4个字节）、加密内容3。\n\n如此，便可写一个脚本，尝试把加密内容脱下来并解密，如下图所示，下图是dex1的内容，仍然是加密内容。\n\n\n跟着博主（函数调用链）继续分析，函数sub_18F6AC似乎在做解密。\n其中，a3是加密内容被rc4解密后，从0xC开始的数据地址。\n\n\n具体如下图所示。\n\n还有11个字节，在函数sub_18DCC0进行处理。以5、4、4字节的大小进行读取。\n\n以dex1.dex为例，按照这种方式进行读取的话，内容在破折号后面，记作a1、a2、a3——0x 01 00 00 00 5D、0x 00 40 00 00、0x 00 10 94 92。\na2：\n之前将加密内容分成了：1.rc4解密数据，2.未加密数据；而在更早之前，我们在hook maps文件的时候，曾获得了一个解密的dex文件，经过搜索未加密数据，发现未加密数据在dex的偏移量刚好是a2。\n以dex1.dex为例，dex1的a2是0x400000，那未加密数据的内容，在dex1.dex中需要移动到偏移量为0x400000的地方。\n下图是dex1.dex。\n\n下图是未加密数据。\n\n而a3，代表着第2次解密的长度（尚未知道是什么算法）。\n\n随后，发现了一个很关键的信息——sub_128D44的返回值是一个3级指针，指向着解密之后的dex。\n\n而且，这个dex数据的首地址是0x6ffeae3000，一般mmap申请空间才会这么规整，按照0x1000对齐来给空间。\n发现，sub_19b73c调用了mmap。\n那咱可以尝试在mmap调用完后，获得申请的空间地址，然后对这部分空间下读写断点，同时打印调用栈。\nfunction hook_mmap()&#123;    var module = Process.findModuleByName(&quot;libjiagu_64.so&quot;);    Interceptor.attach(module.base.add(0x19B81C), &#123;        // fd, buff, len        onEnter: function (args) &#123;            console.log(&quot;mmap!&quot;)            console.log(this.context.x0);            MemoryAccessMonitor.enable(                &#123;                    base:this.context.x0,                    size:30                &#125;,&#123;                    onAccess: function (details) &#123;                        console.log(details.operation)                        console.log(get_addr_in_so(details.from));                    &#125;                &#125;            )        &#125;,        onLeave: function (ret) &#123;        &#125;    &#125;);&#125;function get_addr_in_so(addr)&#123;    var process_Obj_Module_Arr = Process.enumerateModules();    for(var i = 0; i &lt; process_Obj_Module_Arr.length; i++) &#123;        if(addr&gt;process_Obj_Module_Arr[i].base &amp;&amp; addr&lt;process_Obj_Module_Arr[i].base.add(process_Obj_Module_Arr[i].size))&#123;            return addr.toString(16)+&quot; is in &quot;+process_Obj_Module_Arr[i].name+&quot; offset: 0x&quot;+(addr-process_Obj_Module_Arr[i].base).toString(16);        &#125;    &#125;    return addr.toString(16);&#125;\n\n脚本执行结果如下，可以发现调用了3次mmap，对应3个dex的映射，同时通过写断点，找到了是哪里在给这块内容进行写操作——0x18ebd4。\n\n\n定位过来，在函数sub_18E8D0内部，这个函数十分大，第2次解密算法是自定义的算法，一般自定义算法，我会通过trace，通过汇编指令逐步还原解密法。——实习还没着落，不太想花时间在这，暂时先搁置吧。\n可以猜到v15是基址，v4是游标，v28是解密后的内容。\n\n\n最后写一个脚本，判断一下这里的v28是不是解密后的dex。\n\n\n还不是dex的魔数？但发现：a1 a0 bd cf f5 f6 fd c5与c5进行异或后。\n\n原来还有一步异或。\n感想很感谢有这样的大佬愿意分享技术博客，光是复现就学到很多了，谢谢！\n从我自己的角度来说，这一次分析360免费壳真是学到了很多，不仅对动态链接的流程更加深刻了，同时开阔了眼界——还能这么玩？\n在复现的时候，对于主so的还原，我还有些思路，就算没思路了还可以看看大佬的博客；但在主dex的还原时，明显感觉到，我的分析缺乏目的性，虽然看了大佬的博客会有思路，但很多时候还是踩在巨人的肩膀上，我很难想象要是从头自己分析，要分析得有多崩溃（可能我太菜了吧）。\n总结\n数字壳的加固方案：壳DEX-&gt;壳ELF-&gt;主ELF-&gt;主DEX——具体的加固方式在上面的内容中。\n反调使用了sscanf解读maps文件，读取相应字段对frida进行检测，这算是常规操作了。\n\n不足之处1.学习如何写JEB脚本，oacia师傅写了一个JEB解密脚本，可以简单学习一下。\n# coding=utf-8from com.pnfsoftware.jeb.client.api import IScript, IconType, ButtonGroupTypefrom com.pnfsoftware.jeb.core import RuntimeProjectUtilfrom com.pnfsoftware.jeb.core.units.code.java import IJavaSourceUnitfrom com.pnfsoftware.jeb.core.units.code import ICodeUnit, ICodeItemfrom com.pnfsoftware.jeb.core.output.text import ITextDocumentfrom com.pnfsoftware.jeb.core.units.code.java import IJavaSourceUnit, IJavaStaticField, IJavaNewArray, IJavaConstant, IJavaCall, IJavaField, IJavaMethod, IJavaClassfrom com.pnfsoftware.jeb.core.events import JebEvent, Jfrom com.pnfsoftware.jeb.core.util import DecompilerHelper# 解密字符串函数的类名以及方法名methodName = [&#x27;Lcom/qihoo/util/a;&#x27;, &#x27;a&#x27;]class dec_str_360jiagu(IScript):    def run(self, ctx):        print(&#x27;start deal with strings&#x27;)        self.ctx = ctx        engctx = ctx.getEnginesContext()        if not engctx:            print(&#x27;Back-end engines not initialized&#x27;)            return        projects = engctx.getProjects()        if not projects:            print(&#x27;There is no opened project&#x27;)            return        units = RuntimeProjectUtil.findUnitsByType(projects[0], IJavaSourceUnit, False)        for unit in units:            javaClass = unit.getClassElement()            print(&#x27;[+] decrypt:&#x27; + javaClass.getName())            self.cstbuilder = unit.getFactories().getConstantFactory()            self.processClass(javaClass)            unit.notifyListeners(JebEvent(J.UnitChange))        print(&#x27;Done.&#x27;)    def processClass(self, javaClass):        if javaClass.getName() == methodName[0]:            return        for method in javaClass.getMethods():            block = method.getBody()            i = 0            while i &lt; block.size():                stm = block.get(i)                self.checkElement(block, stm)                i += 1    def checkElement(self, parent, e):        try:            if isinstance(e, IJavaCall):                mmethod = e.getMethod()                mname = mmethod.getName()                msig = mmethod.getSignature()                if mname == methodName[1] and methodName[0] in msig:                    v = []                    for arg in e.getArguments():                        if isinstance(arg, IJavaConstant):                            v.append(arg.getString())                    if len(v) == 1:                        decstr = self.decryptstring(v[0])                        parent.replaceSubElement(e, self.cstbuilder.createString(decstr))            for subelt in e.getSubElements():                if isinstance(subelt, IJavaClass) or isinstance(subelt, IJavaField) or isinstance(subelt, IJavaMethod):                    continue                self.checkElement(e, subelt)        except:            print(&#x27;error&#x27;)    def decryptstring(self, string):        src = []        for index, char in enumerate(string):            src.append(chr(ord(char) ^ 16))        return &#x27;&#x27;.join(src).decode(&#x27;unicode_escape&#x27;)\n\n2.根据大佬的博客，在attachBaseContexr中会加载DtcLoader类，jeb中没显示出来，而在jadx中显示了，这是如何做到的？这个DtcLoader做了什么？\n3.onCreate的vmp没分析。\n参考链接https://oacia.dev/360-jiagu/\n","tags":["收获颇多hhh"]},{"title":"baidu免费壳分析复现","url":"/2025/05/27/baidu%E5%85%8D%E8%B4%B9%E5%A3%B3%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0/","content":"libbaiduprotect.so加载分析通过Manifest可以看到包名和第一个加载的app类。——“com.example.test”和“com.baidu.protect.StubApplication”。\n\n在原来的lib下，多出了一个libbaiduprotect.so，而在assets下面也多了几个文件。\n\n猜测是libbaiduprotect.so将assets下的文件解密出了dex，然后进行加载。\n下面开始分析。\n根据app类的名称，找到app类，一般整体壳，app类会对attachBaseContext和onCreate进行覆写。\n先看attachBaseContext。\n\n\n其中，StubApplication.loadLibrary实际上是加载了libbaiduprotect.so，因此，接下来用ida查看libbaiduprotect.so。\n\n搜索函数“init_proc”并没有搜到，接下来查看.init_array节，存在以下在加载so阶段会执行的函数。\n\n\n先来看sub_88060，一眼混淆，本来靠着NOP，去掉了几个虚假控制流和不透明谓词，但还是太多了，直接使用d810进行处理。\n\n处理完后，算上default的话，有32个case选项，看样子是在做解密操作。\n\n再来看JNI_OnLoad，会发现被加密了，可以猜到是sub_88060对它进行了加密。\n\n下面是一个frida脚本，用于在sub_88060解完密后，第一时间dump整个so。\n// 要hook的函数offsetvar offset = 0x88060;// so文件的大小var module_size = 0;// 要hook的so的名字var module_name = &quot;libbaiduprotect.so&quot;;function hook_linker_call_constructors() &#123;    // 获得linker64的地址    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;)    let offset_call = 0x51BA8    // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset_call)    let listener = Interceptor.attach(call_constructors,&#123;        onEnter:function(args)&#123;            // 判断是否可以通过findModuleByName查找到目标so文件            console.log(&#x27;[linker] Call_Constructors onEnter&#x27;)            let secmodule = Process.findModuleByName(module_name);            if (secmodule != null)&#123;                module_size = secmodule.size;                // 第一时间hook                hook_target_func(secmodule.base);                listener.detach();            &#125;        &#125;    &#125;)&#125;function hook_target_func(baseaddr)&#123;    let listener = Interceptor.attach(baseaddr.add(offset), &#123;        onEnter:function(args)&#123;        &#125;,        onLeave:function(retval)&#123;            // 在执行完某个函数后，立马进行dump            dump(baseaddr, module_size);            listener.detach();        &#125;    &#125;);&#125;function dump(begin_addr, dump_size)&#123;    console.log(&quot;[name] &quot;, module_name);    console.log(&quot;[base] &quot;, begin_addr);    console.log(&quot;[size] &quot;, &quot;0x&quot; + dump_size.toString(16));    var file_path = &quot;/data/data/com.example.test/zzc_&quot; + begin_addr + &quot;_0x&quot; + dump_size.toString(16) + &quot;.so&quot;;    var file_handle = new File(file_path, &quot;wb&quot;);    if (file_handle &amp;&amp; file_handle != null) &#123;        Memory.protect(ptr(begin_addr), dump_size, &#x27;rwx&#x27;);        var libso_buffer = ptr(begin_addr).readByteArray(dump_size);        file_handle.write(libso_buffer);        file_handle.flush();        file_handle.close();        console.log(&quot;[dump] &quot;, file_path);    &#125;&#125;setImmediate(hook_linker_call_constructors)\n\n将dump下来的so文件，通过soFixer进行修复。\nSoFixer-Windows-64.exe -s .\\zzc_0x6f7471a000_0xc1000.so -o .\\zzc_0x6f7471a000_0xc1000.sofixer.so -m 0x6f7471a000 -d\n\n可以看到，JNI_OnLoad已经恢复正常了。\n\n接下来看其它的在.init_array上的函数（在加密so的中查看）。\n查看sub_6FC4。\n\n可以看出来，qword_28c28s是一个函数指针，它在解密后面那一串内容。\n\n点开地址28c28的位置，发现存在加密的内容。\n\n\n这说明这个函数也需要得到解密，那就只能是在sub_88060里了，去另一个解密的so文件看一眼，发现果然解密了。\n\n\n通过hook解密后的sub_28c28，可以得到解密字符串，脚本如下。\n// 要hook的函数offsetvar offset = 0x88060;// so文件的大小var module_size = 0;// 要hook的so的名字var module_name = &quot;libbaiduprotect.so&quot;;function hook_linker_call_constructors() &#123;    // 获得linker64的地址    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;)    let offset_call = 0x51BA8    // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset_call)    let listener = Interceptor.attach(call_constructors,&#123;        onEnter:function(args)&#123;            // 判断是否可以通过findModuleByName查找到目标so文件            console.log(&#x27;[linker] Call_Constructors onEnter&#x27;)            let secmodule = Process.findModuleByName(module_name);            if (secmodule != null)&#123;                module_size = secmodule.size;                // 第一时间hook                hook_target_func(secmodule.base);                listener.detach();            &#125;        &#125;    &#125;)&#125;function hook_target_func(baseaddr)&#123;    let listener = Interceptor.attach(baseaddr.add(offset), &#123;        onEnter:function(args)&#123;        &#125;,        onLeave:function(retval)&#123;            // 第一个函数解密完后，才能hook sub_28c28            decrypt_28c28(baseaddr);            listener.detach();        &#125;    &#125;);&#125;function decrypt_28c28(baseaddr)&#123;        Interceptor.attach(baseaddr.add(0x28c28), &#123;            onEnter:function(args)&#123;                console.log(&quot;[sub_28c28] &quot;, &quot;arg = &quot;, ptr(args[0]).readCString());            &#125;, onLeave:function(retval)&#123;                console.log(&quot;[sub_28c28] &quot;, &quot;retval = &quot;, ptr(retval).readCString());            &#125;        &#125;)&#125;setImmediate(hook_linker_call_constructors)\n\n执行的结果如下。\n\n\n写了一个ida脚本，给这些字符串的地方添加注释。\nimport idaapiimport idautils# 加密/明文映射mappings = &#123;    &quot;710E34DFB3D273975E0936FBB4CF62BE541F3CC4A8&quot;: &quot;FeatureLibcProtection&quot;,    &quot;530A39DDAFCB39A84E1821CEAB8F52BE4F3B34DFAEEC7FA843&quot;: &quot;dalvik/system/DexPathList&quot;&#125;# 函数列表（地址或函数名）func_list = [    0x28c28]def find_string_addr(search_str):    &quot;&quot;&quot;查找字符串的地址&quot;&quot;&quot;    for addr in idautils.Strings():        if str(addr) == search_str:            return addr.ea    return Nonedef resolve_func_addr(func_entry):    &quot;&quot;&quot;将函数名或地址转换为地址&quot;&quot;&quot;    if isinstance(func_entry, int):        return func_entry    elif isinstance(func_entry, str):        func_addr = idaapi.get_name_ea_simple(func_entry)        if func_addr == idaapi.BADADDR:            print(f&quot;Function not found: &#123;func_entry&#125;&quot;)            return None        return func_addr    else:        print(f&quot;Invalid function entry: &#123;func_entry&#125;&quot;)        return Nonedef add_comments_to_strings():    &quot;&quot;&quot;为 .rodata 中的字符串添加解密注释和重命名&quot;&quot;&quot;    for encrypted, decrypted in mappings.items():        str_addr = find_string_addr(encrypted)        if str_addr:            idaapi.set_cmt(str_addr, f&quot;Decrypted: &#123;decrypted&#125;&quot;, 0)            # 重命名字符串，替换特殊字符以符合命名规则            safe_name = f&quot;str_&#123;decrypted.replace(&#x27;/&#x27;, &#x27;_&#x27;).replace(&#x27; &#x27;, &#x27;_&#x27;)&#125;&quot;            idaapi.set_name(str_addr, safe_name, idaapi.SN_FORCE)            print(f&quot;Added comment at 0x&#123;str_addr:x&#125;: &#123;encrypted&#125; -&gt; &#123;decrypted&#125;&quot;)        else:            print(f&quot;String not found in .rodata: &#123;encrypted&#125;&quot;)def add_comments_to_function(func_addr):    &quot;&quot;&quot;为指定函数添加注释，扫描加载字符串的指令&quot;&quot;&quot;    func = idaapi.get_func(func_addr)    if not func:        print(f&quot;Function at 0x&#123;func_addr:x&#125; not found or invalid&quot;)        return    # 添加函数注释    func_name = idaapi.get_func_name(func_addr)    idaapi.set_func_cmt(func_addr, f&quot;Decrypts strings (e.g., &#123;&#x27;, &#x27;.join(f&#x27;&#123;k&#125;-&gt;&#123;v&#125;&#x27; for k, v in mappings.items())&#125;)&quot;, 1)    print(f&quot;Processing function: &#123;func_name&#125; at 0x&#123;func_addr:x&#125;&quot;)    # 扫描函数指令，查找加载字符串的指令    for ea in idautils.FuncItems(func.start_ea):        disasm = idaapi.generate_disasm_line(ea, 0)        if &quot;LDR&quot; in disasm:  # 检查加载指令            for enc, dec in mappings.items():                if enc in disasm:                    idaapi.set_cmt(ea, f&quot;Loads &#123;enc&#125; -&gt; &#123;dec&#125;&quot;, 0)                    print(f&quot;Added comment at 0x&#123;ea:x&#125;: &#123;enc&#125; -&gt; &#123;dec&#125;&quot;)def main():    &quot;&quot;&quot;主函数：处理字符串和函数列表&quot;&quot;&quot;    # 处理 .rodata 中的字符串    print(&quot;Processing strings in .rodata...&quot;)    add_comments_to_strings()    # 处理函数列表    print(&quot;\\nProcessing functions...&quot;)    for func_entry in func_list:        func_addr = resolve_func_addr(func_entry)        if func_addr is not None:            add_comments_to_function(func_addr)        else:            print(f&quot;Skipping invalid function: &#123;func_entry&#125;&quot;)# 执行脚本if __name__ == &quot;__main__&quot;:    main()\n\nida脚本的执行情况如下，自动添加注释并对字符串重命名。\n\n回到sub_6FC4的位置，710….代表FeatureLibcProtection。\n\n函数sub_3E590也被加密了，通过解密的so文件查看，它似乎是在赋值？a1是一个全局变量，a2是解密后的字符串，a3是1，似乎是一个索引。\n\n\nBB9B0是一个函数指针，存放着的内容是sub_811B8的地址（也就是811B8）。\n\n这里创建一个结构体，由于函数指针和字符串指针都是指针，这里定义为__int64*。\n\n结构就比较容易懂了。\n\n因此，sub_6FC4可以理解为在做函数注册。\n\n会根据index，在对应的槽位注册。\n\n\n根据分析，注册了8个函数。\n\n\n整理一下，注册关系大致如下。\nsub_B3B4 -&gt; 索引1 -&gt; global_func_list[1]。\nsub_3E29C -&gt; 索引3 -&gt; global_func_list[3]。\nsub_40CF8 -&gt; 索引6 -&gt; global_func_list[6]。\nsub_3DFC4 -&gt; 索引7 -&gt; global_func_list[7]。\nsub_11F5C -&gt; 索引8 -&gt; global_func_list[8]。\nsub_45964 -&gt; 索引9 -&gt; global_func_list[9]。\nsub_3E96C -&gt; 索引10 -&gt; global_func_list[10]。\nsub_42388 -&gt; 索引13 -&gt; global_func_list[13]。\n之后开始分析JNI_onLoad，由于加密的so中，JNI_onLoad没有解密，所以这里根据解密的so的JNI_onLoad进行分析。\n\n\n上来就看到一大堆混淆，用d810处理一下。\n可能是由于从内存中dump出来的缘故，反汇编伪代码的效果不是很好，连vm都看不到在哪里使用了。\n\n\n先看sub_91D8，十分眼熟，+48，基本可以确认a1是JNIEnv*的类型了。\n\n\n\n\n之后再看sub_7BC4，槽位0是经过初始化的，但没存前面的函数（应该被sub_82254初始化了），如果0号元素的内容为空，则调用sub_3E5A8进行清空。\n\n\n\n\n所以，可以把函数sub_7BC4理解为，判断函数是否注册完毕。\n接着看函数sub_3E628，没搞明白v11、v12在做什么，但能看得出来，是在调用函数列表里的函数，第一个参数是自己的地址，第二个参数是1（JNI_OnLoad传入的a2）。\n\n先来观察函数列表的index为1的函数sub_B3B4。\n\n\n如果a2不为1，直接返回，说明sub_B3B4只接受a2&#x3D;&#x3D;1的情况。\n\nsub_B3B4对很多字符串进行了解密，同时连接了很多字符串。\n\n\n配合着脚本，实现了对这些字符串的解密。\n// 要hook的函数offsetvar offset = 0x88060;// so文件的大小var module_size = 0;// 要hook的so的名字var module_name = &quot;libbaiduprotect.so&quot;;// 解密函数的偏移列表（从 sub_28AD0 到 sub_28A24）var decrypt_offsets = [    0x28AD0, 0x25E78, 0x25F24, 0x25FD0, 0x2607C, 0x26128, 0x261D4, 0x26280,    0x2632C, 0x263D8, 0x26484, 0x26530, 0x265DC, 0x26688, 0x26734, 0x267E0,    0x2688C, 0x26938, 0x269E4, 0x26A90, 0x26B3C, 0x26BE8, 0x26C94, 0x26D40,    0x26DEC, 0x26E98, 0x26F44, 0x26FF0, 0x2709C, 0x27148, 0x271F4, 0x272A0,    0x2734C, 0x273F8, 0x274A4, 0x27550, 0x275FC, 0x276A8, 0x27754, 0x27800,    0x278AC, 0x27958, 0x27A04, 0x27AB0, 0x27B5C, 0x27C08, 0x27CB4, 0x27D60,    0x27E0C, 0x27EB8, 0x27F64, 0x28010, 0x280BC, 0x28168, 0x28214, 0x282C0,    0x2836C, 0x28418, 0x284C4, 0x28570, 0x2861C, 0x286C8, 0x28774, 0x28820,    0x288CC, 0x28A24];function hook_linker_call_constructors() &#123;    // 获得linker64的地址    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;);    let offset_call = 0x51BA8;    // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset_call);    let listener = Interceptor.attach(call_constructors, &#123;        onEnter: function(args) &#123;            // 判断是否可以通过findModuleByName查找到目标so文件            console.log(&#x27;[linker] Call_Constructors onEnter&#x27;);            let secmodule = Process.findModuleByName(module_name);            if (secmodule != null) &#123;                module_size = secmodule.size;                // 第一时间hook                hook_target_func(secmodule.base);                listener.detach();            &#125;        &#125;    &#125;);&#125;function hook_target_func(baseaddr) &#123;    let listener = Interceptor.attach(baseaddr.add(offset), &#123;        onEnter: function(args) &#123;            console.log(&quot;[target_func] onEnter, offset:&quot;, offset.toString(16));        &#125;,        onLeave: function(retval) &#123;            console.log(&quot;[target_func] onLeave, retval:&quot;, retval);            // 第一个函数解密完后，Hook 所有解密函数            hook_decrypt_funcs(baseaddr);            listener.detach();        &#125;    &#125;);&#125;function hook_decrypt_funcs(baseaddr) &#123;    // Hook sub_28C28（保持原有逻辑）    Interceptor.attach(baseaddr.add(0x28C28), &#123;        onEnter: function(args) &#123;            console.log(&quot;[sub_28C28] arg =&quot;, ptr(args[0]).readCString());        &#125;,        onLeave: function(retval) &#123;            console.log(&quot;[sub_28C28] retval =&quot;, ptr(retval).readCString());        &#125;    &#125;);    // 循环 Hook 所有解密函数    decrypt_offsets.forEach(function(offset) &#123;        let func_name = &quot;sub_&quot; + offset.toString(16).toUpperCase();        Interceptor.attach(baseaddr.add(offset), &#123;            onEnter: function(args) &#123;                console.log(&quot;[&quot; + func_name + &quot;] arg =&quot;, ptr(args[0]).readCString());            &#125;,            onLeave: function(retval) &#123;                console.log(&quot;[&quot; + func_name + &quot;] retval =&quot;, ptr(retval).readCString());            &#125;        &#125;);    &#125;);&#125;setImmediate(hook_linker_call_constructors);\n\n用ida进行修改并添加注释。\nimport idaapiimport idautils# 加密/明文映射（从 Frida 输出中提取）mappings = &#123;    &quot;710E34DFB3D273975E0936FBB4CF62BE541F3CC4A8&quot;: &quot;FeatureLibcProtection&quot;,    &quot;530A39DDAFCB39A84E1821CEAB8F52BE4F3B34DFAEEC7FA843&quot;: &quot;dalvik/system/DexPathList&quot;,    &quot;3D7CDAABED5340D60976CFBAFB5560E80D70C9B0F64C40E80F&quot;: &quot;FeatureProtectEnvironment&quot;,    &quot;5227DBB22926DA554467C6EF2433D6524567F7&quot;: &quot;com/baidu/protect/A&quot;,    &quot;14D64606364E3C6D&quot;: &quot;unknown&quot;,    &quot;5A483597E76FC0D170423682FE54CBF073&quot;: &quot;FeatureGlobalInfo&quot;,    &quot;47986CBE0A46F6EE6F8968AD0D5DE7DE429568A914&quot;: &quot;FeatureIntegrityCheck&quot;,    &quot;5227DBB22926DA554467C6EF2433D6524567F5EF2A34DB795026D2F12E35&quot;: &quot;com/baidu/protect/CrashHandler&quot;,    &quot;02D740473B583B0914975D1A364D370E15976F&quot;: &quot;com/baidu/protect/B&quot;,    &quot;0406D0C873B03D581246CD957EA5315F1346FC9761983A5A08&quot;: &quot;com/baidu/protect/AppInfo&quot;,    &quot;C7D432A325E854F696D43CFF27BF03F7&quot;: &quot;c07954f5209e7c14&quot;,    &quot;67C538FE4857A6C4309F39AB4B06A5C5&quot;: &quot;f8547c5c1b4a426b&quot;,    &quot;260714BFA582481D715D15EAA6D34B1C785B43B8F385444A705E15EAF3D54C4B&quot;: &quot;f8547c5c1b4a426b8db3ad940a4aa415&quot;,    &quot;57585C810030ABC6530C06D65363FF9C545A5CD60367A9CD545400D45430A8C9&quot;: &quot;359b71797ac5dbcc07954f5209e7c146&quot;,    &quot;7E6EA364435927F7&quot;: &quot;.suuid&quot;,    &quot;3148B69D4B47B331&quot;: &quot;&quot;,    &quot;61B82D685939526D&quot;: &quot;&quot;,    &quot;065A40FFE793182D255C54F9FB95042D0474&quot;: &quot;FeatureSecuritySDK&quot;,    &quot;1901FAF72A31D21E5D29D8FA6408D15B542BC2A6100BD950472999F12A29D41E7E2ADCF82833881867&quot;: &quot;(ILjava/lang/Object;[Ljava/lang/Object;)V&quot;,    &quot;49F16102384F33420DD9430F7676300704DB59530275380C17D90204385735422EDA470D3A4D69443B&quot;: &quot;(ILjava/lang/Object;[Ljava/lang/Object;)Z&quot;,    &quot;4F20F18D70A735130B08D3803E9E3656020AC9DC4A9D3E5D1108928B70BF3313280BD78272A56F1525&quot;: &quot;(ILjava/lang/Object;[Ljava/lang/Object;)B&quot;,    &quot;8CAD49F071AA53ECC8856BFD3F9350A9C18771A14B9058A2D2852AF671B255ECEB866FFF73A809EAE7&quot;: &quot;(ILjava/lang/Object;[Ljava/lang/Object;)C&quot;,    &quot;29B441A01E42F2886D9C63AD507BF1CD649E79F12478F9C6779C22A61E5AF4884E9F67AF1C40A88E52&quot;: &quot;(ILjava/lang/Object;[Ljava/lang/Object;)S&quot;,    &quot;68766DE1F3971C512C5E4FECBDAE1F14255C55B0C9AD171F365E0EE7F38F1A510F5D4BEEF195465709&quot;: &quot;(ILjava/lang/Object;[Ljava/lang/Object;)I&quot;,    &quot;4C2429895677FDD0080C0B84184EFE95010E11D86C4DF69E120C4A8F566FFBD02B0F0F865475A7D62E&quot;: &quot;(ILjava/lang/Object;[Ljava/lang/Object;)J&quot;,    &quot;78549A7B4B4B46D83C7CB8760572459D357EA22A71714D96267CF97D4B5340D81F7FBC7449491CDE16&quot;: &quot;(ILjava/lang/Object;[Ljava/lang/Object;)F&quot;,    &quot;8F4502F0DDCDC5C2CB6D20FD93F4C687C26F3AA1E7F7CE8CD16D61F6DDD5C3C2E86E24FFDFCF9FC4E3&quot;: &quot;(ILjava/lang/Object;[Ljava/lang/Object;)D&quot;,    &quot;A34B5090CFED8214E763729D81D48151EE6168C1F5D7895AFD633396CFF58414C460769FCDEFD812C7687D8CCFB48F5AE56533B5CCF18658FF39&quot;: &quot;(ILjava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;&quot;,    &quot;2E68C02CC53A063D255DD337C42D001F0162CF&quot;: &quot;FeatureVMProtection&quot;,    &quot;F48398ED31542B0E&quot;: &quot;libc.so&quot;,    &quot;6E2DCEF43F47B331&quot;: &quot;_exit&quot;,    &quot;04C0441C5939526D&quot;: &quot;exit&quot;,    &quot;171DD59574B03063041BD88665B4&quot;: &quot;pthread_create&quot;,    &quot;D4906DE875BD569CCE8B6CF4&quot;: &quot;pthread_join&quot;,    &quot;6C9860A90F4D93A7&quot;: &quot;memcpy&quot;,    &quot;2D5E4DE7FD827D7E&quot;: &quot;malloc&quot;,    &quot;070C098F58629CFF&quot;: &quot;calloc&quot;,    &quot;3D78BB624F4927F7&quot;: &quot;memset&quot;,    &quot;C1633EFFD2BBA4ED&quot;: &quot;fopen&quot;,    &quot;ED617095DDFEE33B&quot;: &quot;fclose&quot;,    &quot;E24E68C72ED3BB4E&quot;: &quot;fgets&quot;,    &quot;4EFE6FC425A325B6&quot;: &quot;strtoul&quot;,    &quot;30640DB4A5A47CCE&quot;: &quot;strtoull&quot;,    &quot;59CA0B1C240EE666&quot;: &quot;strstr&quot;,    &quot;B3783A25593967C1&quot;: &quot;ptrace&quot;,    &quot;715D268CE678C6E2&quot;: &quot;mprotect&quot;,    &quot;678568CC1272D9F4&quot;: &quot;strlen&quot;,    &quot;4333E40A59E92B6B&quot;: &quot;sscanf&quot;,    &quot;20C396763EB607CE&quot;: &quot;free&quot;,    &quot;59EFF51F63070DB8&quot;: &quot;strdup&quot;,    &quot;1B79D33BDD38636B&quot;: &quot;strcmp&quot;,    &quot;11EDA0D862CA71BA0FE9&quot;: &quot;strcasecmp&quot;,    &quot;AD1C8CA1863C3CF3&quot;: &quot;utime&quot;,    &quot;7F7567B6D496D9AC&quot;: &quot;mkdir&quot;,    &quot;3F4E6764B2499D86&quot;: &quot;open&quot;,    &quot;7838B71CCAAF75C6&quot;: &quot;close&quot;,    &quot;04B2CD050F9C47EE&quot;: &quot;unlink&quot;,    &quot;086DDAAB98212586&quot;: &quot;stat&quot;,    &quot;E2292D97D01141B6&quot;: &quot;time&quot;,    &quot;6E4AC4CB291788D4&quot;: &quot;snprintf&quot;,    &quot;302FD3054ECECD91&quot;: &quot;strchr&quot;,    &quot;C65AB9D5625867A8&quot;: &quot;strncmp&quot;,    &quot;0C8A9ABA3559D876189B86A93350&quot;: &quot;pthread_detach&quot;,    &quot;B4D5455E4F6B8C3BB7C4414A&quot;: &quot;pthread_self&quot;,    &quot;A832C433D41105B4&quot;: &quot;opendir&quot;,    &quot;63C7D8A1855BE1D1&quot;: &quot;readdir&quot;,    &quot;DD596595BC74408E&quot;: &quot;closedir&quot;,    &quot;711BD780E966683E&quot;: &quot;mmap&quot;,    &quot;3B70EDB05642EDB6&quot;: &quot;munmap&quot;,    &quot;31F4B35BA15DF8D9&quot;: &quot;lseek&quot;,    &quot;3A7B1DDB8EAEEB3C&quot;: &quot;fstat&quot;,    &quot;2DC5B93C51DE4E8C&quot;: &quot;read&quot;,    &quot;CD3E5AC4CE4EB523&quot;: &quot;select&quot;,    &quot;9C6E379605B933C39F71&quot;: &quot;bsd_signal&quot;,    &quot;C489B09443666A3D&quot;: &quot;fork&quot;,    &quot;266DF31562D26748&quot;: &quot;prctl&quot;,    &quot;176E4794FD670E8110&quot;: &quot;setrlimit&quot;,    &quot;50660A65A953F202&quot;: &quot;getppid&quot;,    &quot;9B333E341D4B67D8&quot;: &quot;getpid&quot;,    &quot;68D77BE990FA40DB&quot;: &quot;waitpid&quot;,    &quot;03B093571B66B5A9&quot;: &quot;kill&quot;,    &quot;75F6DC484BF43E44&quot;: &quot;flock&quot;,    &quot;795BD9475A856CF3&quot;: &quot;write&quot;,    &quot;BE66196673ACF758&quot;: &quot;execve&quot;,    &quot;296C25084100FFA8&quot;: &quot;execv&quot;,    &quot;164C148245E50A35&quot;: &quot;execl&quot;,    &quot;FEF19D484641B9EC&quot;: &quot;sysconf&quot;,    &quot;E215844F2E808FC7E23A85592D9198DEC415905329&quot;: &quot;__system_property_get&quot;,    &quot;C033AAA8B3EE1BBFC3&quot;: &quot;ftruncate&quot;,    &quot;D818528B9AD01DD0&quot;: &quot;gettid&quot;,    &quot;2E1331FA88B61B58&quot;: &quot;pread64&quot;,    &quot;8F6EB5FBB011CE0A&quot;: &quot;pwrite64&quot;,    &quot;3DFBFF6E535AF038&quot;: &quot;pread&quot;,    &quot;B2D06CEC09B428DF&quot;: &quot;pwrite&quot;,    &quot;326FA0A56FCADBAB&quot;: &quot;statvfs&quot;,    &quot;09598DD611D1543C&quot;: &quot;n001&quot;,    &quot;8CA86FFB66BD1DAFC58A62B543A840AACA833ED67ABD44A28B8864F477F361B7D68D6BFD2B9058A2D2852AF671B255ECF79077F37EBB098FCE8573FB3FB053ADC3CB56EE62B55CA49FAD5FB346&quot;: &quot;(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;IZ)V&quot;,    &quot;6FCD3DF87F3493A7&quot;: &quot;n002&quot;,    &quot;687340E5F6931217241042E4FC951810341062E4FC951806340408DD&quot;: &quot;(Landroid/content/Context;)V&quot;,    &quot;0A5D55D037019CFF&quot;: &quot;n003&quot;,    &quot;783480112A3D27F7&quot;: &quot;()V&quot;,    &quot;226212F6FEFC669A22&quot;: &quot;arm64-v8a&quot;,    &quot;4819CF8872FE27590B0F928A70A127&quot;: &quot;/proc/self/maps&quot;,    &quot;D6E4059A10DC32C3&quot;: &quot;r&quot;,    &quot;6D946FAE0959BDD46E&quot;: &quot;libdvm.so&quot;,    &quot;2C5643EAE095530D2F&quot;: &quot;libart.so&quot;,    &quot;080407955A6AF59B3B01008E4273B28C0B&quot;: &quot;libvmkid_lemur.so&quot;,    &quot;3C74B470455E09843F&quot;: &quot;libaoc.so&quot;,    &quot;54AFA16C61F747EE&quot;: &quot;%s&quot;,    &quot;44CB02463B5D3E0202D3&quot;: &quot;%s/.bdlock&quot;,    &quot;050301915868F8D007020B97526FE8D014004AB05E66F29E10181786&quot;: &quot;android/content/pm/Signature&quot;,    &quot;3173B263455443D83372B8654F5353D82070F9414B5E4C9637789F7F4C52&quot;: &quot;android/content/pm/PackageInfo&quot;,    &quot;C6622AE8D3D2C0C2C46320EED9D5D0C2D76161CADDD8CF8CC06903FBD2DAC388D5&quot;: &quot;android/content/pm/PackageManager&quot;,    &quot;EA6C7888C1F28714EA726CD5EFF89752FD6B6883FAF3915EEA66&quot;: &quot;android/app/ActivityThread&quot;,    &quot;E54769C132BADF61E5597D9C1EBCD53AE15179FA30A3D7&quot;: &quot;android/app/ContextImpl&quot;,    &quot;5AEF69E333A53DD350C972DE3EB331C2&quot;: &quot;getSystemContext&quot;,    &quot;6B3933A1A4B562CD2A7450A1BAA13FE12C7E0BA5B2A559CF337C44&quot;: &quot;()Landroid/app/ContextImpl;&quot;,    &quot;49CB0B1D3512922749CA101939089F3242CC1C0E34&quot;: &quot;currentActivityThread&quot;,    &quot;EB250425543815AEAA6867254A2C4880A078213253281E95AB7E2D255E67&quot;: &quot;()Landroid/app/ActivityThread;&quot;,    &quot;7B4820B3F37ECEF77B481982FC7CC2F36E&quot;: &quot;getPackageManager&quot;,    &quot;3CD856C11978AB9B7D9535C31872AD917A8535D01A338995779A7BC71251B89A75967FD24C&quot;: &quot;()Landroid/content/pm/PackageManager;&quot;,    &quot;5725F33B56EC400A5725CE0551E0&quot;: &quot;getPackageInfo&quot;,    &quot;6EFD997248D728A227DF943C6DC275A728D6C85A17FA66A022C39C7A5A9964A128C5967D4A9977A369E1927055D760AB0FDF957C05&quot;: &quot;(Ljava/lang/String;I)Landroid/content/pm/PackageInfo;&quot;,    &quot;59F2E015770378CA4FE8&quot;: &quot;signatures&quot;,    &quot;3341C036D43A0C020C22C237DE3C06051C22D1359F1B0A0C066CD52DC22D58&quot;: &quot;[Landroid/content/pm/Signature;&quot;,    &quot;16F690C277DC55AB10F8AB&quot;: &quot;toByteArray&quot;,    &quot;F041BE8EE33C3CF3&quot;: &quot;()[B&quot;,    &quot;376D2CF19796D9AC&quot;: &quot;%s/.1&quot;,    &quot;754D2D248366B8F5&quot;: &quot;%s/.1/%s&quot;,    &quot;EA6C7888C1F28714E47133B8DBF28F5F&quot;: &quot;android/os/Build&quot;,    &quot;C96649F611D3BB4E&quot;: &quot;MODEL&quot;,    &quot;71E07CC62BF925D753ED32E33EA420D85AB1&quot;: &quot;Ljava/lang/String;&quot;,    &quot;E67F6728533E67C1&quot;: &quot;%s/lib&quot;,    &quot;395E7BCDB779A596&quot;: &quot;%s/.%d&quot;,    &quot;758269C5036FF69675987ED5076EB68071926E851332B39566&quot;: &quot;assets/baiduprotect%d.jar&quot;,    &quot;1F71A90156FD2B6B&quot;: &quot;/1.jar&quot;,    &quot;69D29F724DC562BD68DB9261&quot;: &quot;/classes.jar&quot;,    &quot;05F8EB1A650468CB04FFE203&quot;: &quot;/classes.dex&quot;,    &quot;4769C02CD167070A1C6C8E7DC3674D4E0C22C234D13B100E1B23CB39C2&quot;: &quot;/data/data/%s/.%d/classes.jar&quot;,    &quot;4DFDB3CF629670B816F8FD9E70963AFC06B6B1D762CA67BC11B7B6DE7B&quot;: &quot;/data/data/%s/.%d/classes.dex&quot;,    &quot;0DD14F092B4D300C12DD031B36&quot;: &quot;libartbase.so&quot;,    &quot;1E38C4F22868C0545D2E99F02A37C0&quot;: &quot;/proc/self/maps&quot;,    &quot;13B82D685939526D&quot;: &quot;r&quot;,    &quot;1544909711D1543C&quot;: &quot;r--p&quot;,    &quot;819725BF63FC17E9D7C420B063FC17E9D7C420E9&quot;: &quot;%s %s %*s %*s %*s %s&quot;,    &quot;73D075BA7F3493A7&quot;: &quot;r-xp&quot;,    &quot;FBBB64F474AE5DAAC0BB69F5778342B1CD8A71&quot;: &quot;__android_log_print&quot;,    &quot;2D5240FB92E17D7E&quot;: &quot;mmap&quot;,    &quot;503BC5F83F349C535021D2E83B35DC45542BC2B82F69D95043&quot;: &quot;assets/baiduprotect%d.jar&quot;,    &quot;0900049337019CFF&quot;: &quot;mmap&quot;,    &quot;D2290DB35DD3BB4E&quot;: &quot;V&quot;,    &quot;678A1DB04AD649B6&quot;: &quot;Z&quot;,    &quot;01107FC0CAD110A2&quot;: &quot;B&quot;,    &quot;69BE796F507CE666&quot;: &quot;C&quot;,    &quot;900C48443A5C67C1&quot;: &quot;S&quot;,    &quot;552D54E3921DA596&quot;: &quot;I&quot;,    &quot;5EF11AA0771CD9F4&quot;: &quot;J&quot;,    &quot;7640876B378F2B6B&quot;: &quot;F&quot;,    &quot;02B1F3133EB607CE&quot;: &quot;D&quot;,    &quot;669B877B16770DB8&quot;: &quot;L&quot;,    &quot;6A0EB69D4B47B331&quot;: &quot;[F&quot;,    &quot;3AFC2D685939526D&quot;: &quot;[D&quot;,    &quot;0D08CB863EBD35520046FF887EBD315D09&quot;: &quot;java/lang/Boolean&quot;,    &quot;CE8573FB3FB053ADC3CB47E364B9&quot;: &quot;java/lang/Byte&quot;,    &quot;6B9C7BAB5058F2C966D24EA21E46F2C475987F&quot;: &quot;java/lang/Character&quot;,    &quot;2A5E57EABD8D1C10271072E3FD9309&quot;: &quot;java/lang/Short&quot;,    &quot;0E0C1382186DFD9103422C8D4364FB9A16&quot;: &quot;java/lang/Integer&quot;,    &quot;3A7CA0700551469937329A7E445A&quot;: &quot;java/lang/Long&quot;,    &quot;CD6D38FB93D7C583C02308F6D3DAD0&quot;: &quot;java/lang/Float&quot;,    &quot;E1636A9B81F78255EC2D5895DBF98F5E&quot;: &quot;java/lang/Double&quot;,    &quot;EE487BD272BFDA20E30642D137B6D83A&quot;: &quot;java/lang/Object&quot;,    &quot;01E373D93EE849B6&quot;: &quot;&lt;init&gt;&quot;,    &quot;6B4A5696CAD110A2&quot;: &quot;(Z)V&quot;,    &quot;16D717062442E666&quot;: &quot;&lt;init&gt;&quot;,    &quot;EB4E61123A5C67C1&quot;: &quot;(B)V&quot;,    &quot;20443A8AE623A596&quot;: &quot;&lt;init&gt;&quot;,    &quot;3CB233F6771CD9F4&quot;: &quot;(C)V&quot;,    &quot;0C29E90243B12B6B&quot;: &quot;&lt;init&gt;&quot;,    &quot;6EE2DA453EB607CE&quot;: &quot;(S)V&quot;,    &quot;16F2E91262490DB8&quot;: &quot;&lt;init&gt;&quot;,    &quot;4044880EB048636B&quot;: &quot;(I)V&quot;,    &quot;5EF0BCD2778714D9&quot;: &quot;&lt;init&gt;&quot;,    &quot;F022CC9AE33C3CF3&quot;: &quot;(J)V&quot;,    &quot;2E776DB6D2A8D9AC&quot;: &quot;&lt;init&gt;&quot;,    &quot;78782B5CB2499D86&quot;: &quot;(F)V&quot;,    &quot;273DB606DB9175C6&quot;: &quot;&lt;init&gt;&quot;,    &quot;5998883A61F747EE&quot;: &quot;(D)V&quot;,    &quot;1976D4B3FD404BD01A75CEBA&quot;: &quot;booleanValue&quot;,    &quot;BE691AF2D01141B6&quot;: &quot;()Z&quot;,    &quot;7F5DC0DC161890C778&quot;: &quot;byteValue&quot;,    &quot;6B72E36626BCCD91&quot;: &quot;()B&quot;,    &quot;D646AAC957547BDDD0&quot;: &quot;charValue&quot;,    &quot;54D7B1C85038BC29&quot;: &quot;()C&quot;,    &quot;B7C9425E5E5C8908B1C4&quot;: &quot;shortValue&quot;,    &quot;EF6BF25DB07877B4&quot;: &quot;()S&quot;,    &quot;78CCCD93805EE6B4&quot;: &quot;intValue&quot;,    &quot;961C43E6D91029FC&quot;: &quot;()I&quot;,    &quot;7019D897BF07044B79&quot;: &quot;longValue&quot;,    &quot;7E2CC9DD3732EDB6&quot;: &quot;()J&quot;,    &quot;3BEBB95FBE0B99B528E2&quot;: &quot;floatValue&quot;,    &quot;74212FBAFAAEEB3C&quot;: &quot;()F&quot;,    &quot;3BCFAD3A3DBB18ED33D5BD&quot;: &quot;doubleValue&quot;,    &quot;967272A1AD3AB523&quot;: &quot;()D&quot;,    &quot;947C25A859BC35C3993200BD04B93ACA&quot;: &quot;java/lang/String&quot;,    &quot;CB88B69A31086A3D&quot;: &quot;intern&quot;,    &quot;7E36DC0B6FA406673A7EFE062181133A3F71F75A&quot;: &quot;()Ljava/lang/String;&quot;,    &quot;0406D0C873B03D581246C59479B831500346DC843E891C&quot;: &quot;com/baidu/xshield/ac/XH&quot;,    &quot;8CA864F474AE5DAAC0CB66F57EA857ADD0CB46F57EA857BBD0DF49F071AA53ECC8856BFD3F8F46B1CD8A62A15CB653B5C5CB69FB7EBB1D90D0966CF477E7698A8DB2&quot;: &quot;(Landroid/content/Context;Ljava/lang/String;Ljava/lang/String;[I)V&quot;,    &quot;689364BE7F3493A7&quot;: &quot;init&quot;,    &quot;503BC5F83F349C535021D2E83B35DC45542BC2B326&quot;: &quot;assets/baiduprotect.m&quot;,    &quot;44CB2D685939526D&quot;: &quot;%s&quot;,    &quot;3E27F603C0CC1EC6&quot;: &quot;%s.lock&quot;&#125;# 函数列表（从 Frida 输出中提取涉及的函数地址）func_list = [    0x28C28,  # sub_28C28    0x2709C,  # sub_2709C    0x25E78,  # sub_25E78    0x25F24,  # sub_25F24    0x25FD0,  # sub_25FD0    0x2607C,  # sub_2607C    0x26128,  # sub_26128    0x261D4,  # sub_261D4    0x26280,  # sub_26280    0x2632C,  # sub_2632C    0x263D8,  # sub_263D8    0x26484,  # sub_26484    0x26BE8,  # sub_26BE8    0x28AD0   # sub_28AD0]def find_string_addr(search_str):    &quot;&quot;&quot;查找字符串的地址&quot;&quot;&quot;    for addr in idautils.Strings():        if str(addr) == search_str:            return addr.ea    return Nonedef resolve_func_addr(func_entry):    &quot;&quot;&quot;将函数名或地址转换为地址&quot;&quot;&quot;    if isinstance(func_entry, int):        return func_entry    elif isinstance(func_entry, str):        func_addr = idaapi.get_name_ea_simple(func_entry)        if func_addr == idaapi.BADADDR:            print(f&quot;Function not found: &#123;func_entry&#125;&quot;)            return None        return func_addr    else:        print(f&quot;Invalid function entry: &#123;func_entry&#125;&quot;)        return Nonedef add_comments_to_strings():    &quot;&quot;&quot;为 .rodata 中的字符串添加解密注释和重命名&quot;&quot;&quot;    for encrypted, decrypted in mappings.items():        str_addr = find_string_addr(encrypted)        if str_addr:            idaapi.set_cmt(str_addr, f&quot;Decrypted: &#123;decrypted&#125;&quot;, 0)            # 重命名字符串，替换特殊字符以符合命名规则            safe_name = f&quot;str_&#123;decrypted.replace(&#x27;/&#x27;, &#x27;_&#x27;).replace(&#x27; &#x27;, &#x27;_&#x27;).replace(&#x27;(&#x27;, &#x27;_&#x27;).replace(&#x27;)&#x27;, &#x27;_&#x27;).replace(&#x27;;&#x27;, &#x27;_&#x27;).replace(&#x27;[&#x27;, &#x27;_&#x27;).replace(&#x27;]&#x27;, &#x27;_&#x27;)&#125;&quot;            idaapi.set_name(str_addr, safe_name, idaapi.SN_FORCE)            print(f&quot;Added comment at 0x&#123;str_addr:x&#125;: &#123;encrypted&#125; -&gt; &#123;decrypted&#125;&quot;)        else:            print(f&quot;String not found in .rodata: &#123;encrypted&#125;&quot;)def add_comments_to_function(func_addr):    &quot;&quot;&quot;为指定函数添加注释，扫描加载字符串的指令&quot;&quot;&quot;    func = idaapi.get_func(func_addr)    if not func:        print(f&quot;Function at 0x&#123;func_addr:x&#125; not found or invalid&quot;)        return    # 添加函数注释    func_name = idaapi.get_func_name(func_addr)    idaapi.set_func_cmt(func_addr, f&quot;Decrypts strings (e.g., &#123;&#x27;, &#x27;.join(f&#x27;&#123;k&#125;-&gt;&#123;v&#125;&#x27; for k, v in list(mappings.items())[:5])&#125;...)&quot;, 1)    print(f&quot;Processing function: &#123;func_name&#125; at 0x&#123;func_addr:x&#125;&quot;)    # 扫描函数指令，查找加载字符串的指令    for ea in idautils.FuncItems(func.start_ea):        disasm = idaapi.generate_disasm_line(ea, 0)        if &quot;LDR&quot; in disasm:  # 检查加载指令            for enc, dec in mappings.items():                if enc in disasm:                    idaapi.set_cmt(ea, f&quot;Loads &#123;enc&#125; -&gt; &#123;dec&#125;&quot;, 0)                    print(f&quot;Added comment at 0x&#123;ea:x&#125;: &#123;enc&#125; -&gt; &#123;dec&#125;&quot;)def main():    &quot;&quot;&quot;主函数：处理字符串和函数列表&quot;&quot;&quot;    # 处理 .rodata 中的字符串    print(&quot;Processing strings in .rodata...&quot;)    add_comments_to_strings()    # 处理函数列表    print(&quot;\\nProcessing functions...&quot;)    for func_entry in func_list:        func_addr = resolve_func_addr(func_entry)        if func_addr is not None:            add_comments_to_function(func_addr)        else:            print(f&quot;Skipping invalid function: &#123;func_entry&#125;&quot;)# 执行脚本if __name__ == &quot;__main__&quot;:    main()\n\n效果如下。\n\n由于解密我在hook的脚本里，设置第一个参数是字符串，而在sub_b3b4中，有些解密函数的参数是字节码，因此还需要补充5个解密函数的hook。\n// 要 hook 的 so 文件名字var module_name = &quot;libbaiduprotect.so&quot;;// so 文件的大小var module_size = 0;// 默认的目标函数偏移var target_offset = 0x88060;// 需要 hook 的字节码解密函数偏移列表var bytecode_decrypt_offsets = [    0x267e0, 0x26A90, 0x27550, 0x27800, 0x28418];// Hook linker64 的 call_constructors，检测目标 so 文件加载function hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;);    let offset_call = 0x51BA8; // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset_call);    let listener = Interceptor.attach(call_constructors, &#123;        onEnter: function(args) &#123;            console.log(&#x27;[linker] Call_Constructors onEnter&#x27;);            let secmodule = Process.findModuleByName(module_name);            if (secmodule != null) &#123;                module_size = secmodule.size;                // 第一时间 hook 目标函数                hook_target_func(secmodule.base);                listener.detach();            &#125;        &#125;    &#125;);&#125;// Hook 目标函数（触发后续字节码解密函数的 hook）function hook_target_func(baseaddr) &#123;    let listener = Interceptor.attach(baseaddr.add(target_offset), &#123;        onEnter: function(args) &#123;            console.log(&quot;[target_func] onEnter, offset: 0x&quot; + target_offset.toString(16));        &#125;,        onLeave: function(retval) &#123;            console.log(&quot;[target_func] onLeave, retval: &quot; + retval);            // 在目标函数退出时，hook 所有字节码解密函数            hook_bytecode_decrypt_funcs(baseaddr);            listener.detach();        &#125;    &#125;);&#125;// Hook 指定的字节码解密函数function hook_bytecode_decrypt_funcs(baseaddr) &#123;    bytecode_decrypt_offsets.forEach(function(offset) &#123;        let func_name = &quot;sub_&quot; + offset.toString(16).toUpperCase();        Interceptor.attach(baseaddr.add(offset), &#123;            onEnter: function(args) &#123;                let input_ptr = args[0]; // 捕获输入指针（指向字节数组）                console.log(&quot;[&quot; + func_name + &quot;] Input pointer: &quot; + input_ptr);                                // 读取以 0x00 结尾的字节数组                let bytes = [];                let i = 0;                while (true) &#123;                    let byte = Memory.readU8(input_ptr.add(i));                    if (byte === 0x00) break; // 遇到 0x00 停止                    bytes.push(byte.toString(16));                    i++;                &#125;                console.log(&quot;[&quot; + func_name + &quot;] Input bytes: &quot; + bytes.join(&quot;, &quot;));            &#125;,            onLeave: function(retval) &#123;                // 捕获返回值（解密后的字符串）                let output_str = retval.readCString();                console.log(&quot;[&quot; + func_name + &quot;] Output string: &quot; + output_str);            &#125;        &#125;);    &#125;);&#125;// 主逻辑：启动 hooksetImmediate(hook_linker_call_constructors);\n\n看得出来，sub_b3b4负责解密字符串，因此改名成这个。\n\n接下来看其它的函数，根据分析，当a2&#x3D;&#x3D;1时，只执行sub_B3B4。\n\n\n回到JNI_OnLoad，继续分析sub_91E4。\n\n\n可以看出来，在进行JNI动态注册，所以给它改了些函数名及变量名。\n\n回到JNI_OnLoad，我一直很好奇剩下的fread是什么东西？下图是别人对同样的so文件的分析，它这里伪代码是gettimeofday，那就很好理解了，在计算时间差，一般计算时间差是为了反调试，博主说这里只是收集信息。\n\n接下来可以分析第a2&#x3D;&#x3D;2的时候，会调用什么内容。\n\n已知B3B4只当a2&#x3D;&#x3D;1时才调用，这里从3E29C开始分析。\n\n\n直接分析3E36C。\n\n\n再进入3E3F0。\n\n\n3E3F0这两个函数很奇怪，似乎是我dump出现了点bug？\n\n和博主dump下来的so不太一样呢。\n\n用博主的图来讲函数3E3F0，大概是通过&#x2F;proc&#x2F;self&#x2F;maps获取进程虚拟机类型。\n\n这样子分析下去有点难受，我重新dump了一个，还是这样子，难道是壳做了什么手脚？——保留疑惑。看了一下修复的soFixer，它github写着。——阿这。\n\n之后换了一个so修复的程序，需要自己编译。\n链接：https://github.com/maiyao1988/elf-dump-fix\n再次查看3e3f0，这回终于没问题了。\n\n\n继续看函数列表，发现当a2&#x3D;&#x3D;2时，只执行了3E29C。\n\n\n总结至此，libbaiduprotect.so加载完了，总结一下：\n\n在.init_array的sub_88060进行解密，对so里的一些关键函数进行恢复。\n下述这些函数，统统在全局函数列表处进行注册添加，等待调用。\n\n\n\n\n在JNI_OnLoad处。\nsub_B3B4（a2&#x3D;&#x3D;1）解密了一些libc常用的函数地址，存在全局变量中。\n\n\nsub_91E4处，进行JNI动态注册，注册了n001、n002、n003共3个JNI函数。\n\nsub_3E29C（a2&#x3D;&#x3D;2）执行了下面的内容，获取最大IO向量数量并获得虚拟机类型。\n\n\n\nJNI函数分析（attachBaseContext&#x2F;onCreate）n001Java层的n001，对应于sub_91E4注册的3个函数的第1个函数。\n通过分析，得知n001属于类com.baidu.protect.A。\n\n\n然后在com.baidu.protect.StubApplication类的attachBaseContext中进行调用。\n\n接下来进入native层进行分析。\n首先简单的改了一下名字和类型。\n\n\n下图中，还原了一些函数名。\n\n\n先来分析sub_95B4。\n下面两个图中，可以看到函数sub_968C的参数列表不一样。\n\n\n\n\n在sub_95B4调用sub_968C的地方，进入汇编层分析。\n可以看到，前sub_968C的前两个参数是sub_9584的前两个参数，而X2 &#x3D; X19 + X1 &#x3D; strlen(X1) + X1，因此，sub_968C的参数列表应该是3个参数，第3个参数是a2字符串的结束地址。\n\n\n修改后是这样。\n\n\n进入sub_968C进行分析，修改了一些变量名后，如下图所示。\n它大致是一个管理缓冲区的函数，将字符串复制到目标缓冲区，并防止缓冲区溢出，重命名为buffer_manager。\n\n回到n001的JNI函数，继续往下分析，尝试hook decrypt_str2，观察返回值。\n\nhook的脚本如下。\n// 要 hook 的 so 文件名字var module_name = &quot;libbaiduprotect.so&quot;;// so 文件的大小var module_size = 0;// 默认的目标函数偏移var target_offset = 0x88060;// 需要 hook 的字节码解密函数偏移列表var bytecode_decrypt_offsets = [    0x95F4];// Hook linker64 的 call_constructors，检测目标 so 文件加载function hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;);    let offset_call = 0x51BA8; // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset_call);    let listener = Interceptor.attach(call_constructors, &#123;        onEnter: function(args) &#123;            console.log(&#x27;[linker] Call_Constructors onEnter&#x27;);            let secmodule = Process.findModuleByName(module_name);            if (secmodule != null) &#123;                module_size = secmodule.size;                // 第一时间 hook 目标函数                hook_target_func(secmodule.base);                listener.detach();            &#125;        &#125;    &#125;);&#125;// Hook 目标函数（触发后续字节码解密函数的 hook）function hook_target_func(baseaddr) &#123;    let listener = Interceptor.attach(baseaddr.add(target_offset), &#123;        onEnter: function(args) &#123;            console.log(&quot;[target_func] onEnter, offset: 0x&quot; + target_offset.toString(16));        &#125;,        onLeave: function(retval) &#123;            console.log(&quot;[target_func] onLeave, retval: &quot; + retval);            // 在目标函数退出时，hook 所有字节码解密函数            hook_bytecode_decrypt_funcs(baseaddr);            listener.detach();        &#125;    &#125;);&#125;// Hook 指定的字节码解密函数function hook_bytecode_decrypt_funcs(baseaddr) &#123;    bytecode_decrypt_offsets.forEach(function(offset) &#123;        let func_name = &quot;sub_&quot; + offset.toString(16).toUpperCase();        Interceptor.attach(baseaddr.add(offset), &#123;            onEnter: function(args) &#123;                let input_ptr = args[0]; // 捕获输入指针（指向字节数组）                console.log(&quot;[&quot; + func_name + &quot;] Input pointer: &quot; + input_ptr);                                // 读取以 0x00 结尾的字节数组                let bytes = [];                let i = 0;                while (true) &#123;                    let byte = Memory.readU8(input_ptr.add(i));                    if (byte === 0x00) break; // 遇到 0x00 停止                    bytes.push(byte.toString(16));                    i++;                &#125;                console.log(&quot;[&quot; + func_name + &quot;] Input bytes: &quot; + bytes.join(&quot;, &quot;));            &#125;,            onLeave: function(retval) &#123;                // 捕获返回值（解密后的字符串）                let output_str = retval.readCString();                console.log(&quot;[&quot; + func_name + &quot;] Output string: &quot; + output_str);            &#125;        &#125;);    &#125;);&#125;// 主逻辑：启动 hooksetImmediate(hook_linker_call_constructors);\n\n打印的结果如下。\n\n打印了几个字符串，BCDB0[0]的值是BE660，因此可以确定，&#x2F;data&#x2F;user&#x2F;0&#x2F;com.example.test是我们要找的解密字符串。\n\n\n之后又调用函数sub_95FC。\n\n在这个函数中，创建了文件&#x2F;data&#x2F;user&#x2F;0&#x2F;com.example.test&#x2F;.bdlock，然后通过flock函数上锁（文件锁）。更名为open_and_lock。\n\n之后再分析sub_781C，又有混淆，通过d810去一下混淆，又调用函数列表，这回调用a2&#x3D;&#x3D;3的情况。\n\n\n观察函数列表的函数，先整理出有哪些函数当a2&#x3D;&#x3D;3的时候执行。\n\n\n经过整理，会执行3E29C、40CF8（与java层传入的arg5有关）、3DFC4、11F5C、45964。\nsub_3E29C(a2&#x3D;&#x3D;3)先分析3E29C。\n查看call_funcs_list，传入的参数为：a1是函数列表，a2是3，a3是env。\n\n\n进入sub_13880进行查看。\n\n解密了很多系统库中的函数名，通过JNI进行调用。\n这一块代码有点怪，v29应该传入getPackageInfo的函数参数里的，可以从汇编看看。\n\n如下图所示，应该有5个参数。（arm64支持X0-X7传递参数）\n\n但这里不能修改一下callxxxxx的函数签名，因为他是一个不定长的函数调用。但我们知道，a2是一个字符串（包名，稍微追踪一下，发现是在JNI_OnLoad赋值的，当时没改名字，现在苦苦分析）。\n\n\nflags的值是0x40，代表返回PackageInfo的PackageInfo对象，包含签名信息。（如果不填0x40，返回的PackageInfo对象中的signatures字段将会是null）\n继续分析，为他们修改注释和变量名。\n\n进入sub_3AE58，直接返回16字节，有点像md5的初始化常量。\n\n借助大模型的力量，我成功识别了md5的相关函数，不过也说明了算法是我的薄弱点，得找时间好好看看。\n\n\n分析完了，sub_13880的行为：根据签名数组的第0个签名生成md5，赋值给a3并返回。\n\n接着看sub_66064。\n在sub_65E94中，会根据md5的值，在result地址+8的为止，根据md5，累积异或产生了16个新字节（假如记作buf1）。\n在sub_64A50中，result将指向ptr_result+1的位置，也就是result &#x3D; buf1，然后在sub_64A50中，根据buf1的最后4个字节，又生成了160个字节，也就是说，result指向的字节数组大小为176。\n因此，将sub_66064命名为md5_extend_176。\n\n整理一下，sub_3E29C得到了一个md5和一个基于md5的176字节。\nsub_40cf8(a2&#x3D;&#x3D;3)继续看，下一个看40CF8——3E29C、40CF8（与java层传入的arg5有关）、3DFC4、11F5C、45964。\n\n这里的BCE28，和n001传入的arg5有关。\n\n\n为了确定这个值，尝试hook一下Java层的n001，脚本如下。\nfunction hook_n001()&#123;    Java.perform(function()&#123;        var clazz_A = Java.use(&quot;com.baidu.protect.A&quot;);        clazz_A.n001.implementation = function(arg0, arg1, arg2, arg3, arg4, arg5)&#123;            console.log(&quot;[arg0] &quot;, arg0);            console.log(&quot;[arg1] &quot;, arg1);            console.log(&quot;[arg2] &quot;, arg2);            console.log(&quot;[arg3] &quot;, arg3);            console.log(&quot;[arg4] &quot;, arg4);            console.log(&quot;[arg5] &quot;, arg5);            var result = this.n001(arg0,arg1,arg2,arg3,arg4,arg5);            return result;        &#125;    &#125;)&#125;setImmediate(hook_n001);\n\n结果如下。\n\n从调用的地方可以猜到含义，分别代表着：包名、app名、apk路径、数据路径、sdk版本、是否报崩溃的错误。\n\n回到40CF8，这回知道了off_BCE28的含义了，用来判断是否上报crash信息的，那40CF8的这段代码，应该是用来处理崩溃信息上传的？\n在调用call_funcs_list这个函数中，调用函数列表每个函数的传参方式是：函数地址、a2、env、a4、a5、a6。（a3就是env）\n\n因此，在40CF8中，sub_409E0和sub_40F38的传参就好懂了。\n\n\n先进入409E0，修改a2的类型，看样子是注册了两个函数。\n\n\n交叉引用qword_BE808，找到它赋值的位置，发现它是一个之前的解密字符串，“com&#x2F;baidu&#x2F;protect&#x2F;CrashHandler”。\n\n鉴于sub_7398、sub_409E0等函数还存在字符串未解密，这里先把它们的解密字符串收集起来，就不提供脚本了，脚本都大差不差。\n回到409e0。\n有些搞不明白这里的v10与v11的关系，v11按理来说应该是异常的回调函数，但这里的写法我确实没看懂。\n总之，sub_409E0动态注册了com.baidu.protect.CrashHandler.a()和com.baidu.protect.CrashHandler.b(Ljava&#x2F;lang&#x2F;String)。\n同时，注册了一个统一的自定义处理函数sub_40bd0，负责处理异常。\n综上所述，直接将这个函数改名成处理异常。\n\n回到40cf8，这个函数在a2&#x3D;&#x3D;3时，做了下面的操作，接着看下一个函数列表的函数。\n\nsub_3DFC4(a2&#x3D;&#x3D;3)该看3DFC4了——3E29C、40CF8（与java层传入的arg5有关）、3DFC4、11F5C、45964。\n先将a3的类型改为JNIEnv*，然后尝试阅读一下代码。\n\n这一个函数的难度，比我想象中难很多啊，博客说，3D6AC是3DFC4的关键函数…点进去一看，不知道3D6AC在做什么，ptr_buf的大小是0x13E80，不妨hook sub_3d6ac，观察结束后，ptr_buf的内容是多少。\n\n脚本如下。\n// Frida脚本：hexdump sub_3D6AC的第一个参数ptr_buf// 1. 请将 &quot;libyourtarget.so&quot; 替换为目标SO文件的实际名称const TARGET_MODULE_NAME = &quot;libbaiduprotect.so&quot;;// 2. 这是 sub_3D6AC 函数在SO文件中的偏移地址//    如果 &quot;sub_3D6AC&quot; 是一个导出的函数名，你可以尝试使用 Module.findExportByName()//    但通常这种 &quot;sub_XXXXX&quot; 格式的名称是IDA反编译后基于地址命名的，所以使用偏移量更可靠。const FUNCTION_OFFSET = 0x3D6AC; // 函数 sub_3D6AC 的偏移地址// 3. ptr_buf 指向的内存区域大小const BUFFER_SIZE = 0x13e80;// (可选) 你想在hexdump中实际打印的最大字节数，以防BUFFER_SIZE过大导致控制台输出混乱// 如果你想打印全部内容，可以将MAX_DUMP_SIZE设置为BUFFER_SIZEconst MAX_DUMP_SIZE = Math.min(BUFFER_SIZE); // 例如，最多打印1024字节function hook_linker_call_constructors() &#123;    // 获得linker64的地址    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;);    let offset_call = 0x51BA8;    // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset_call);    let listener = Interceptor.attach(call_constructors, &#123;        onEnter: function(args) &#123;            // 判断是否可以通过findModuleByName查找到目标so文件            console.log(&#x27;[linker] Call_Constructors onEnter&#x27;);            let secmodule = Process.findModuleByName(TARGET_MODULE_NAME);            if (secmodule != null) &#123;                // 第一时间hook                hook_target_func(secmodule.base);                listener.detach();            &#125;        &#125;    &#125;);&#125;function hook_target_func(baseaddr)&#123;    let listener = Interceptor.attach(baseaddr.add(0x88060), &#123;        onEnter:function(args)&#123;        &#125;,        onLeave:function(retval)&#123;            // 第一个函数解密完后，才能hook sub_28c28            main(baseaddr);            listener.detach();        &#125;    &#125;);&#125;function main(base) &#123;    const moduleBase = base;    if (!moduleBase) &#123;        console.error(&quot;[-] 模块 &quot; + TARGET_MODULE_NAME + &quot; 未找到。请确保模块名正确且已加载。&quot;);        return;    &#125;    const targetFunctionAddr = moduleBase.add(FUNCTION_OFFSET);    console.log(&quot;[+] 目标函数 sub_3D6AC 地址: &quot; + targetFunctionAddr);    console.log(&quot;[+] ptr_buf 大小: 0x&quot; + BUFFER_SIZE.toString(16) + &quot; (&quot; + BUFFER_SIZE + &quot; bytes)&quot;);    console.log(&quot;[+] hexdump 将显示最多: 0x&quot; + MAX_DUMP_SIZE.toString(16) + &quot; (&quot; + MAX_DUMP_SIZE + &quot; bytes)&quot;);    Interceptor.attach(targetFunctionAddr, &#123;        onEnter: function(args) &#123;            // args[0] 是第一个参数 (__int64 a1, 即 ptr_buf)            // args[1] 是第二个参数 (JNIEnv *env)            this.ptr_buf = args[0]; // 保存 ptr_buf 的指针以在 onLeave 中使用            this.jniEnv = args[1];  // 保存 JNIEnv 指针            console.log(&quot;\\n[*] 进入 sub_3D6AC:&quot;);            console.log(&quot;    ptr_buf (a1): &quot; + this.ptr_buf);            console.log(&quot;    JNIEnv* (a2): &quot; + this.jniEnv);        &#125;,        onLeave: function(retval) &#123;            console.log(&quot;[*] 离开 sub_3D6AC. 返回值: &quot; + retval);            if (this.ptr_buf &amp;&amp; !this.ptr_buf.isNull()) &#123;                console.log(&quot;[+] ptr_buf (&quot; + this.ptr_buf + &quot;) 内容 (前 &quot; + MAX_DUMP_SIZE + &quot; 字节):&quot;);                try &#123;                    // Memory.readByteArray(pointer, length) 返回一个 ArrayBuffer                    const bufferContent = Memory.readByteArray(this.ptr_buf, Math.min(BUFFER_SIZE, MAX_DUMP_SIZE));                    console.log(hexdump(bufferContent, &#123;                        offset: 0,                        length: Math.min(BUFFER_SIZE, MAX_DUMP_SIZE), // 确保hexdump长度与读取长度一致                        header: true,                        ansi: true // 如果你的控制台支持，可以开启颜色高亮                    &#125;));                    // 如果你想保存整个缓冲区到文件（这部分比较复杂，通常建议在PC端Python脚本中处理）                    // 你可以在这里发送 bufferContent (或者 this.ptr_buf 和 BUFFER_SIZE) 到你的Python脚本                    // 例如: send(&#123; ptr: this.ptr_buf.toString(), size: BUFFER_SIZE &#125;);                    // 然后在Python端接收并保存：                    // def on_message(message, data):                    //     if message[&#x27;type&#x27;] == &#x27;send&#x27;:                    //         payload = message[&#x27;payload&#x27;]                    //         ptr = int(payload[&#x27;ptr&#x27;], 16)                    //         size = payload[&#x27;size&#x27;]                    //         print(f&quot;Receiving buffer from &#123;hex(ptr)&#125; with size &#123;size&#125;&quot;)                    //         buffer_data = process.read_bytes(ptr, size)                    //         with open(f&quot;ptr_buf_dump_&#123;hex(ptr)&#125;.bin&quot;, &quot;wb&quot;) as f_out:                    //             f_out.write(buffer_data)                    //         print(f&quot;Buffer dumped to ptr_buf_dump_&#123;hex(ptr)&#125;.bin&quot;)                    // script.on(&#x27;message&#x27;, on_message)                &#125; catch (e) &#123;                    console.error(&quot;[-] 读取或hexdump ptr_buf 时发生错误: &quot; + e);                    console.error(&quot;    错误详情: &quot; + e.stack);                &#125;            &#125; else &#123;                console.warn(&quot;[-] ptr_buf 在 onLeave 时为 null 或无效。&quot;);            &#125;            console.log(&quot;--- 结束 sub_3D6AC 打印 ---&quot;);        &#125;    &#125;);&#125;// 确保在Java环境准备好后执行main函数，尤其是在attach模式下早期hook时// 对于 Android SO 文件中的函数，通常直接调用 main() 即可，// 或者使用 setImmediate(main) 来确保主循环已准备好setImmediate(hook_linker_call_constructors);// 或者对于某些情况，特别是应用启动非常早期的hook，可能需要等待Java VM加载完毕// Java.perform(function() &#123;//     console.log(&quot;[+] Java VM 已加载，开始执行 main()&quot;);//     main();// &#125;);\n\n打印的结果如下图所示，文件还挺大的。\n\n回到3DFC4，验证一下我们之前的分析，第0x721个元素存放了目录路径的个数。0x721 x 4 &#x3D; 0x1C84，因此到0x1C84去读取个数。\n\n读4个字节，02 00 00 00，即为2。因此会创建2个文件夹，再来到第0x744个元素（也就是0x744 x 4 &#x3D; 0x1D10），去读取目录字符串。\n\n也就是说，第一个目录字符串的地址存放再0x7969adfcc0处，下一个地址则是0x7969adfd20。\n\n要获取这2个字符串，即去读取ptr_buf + 0x1D10和ptr_buf + 0x1D40，修改一下脚本。\nconst TARGET_MODULE_NAME = &quot;libbaiduprotect.so&quot;;const FUNCTION_OFFSET = 0x3D6AC;const BUFFER_SIZE = 0x13e80;const MAX_DUMP_SIZE = Math.min(BUFFER_SIZE);function hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;);    let offset_call = 0x51BA8; // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset_call);    let listener = Interceptor.attach(call_constructors, &#123;        onEnter: function(args) &#123;            console.log(&#x27;[linker] Call_Constructors onEnter&#x27;);            let secmodule = Process.findModuleByName(TARGET_MODULE_NAME);            if (secmodule != null) &#123;                hook_target_func(secmodule.base);                listener.detach();            &#125;        &#125;    &#125;);&#125;function hook_target_func(baseaddr) &#123;    let listener = Interceptor.attach(baseaddr.add(0x88060), &#123;        onEnter: function(args) &#123;&#125;,        onLeave: function(retval) &#123;            main(baseaddr);            listener.detach();        &#125;    &#125;);&#125;function main(base) &#123;    const moduleBase = base;    if (!moduleBase) &#123;        console.error(&quot;[-] 模块 &quot; + TARGET_MODULE_NAME + &quot; 未找到。请确保模块名正确且已加载。&quot;);        return;    &#125;    const targetFunctionAddr = moduleBase.add(FUNCTION_OFFSET);    console.log(&quot;[+] 目标函数 sub_3D6AC 地址: &quot; + targetFunctionAddr);    console.log(&quot;[+] ptr_buf 大小: 0x&quot; + BUFFER_SIZE.toString(16) + &quot; (&quot; + BUFFER_SIZE + &quot; bytes)&quot;);    console.log(&quot;[+] hexdump 将显示最多: 0x&quot; + MAX_DUMP_SIZE.toString(16) + &quot; (&quot; + MAX_DUMP_SIZE + &quot; bytes)&quot;);    Interceptor.attach(targetFunctionAddr, &#123;        onEnter: function(args) &#123;            this.ptr_buf = args[0]; // 保存 ptr_buf 的指针            this.jniEnv = args[1];  // 保存 JNIEnv 指针            console.log(&quot;\\n[*] 进入 sub_3D6AC:&quot;);            console.log(&quot;    ptr_buf (a1): &quot; + this.ptr_buf);            console.log(&quot;    JNIEnv* (a2): &quot; + this.jniEnv);        &#125;,        onLeave: function(retval) &#123;            console.log(&quot;[*] 离开 sub_3D6AC. 返回值: &quot; + retval);            if (this.ptr_buf &amp;&amp; !this.ptr_buf.isNull()) &#123;                console.log(&quot;[+] ptr_buf (&quot; + this.ptr_buf + &quot;) 内容:&quot;);                try &#123;                    // 读取目录个数 (ptr_buf[0x721])                    const dirCount = this.ptr_buf.add(0x721 * 4).readU32();                    console.log(&quot;[+] 目录个数 (ptr_buf[0x721]): &quot; + dirCount);                    // 从 0x744 开始遍历目录结构                    let dirOffset = 0x744 * 4; // 字节偏移                    for (let i = 0; i &lt; dirCount; i++) &#123;                        const dirEntry = this.ptr_buf.add(dirOffset);                        const dirPathPtr = dirEntry.readPointer(); // 读取目录路径指针                        try &#123;                            const dirPath = dirPathPtr.readCString();                            console.log(`[Dir $&#123;i&#125;] $&#123;dirPathPtr&#125;: $&#123;dirPath&#125;`);                        &#125; catch (e) &#123;                            console.log(`[Dir $&#123;i&#125;] $&#123;dirPathPtr&#125;: (无法读取字符串: $&#123;e&#125;)`);                        &#125;                        dirOffset += 48; // 每个目录结构 48 字节                    &#125;                    // 可选：打印整个缓冲区 (注释掉，避免输出过多)                    /*                    const bufferContent = Memory.readByteArray(this.ptr_buf, Math.min(BUFFER_SIZE, MAX_DUMP_SIZE));                    console.log(hexdump(bufferContent, Math.min(BUFFER_SIZE, MAX_DUMP_SIZE)));                    */                &#125; catch (e) &#123;                    console.error(&quot;[-] 读取 ptr_buf 时发生错误: &quot; + e);                    console.error(&quot;    错误详情: &quot; + e.stack);                &#125;            &#125; else &#123;                console.warn(&quot;[-] ptr_buf 在 onLeave 时为 null 或无效。&quot;);            &#125;            console.log(&quot;--- 结束 sub_3D6AC 打印 ---&quot;);        &#125;    &#125;);&#125;setImmediate(hook_linker_call_constructors);\n\n打印的结果如下图所示，创建了2个目录。\n\n至于sub_3DFC4d剩下的内容就不分析了，因为sdk版本之前打印好像是32。\n\nsub_11F5C(a2&#x3D;&#x3D;3)接着看11F5C。——3E29C、40CF8（与java层传入的arg5有关）、3DFC4、11F5C、45964。\n直接调用sub_BC60。\n\n\n在sub_BC60中，根据sdk版本，执行不同的代码块，我记得之前打印过，sdk_version是32，因此这里只关注需要执行的函数。\n\n\n来看看sub_188AC，用d810去一下混淆。\n\n\nhook这些字符串，打印看看什么含义，似乎没打印出来，说明没执行到。v0是一个指针，存储着BCEB8。我猜测，这里是在根据sdk，选择对应的so。\n\n\n我知道libart.so，但libartbase.so是什么呢？\n\n\n接着看sub_4029c，进行一定分析，修改变量名，写注释，如下图所示。\n看上去，sub_4029C是一个处理内存映射的函数。\n\n整理一下：\n\n读取 &#x2F;proc&#x2F;self&#x2F;maps：\n\n\n打开 &#x2F;proc&#x2F;self&#x2F;maps 文件，获取当前进程的内存映射信息。\n\n\n查找目标模块（str）：\n\n\n在内存映射中查找包含 str（例如 “libartbase.so”）的条目。\n\n\n修改内存权限：\n\n\n对于目标模块的内存段，修改其权限（mprotect）：\n如果段权限是 r–p（只读），改为 r-x（可读可执行）。\n如果段权限是 r-xp（可读可执行），改为 rwx（可读可写可执行）。\n\n\n\n\n存储基地址：\n\n\n将目标模块的基地址存储到 a1 中。\n\n回到sub_188AC，继续分析，将sub_4029C改名成get_so_baseaddr_AND_change_flags。\n我之前hook过sub_25E78，但这里似乎并没有对6A6DC5A……进行解密，大概率是没执行，这里分析else分支，继续分析sub_3FF9C。\n\nbaseaddr是libartbase.so的基址，这里看上去是在解析ELF文件。\n\n\n随便打开一个普通的so文件看看，寻找第0x38个字节和0x20个字节的含义。——先取指针，后进行运算，所以这里用0x38*8。\n第0x38字节的含义：e_phnum_NUMBER_OF_PROGRAM_HEADER_ENTRIES，代表PHT的个数。\n\n第0x20字节的含义：e_phoff_PROGRAM_HEADER_OFFSET_IN_FILE，代表PHT在文件中的偏移量。\n\n除此之外，还有访问pht + 16位置的代码段…这里就不贴图了，直接修改变量名。\n这个函数手动解析了ELF动态信息，这种方式可以绕过一些针对标准dlsym的Hook，或者在某些特殊环境中加载和解析符号。\n那么，sub_3FF9C看似是在解析动态链接库，并找到对应的符号。——当然不是这样，继续往下看。\n\n可以注意到，函数3FAE0和3F924出现在了switch-case结构中，这里简单介绍这俩函数的作用。\n函数sub_3FAE0负责处理标准的ELF重定位表（如 .rela.dyn 用于数据重定位，.rela.plt 用于过程链接表PLT的函数调用重定位）。它查找对目标符号的引用，并将这些引用重定向到a3（调用时提供的“空函数”地址，伏笔）。\n函数sub_3FAE0负责处理一个自定义的、以”APS2”开头的特殊数据结构。这个结构中也包含了对某些符号的引用信息（可能是为了处理更复杂的场景，如与符号版本控制相关的重定位，或者是一些内部模块间的链接）。它同样查找对目标符号的引用，并将这些引用重定向到提供的“空函数”地址。\n这里的空函数，指的是sub_1B044，这是一个空函数，点进去只有一个return。（这里的redirect_func_to_a3是sub_3FF9C，被我改名了）。\n\n\n\n在sub_188AC中，除了将__android_log_print进行hook，重定位到一个空函数，还将mmap进行了hook，重定位到了sub_1B070，博主说，这里在加载Dex的时候有用。那就待会再来看sub_1B070吧。\n\n回到sub_BC60，总结一下sub_188AC，它将__android_log_print和mmap进行了hook。\n因为我们的sdk是32，再继续分析sub_11AB0。\n\n\n还有好多未解密的字符串，写个脚本打印一下。\n\n\n打印的结果如下，涉及动态加载。\n\n有个很奇怪的现象，可能是我没分析到？当把未解密的so文件放入ida中，跳转到11ab0，是可以看到循环的（和博客一致）。而解密后的so文件在查看时，没有for循环，不知道是什么导致的。麻了，因为这个so文件我没添加注释，没改变量名，有些东西乍一看看不出来。\n\n\n直接拿博客的图来用一下吧，好糊。\n简单说一下思路，将jar文件转换成dex文件，然后通过InMemoryDexClassLoader进行加载，然后将两个加载器的Element数组合并，重新设置成原加载器的Element数组（为了之后加载的类，可以被原始类加载器加载，热更新），随后将Dex文件的信息，在baidu设置的0x13E80个字节的缓冲区里进行更新——也不知道更新什么东西？费这么大信息，hook上mmap函数，最后只是为了拿到mmap分配的地址，给到函数update_dex_info_to_baidu_struct。\n\n\n回到sub_bc60，再次总结一下，在hook mmap之后，会加载jar文件（目标dex文件），然后去除mmap的hook。\n\n\n至此，sub_bc60分析完了——我没特意分析具体是如何解密出dex文件的，感觉很复杂——之前的签名扩展的176字节，会被用来当密钥，也就是说，如果这个apk被修改后重新签名，是无法打开的，因为Dex文件解不开。\n要想得到这个Dex文件，可以通过hook sub_3BA90，在onLeave时dump第3个参数，而dump的大小是第4个参数。\n\n\nsub_45964(a2&#x3D;&#x3D;3)最后，分析sub_45964。——3E29C、40CF8（与java层传入的arg5有关）、3DFC4、11F5C、45964。\n做了一下简单的分析。\n在RegisterNative_10item的函数中，注册了10个JNI函数，10个JNI函数全部注册到了1个Native地址上。\n\n10个函数全部注册到1个地址，说明是vmp。\n\n下图来自未解密的so文件，又有do-while没被检测出来。在函数sub_42D8C中，会对每个Dex文件去解析附加数据3。\n\n下图是每个Jar文件的内容。sub_42D8C负责处理其中的附加数据3。\n\n这里直接引用博主的分析，如下图所示。\n\n如何分析出来的呢？过几天来看看。\n总结至此，n001分析完了，总结一下。\nsub_3E29C取出了签名数组，取了数组的第0个元素，通过md5得到了16个字节，再把这16字节扩展成了176字节。\nsub_40cf8注册的函数异常处理有关，大致是负责异常处理。\nsub_3DFC4创建了两个目录，分别是&#x2F;data&#x2F;user&#x2F;0&#x2F;com.example.test&#x2F;.1和&#x2F;data&#x2F;user&#x2F;0&#x2F;com.example.test&#x2F;.2，这两个目录应该是与dex、jar相关，为sub_11f5c服务的。——我发现了一些字符串，&#x2F;data&#x2F;data&#x2F;包名&#x2F; &#x3D;&#x3D; &#x2F;data&#x2F;user&#x2F;0&#x2F;包名。\n\nsub_11f5C hook了两个函数，一个是__android_log_print，一个是mmap，然后解密加载了业务dex文件（需要用到sub_3E29C签名扩展的176字节进行解密），加载完后，删除了mmap的hook。\nsub_4596c注册了10个JNI函数，解析了vmp的方法数组和指令替换表。\nn002n002函数是在onCreate函数中调用的，也是启动app的流程必经的函数之一。\n在n002中，又是调用函数列表上的函数，这回的a2&#x3D;&#x3D;4。\n通过分析，会有sub_ 40CF8、sub_ 3E96C、sub_ 42388这3个函数执行。\nsub_ 40CF8调用CrashHandler.asynRun方法，向https://apkprotect.baidu.com/apklog发送统计信息。\nsub_ 3E96C assets&#x2F;baiduprotect.m检查dex的完整性，该文件中存有加密的dex MD5，如果修改dex进行重新签名，会导致app打不开。——应该还有对调试器的检测，因为使用frida和IDA的时候会异常退出。\nsub_ 42388注册com.baidu.xshield.jni.Asc和com.baidu.xshield.utility.KeyUtil的本地函数，调用com.baidu.xshield.ac.XH.init方法。\n至此，app启动流程涉及到的n001和n002分析完了。\nvmp分析先把dex dump下来，下面是脚本，hook sub_3BA90，在onLeave时进行dump。\n脚本如下。\nconst TARGET_MODULE_NAME = &quot;libbaiduprotect.so&quot;;function hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;);    let offset_call = 0x51BA8; // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset_call);    let listener = Interceptor.attach(call_constructors, &#123;        onEnter: function(args) &#123;            console.log(&#x27;[linker] Call_Constructors onEnter&#x27;);            let secmodule = Process.findModuleByName(TARGET_MODULE_NAME);            if (secmodule != null) &#123;                hook_target_func(secmodule.base);                listener.detach();            &#125;        &#125;    &#125;);&#125;function hook_target_func(baseaddr) &#123;    let listener = Interceptor.attach(baseaddr.add(0x88060), &#123;        onEnter: function(args) &#123;&#125;,        onLeave: function(retval) &#123;            // hook sub_3BA90            hook_3BA90(baseaddr);            listener.detach();        &#125;    &#125;);&#125;function hook_3BA90(baseaddr) &#123;    Interceptor.attach(baseaddr.add(0x3BA90), &#123;        onEnter: function(args) &#123;            // 保存指针地址            this.dexPtr = args[2]; // &amp;dex_ 的地址            this.sizePtr = args[3]; // &amp;v6 的地址            console.log(&quot;[+] sub_3BA90 - dexPtr:&quot;, this.dexPtr, &quot;sizePtr:&quot;, this.sizePtr);            console.log(&quot;[+] Call stack:\\n&quot;, Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join(&quot;\\n&quot;));        &#125;,        onLeave: function(retval) &#123;                // 读取 dex_ 和 v6 的值                this.ptr = this.dexPtr.readPointer(); // *dexPtr, 即 dex_ 的值                this.size = this.sizePtr.readU64().toNumber(); // *sizePtr, 即 v6 的值                console.log(&quot;[+] DEX dump - ptr:&quot;, this.ptr, &quot;size:&quot;, this.size);                if (this.ptr &amp;&amp; !this.ptr.isNull() &amp;&amp; this.size &gt; 0 &amp;&amp; this.size &lt; 0x10000000) &#123; // 限制最大 256MB                    // 修改内存权限                    Memory.protect(this.ptr, this.size, &#x27;rwx&#x27;);                    console.log(&quot;[+] 内存权限已修改为 rwx&quot;);                    // 读取 DEX 文件内容                    const dexData = Memory.readByteArray(this.ptr, this.size);                    console.log(&quot;[+] 成功读取 DEX 数据&quot;);                    // 生成唯一的文件名                    const filename = `/data/data/com.example.test/dex_dump_$&#123;this.ptr.toString(16)&#125;_$&#123;Date.now()&#125;.dex`;                    // 写入文件                    const file = new File(filename, &quot;wb&quot;);                    if (file) &#123;                        file.write(dexData);                        file.flush();                        file.close();                        console.log(&quot;[+] DEX 文件成功保存到:&quot;, filename);                    &#125; else &#123;                        console.error(&quot;[-] 无法打开文件:&quot;, filename);                    &#125;                &#125; else &#123;                    console.warn(&quot;[-] 无效的 ptr 或 size:&quot;, this.ptr, this.size);                &#125;        &#125;    &#125;);&#125;setImmediate(hook_linker_call_constructors);\n\n打印的结果如下。\n\n\n这里图方便，分析onCreate函数（vmp化），需要判断它在哪个dex文件里。\n通过这个指令：grep -r “MainActivity” .&#x2F;dex_dump 可以找到。\n\n算了，直接将2个dex都pull出来，丢进行jadx里看看。\n成功找到了类MainActivity，onCreate明显被vmp动过。\n\n\n-1426063360即为0xAB00 0000。\n\n\n来到之前注册V的函数的地方，函数列表很怪，按理来说，应该有5个参数，前2个是JNIEnv和jclass，然后是A.V传的3个参数。\n\n把签名改成我期待的样子。\n\n再看这个sub_4A458，很不正常，连传了3个BYTE(a3)，还是看汇编吧。\n\n通过汇编的还原，调用的参数列表应该是这样子的。\n\n\n接下来，进入sub_4a458。看一眼就累了，很多函数的参数都是瞎传递的，ida没正确识别。\n\n试试用ida的trace，由于vmp这一块代码是加密的，要等到解密后才方便下断点。因此，还是使用frida进行trace吧。\n但是frida trace受挫了，似乎有反调？我之前尝试使用jnitrace也是执行到特定时候就会退出。\n之后尝试绕过。——hook pthread_create的线程函数，置为空，然后重新使用hook_libart.js来查看调用的JNI函数，看看会不会退出。\n好消息，成功了，脚本如下。\nvar offset = 0x88060;var module_size = 0;var module_name = &quot;libbaiduprotect.so&quot;;var base_addr = null; // To store the base address of libbaiduprotect.so// Create an empty functionvar empty_func = new NativeCallback(function() &#123;    return 0;&#125;, &#x27;int&#x27;, [&#x27;pointer&#x27;]);function hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;);    let offset_call = 0x51BA8; // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset_call);    let listener = Interceptor.attach(call_constructors, &#123;        onEnter: function(args) &#123;            console.log(&#x27;[linker] Call_Constructors onEnter&#x27;);            let secmodule = Process.findModuleByName(module_name);            if (secmodule != null) &#123;                module_size = secmodule.size;                base_addr = secmodule.base; // Save the base address                console.log(&quot;libbaiduprotect.so base: &quot; + base_addr + &quot;, size: &quot; + module_size);                hook_target_func(base_addr);                listener.detach();            &#125;        &#125;    &#125;);&#125;function hook_target_func(baseaddr) &#123;    let target_addr = baseaddr.add(offset);    let listener = Interceptor.attach(target_addr, &#123;        onEnter: function(args) &#123;            console.log(&quot;Target function at &quot; + target_addr + &quot; entered&quot;);        &#125;,        onLeave: function(retval) &#123;            console.log(&quot;libbaiduprotect.so base address: &quot; + baseaddr);            hook_pthread_create();            listener.detach();        &#125;    &#125;);&#125;function hook_pthread_create() &#123;    let pthread_create_addr = Module.getExportByName(&quot;libc.so&quot;, &quot;pthread_create&quot;);    Interceptor.attach(pthread_create_addr, &#123;        onEnter: function(args) &#123;            let func_addr = args[2];            let target_func_addr = base_addr.add(0x3E9F0); // Calculate the target function address            if (func_addr.equals(target_func_addr)) &#123;                console.log(&quot;Replacing func_addr &quot; + func_addr + &quot; with empty function&quot;);                args[2] = empty_func; // Replace with the empty function                hook_libart(); // Execute hook_libart            &#125; else &#123;                let module = Process.findModuleByAddress(func_addr);                if (module &amp;&amp; module.name === module_name) &#123;                    console.log(&quot;pthread_create called in libbaiduprotect.so, function address: &quot; + func_addr);                &#125;            &#125;        &#125;,        onLeave: function(retval) &#123;            // Optionally log return value        &#125;    &#125;);&#125;const STD_STRING_SIZE = 3 * Process.pointerSize;class StdString &#123;    constructor() &#123;        this.handle = Memory.alloc(STD_STRING_SIZE);    &#125;    dispose() &#123;        const [data, isTiny] = this._getData();        if (!isTiny) &#123;            Java.api.$delete(data);        &#125;    &#125;    disposeToString() &#123;        const result = this.toString();        this.dispose();        return result;    &#125;    toString() &#123;        const [data] = this._getData();        return data.readUtf8String();    &#125;    _getData() &#123;        const str = this.handle;        const isTiny = (str.readU8() &amp; 1) === 0;        const data = isTiny ? str.add(1) : str.add(2 * Process.pointerSize).readPointer();        return [data, isTiny];    &#125;&#125;function prettyMethod(method_id, withSignature) &#123;    const result = new StdString();    Java.api[&#x27;art::ArtMethod::PrettyMethod&#x27;](result, method_id, withSignature ? 1 : 0);    return result.disposeToString();&#125;function hook_libart() &#123;    var symbols = Module.enumerateSymbolsSync(&quot;libart.so&quot;);    var addrGetStringUTFChars = null;    var addrNewStringUTF = null;    var addrFindClass = null;    var addrGetMethodID = null;    var addrGetStaticMethodID = null;    var addrGetFieldID = null;    var addrGetStaticFieldID = null;    var addrRegisterNatives = null;    var so_name = &quot;lib&quot;;      // TODO: Specify the SO to filter    for (var i = 0; i &lt; symbols.length; i++) &#123;        var symbol = symbols[i];        if (symbol.name.indexOf(&quot;art&quot;) &gt;= 0 &amp;&amp;            symbol.name.indexOf(&quot;JNI&quot;) &gt;= 0 &amp;&amp;            symbol.name.indexOf(&quot;CheckJNI&quot;) &lt; 0 &amp;&amp;            symbol.name.indexOf(&quot;_ZN3art3JNIILb0&quot;) &gt;= 0        ) &#123;            if (symbol.name.indexOf(&quot;GetStringUTFChars&quot;) &gt;= 0) &#123;                addrGetStringUTFChars = symbol.address;                console.log(&quot;GetStringUTFChars is at &quot;, symbol.address, symbol.name);            &#125; else if (symbol.name.indexOf(&quot;NewStringUTF&quot;) &gt;= 0) &#123;                addrNewStringUTF = symbol.address;                console.log(&quot;NewStringUTF is at &quot;, symbol.address, symbol.name);            &#125; else if (symbol.name.indexOf(&quot;FindClass&quot;) &gt;= 0) &#123;                addrFindClass = symbol.address;                console.log(&quot;FindClass is at &quot;, symbol.address, symbol.name);            &#125; else if (symbol.name.indexOf(&quot;GetMethodID&quot;) &gt;= 0) &#123;                addrGetMethodID = symbol.address;                console.log(&quot;GetMethodID is at &quot;, symbol.address, symbol.name);            &#125; else if (symbol.name.indexOf(&quot;GetStaticMethodID&quot;) &gt;= 0) &#123;                addrGetStaticMethodID = symbol.address;                console.log(&quot;GetStaticMethodID is at &quot;, symbol.address, symbol.name);            &#125; else if (symbol.name.indexOf(&quot;GetFieldID&quot;) &gt;= 0) &#123;                addrGetFieldID = symbol.address;                console.log(&quot;GetFieldID is at &quot;, symbol.address, symbol.name);            &#125; else if (symbol.name.indexOf(&quot;GetStaticFieldID&quot;) &gt;= 0) &#123;                addrGetStaticFieldID = symbol.address;                console.log(&quot;GetStaticFieldID is at &quot;, symbol.address, symbol.name);            &#125; else if (symbol.name.indexOf(&quot;RegisterNatives&quot;) &gt;= 0) &#123;                addrRegisterNatives = symbol.address;                console.log(&quot;RegisterNatives is at &quot;, symbol.address, symbol.name);            &#125; else if (symbol.name.indexOf(&quot;CallStatic&quot;) &gt;= 0) &#123;                console.log(&quot;CallStatic is at &quot;, symbol.address, symbol.name);                Interceptor.attach(symbol.address, &#123;                    onEnter: function (args) &#123;                        var module = Process.findModuleByAddress(this.returnAddress);                        if (module != null &amp;&amp; module.name.indexOf(so_name) == 0) &#123;                            var java_class = args[1];                            var mid = args[2];                            var class_name = Java.vm.tryGetEnv().getClassName(java_class);                            if (class_name.indexOf(&quot;java.&quot;) == -1 &amp;&amp; class_name.indexOf(&quot;android.&quot;) == -1) &#123;                                var method_name = prettyMethod(mid, 1);                                console.log(&quot;&lt;&gt;CallStatic:&quot;, DebugSymbol.fromAddress(this.returnAddress), class_name, method_name);                            &#125;                        &#125;                    &#125;,                    onLeave: function (retval) &#123; &#125;                &#125;);            &#125; else if (symbol.name.indexOf(&quot;CallNonvirtual&quot;) &gt;= 0) &#123;                console.log(&quot;CallNonvirtual is at &quot;, symbol.address, symbol.name);                Interceptor.attach(symbol.address, &#123;                    onEnter: function (args) &#123;                        var module = Process.findModuleByAddress(this.returnAddress);                        if (module != null &amp;&amp; module.name.indexOf(so_name) == 0) &#123;                            var jobject = args[1];                            var jclass = args[2];                            var jmethodID = args[3];                            var obj_class_name = Java.vm.tryGetEnv().getObjectClassName(jobject);                            var class_name = Java.vm.tryGetEnv().getClassName(jclass);                            if (class_name.indexOf(&quot;java.&quot;) == -1 &amp;&amp; class_name.indexOf(&quot;android.&quot;) == -1) &#123;                                var method_name = prettyMethod(jmethodID, 1);                                console.log(&quot;&lt;&gt;CallNonvirtual:&quot;, DebugSymbol.fromAddress(this.returnAddress), class_name, obj_class_name, method_name);                            &#125;                        &#125;                    &#125;,                    onLeave: function (retval) &#123; &#125;                &#125;);            &#125; else if (symbol.name.indexOf(&quot;Call&quot;) &gt;= 0 &amp;&amp; symbol.name.indexOf(&quot;Method&quot;) &gt;= 0) &#123;                console.log(&quot;Call&lt;&gt;Method is at &quot;, symbol.address, symbol.name);                Interceptor.attach(symbol.address, &#123;                    onEnter: function (args) &#123;                        var module = Process.findModuleByAddress(this.returnAddress);                        if (module != null &amp;&amp; module.name.indexOf(so_name) == 0) &#123;                            var java_class = args[1];                            var mid = args[2];                            var class_name = Java.vm.tryGetEnv().getObjectClassName(java_class);                            if (class_name.indexOf(&quot;java.&quot;) == -1 &amp;&amp; class_name.indexOf(&quot;android.&quot;) == -1) &#123;                                var method_name = prettyMethod(mid, 1);                                console.log(&quot;&lt;&gt;Call&lt;&gt;Method:&quot;, DebugSymbol.fromAddress(this.returnAddress), class_name, method_name);                            &#125;                        &#125;                    &#125;,                    onLeave: function (retval) &#123; &#125;                &#125;);            &#125;        &#125;    &#125;    if (addrGetStringUTFChars != null) &#123;        Interceptor.attach(addrGetStringUTFChars, &#123;            onEnter: function (args) &#123;            &#125;,            onLeave: function (retval) &#123;                if (retval != null) &#123;                    var module = Process.findModuleByAddress(this.returnAddress);                    if (module != null &amp;&amp; module.name.indexOf(so_name) == 0) &#123;                        var bytes = Memory.readCString(retval);                        console.log(&quot;[GetStringUTFChars] result:&quot; + bytes, DebugSymbol.fromAddress(this.returnAddress));                    &#125;                &#125;            &#125;        &#125;);    &#125;    if (addrNewStringUTF != null) &#123;        Interceptor.attach(addrNewStringUTF, &#123;            onEnter: function (args) &#123;                if (args[1] != null) &#123;                    var module = Process.findModuleByAddress(this.returnAddress);                    if (module != null &amp;&amp; module.name.indexOf(so_name) == 0) &#123;                        var string = Memory.readCString(args[1]);                        console.log(&quot;[NewStringUTF] bytes:&quot; + string, DebugSymbol.fromAddress(this.returnAddress));                    &#125;                &#125;            &#125;,            onLeave: function (retval) &#123; &#125;        &#125;);    &#125;    if (addrFindClass != null) &#123;        Interceptor.attach(addrFindClass, &#123;            onEnter: function (args) &#123;                if (args[1] != null) &#123;                    var module = Process.findModuleByAddress(this.returnAddress);                    if (module != null &amp;&amp; module.name.indexOf(so_name) == 0) &#123;                        var name = Memory.readCString(args[1]);                        console.log(&quot;[FindClass] name:&quot; + name, DebugSymbol.fromAddress(this.returnAddress));                    &#125;                &#125;            &#125;,            onLeave: function (retval) &#123; &#125;        &#125;);    &#125;    if (addrGetMethodID != null) &#123;        Interceptor.attach(addrGetMethodID, &#123;            onEnter: function (args) &#123;                if (args[2] != null) &#123;                    var clazz = args[1];                    var class_name = Java.vm.tryGetEnv().getClassName(clazz);                    var module = Process.findModuleByAddress(this.returnAddress);                    if (module != null &amp;&amp; module.name.indexOf(so_name) == 0) &#123;                        var name = Memory.readCString(args[2]);                        if (args[3] != null) &#123;                            var sig = Memory.readCString(args[3]);                            console.log(&quot;[GetMethodID] class_name:&quot; + class_name + &quot; name:&quot; + name + &quot;, sig:&quot; + sig, DebugSymbol.fromAddress(this.returnAddress));                        &#125; else &#123;                            console.log(&quot;[GetMethodID] class_name:&quot; + class_name + &quot; name:&quot; + name, DebugSymbol.fromAddress(this.returnAddress));                        &#125;                    &#125;                &#125;            &#125;,            onLeave: function (retval) &#123; &#125;        &#125;);    &#125;    if (addrGetStaticMethodID != null) &#123;        Interceptor.attach(addrGetStaticMethodID, &#123;            onEnter: function (args) &#123;                if (args[2] != null) &#123;                    var clazz = args[1];                    var class_name = Java.vm.tryGetEnv().getClassName(clazz);                    var module = Process.findModuleByAddress(this.returnAddress);                    if (module != null &amp;&amp; module.name.indexOf(so_name) == 0) &#123;                        var name = Memory.readCString(args[2]);                        if (args[3] != null) &#123;                            var sig = Memory.readCString(args[3]);                            console.log(&quot;[GetStaticMethodID] class_name:&quot; + class_name + &quot; name:&quot; + name + &quot;, sig:&quot; + sig, DebugSymbol.fromAddress(this.returnAddress));                        &#125; else &#123;                            console.log(&quot;[GetStaticMethodID] class_name:&quot; + class_name + &quot; name:&quot; + name, DebugSymbol.fromAddress(this.returnAddress));                        &#125;                    &#125;                &#125;            &#125;,            onLeave: function (retval) &#123; &#125;        &#125;);    &#125;    if (addrGetFieldID != null) &#123;        Interceptor.attach(addrGetFieldID, &#123;            onEnter: function (args) &#123;                if (args[2] != null) &#123;                    var module = Process.findModuleByAddress(this.returnAddress);                    if (module != null &amp;&amp; module.name.indexOf(so_name) == 0) &#123;                        var name = Memory.readCString(args[2]);                        if (args[3] != null) &#123;                            var sig = Memory.readCString(args[3]);                            console.log(&quot;[GetFieldID] name:&quot; + name + &quot;, sig:&quot; + sig, DebugSymbol.fromAddress(this.returnAddress));                        &#125; else &#123;                            console.log(&quot;[GetFieldID] name:&quot; + name, DebugSymbol.fromAddress(this.returnAddress));                        &#125;                    &#125;                &#125;            &#125;,            onLeave: function (retval) &#123; &#125;        &#125;);    &#125;    if (addrGetStaticFieldID != null) &#123;        Interceptor.attach(addrGetStaticFieldID, &#123;            onEnter: function (args) &#123;                if (args[2] != null) &#123;                    var module = Process.findModuleByAddress(this.returnAddress);                    if (module != null &amp;&amp; module.name.indexOf(so_name) == 0) &#123;                        var name = Memory.readCString(args[2]);                        if (args[3] != null) &#123;                            var sig = Memory.readCString(args[3]);                            console.log(&quot;[GetStaticFieldID] name:&quot; + name + &quot;, sig:&quot; + sig, DebugSymbol.fromAddress(this.returnAddress));                        &#125; else &#123;                            console.log(&quot;[GetStaticFieldID] name:&quot; + name, DebugSymbol.fromAddress(this.returnAddress));                        &#125;                    &#125;                &#125;            &#125;,            onLeave: function (retval) &#123; &#125;        &#125;);    &#125;    if (addrRegisterNatives != null) &#123;        Interceptor.attach(addrRegisterNatives, &#123;            onEnter: function (args) &#123;                console.log(&quot;[RegisterNatives] method_count:&quot;, args[3], DebugSymbol.fromAddress(this.returnAddress));                var env = args[0];                var java_class = args[1];                var class_name = Java.vm.tryGetEnv().getClassName(java_class);                var methods_ptr = ptr(args[2]);                var method_count = parseInt(args[3]);                for (var i = 0; i &lt; method_count; i++) &#123;                    var name_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3));                    var sig_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize));                    var fnPtr_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize * 2));                    var name = Memory.readCString(name_ptr);                    var sig = Memory.readCString(sig_ptr);                    var find_module = Process.findModuleByAddress(fnPtr_ptr);                    console.log(&quot;[RegisterNatives] java_class:&quot;, class_name, &quot;name:&quot;, name, &quot;sig:&quot;, sig, &quot;fnPtr:&quot;, fnPtr_ptr, &quot;module_name:&quot;, find_module.name, &quot;module_base:&quot;, find_module.base, &quot;offset:&quot;, ptr(fnPtr_ptr).sub(find_module.base));                &#125;            &#125;,            onLeave: function (retval) &#123; &#125;        &#125;);    &#125;&#125;hook_linker_call_constructors();\n\n成功打印出jni调用的函数，也就是说，离frida trace所有vmp的指令又进一步。\n\n暂时先到这吧，明天面携程，先复习一下加解密算法，之后继续复现vmp。\n ok，继续分析，也不知道携程能不能有个善终——20250514 09:28。\n我将jni调用的日志输出到文件中，慢慢看。\n我们要分析的被vmp的函数是onCreate，不妨猜测它会调用super.onCreate，而要实现super.onCreate，不能只靠vmp的解释器进行解释执行，还需要用到jni调用，因此可以在日志中搜索onCreate，于是得到下面的日志。\n于是，我们能确定了解释器是在哪里获取的onCreate的jmethod_id（0x5df18）和在哪里真正调用onCreate函数的（0x54370）。\n[GetMethodID] class_name:androidx.appcompat.app.AppCompatActivity name:onCreate, sig:(Landroid/os/Bundle;)V 0x743fd08f18 libbaiduprotect.so!0x5df18[GetMethodID] class_name:android.system.StructStatVfs name:&lt;init&gt;, sig:(JJJJJJJJJJJ)V 0x744a5310b4 libjavacore.so!0x310b4&lt;&gt;CallNonvirtual: 0x743fcff370 libbaiduprotect.so!0x54370 androidx.appcompat.app.AppCompatActivity com.example.test.MainActivity void androidx.appcompat.app.AppCompatActivity.onCreate(android.os.Bundle)\n\n不妨想想如何倒推——如果没有被vmp化，原onCreate中，大概率要执行super.onCreate，对应的smali指令，大概率是invoke-super，通过invoke-super调用父类的onCreate。\n先尝试将指令trace下来吧，试了一下，即便先绕过反调，仍然无法trace下来，那是什么原因呢？\n追踪指令流，发现执行到sub_45EBC后，程序便不会返回到BL sub_45EBC的下一条指令了，而sub_45EBC的最后一条指令是，将栈指针寄存器变成了0x1，难怪会退出——为什么使用frida-stalker之后，会出现这种问题呢？\nmov wsp, #1\n\n整理一下现有的信息，我知道：\n\n哪里调用了onCreate。\n\n执行sub_45EBC就会崩溃。\n\n\n那我是否可以根据onCreate的交叉引用，一步一步回推是哪个跳转出现了问题，最后进入了sub_45EBC退出的。\n已知0x5df18处会获取onCreate的method_id，而0x54370会调用onCreate，交叉引用一下这两个地址，发现两个函数都追踪到了.data节，除此之外，没有其它函数引用了它们。\n把函数地址存放在.data节中，而且不只一个函数地址，大概率是通过BLR或BR指令跳转的。\nBL和BLR的区别在，前者是通过PC相对偏移量跳转到目标函数在内存中的地址，而后者是跳转到寄存器中存储的地址，也就是说，BL的跳转地址基本是硬编码在指令里的，是编译时就确定的，而BLR可以根据寄存器的内容进行跳转，在运行时决定。这里这么多个地址放在一块，大概率在执行时要跳转很多个函数，所以使用有R的跳转指令。\n这里继续交叉引用off_BD040。\n\n\nBR X8，符合上面的分析。\n\n\n回到函数列表中，突然发现它有256个函数地址，smali的操作码是1个字节，对应256种操作，这里会不会就是vmp解释器模拟smali指令的地方？读取解密后的vmp_code_item，然后根据vmp_code_item里的每一条指令，模拟执行对应的函数。\n.data:00000000000BD040 58 CD 04 00 00 00 00 00 off_BD040       DCQ sub_4CD58           ; DATA XREF: sub_4CC20+C4↑o.data:00000000000BD048 8C CD 04 00 00 00 00 00                 DCQ sub_4CD8C.data:00000000000BD050 E0 CD 04 00 00 00 00 00                 DCQ sub_4CDE0.data:00000000000BD058 34 CE 04 00 00 00 00 00                 DCQ sub_4CE34.data:00000000000BD060 84 CE 04 00 00 00 00 00                 DCQ sub_4CE84.data:00000000000BD068 D4 CE 04 00 00 00 00 00                 DCQ sub_4CED4.data:00000000000BD070 24 CF 04 00 00 00 00 00                 DCQ sub_4CF24.data:00000000000BD078 70 CF 04 00 00 00 00 00                 DCQ sub_4CF70.data:00000000000BD080 C0 CF 04 00 00 00 00 00                 DCQ sub_4CFC0.data:00000000000BD088 10 D0 04 00 00 00 00 00                 DCQ sub_4D010.data:00000000000BD090 5C D0 04 00 00 00 00 00                 DCQ sub_4D05C.data:00000000000BD098 C0 D0 04 00 00 00 00 00                 DCQ sub_4D0C0.data:00000000000BD0A0 2C D1 04 00 00 00 00 00                 DCQ sub_4D12C.data:00000000000BD0A8 98 D1 04 00 00 00 00 00                 DCQ sub_4D198.data:00000000000BD0B0 DC 46 05 00 00 00 00 00                 DCQ loc_546DC           ; jumptable 0000000000053D00 cases 69,71,72,75,77-82,84,85,87-89.data:00000000000BD0B0                                                                 ; jumptable 0000000000053D50 cases 69,71,72,75,77-82,84,85,87-89.data:00000000000BD0B0                                                                 ; jumptable 0000000000053DAC cases 69,71,72,75,77-82,84,85,87-89.data:00000000000BD0B8 BC 46 05 00 00 00 00 00                 DCQ loc_546BC.data:00000000000BD0C0 14 D2 04 00 00 00 00 00                 DCQ sub_4D214.data:00000000000BD0C8 14 D2 04 00 00 00 00 00                 DCQ sub_4D214.data:00000000000BD0D0 34 D2 04 00 00 00 00 00                 DCQ loc_4D234.data:00000000000BD0D8 80 D2 04 00 00 00 00 00                 DCQ loc_4D280.data:00000000000BD0E0 D0 D2 04 00 00 00 00 00                 DCQ loc_4D2D0.data:00000000000BD0E8 24 D3 04 00 00 00 00 00                 DCQ loc_4D324.data:00000000000BD0F0 74 D3 04 00 00 00 00 00                 DCQ loc_4D374.data:00000000000BD0F8 C0 D3 04 00 00 00 00 00                 DCQ loc_4D3C0.data:00000000000BD100 18 D4 04 00 00 00 00 00                 DCQ loc_4D418.data:00000000000BD108 7C D4 04 00 00 00 00 00                 DCQ loc_4D47C.data:00000000000BD110 CC D4 04 00 00 00 00 00                 DCQ loc_4D4CC.data:00000000000BD118 44 D5 04 00 00 00 00 00                 DCQ loc_4D544.data:00000000000BD120 C4 D5 04 00 00 00 00 00                 DCQ loc_4D5C4.data:00000000000BD128 40 D6 04 00 00 00 00 00                 DCQ loc_4D640.data:00000000000BD130 A8 D6 04 00 00 00 00 00                 DCQ loc_4D6A8.data:00000000000BD138 24 D7 04 00 00 00 00 00                 DCQ loc_4D724.data:00000000000BD140 C4 D7 04 00 00 00 00 00                 DCQ loc_4D7C4.data:00000000000BD148 68 D8 04 00 00 00 00 00                 DCQ loc_4D868.data:00000000000BD150 E0 D8 04 00 00 00 00 00                 DCQ loc_4D8E0.data:00000000000BD158 C0 DA 04 00 00 00 00 00                 DCQ loc_4DAC0.data:00000000000BD160 90 33 05 00 00 00 00 00                 DCQ loc_53390.data:00000000000BD168 28 DC 04 00 00 00 00 00                 DCQ loc_4DC28.data:00000000000BD170 30 DC 04 00 00 00 00 00                 DCQ loc_4DC30.data:00000000000BD178 AC DC 04 00 00 00 00 00                 DCQ loc_4DCAC.data:00000000000BD180 E8 DC 04 00 00 00 00 00                 DCQ loc_4DCE8.data:00000000000BD188 24 DD 04 00 00 00 00 00                 DCQ loc_4DD24.data:00000000000BD190 60 DD 04 00 00 00 00 00                 DCQ loc_4DD60.data:00000000000BD198 A4 DD 04 00 00 00 00 00                 DCQ loc_4DDA4.data:00000000000BD1A0 24 DE 04 00 00 00 00 00                 DCQ loc_4DE24.data:00000000000BD1A8 A4 DE 04 00 00 00 00 00                 DCQ loc_4DEA4.data:00000000000BD1B0 30 DF 04 00 00 00 00 00                 DCQ loc_4DF30.data:00000000000BD1B8 B0 DF 04 00 00 00 00 00                 DCQ loc_4DFB0.data:00000000000BD1C0 34 E0 04 00 00 00 00 00                 DCQ loc_4E034.data:00000000000BD1C8 AC E0 04 00 00 00 00 00                 DCQ loc_4E0AC.data:00000000000BD1D0 28 E1 04 00 00 00 00 00                 DCQ loc_4E128.data:00000000000BD1D8 14 E2 04 00 00 00 00 00                 DCQ loc_4E214.data:00000000000BD1E0 00 E3 04 00 00 00 00 00                 DCQ loc_4E300.data:00000000000BD1E8 94 E3 04 00 00 00 00 00                 DCQ loc_4E394.data:00000000000BD1F0 28 E4 04 00 00 00 00 00                 DCQ loc_4E428.data:00000000000BD1F8 BC E4 04 00 00 00 00 00                 DCQ loc_4E4BC.data:00000000000BD200 50 E5 04 00 00 00 00 00                 DCQ loc_4E550.data:00000000000BD208 D4 E5 04 00 00 00 00 00                 DCQ loc_4E5D4.data:00000000000BD210 58 E6 04 00 00 00 00 00                 DCQ loc_4E658.data:00000000000BD218 E0 E6 04 00 00 00 00 00                 DCQ loc_4E6E0.data:00000000000BD220 68 E7 04 00 00 00 00 00                 DCQ loc_4E768.data:00000000000BD228 F0 E7 04 00 00 00 00 00                 DCQ loc_4E7F0.data:00000000000BD230 78 E8 04 00 00 00 00 00                 DCQ loc_4E878.data:00000000000BD238 78 E8 04 00 00 00 00 00                 DCQ loc_4E878.data:00000000000BD240 78 E8 04 00 00 00 00 00                 DCQ loc_4E878.data:00000000000BD248 78 E8 04 00 00 00 00 00                 DCQ loc_4E878.data:00000000000BD250 78 E8 04 00 00 00 00 00                 DCQ loc_4E878.data:00000000000BD258 78 E8 04 00 00 00 00 00                 DCQ loc_4E878.data:00000000000BD260 78 E8 04 00 00 00 00 00                 DCQ loc_4E878.data:00000000000BD268 A4 E9 04 00 00 00 00 00                 DCQ loc_4E9A4.data:00000000000BD270 A4 EA 04 00 00 00 00 00                 DCQ loc_4EAA4.data:00000000000BD278 30 EC 04 00 00 00 00 00                 DCQ loc_4EC30.data:00000000000BD280 1C ED 04 00 00 00 00 00                 DCQ loc_4ED1C.data:00000000000BD288 E0 ED 04 00 00 00 00 00                 DCQ loc_4EDE0.data:00000000000BD290 A0 EE 04 00 00 00 00 00                 DCQ loc_4EEA0.data:00000000000BD298 64 EF 04 00 00 00 00 00                 DCQ loc_4EF64.data:00000000000BD2A0 60 F0 04 00 00 00 00 00                 DCQ loc_4F060.data:00000000000BD2A8 50 F1 04 00 00 00 00 00                 DCQ loc_4F150.data:00000000000BD2B0 F4 F1 04 00 00 00 00 00                 DCQ loc_4F1F4.data:00000000000BD2B8 9C F2 04 00 00 00 00 00                 DCQ loc_4F29C.data:00000000000BD2C0 44 F3 04 00 00 00 00 00                 DCQ loc_4F344.data:00000000000BD2C8 EC F3 04 00 00 00 00 00                 DCQ loc_4F3EC.data:00000000000BD2D0 94 F4 04 00 00 00 00 00                 DCQ loc_4F494.data:00000000000BD2D8 6C F5 04 00 00 00 00 00                 DCQ loc_4F56C.data:00000000000BD2E0 30 F6 04 00 00 00 00 00                 DCQ loc_4F630.data:00000000000BD2E8 A4 F7 04 00 00 00 00 00                 DCQ loc_4F7A4.data:00000000000BD2F0 4C F8 04 00 00 00 00 00                 DCQ loc_4F84C.data:00000000000BD2F8 F8 F8 04 00 00 00 00 00                 DCQ loc_4F8F8.data:00000000000BD300 A0 F9 04 00 00 00 00 00                 DCQ loc_4F9A0.data:00000000000BD308 4C FA 04 00 00 00 00 00                 DCQ loc_4FA4C.data:00000000000BD310 0C FB 04 00 00 00 00 00                 DCQ loc_4FB0C.data:00000000000BD318 C8 FB 04 00 00 00 00 00                 DCQ loc_4FBC8.data:00000000000BD320 68 FC 04 00 00 00 00 00                 DCQ loc_4FC68.data:00000000000BD328 0C FD 04 00 00 00 00 00                 DCQ loc_4FD0C.data:00000000000BD330 B0 FD 04 00 00 00 00 00                 DCQ loc_4FDB0.data:00000000000BD338 54 FE 04 00 00 00 00 00                 DCQ loc_4FE54.data:00000000000BD340 F8 FE 04 00 00 00 00 00                 DCQ loc_4FEF8.data:00000000000BD348 C0 FF 04 00 00 00 00 00                 DCQ loc_4FFC0.data:00000000000BD350 78 00 05 00 00 00 00 00                 DCQ loc_50078.data:00000000000BD358 E8 01 05 00 00 00 00 00                 DCQ loc_501E8.data:00000000000BD360 88 02 05 00 00 00 00 00                 DCQ loc_50288.data:00000000000BD368 2C 03 05 00 00 00 00 00                 DCQ loc_5032C.data:00000000000BD370 CC 03 05 00 00 00 00 00                 DCQ loc_503CC.data:00000000000BD378 70 04 05 00 00 00 00 00                 DCQ loc_50470.data:00000000000BD380 24 05 05 00 00 00 00 00                 DCQ loc_50524.data:00000000000BD388 D4 05 05 00 00 00 00 00                 DCQ loc_505D4.data:00000000000BD390 6C 06 05 00 00 00 00 00                 DCQ loc_5066C.data:00000000000BD398 08 07 05 00 00 00 00 00                 DCQ loc_50708.data:00000000000BD3A0 A4 07 05 00 00 00 00 00                 DCQ loc_507A4.data:00000000000BD3A8 40 08 05 00 00 00 00 00                 DCQ loc_50840.data:00000000000BD3B0 74 37 05 00 00 00 00 00                 DCQ loc_53774.data:00000000000BD3B8 C4 37 05 00 00 00 00 00                 DCQ loc_537C4.data:00000000000BD3C0 9C 38 05 00 00 00 00 00                 DCQ loc_5389C.data:00000000000BD3C8 CC 39 05 00 00 00 00 00                 DCQ loc_539CC.data:00000000000BD3D0 44 38 05 00 00 00 00 00                 DCQ loc_53844.data:00000000000BD3D8 70 37 05 00 00 00 00 00                 DCQ loc_53770.data:00000000000BD3E0 70 37 05 00 00 00 00 00                 DCQ loc_53770.data:00000000000BD3E8 C0 37 05 00 00 00 00 00                 DCQ loc_537C0.data:00000000000BD3F0 DC 08 05 00 00 00 00 00                 DCQ loc_508DC.data:00000000000BD3F8 C8 39 05 00 00 00 00 00                 DCQ loc_539C8.data:00000000000BD400 40 38 05 00 00 00 00 00                 DCQ loc_53840.data:00000000000BD408 F4 08 05 00 00 00 00 00                 DCQ loc_508F4.data:00000000000BD410 F4 08 05 00 00 00 00 00                 DCQ loc_508F4.data:00000000000BD418 F4 08 05 00 00 00 00 00                 DCQ loc_508F4.data:00000000000BD420 4C 09 05 00 00 00 00 00                 DCQ loc_5094C.data:00000000000BD428 A4 09 05 00 00 00 00 00                 DCQ loc_509A4.data:00000000000BD430 F8 09 05 00 00 00 00 00                 DCQ loc_509F8.data:00000000000BD438 4C 0A 05 00 00 00 00 00                 DCQ loc_50A4C.data:00000000000BD440 AC 0A 05 00 00 00 00 00                 DCQ loc_50AAC.data:00000000000BD448 00 0B 05 00 00 00 00 00                 DCQ loc_50B00.data:00000000000BD450 54 0B 05 00 00 00 00 00                 DCQ loc_50B54.data:00000000000BD458 B4 0B 05 00 00 00 00 00                 DCQ loc_50BB4.data:00000000000BD460 10 0C 05 00 00 00 00 00                 DCQ loc_50C10.data:00000000000BD468 68 0C 05 00 00 00 00 00                 DCQ loc_50C68.data:00000000000BD470 C4 0C 05 00 00 00 00 00                 DCQ loc_50CC4.data:00000000000BD478 18 0D 05 00 00 00 00 00                 DCQ loc_50D18.data:00000000000BD480 B8 0D 05 00 00 00 00 00                 DCQ loc_50DB8.data:00000000000BD488 50 0E 05 00 00 00 00 00                 DCQ loc_50E50.data:00000000000BD490 A8 0E 05 00 00 00 00 00                 DCQ loc_50EA8.data:00000000000BD498 44 0F 05 00 00 00 00 00                 DCQ loc_50F44.data:00000000000BD4A0 D8 0F 05 00 00 00 00 00                 DCQ loc_50FD8.data:00000000000BD4A8 34 10 05 00 00 00 00 00                 DCQ loc_51034.data:00000000000BD4B0 88 10 05 00 00 00 00 00                 DCQ loc_51088.data:00000000000BD4B8 DC 10 05 00 00 00 00 00                 DCQ loc_510DC.data:00000000000BD4C0 30 11 05 00 00 00 00 00                 DCQ loc_51130.data:00000000000BD4C8 98 11 05 00 00 00 00 00                 DCQ loc_51198.data:00000000000BD4D0 00 12 05 00 00 00 00 00                 DCQ loc_51200.data:00000000000BD4D8 68 12 05 00 00 00 00 00                 DCQ loc_51268.data:00000000000BD4E0 0C 13 05 00 00 00 00 00                 DCQ loc_5130C.data:00000000000BD4E8 98 13 05 00 00 00 00 00                 DCQ loc_51398.data:00000000000BD4F0 00 14 05 00 00 00 00 00                 DCQ loc_51400.data:00000000000BD4F8 68 14 05 00 00 00 00 00                 DCQ loc_51468.data:00000000000BD500 D0 14 05 00 00 00 00 00                 DCQ loc_514D0.data:00000000000BD508 3C 15 05 00 00 00 00 00                 DCQ loc_5153C.data:00000000000BD510 A8 15 05 00 00 00 00 00                 DCQ loc_515A8.data:00000000000BD518 14 16 05 00 00 00 00 00                 DCQ loc_51614.data:00000000000BD520 74 16 05 00 00 00 00 00                 DCQ loc_51674.data:00000000000BD528 D4 16 05 00 00 00 00 00                 DCQ loc_516D4.data:00000000000BD530 34 17 05 00 00 00 00 00                 DCQ loc_51734.data:00000000000BD538 C4 17 05 00 00 00 00 00                 DCQ loc_517C4.data:00000000000BD540 48 18 05 00 00 00 00 00                 DCQ loc_51848.data:00000000000BD548 A8 18 05 00 00 00 00 00                 DCQ loc_518A8.data:00000000000BD550 08 19 05 00 00 00 00 00                 DCQ loc_51908.data:00000000000BD558 68 19 05 00 00 00 00 00                 DCQ loc_51968.data:00000000000BD560 D0 19 05 00 00 00 00 00                 DCQ loc_519D0.data:00000000000BD568 38 1A 05 00 00 00 00 00                 DCQ loc_51A38.data:00000000000BD570 A0 1A 05 00 00 00 00 00                 DCQ loc_51AA0.data:00000000000BD578 10 1B 05 00 00 00 00 00                 DCQ loc_51B10.data:00000000000BD580 80 1B 05 00 00 00 00 00                 DCQ loc_51B80.data:00000000000BD588 F0 1B 05 00 00 00 00 00                 DCQ loc_51BF0.data:00000000000BD590 60 1C 05 00 00 00 00 00                 DCQ loc_51C60.data:00000000000BD598 F0 1C 05 00 00 00 00 00                 DCQ loc_51CF0.data:00000000000BD5A0 50 1D 05 00 00 00 00 00                 DCQ loc_51D50.data:00000000000BD5A8 B0 1D 05 00 00 00 00 00                 DCQ loc_51DB0.data:00000000000BD5B0 10 1E 05 00 00 00 00 00                 DCQ loc_51E10.data:00000000000BD5B8 70 1E 05 00 00 00 00 00                 DCQ loc_51E70.data:00000000000BD5C0 F0 1E 05 00 00 00 00 00                 DCQ loc_51EF0.data:00000000000BD5C8 50 1F 05 00 00 00 00 00                 DCQ loc_51F50.data:00000000000BD5D0 B0 1F 05 00 00 00 00 00                 DCQ loc_51FB0.data:00000000000BD5D8 10 20 05 00 00 00 00 00                 DCQ loc_52010.data:00000000000BD5E0 A0 20 05 00 00 00 00 00                 DCQ loc_520A0.data:00000000000BD5E8 24 21 05 00 00 00 00 00                 DCQ loc_52124.data:00000000000BD5F0 84 21 05 00 00 00 00 00                 DCQ loc_52184.data:00000000000BD5F8 E4 21 05 00 00 00 00 00                 DCQ loc_521E4.data:00000000000BD600 44 22 05 00 00 00 00 00                 DCQ loc_52244.data:00000000000BD608 A8 22 05 00 00 00 00 00                 DCQ loc_522A8.data:00000000000BD610 0C 23 05 00 00 00 00 00                 DCQ loc_5230C.data:00000000000BD618 70 23 05 00 00 00 00 00                 DCQ loc_52370.data:00000000000BD620 CC 23 05 00 00 00 00 00                 DCQ loc_523CC.data:00000000000BD628 28 24 05 00 00 00 00 00                 DCQ loc_52428.data:00000000000BD630 84 24 05 00 00 00 00 00                 DCQ loc_52484.data:00000000000BD638 0C 25 05 00 00 00 00 00                 DCQ loc_5250C.data:00000000000BD640 88 25 05 00 00 00 00 00                 DCQ loc_52588.data:00000000000BD648 E4 25 05 00 00 00 00 00                 DCQ loc_525E4.data:00000000000BD650 40 26 05 00 00 00 00 00                 DCQ loc_52640.data:00000000000BD658 9C 26 05 00 00 00 00 00                 DCQ loc_5269C.data:00000000000BD660 00 27 05 00 00 00 00 00                 DCQ loc_52700.data:00000000000BD668 64 27 05 00 00 00 00 00                 DCQ loc_52764.data:00000000000BD670 C8 27 05 00 00 00 00 00                 DCQ loc_527C8.data:00000000000BD678 2C 28 05 00 00 00 00 00                 DCQ loc_5282C.data:00000000000BD680 90 28 05 00 00 00 00 00                 DCQ loc_52890.data:00000000000BD688 F4 28 05 00 00 00 00 00                 DCQ loc_528F4.data:00000000000BD690 58 29 05 00 00 00 00 00                 DCQ loc_52958.data:00000000000BD698 DC 29 05 00 00 00 00 00                 DCQ loc_529DC.data:00000000000BD6A0 38 2A 05 00 00 00 00 00                 DCQ loc_52A38.data:00000000000BD6A8 94 2A 05 00 00 00 00 00                 DCQ loc_52A94.data:00000000000BD6B0 F0 2A 05 00 00 00 00 00                 DCQ loc_52AF0.data:00000000000BD6B8 4C 2B 05 00 00 00 00 00                 DCQ loc_52B4C.data:00000000000BD6C0 C8 2B 05 00 00 00 00 00                 DCQ loc_52BC8.data:00000000000BD6C8 24 2C 05 00 00 00 00 00                 DCQ loc_52C24.data:00000000000BD6D0 80 2C 05 00 00 00 00 00                 DCQ loc_52C80.data:00000000000BD6D8 DC 2C 05 00 00 00 00 00                 DCQ loc_52CDC.data:00000000000BD6E0 70 2D 05 00 00 00 00 00                 DCQ loc_52D70.data:00000000000BD6E8 F8 2D 05 00 00 00 00 00                 DCQ loc_52DF8.data:00000000000BD6F0 54 2E 05 00 00 00 00 00                 DCQ loc_52E54.data:00000000000BD6F8 B0 2E 05 00 00 00 00 00                 DCQ loc_52EB0.data:00000000000BD700 0C 2F 05 00 00 00 00 00                 DCQ loc_52F0C.data:00000000000BD708 6C 2F 05 00 00 00 00 00                 DCQ loc_52F6C.data:00000000000BD710 D0 2F 05 00 00 00 00 00                 DCQ loc_52FD0.data:00000000000BD718 34 30 05 00 00 00 00 00                 DCQ loc_53034.data:00000000000BD720 C8 30 05 00 00 00 00 00                 DCQ loc_530C8.data:00000000000BD728 50 31 05 00 00 00 00 00                 DCQ loc_53150.data:00000000000BD730 B0 31 05 00 00 00 00 00                 DCQ loc_531B0.data:00000000000BD738 10 32 05 00 00 00 00 00                 DCQ loc_53210.data:00000000000BD740 70 32 05 00 00 00 00 00                 DCQ loc_53270.data:00000000000BD748 D0 32 05 00 00 00 00 00                 DCQ loc_532D0.data:00000000000BD750 30 33 05 00 00 00 00 00                 DCQ loc_53330.data:00000000000BD758 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD760 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD768 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD770 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD778 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD780 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD788 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD790 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD798 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD7A0 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD7A8 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD7B0 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD7B8 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD7C0 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD7C8 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD7D0 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD7D8 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD7E0 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD7E8 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD7F0 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD7F8 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD800 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD808 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD810 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD818 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD820 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD828 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD830 98 33 05 00 00 00 00 00                 DCQ loc_53398.data:00000000000BD838 98 33 05 00 00 00 00 00                 DCQ loc_53398\n\n继续交叉引用sub_4CC20，来到了关键的地方，基本可以确认sub_4CC20就是解释器了。\n\nhook了一些libc的open、strstr、read、strcmp之类的函数，并没有发现对frida的检测，好奇怪，那为什么会执行到sub_45EBC就崩溃呢？\n对着sub_45EBC进行分析，发现一个比较关键的地方。\n\n这个时候，可以打开我们之前trace的汇编指令，究竟是谁让w8变成了0。从0x4ad0c往上找，关于x8&#x2F;w8的赋值。\n\n很容易就找到，x11存放了一个地址，而x10的值为0，因此w8变成了0，继续追踪x10&#x2F;x11的含义。\n\n可以根据减去基址，看看x8和x0的含义，基址是0x743fc99000。\nx0对应0x2F38BFB0，x8对应0x2D40FEC78，看来调用的不是libbaiduprotect.so的函数，应该是别的库，所以减错了基址。\n我在ida中还原过这个地方，x8是malloc的运行地址，所以这里的x0是分配到的空间地址，和我想得不太一样啊？\n\n这说明，进入sub_45EBC函数后，应该是能正常出来的。\n其实仔细观察，为什么会发生崩溃呢？MOV WSP, #1虽然将栈顶寄存器指向了一个会奇怪的地方，但下一条指令很快的覆盖了SP的内容，因此应该不会造成崩溃，那问题只能处在frida-stalker了，它是不是在插桩的时候用到了SP？\n\n我们来看一下frida-stalker的原理。\n\n离我们的猜想很近，如果插桩的黄色代码中，使用到了sp寄存器，就会把程序弄崩溃，我们试试能不能在识别到MOV WSP, #1时候将它NOP掉，不执行，避免产生这样的问题。\n代码如下，下面这个代码可以绕过这一条指令，继续打印追踪的流程。\nvar offset = 0x88060;var module_size = 0;var module_name = &quot;libbaiduprotect.so&quot;;var base_addr = null; // To store the base address of libbaiduprotect.so// Create an empty functionvar empty_func = new NativeCallback(function() &#123;    // console.log(&quot;[Anti-Debug] Empty function executed.&quot;); // 可选日志    return 0;&#125;, &#x27;int&#x27;, [&#x27;pointer&#x27;]);function hook_linker_call_constructors() &#123;    // 为提高健壮性，建议使用更完善的 linker 及 call_constructors 查找逻辑    // 但为保持与你原始脚本的结构，暂时保留这种直接方式    let linker_module_name = Process.arch === &#x27;arm64&#x27; ? &#x27;linker64&#x27; : &#x27;linker&#x27;;    let linker64_base_addr = Module.getBaseAddress(linker_module_name);    if (!linker64_base_addr) &#123;        console.warn(&quot;[-] Failed to get &quot; + linker_module_name + &quot; base address. Trying to find module directly later.&quot;);        // Fallback if linker not found        setTimeout(function() &#123;            if (!base_addr) &#123; // Check if already found                let secmodule = Process.findModuleByName(module_name);                if (secmodule) &#123;                    base_addr = secmodule.base;                    module_size = secmodule.size;                    console.log(module_name + &quot; base (fallback): &quot; + base_addr + &quot;, size: &quot; + module_size);                    hook_target_func(base_addr);                &#125; else &#123;                    console.error(&quot;[-] &quot; + module_name + &quot; not found via fallback. Cannot proceed.&quot;);                &#125;            &#125;        &#125;, 1500); // Delay slightly        return;    &#125;    let offset_call = 0x51BA8; // __dl__ZN6soinfo17call_constructorsEv - 这个偏移非常依赖系统    let call_constructors = linker64_base_addr.add(offset_call);    console.log(&quot;[i] Attempting to attach to linker&#x27;s call_constructors at &quot; + call_constructors);    try &#123;        let listener = Interceptor.attach(call_constructors, &#123;            onEnter: function(args) &#123;                // console.log(&#x27;[linker] Call_Constructors onEnter&#x27;);                let secmodule = Process.findModuleByName(module_name);                if (secmodule != null) &#123;                    if (base_addr === null) &#123; // 确保只初始化一次                        module_size = secmodule.size;                        base_addr = secmodule.base; // Save the base address                        console.log(module_name + &quot; base: &quot; + base_addr + &quot;, size: &quot; + module_size);                                                // *** 在这里也可以考虑直接打补丁已知崩溃点, 但Stalker内处理更灵活些 ***                        // patchInstructionToNop(base_addr, 0x48AC0, 4);                        // patchInstructionToNop(base_addr, 0x4ABB8, 4);                        hook_target_func(base_addr);                        listener.detach();                        console.log(&quot;[i] Detached from linker hook.&quot;);                    &#125;                &#125;            &#125;        &#125;);    &#125; catch (e) &#123;        console.error(&quot;[-] Failed to attach to linker&#x27;s call_constructors: &quot; + e.message);        console.log(&quot;    Will rely on fallback to find module &quot; + module_name);         setTimeout(function() &#123; // 与上面的 fallback 逻辑类似            if (!base_addr) &#123;                let secmodule = Process.findModuleByName(module_name);                if (secmodule) &#123;                    base_addr = secmodule.base;                    module_size = secmodule.size;                    console.log(module_name + &quot; base (fallback after attach error): &quot; + base_addr + &quot;, size: &quot; + module_size);                    hook_target_func(base_addr);                &#125; else &#123;                    console.error(&quot;[-] Fallback after attach error: &quot; + module_name + &quot; not found.&quot;);                &#125;            &#125;        &#125;, 1500);    &#125;&#125;function hook_target_func(current_base_addr) &#123; // 使用 current_base_addr 区分全局 base_addr    if (!current_base_addr || current_base_addr.isNull())&#123;        console.error(&quot;[-] hook_target_func: current_base_addr is invalid.&quot;);        return;    &#125;    let target_addr = current_base_addr.add(offset); // offset = 0x88060    console.log(&quot;[+] Hooking target function at &quot; + target_addr + &quot; (offset 0x&quot; + offset.toString(16) + &quot;)&quot;);    try &#123;        let listener = Interceptor.attach(target_addr, &#123;            onEnter: function(args) &#123;                console.log(&quot;Target function &quot; + module_name + &quot;!0x&quot; + offset.toString(16) + &quot; entered. Called from: &quot; + this.returnAddress);            &#125;,            onLeave: function(retval) &#123;                console.log(module_name + &quot;!0x&quot; + offset.toString(16) + &quot; onLeave. Base address: &quot; + current_base_addr);                if (base_addr &amp;&amp; !base_addr.isNull()) &#123; // 确保全局base_addr有效                    hook_pthread_create();                    StalkerTrace(base_addr); // 传递正确的模块基址给StalkerTrace                &#125; else &#123;                    console.error(&quot;[-] Global base_addr not set in hook_target_func onLeave. Cannot start Stalker / pthread hook.&quot;);                &#125;                listener.detach();                console.log(&quot;[i] Detached from target_func hook at &quot; + target_addr);            &#125;        &#125;);    &#125; catch (e) &#123;        console.error(&quot;[-] Failed to attach to target_func at &quot; + target_addr + &quot;: &quot; + e.message);    &#125;&#125;function hook_pthread_create() &#123;    if (!base_addr || base_addr.isNull()) &#123;        console.error(&quot;[-] hook_pthread_create: Global base_addr is null.&quot;);        return;    &#125;    let pthread_create_addr = Module.findExportByName(&quot;libc.so&quot;, &quot;pthread_create&quot;);    if (pthread_create_addr) &#123;        console.log(&quot;[+] Hooking pthread_create at &quot; + pthread_create_addr);        try &#123;            Interceptor.attach(pthread_create_addr, &#123;                onEnter: function(args) &#123;                    let func_addr = args[2];                    let target_func_addr = base_addr.add(0x3E9F0);                    if (func_addr.equals(target_func_addr)) &#123;                        console.log(&quot;[Anti-Debug] Replacing thread start_routine &quot; + func_addr + &quot; with empty function.&quot;);                        args[2] = empty_func;                    &#125;                &#125;            &#125;);        &#125; catch (e) &#123;            console.error(&quot;[-] Failed to attach to pthread_create: &quot; + e.message);        &#125;    &#125; else &#123;        console.warn(&quot;[-] pthread_create not found in libc.so. Hook skipped.&quot;);    &#125;&#125;const TARGET_MODULE_NAME = &quot;libbaiduprotect.so&quot;; // 等同于 module_namefunction get_diff_regs(context, pre_regs) &#123;    var diff_regs = &#123;&#125;;    const current_regs_snapshot = JSON.parse(JSON.stringify(context));    for (const reg_name_orig in current_regs_snapshot) &#123;        if (current_regs_snapshot.hasOwnProperty(reg_name_orig)) &#123;            const reg_name = reg_name_orig.toLowerCase();            if (reg_name !== &quot;pc&quot; &amp;&amp; !reg_name.startsWith(&quot;q&quot;) &amp;&amp; reg_name !== &quot;sp&quot;) &#123; // 也可以过滤掉sp                if (pre_regs[reg_name_orig] !== current_regs_snapshot[reg_name_orig]) &#123;                    pre_regs[reg_name_orig] = current_regs_snapshot[reg_name_orig];                    diff_regs[reg_name_orig] = current_regs_snapshot[reg_name_orig];                &#125;            &#125;        &#125;    &#125;    return diff_regs;&#125;function get_involved_regs(instruction) &#123; /* ... (保持不变) ... */    const involved_regs = new Set();    instruction.operands.forEach(op =&gt; &#123;        if (op.type === &#x27;reg&#x27;) &#123; involved_regs.add(op.value); &#125;        else if (op.type === &#x27;mem&#x27;) &#123;            if (op.value.base) &#123; involved_regs.add(op.value.base); &#125;            if (op.value.index) &#123; involved_regs.add(op.value.index); &#125;        &#125;    &#125;);    return Array.from(involved_regs);&#125;// =======================================================================================// 修改 StalkerTrace 函数// =======================================================================================function StalkerTrace(current_module_baseaddr) &#123; // 确保传入的是正确的模块基地址    var stalker_target_func_offset = 0x4a458; // 这是你希望Stalker开始追踪的函数偏移    var sub_42598_addr = current_module_baseaddr.add(stalker_target_func_offset);    console.log(&quot;[+] StalkerTrace will target &quot; + TARGET_MODULE_NAME + &quot;!&quot; + ptr(stalker_target_func_offset) + &quot; at actual address: &quot; + sub_42598_addr);    var module_stalk_target = Process.findModuleByAddress(sub_42598_addr);    if (!module_stalk_target || module_stalk_target.name !== TARGET_MODULE_NAME) &#123;        console.error(&quot;[-] StalkerTrace: Module for target function (&quot; + sub_42598_addr + &quot;) is not &quot; + TARGET_MODULE_NAME +                      &quot;. Found: &quot; + (module_stalk_target ? module_stalk_target.name : &quot;none&quot;) +                      &quot;. Ensure base address and offset are correct. Stalker might not work as expected.&quot;);        // 如果模块名不匹配，我们可能不应该继续，或者用传入的 baseaddr 作为module_start/end的依据        if (!current_module_baseaddr || current_module_baseaddr.isNull()) &#123;            console.error(&quot;[-] StalkerTrace: No valid base address to proceed with module bounds.&quot;);            return;        &#125;         module_stalk_target = &#123; base: current_module_baseaddr, size: module_size, name: TARGET_MODULE_NAME &#125;; // module_size 是全局的         console.warn(&quot;[-] StalkerTrace: Using passed base_addr for module bounds for Stalker.&quot;);    &#125;        const module_start = module_stalk_target.base;    const module_end = module_stalk_target.base.add(module_stalk_target.size); // Stalker只记录此模块内的指令    console.log(&quot;[i] Stalker module bounds: Start=&quot; + module_start + &quot;, End=&quot; + module_end);    Interceptor.attach(sub_42598_addr, &#123;        onEnter: function (args) &#123;            this.tid = Process.getCurrentThreadId();            console.log(&quot;[+] Stalker: Entered &quot; + TARGET_MODULE_NAME + &quot;!&quot; + ptr(stalker_target_func_offset) + &quot; (TID: &quot; + this.tid + &quot;)&quot;);            const local_pre_regs = &#123;&#125;;            const initial_context_snapshot = JSON.parse(JSON.stringify(this.context));            for (const reg_name_orig in initial_context_snapshot) &#123;                if (initial_context_snapshot.hasOwnProperty(reg_name_orig)) &#123;                    const reg_name = reg_name_orig.toLowerCase();                    if (reg_name !== &quot;pc&quot; &amp;&amp; !reg_name.startsWith(&quot;q&quot;)) &#123;                        local_pre_regs[reg_name_orig] = initial_context_snapshot[reg_name_orig];                    &#125;                &#125;            &#125;                        // === 新增：用于直接patch的已知崩溃点 ===            // 这些地址相对于 current_module_baseaddr (即 libbaiduprotect.so 的基地址)            const knownCrashOffsets = [0x48AC0, 0x4ABB8]; // 把已知的都列出来            knownCrashOffsets.forEach(offset =&gt; &#123;                try &#123;                    const patchAddr = current_module_baseaddr.add(offset);                    // 读取指令，确认是否是 MOV WSP, #1                    const instrBytes = patchAddr.readByteArray(4);                    // MOV WSP, #1 (MOVZ W31, #1, LSL #0) -&gt; FF 03 00 32 (Little Endian: 320003FF)                    if (instrBytes &amp;&amp; instrBytes[0] === 0x32 &amp;&amp; instrBytes[1] === 0x00 &amp;&amp; instrBytes[2] === 0x03 &amp;&amp; instrBytes[3] === 0xFF) &#123;                        Memory.patchCode(patchAddr, 4, code =&gt; &#123;                            const writer = new Arm64Writer(code, &#123; pc: patchAddr &#125;);                            writer.putNop();                            writer.flush();                        &#125;);                        console.log(&quot;[MemoryPatch] Stalker&#x27;s onEnter: NOPped known crash (MOV WSP, #1) at &quot; + module_name + &quot;!&quot; + ptr(offset) + &quot; (&quot;+ patchAddr + &quot;)&quot;);                    &#125; else &#123;                        // console.log(&quot;[MemoryPatch] Stalker&#x27;s onEnter: Instruction at &quot; + module_name + &quot;!&quot; + ptr(offset) + &quot; is not MOV WSP, #1. Bytes: &quot; + Array.from(new Uint8Array(instrBytes)).map(b =&gt; b.toString(16).padStart(2,&#x27;0&#x27;)).join(&#x27;&#x27;));                    &#125;                &#125; catch (e) &#123;                    console.warn(&quot;[MemoryPatch] Stalker&#x27;s onEnter: Error patching &quot; + module_name + &quot;!&quot; + ptr(offset) + &quot;: &quot; + e.message);                &#125;            &#125;);            // =====================================            Stalker.follow(this.tid, &#123;                events: &#123; call: false, ret: false, exec: true, block: false, compile: false &#125;,                transform(iterator) &#123;                    let instruction = iterator.next();                    do &#123;                        const currentAddress = instruction.address;                        let patchedThisInstruction = false;                        // 通用的 MOV WSP/SP, #1 检测和NOP逻辑 (作为补充)                        const mnemonic = instruction.mnemonic.toLowerCase();                        if ((mnemonic === &#x27;mov&#x27; || mnemonic === &#x27;movz&#x27;) &amp;&amp; instruction.operands.length &gt;= 2) &#123;                            const destOperand = instruction.operands[0];                            const srcOperand = instruction.operands[1];                            if (destOperand.type === &#x27;reg&#x27; &amp;&amp;                                (destOperand.value === &#x27;wsp&#x27; || destOperand.value === &#x27;sp&#x27; ||                                 destOperand.value === &#x27;w31&#x27; || destOperand.value === &#x27;x31&#x27;) &amp;&amp;                                srcOperand.type === &#x27;imm&#x27; &amp;&amp;                                parseInt(srcOperand.value.toString()) === 1) &#123;                                console.warn(&quot;[StalkerTransform] Identified &#x27;&quot; + instruction.toString() + &quot;&#x27; at &quot; + currentAddress + &quot;. Replacing with NOP.&quot;);                                iterator.putNop();                                patchedThisInstruction = true;                            &#125;                        &#125;                        if (!patchedThisInstruction) &#123;                            // 仅在模块代码范围内执行putCallout，减少日志量并避免干扰其他模块                            const is_module_code = currentAddress.compare(module_start) &gt;= 0 &amp;&amp;                                                   currentAddress.compare(module_end) &lt; 0;                            if (is_module_code) &#123;                                iterator.putCallout(function (context) &#123;                                    var pc = context.pc;                                    // module_start, module_end, TARGET_MODULE_NAME, get_diff_regs, local_pre_regs                                    // 这些变量需要能被这个闭包访问到。local_pre_regs 是 onEnter 作用域的。                                    // module_start 等可以考虑从外部作用域传入或再次获取。                                    // 为简化，假设它们可访问。                                    var current_callout_module = Process.findModuleByAddress(pc);                                    if (current_callout_module &amp;&amp; current_callout_module.name === TARGET_MODULE_NAME) &#123;                                        const instrToLog = Instruction.parse(pc);                                        const diff_regs = get_diff_regs(context, local_pre_regs);                                        console.log(                                            current_callout_module.name + &quot;!&quot; + pc.sub(current_callout_module.base),                                            instrToLog.toString(),                                            &quot;\\t\\t&quot;, JSON.stringify(diff_regs)                                        );                                    &#125;                                &#125;);                            &#125;                            iterator.keep();                        &#125;                    &#125; while ((instruction = iterator.next()) !== null);                &#125;            &#125;);        &#125;,        onLeave: function (retval) &#123;            console.log(&quot;[+] &quot; + TARGET_MODULE_NAME + &quot;!&quot; + ptr(stalker_target_func_offset) + &quot; onLeave, TID:&quot;, this.tid);            Stalker.unfollow(this.tid); // 在函数退出时明确停止Stalker是个好习惯            Stalker.garbageCollect();   // 回收Stalker资源        &#125;    &#125;);&#125;setImmediate(function() &#123;    console.log(&quot;[i] Script starting for &quot; + module_name + &quot;...&quot;);    hook_linker_call_constructors();&#125;);console.log(&quot;[i] Script loaded. Waiting for &quot; + module_name + &quot;...&quot;);\n\n听说frida-sktrace实现了字符串（连续有4个可显示的字符时，打印字符串）的打印，而且更美观一些，这里试试使用frida-sktrace，但似乎不支持spawn模式附加进程，而且hook的时机还得修改，我决定在我原有的代码上添加这个功能。——我改成了，存在连续3个可视字符时，把指针内容当成字符串地址。\n下面是让大模型帮我写的代码，不过也太长了吧。\n// =======================================================================================// Modified StalkerTrace Function (FIXED local_pre_regs access)// =======================================================================================function StalkerTrace(current_module_baseaddr) &#123; // Ensure the correct module base address is passed    // Use the global module_size which should be set by now    if (!current_module_baseaddr || current_module_baseaddr.isNull() || module_size === 0) &#123;         console.error(&quot;[-] StalkerTrace: Invalid module base address or size. Cannot proceed.&quot;);         return;    &#125;    var stalker_target_func_offset = 0x4a458; // The offset of the function you want Stalker to trace    var stalker_start_addr = current_module_baseaddr.add(stalker_target_func_offset);    console.log(&quot;[+] StalkerTrace will target &quot; + TARGET_MODULE_NAME + &quot;!&quot; + ptr(stalker_target_func_offset) + &quot; at actual address: &quot; + stalker_start_addr);    // Define the module bounds for Stalker logging    const module_start = current_module_baseaddr;    const module_end = current_module_baseaddr.add(module_size);    console.log(&quot;[i] Stalker module bounds: Start=&quot; + module_start + &quot;, End=&quot; + module_end);    Interceptor.attach(stalker_start_addr, &#123;        onEnter: function (args) &#123;            // Stalker operates per thread. Get the current thread ID.            this.tid = Process.getCurrentThreadId();            console.log(&quot;[+] Stalker: Entered &quot; + TARGET_MODULE_NAME + &quot;!&quot; + ptr(stalker_target_func_offset) + &quot; (TID: &quot; + this.tid + &quot;)&quot;);            // Initialize previous register state *for this specific thread*.            // This variable is local to this onEnter call but will be captured by the closure.            const local_pre_regs = &#123;&#125;;             // Populate initial state, excluding filtered registers            const initial_context_snapshot = JSON.parse(JSON.stringify(this.context));            for (const reg_name_orig in initial_context_snapshot) &#123;                if (initial_context_snapshot.hasOwnProperty(reg_name_orig)) &#123;                    const reg_name_lower = reg_name_orig.toLowerCase();                     if (reg_name_lower !== &quot;pc&quot; &amp;&amp; reg_name_lower !== &quot;sp&quot; &amp;&amp; !reg_name_lower.startsWith(&quot;q&quot;) &amp;&amp; !reg_name_lower.startsWith(&quot;v&quot;)) &#123;                        local_pre_regs[reg_name_orig] = initial_context_snapshot[reg_name_orig];                    &#125;                &#125;            &#125;            // *** REMOVE THIS LINE *** this.local_pre_regs = local_pre_regs;             // The variable &#x27;local_pre_regs&#x27; is already in scope for the transform/callout closures.            // === Patch known crashing instructions on entering the traced function ===            // These addresses are relative to the module base address (current_module_baseaddr)            const knownCrashOffsets = [0x48AC0, 0x4ABB8]; // List of known problematic instruction offsets            knownCrashOffsets.forEach(offset =&gt; &#123;                try &#123;                    const patchAddr = current_module_baseaddr.add(offset);                    // Read instruction bytes to verify it&#x27;s the expected &#x27;MOV WSP, #1&#x27;                    // ARM64: MOV WSP, #1 is 320003FF (little endian)                    const expectedBytes = new Uint8Array([0x32, 0x00, 0x03, 0xFF]);                    const instrBytes = patchAddr.readByteArray(4);                    const actualBytes = new Uint8Array(instrBytes);                    let matchesExpected = true;                    if (actualBytes.length === 4) &#123;                         for(let i=0; i&lt;4; i++) &#123;                              if (actualBytes[i] !== expectedBytes[i]) &#123;                                   matchesExpected = false;                                   break;                              &#125;                         &#125;                    &#125; else &#123;                         matchesExpected = false;                    &#125;                    if (matchesExpected) &#123;                         // If it matches, NOP it                         Memory.patchCode(patchAddr, 4, code =&gt; &#123;                             const writer = new Arm64Writer(code, &#123; pc: patchAddr &#125;);                             writer.putNop(); // Replace the instruction with NOP                             writer.flush();                         &#125;);                         console.log(&quot;[MemoryPatch] Stalker&#x27;s onEnter: NOPped known crash (MOV WSP, #1) at &quot; + module_name + &quot;!&quot; + ptr(offset) + &quot; (&quot;+ patchAddr + &quot;)&quot;);                    &#125; else &#123;                         // console.log(&quot;[MemoryPatch] Stalker&#x27;s onEnter: Instruction at &quot; + module_name + &quot;!&quot; + ptr(offset) + &quot; is not MOV WSP, #1. Bytes: &quot; + Array.from(actualBytes).map(b =&gt; b.toString(16).padStart(2,&#x27;0&#x27;)).join(&#x27;&#x27;)); // Optional log                    &#125;                &#125; catch (e) &#123;                    console.warn(&quot;[MemoryPatch] Stalker&#x27;s onEnter: Error patching &quot; + module_name + &quot;!&quot; + ptr(offset) + &quot;: &quot; + e.message);                &#125;            &#125;);            // ==================================================================            Stalker.follow(this.tid, &#123;                 // Configure events to trace. exec=true traces every executed instruction.                events: &#123; call: false, ret: false, exec: true, block: false, compile: false &#125;,                 // The transform callback allows inspecting/rewriting instruction blocks                transform(iterator) &#123;                    let instruction = iterator.next();                    do &#123;                        const currentAddress = instruction.address;                        let patchedThisInstruction = false;                        // Check if the instruction is within the target module&#x27;s bounds                        const is_module_code = currentAddress.compare(module_start) &gt;= 0 &amp;&amp;                                               currentAddress.compare(module_end) &lt; 0;                         // === Universal MOV WSP/SP, #1 detection and NOP logic ===                         // This is a fallback/alternative to the onEnter patch                         // It happens per block compiled by Stalker                        if (is_module_code) &#123; // Only patch instructions within the target module                            const mnemonic = instruction.mnemonic.toLowerCase();                             // Check for MOV or MOVZ with SP/WSP as destination and immediate 1                             if ((mnemonic === &#x27;mov&#x27; || mnemonic === &#x27;movz&#x27;) &amp;&amp; instruction.operands.length &gt;= 2) &#123;                                 const destOperand = instruction.operands[0];                                 const srcOperand = instruction.operands[1];                                 if (destOperand.type === &#x27;reg&#x27; &amp;&amp;                                     (destOperand.value === &#x27;wsp&#x27; || destOperand.value === &#x27;sp&#x27; ||                                      destOperand.value === &#x27;w31&#x27; || destOperand.value === &#x27;x31&#x27;) &amp;&amp; // w31/x31 are aliases for wsp/sp                                     srcOperand.type === &#x27;imm&#x27; &amp;&amp;                                     parseInt(srcOperand.value.toString()) === 1) &#123;                                     console.warn(&quot;[StalkerTransform] Identified potential crash instruction &#x27;&quot; + instruction.toString() + &quot;&#x27; at &quot; + currentAddress + &quot;. Replacing with NOP.&quot;);                                     iterator.putNop(); // Replace the instruction with NOP                                     patchedThisInstruction = true;                                 &#125;                             &#125;                        &#125;                        // =========================================================                        // If the instruction wasn&#x27;t NOPped by the above check, add a callout for logging                        if (!patchedThisInstruction) &#123;                            // Only add callout for instructions within the target module                            if (is_module_code) &#123;                                // &#x27;local_pre_regs&#x27; is accessible here via closure                                iterator.putCallout(function (context) &#123;                                    // Access local_pre_regs directly from the outer scope (captured by closure)                                    const thread_pre_regs = local_pre_regs;                                     const pc = context.pc;                                    // Get the register differences after this instruction executes                                    // get_diff_regs modifies thread_pre_regs in place                                    const diff_regs = get_diff_regs(context, thread_pre_regs);                                                                        // Find the module info again (can be optimized by caching, but this is reliable)                                    var current_callout_module = Process.findModuleByAddress(pc);                                     // Ensure we are logging code from the target module                                     if (current_callout_module &amp;&amp; current_callout_module.name === TARGET_MODULE_NAME) &#123;                                         const instrToLog = Instruction.parse(pc);                                         let logLine = `$&#123;current_callout_module.name&#125;!$&#123;pc.sub(current_callout_module.base)&#125; $&#123;instrToLog.toString()&#125;`;                                         // Append changed registers and potential strings                                         const diffRegKeys = Object.keys(diff_regs);                                         if (diffRegKeys.length &gt; 0) &#123;                                              logLine += `\\t\\t| Changed Regs: `;                                              let firstReg = true;                                              for (const regName of diffRegKeys) &#123;                                                   if (!firstReg) logLine += &quot;, &quot;;                                                   firstReg = false;                                                   const regValue = diff_regs[regName]; // The new value of the register                                                   logLine += `$&#123;regName&#125;=$&#123;regValue&#125;`;                                                   // --- Check if the register value points to a string ---                                                   const potentialString = tryReadString(regValue);                                                   if (potentialString !== null) &#123;                                                       // Truncate long strings for readability                                                       const displayString = potentialString.length &gt; 60 ? potentialString.substring(0, 57) + &quot;...&quot; : potentialString;                                                       // Escape potential quotes in the string for cleaner output                                                       const escapedString = displayString.replace(/&quot;/g, &#x27;\\\\&quot;&#x27;).replace(/\\n/g, &#x27;\\\\n&#x27;).replace(/\\r/g, &#x27;\\\\r&#x27;);                                                        logLine += ` (&quot;$&#123;escapedString&#125;&quot;)`;                                                   &#125;                                                   // ----------------------------------------------------------                                              &#125;                                         &#125;                                         console.log(logLine);                                     &#125;                                &#125;);                            &#125;                            // Keep the original instruction                            iterator.keep();                        &#125;                    &#125; while ((instruction = iterator.next()) !== null); // Process next instruction in the block                &#125;            &#125;);        &#125;,        onLeave: function (retval) &#123;            console.log(&quot;[+] &quot; + TARGET_MODULE_NAME + &quot;!&quot; + ptr(stalker_target_func_offset) + &quot; onLeave, TID:&quot;, this.tid);             // Stop stalking this thread when the function exits            Stalker.unfollow(this.tid);             // Clean up Stalker&#x27;s compiled code cache            Stalker.garbageCollect();        &#125;    &#125;);&#125;// ... (rest of the script remains the same)// hook_linker_call_constructors();// hook_target_func(base_addr); // Called from linker hook or fallback// hook_pthread_create(); // Called from hook_target_func onLeave// tryReadString() // Helper function defined above// get_diff_regs() // Helper function defined above// get_involved_regs() // Helper function defined abovevar offset = 0x88060;var module_size = 0; // Will be populated when module is foundvar module_name = &quot;libbaiduprotect.so&quot;;var base_addr = null; // To store the base address of libbaiduprotect.so// Create an empty functionvar empty_func = new NativeCallback(function() &#123;    // console.log(&quot;[Anti-Debug] Empty function executed.&quot;); // Optional log    return 0;&#125;, &#x27;int&#x27;, [&#x27;pointer&#x27;]);// --- Helper function to attempt reading a string ---function tryReadString(address, minPrintableBytes = 3, maxReadLength = 256) &#123;    if (!address) &#123;        return null; // Cannot read from null address    &#125;        try &#123;        // Step 1: Read the first few bytes to see if they look like printable ASCII        const preliminaryBytes = address.readByteArray(minPrintableBytes);        if (!preliminaryBytes) &#123;             // Can&#x27;t read the initial bytes (e.g., invalid address)            return null;        &#125;                const uint8Array = new Uint8Array(preliminaryBytes);        let allPrintable = true;        for (let i = 0; i &lt; uint8Array.length; i++) &#123;            const byte = uint8Array[i];            // Basic check for printable ASCII (0x20 to 0x7E)            if (byte &lt; 0x20 || byte &gt; 0x7E) &#123;                allPrintable = false;                break;            &#125;        &#125;        if (allPrintable) &#123;            // Step 2: If they look printable, attempt to read a C-string            // readCString reads until null terminator or max length            const str = address.readCString(maxReadLength);             // Filter out empty strings or strings that only contained non-null printable chars but no null terminator early on            if (str &amp;&amp; str.length &gt; 0) &#123;                return str;            &#125;        &#125;            &#125; catch (e) &#123;        // Reading failed (e.g., invalid memory access)        // console.warn(&quot;[-] Failed to read memory at &quot; + address + &quot; for string check: &quot; + e.message); // Optional: Log errors        return null;    &#125;    return null; // Did not pass the checks or failed to read&#125;// ---------------------------------------------------function hook_linker_call_constructors() &#123;    // 为提高健壮性，建议使用更完善的 linker 及 call_constructors 查找逻辑    // 但为保持与你原始脚本的结构，暂时保留这种直接方式    let linker_module_name = Process.arch === &#x27;arm64&#x27; ? &#x27;linker64&#x27; : &#x27;linker&#x27;;    let linker64_base_addr = Module.getBaseAddress(linker_module_name);    if (!linker64_base_addr) &#123;        console.warn(&quot;[-] Failed to get &quot; + linker_module_name + &quot; base address. Trying to find module directly later.&quot;);        // Fallback if linker not found        setTimeout(function() &#123;            if (!base_addr) &#123; // Check if already found                let secmodule = Process.findModuleByName(module_name);                if (secmodule) &#123;                    base_addr = secmodule.base;                    module_size = secmodule.size;                    console.log(module_name + &quot; base (fallback): &quot; + base_addr + &quot;, size: &quot; + module_size);                    hook_target_func(base_addr);                &#125; else &#123;                    console.error(&quot;[-] &quot; + module_name + &quot; not found via fallback. Cannot proceed.&quot;);                &#125;            &#125;        &#125;, 1500); // Delay slightly        return;    &#125;    // NOTE: This offset is highly dependent on the system/Android version and linker variant!    // A more robust approach would involve scanning for the function signature.    let offset_call = 0x51BA8; // Example: __dl__ZN6soinfo17call_constructorsEv on some systems    let call_constructors = linker64_base_addr.add(offset_call);    console.log(&quot;[i] Attempting to attach to linker&#x27;s call_constructors at &quot; + call_constructors);    try &#123;        let listener = Interceptor.attach(call_constructors, &#123;            onEnter: function(args) &#123;                // console.log(&#x27;[linker] Call_Constructors onEnter&#x27;);                let secmodule = Process.findModuleByName(module_name);                if (secmodule != null) &#123;                    if (base_addr === null) &#123; // Ensure initialized only once                        module_size = secmodule.size;                        base_addr = secmodule.base; // Save the base address                        console.log(module_name + &quot; base: &quot; + base_addr + &quot;, size: &quot; + module_size);                                                // *** Consider patching known points here or within Stalker ***                        // Patching here happens earlier, might be safer for some anti-debug                        // patchInstructionToNop(base_addr, 0x48AC0, 4); // Example offset                        // patchInstructionToNop(base_addr, 0x4ABB8, 4); // Example offset                        hook_target_func(base_addr);                        listener.detach(); // Detach once the module is found                        console.log(&quot;[i] Detached from linker hook.&quot;);                    &#125;                &#125;            &#125;            // No onLeave needed for just finding the module base        &#125;);    &#125; catch (e) &#123;        console.error(&quot;[-] Failed to attach to linker&#x27;s call_constructors: &quot; + e.message);        console.log(&quot;    Will rely on fallback to find module &quot; + module_name);          setTimeout(function() &#123; // Similar fallback logic as above              if (!base_addr) &#123;                  let secmodule = Process.findModuleByName(module_name);                  if (secmodule) &#123;                      base_addr = secmodule.base;                      module_size = secmodule.size;                      console.log(module_name + &quot; base (fallback after attach error): &quot; + base_addr + &quot;, size: &quot; + module_size);                      hook_target_func(base_addr);                  &#125; else &#123;                      console.error(&quot;[-] Fallback after attach error: &quot; + module_name + &quot; not found.&quot;);                  &#125;              &#125;          &#125;, 1500);    &#125;&#125;function hook_target_func(current_base_addr) &#123; // Use current_base_addr to distinguish from global base_addr    if (!current_base_addr || current_base_addr.isNull())&#123;        console.error(&quot;[-] hook_target_func: current_base_addr is invalid.&quot;);        return;    &#125;    let target_addr = current_base_addr.add(offset); // offset = 0x88060    console.log(&quot;[+] Hooking target function at &quot; + target_addr + &quot; (offset 0x&quot; + offset.toString(16) + &quot;)&quot;);    try &#123;        // Use attachOnce if you only need it to trigger once        Interceptor.attach(target_addr, &#123;            onEnter: function(args) &#123;                console.log(&quot;Target function &quot; + module_name + &quot;!0x&quot; + offset.toString(16) + &quot; entered. Called from: &quot; + this.returnAddress);            &#125;,            onLeave: function(retval) &#123;                console.log(module_name + &quot;!0x&quot; + offset.toString(16) + &quot; onLeave. Base address: &quot; + current_base_addr);                // IMPORTANT: Use the global base_addr here as it should be set by now and is needed by StalkerTrace/pthread hook                if (base_addr &amp;&amp; !base_addr.isNull()) &#123;                     hook_pthread_create();                    StalkerTrace(base_addr); // Pass the correct module base address to StalkerTrace                &#125; else &#123;                    console.error(&quot;[-] Global base_addr not set in hook_target_func onLeave. Cannot start Stalker / pthread hook.&quot;);                &#125;                 // No need to detach here if using attachOnce, but if using attach, you might detach                 // listener.detach();                 // console.log(&quot;[i] Detached from target_func hook at &quot; + target_addr);            &#125;        &#125;);         // Note: Interceptor.attachOnce is often better if you only need the onLeave logic once         // However, let&#x27;s stick to attach and detach in onLeave for now based on your original code structure.    &#125; catch (e) &#123;        console.error(&quot;[-] Failed to attach to target_func at &quot; + target_addr + &quot;: &quot; + e.message);    &#125;&#125;function hook_pthread_create() &#123;    // Ensure base_addr is set before hooking pthread_create as it&#x27;s needed for comparison    if (!base_addr || base_addr.isNull()) &#123;        console.error(&quot;[-] hook_pthread_create: Global base_addr is null. Skipping hook.&quot;);        return;    &#125;    let pthread_create_addr = Module.findExportByName(&quot;libc.so&quot;, &quot;pthread_create&quot;);    if (pthread_create_addr) &#123;        console.log(&quot;[+] Hooking pthread_create at &quot; + pthread_create_addr);        try &#123;            Interceptor.attach(pthread_create_addr, &#123;                onEnter: function(args) &#123;                    // pthread_create signature:                    // int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);                    // start_routine is the 3rd argument (index 2)                    let func_addr = args[2];                                         // Target function address within libbaiduprotect.so                    // This offset (0x3E9F0) might also need dynamic finding                    let target_func_offset_pthread = 0x3E9F0;                     let target_func_addr = base_addr.add(target_func_offset_pthread);                    // Check if the thread being created is the one we want to intercept                    if (func_addr.equals(target_func_addr)) &#123;                        console.log(&quot;[Anti-Debug] Replacing thread start_routine &quot; + func_addr + &quot; with empty function.&quot;);                        // Replace the actual start routine pointer with our empty function&#x27;s pointer                        args[2] = empty_func;                     &#125;                &#125;            &#125;);        &#125; catch (e) &#123;            console.error(&quot;[-] Failed to attach to pthread_create: &quot; + e.message);        &#125;    &#125; else &#123;        console.warn(&quot;[-] pthread_create not found in libc.so. Hook skipped.&quot;);    &#125;&#125;const TARGET_MODULE_NAME = &quot;libbaiduprotect.so&quot;; // Same as module_name for clarity with Stalkerfunction get_diff_regs(context, pre_regs) &#123;    var diff_regs = &#123;&#125;;    // Create a snapshot of the current context&#x27;s general-purpose registers    const current_regs_snapshot = JSON.parse(JSON.stringify(context));         // Iterate through the original register names from the snapshot    for (const reg_name_orig in current_regs_snapshot) &#123;        // Ensure it&#x27;s a direct property, not inherited        if (current_regs_snapshot.hasOwnProperty(reg_name_orig)) &#123;            const reg_name_lower = reg_name_orig.toLowerCase();            // Filter out PC, SP, and floating-point/vector registers (q* or v*)            if (reg_name_lower !== &quot;pc&quot; &amp;&amp; reg_name_lower !== &quot;sp&quot; &amp;&amp; !reg_name_lower.startsWith(&quot;q&quot;) &amp;&amp; !reg_name_lower.startsWith(&quot;v&quot;)) &#123;                 // Compare with the previous snapshot                if (pre_regs[reg_name_orig] !== current_regs_snapshot[reg_name_orig]) &#123;                    // If the value has changed, update the previous snapshot and record the difference                    pre_regs[reg_name_orig] = current_regs_snapshot[reg_name_orig];                    diff_regs[reg_name_orig] = current_regs_snapshot[reg_name_orig]; // Store the NEW value                &#125;            &#125;        &#125;    &#125;    return diff_regs;&#125;// This function is defined but not currently used in the logging. Keeping it as it was in the original code.function get_involved_regs(instruction) &#123;     const involved_regs = new Set();    instruction.operands.forEach(op =&gt; &#123;        if (op.type === &#x27;reg&#x27;) &#123; involved_regs.add(op.value); &#125;        else if (op.type === &#x27;mem&#x27;) &#123;            if (op.value.base) &#123; involved_regs.add(op.value.base); &#125;            if (op.value.index) &#123; involved_regs.add(op.value.index); &#125;        &#125;    &#125;);    return Array.from(involved_regs);&#125;// =======================================================================================// Modified StalkerTrace Function (FIXED local_pre_regs access)// =======================================================================================function StalkerTrace(current_module_baseaddr) &#123; // Ensure the correct module base address is passed    // Use the global module_size which should be set by now    if (!current_module_baseaddr || current_module_baseaddr.isNull() || module_size === 0) &#123;         console.error(&quot;[-] StalkerTrace: Invalid module base address or size. Cannot proceed.&quot;);         return;    &#125;    var stalker_target_func_offset = 0x4a458; // The offset of the function you want Stalker to trace    var stalker_start_addr = current_module_baseaddr.add(stalker_target_func_offset);    console.log(&quot;[+] StalkerTrace will target &quot; + TARGET_MODULE_NAME + &quot;!&quot; + ptr(stalker_target_func_offset) + &quot; at actual address: &quot; + stalker_start_addr);    // Define the module bounds for Stalker logging    const module_start = current_module_baseaddr;    const module_end = current_module_baseaddr.add(module_size);    console.log(&quot;[i] Stalker module bounds: Start=&quot; + module_start + &quot;, End=&quot; + module_end);    Interceptor.attach(stalker_start_addr, &#123;        onEnter: function (args) &#123;            // Stalker operates per thread. Get the current thread ID.            this.tid = Process.getCurrentThreadId();            console.log(&quot;[+] Stalker: Entered &quot; + TARGET_MODULE_NAME + &quot;!&quot; + ptr(stalker_target_func_offset) + &quot; (TID: &quot; + this.tid + &quot;)&quot;);            // Initialize previous register state *for this specific thread*.            // This variable is local to this onEnter call but will be captured by the closure.            const local_pre_regs = &#123;&#125;;             // Populate initial state, excluding filtered registers            const initial_context_snapshot = JSON.parse(JSON.stringify(this.context));            for (const reg_name_orig in initial_context_snapshot) &#123;                if (initial_context_snapshot.hasOwnProperty(reg_name_orig)) &#123;                    const reg_name_lower = reg_name_orig.toLowerCase();                     if (reg_name_lower !== &quot;pc&quot; &amp;&amp; reg_name_lower !== &quot;sp&quot; &amp;&amp; !reg_name_lower.startsWith(&quot;q&quot;) &amp;&amp; !reg_name_lower.startsWith(&quot;v&quot;)) &#123;                        local_pre_regs[reg_name_orig] = initial_context_snapshot[reg_name_orig];                    &#125;                &#125;            &#125;            // *** REMOVE THIS LINE *** this.local_pre_regs = local_pre_regs;             // The variable &#x27;local_pre_regs&#x27; is already in scope for the transform/callout closures.            // === Patch known crashing instructions on entering the traced function ===            // These addresses are relative to the module base address (current_module_baseaddr)            const knownCrashOffsets = [0x48AC0, 0x4ABB8]; // List of known problematic instruction offsets            knownCrashOffsets.forEach(offset =&gt; &#123;                try &#123;                    const patchAddr = current_module_baseaddr.add(offset);                    // Read instruction bytes to verify it&#x27;s the expected &#x27;MOV WSP, #1&#x27;                    // ARM64: MOV WSP, #1 is 320003FF (little endian)                    const expectedBytes = new Uint8Array([0x32, 0x00, 0x03, 0xFF]);                    const instrBytes = patchAddr.readByteArray(4);                    const actualBytes = new Uint8Array(instrBytes);                    let matchesExpected = true;                    if (actualBytes.length === 4) &#123;                         for(let i=0; i&lt;4; i++) &#123;                              if (actualBytes[i] !== expectedBytes[i]) &#123;                                   matchesExpected = false;                                   break;                              &#125;                         &#125;                    &#125; else &#123;                         matchesExpected = false;                    &#125;                    if (matchesExpected) &#123;                         // If it matches, NOP it                         Memory.patchCode(patchAddr, 4, code =&gt; &#123;                             const writer = new Arm64Writer(code, &#123; pc: patchAddr &#125;);                             writer.putNop(); // Replace the instruction with NOP                             writer.flush();                         &#125;);                         console.log(&quot;[MemoryPatch] Stalker&#x27;s onEnter: NOPped known crash (MOV WSP, #1) at &quot; + module_name + &quot;!&quot; + ptr(offset) + &quot; (&quot;+ patchAddr + &quot;)&quot;);                    &#125; else &#123;                         // console.log(&quot;[MemoryPatch] Stalker&#x27;s onEnter: Instruction at &quot; + module_name + &quot;!&quot; + ptr(offset) + &quot; is not MOV WSP, #1. Bytes: &quot; + Array.from(actualBytes).map(b =&gt; b.toString(16).padStart(2,&#x27;0&#x27;)).join(&#x27;&#x27;)); // Optional log                    &#125;                &#125; catch (e) &#123;                    console.warn(&quot;[MemoryPatch] Stalker&#x27;s onEnter: Error patching &quot; + module_name + &quot;!&quot; + ptr(offset) + &quot;: &quot; + e.message);                &#125;            &#125;);            // ==================================================================            Stalker.follow(this.tid, &#123;                 // Configure events to trace. exec=true traces every executed instruction.                events: &#123; call: false, ret: false, exec: true, block: false, compile: false &#125;,                 // The transform callback allows inspecting/rewriting instruction blocks                transform(iterator) &#123;                    let instruction = iterator.next();                    do &#123;                        const currentAddress = instruction.address;                        let patchedThisInstruction = false;                        // Check if the instruction is within the target module&#x27;s bounds                        const is_module_code = currentAddress.compare(module_start) &gt;= 0 &amp;&amp;                                               currentAddress.compare(module_end) &lt; 0;                         // === Universal MOV WSP/SP, #1 detection and NOP logic ===                         // This is a fallback/alternative to the onEnter patch                         // It happens per block compiled by Stalker                        if (is_module_code) &#123; // Only patch instructions within the target module                            const mnemonic = instruction.mnemonic.toLowerCase();                             // Check for MOV or MOVZ with SP/WSP as destination and immediate 1                             if ((mnemonic === &#x27;mov&#x27; || mnemonic === &#x27;movz&#x27;) &amp;&amp; instruction.operands.length &gt;= 2) &#123;                                 const destOperand = instruction.operands[0];                                 const srcOperand = instruction.operands[1];                                 if (destOperand.type === &#x27;reg&#x27; &amp;&amp;                                     (destOperand.value === &#x27;wsp&#x27; || destOperand.value === &#x27;sp&#x27; ||                                      destOperand.value === &#x27;w31&#x27; || destOperand.value === &#x27;x31&#x27;) &amp;&amp; // w31/x31 are aliases for wsp/sp                                     srcOperand.type === &#x27;imm&#x27; &amp;&amp;                                     parseInt(srcOperand.value.toString()) === 1) &#123;                                     console.warn(&quot;[StalkerTransform] Identified potential crash instruction &#x27;&quot; + instruction.toString() + &quot;&#x27; at &quot; + currentAddress + &quot;. Replacing with NOP.&quot;);                                     iterator.putNop(); // Replace the instruction with NOP                                     patchedThisInstruction = true;                                 &#125;                             &#125;                        &#125;                        // =========================================================                        // If the instruction wasn&#x27;t NOPped by the above check, add a callout for logging                        if (!patchedThisInstruction) &#123;                            // Only add callout for instructions within the target module                            if (is_module_code) &#123;                                // &#x27;local_pre_regs&#x27; is accessible here via closure                                iterator.putCallout(function (context) &#123;                                    // Access local_pre_regs directly from the outer scope (captured by closure)                                    const thread_pre_regs = local_pre_regs;                                     const pc = context.pc;                                    // Get the register differences after this instruction executes                                    // get_diff_regs modifies thread_pre_regs in place                                    const diff_regs = get_diff_regs(context, thread_pre_regs);                                                                        // Find the module info again (can be optimized by caching, but this is reliable)                                    var current_callout_module = Process.findModuleByAddress(pc);                                     // Ensure we are logging code from the target module                                     if (current_callout_module &amp;&amp; current_callout_module.name === TARGET_MODULE_NAME) &#123;                                         const instrToLog = Instruction.parse(pc);                                         let logLine = `$&#123;current_callout_module.name&#125;!$&#123;pc.sub(current_callout_module.base)&#125; $&#123;instrToLog.toString()&#125;`;                                         // Append changed registers and potential strings                                         const diffRegKeys = Object.keys(diff_regs);                                         if (diffRegKeys.length &gt; 0) &#123;                                              logLine += `\\t\\t| Changed Regs: `;                                              let firstReg = true;                                              for (const regName of diffRegKeys) &#123;                                                   if (!firstReg) logLine += &quot;, &quot;;                                                   firstReg = false;                                                   const regValue = diff_regs[regName]; // The new value of the register                                                   logLine += `$&#123;regName&#125;=$&#123;regValue&#125;`;                                                   // --- Check if the register value points to a string ---                                                   const potentialString = tryReadString(regValue);                                                   if (potentialString !== null) &#123;                                                       // Truncate long strings for readability                                                       const displayString = potentialString.length &gt; 60 ? potentialString.substring(0, 57) + &quot;...&quot; : potentialString;                                                       // Escape potential quotes in the string for cleaner output                                                       const escapedString = displayString.replace(/&quot;/g, &#x27;\\\\&quot;&#x27;).replace(/\\n/g, &#x27;\\\\n&#x27;).replace(/\\r/g, &#x27;\\\\r&#x27;);                                                        logLine += ` (&quot;$&#123;escapedString&#125;&quot;)`;                                                   &#125;                                                   // ----------------------------------------------------------                                              &#125;                                         &#125;                                         console.log(logLine);                                     &#125;                                &#125;);                            &#125;                            // Keep the original instruction                            iterator.keep();                        &#125;                    &#125; while ((instruction = iterator.next()) !== null); // Process next instruction in the block                &#125;            &#125;);        &#125;,        onLeave: function (retval) &#123;            console.log(&quot;[+] &quot; + TARGET_MODULE_NAME + &quot;!&quot; + ptr(stalker_target_func_offset) + &quot; onLeave, TID:&quot;, this.tid);             // Stop stalking this thread when the function exits            Stalker.unfollow(this.tid);             // Clean up Stalker&#x27;s compiled code cache            Stalker.garbageCollect();        &#125;    &#125;);&#125;// Start the script execution by hooking the linkersetImmediate(function() &#123;    console.log(&quot;[i] Script starting for &quot; + module_name + &quot;...&quot;);    hook_linker_call_constructors();&#125;);console.log(&quot;[i] Script loaded. Waiting for &quot; + module_name + &quot; to be loaded...&quot;);\n\n接下来又遇到一个问题，在trace到sub_5AE5C内部的时候，会在随机某处地址断开trace。由于是随机断开的，没搞清楚到底是为什么？头疼。\n\n\n先通过下面这个脚本，hook上了sub_5AE5C，跑起来没问题。\nvar offset = 0x88060;var module_size = 0;var module_name = &quot;libbaiduprotect.so&quot;;var base_addr = null; // To store the base address of libbaiduprotect.so// Create an empty functionvar empty_func = new NativeCallback(function() &#123;    return 0;&#125;, &#x27;int&#x27;, [&#x27;pointer&#x27;]);function hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;);    let offset_call = 0x51BA8; // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset_call);    let listener = Interceptor.attach(call_constructors, &#123;        onEnter: function(args) &#123;            console.log(&#x27;[linker] Call_Constructors onEnter&#x27;);            let secmodule = Process.findModuleByName(module_name);            if (secmodule != null) &#123;                module_size = secmodule.size;                base_addr = secmodule.base; // Save the base address                console.log(&quot;libbaiduprotect.so base: &quot; + base_addr + &quot;, size: &quot; + module_size);                hook_target_func(base_addr);                listener.detach();            &#125;        &#125;    &#125;);&#125;function hook_target_func(baseaddr) &#123;    let target_addr = baseaddr.add(offset);    let listener = Interceptor.attach(target_addr, &#123;        onEnter: function(args) &#123;            console.log(&quot;Target function at &quot; + target_addr + &quot; entered&quot;);        &#125;,        onLeave: function(retval) &#123;            console.log(&quot;libbaiduprotect.so base address: &quot; + baseaddr);            hook_pthread_create();            hook_sub_5ae5c(baseaddr); // Hook sub_5AE5C after target function            listener.detach();        &#125;    &#125;);&#125;function hook_pthread_create() &#123;    let pthread_create_addr = Module.findExportByName(&quot;libc.so&quot;, &quot;pthread_create&quot;);    Interceptor.attach(pthread_create_addr, &#123;        onEnter: function(args) &#123;            let func_addr = args[2];            let target_func_addr = base_addr.add(0x3E9F0); // Calculate the target function address            if (func_addr.equals(target_func_addr)) &#123;                console.log(&quot;Replacing func_addr &quot; + func_addr + &quot; with empty function&quot;);                args[2] = empty_func; // Replace with the empty function                // hook_libart(); // Commented out as it was not provided            &#125; else &#123;                let module = Process.findModuleByAddress(func_addr);                if (module &amp;&amp; module.name === module_name) &#123;                    console.log(&quot;pthread_create called in libbaiduprotect.so, function address: &quot; + func_addr);                &#125;            &#125;        &#125;,        onLeave: function(retval) &#123;            // Optionally log return value        &#125;    &#125;);&#125;function hook_sub_5ae5c(baseaddr) &#123;    if (!baseaddr || baseaddr.isNull()) &#123;        console.error(&quot;[-] hook_sub_5ae5c: Invalid base address. Cannot proceed.&quot;);        return;    &#125;    let target_addr = baseaddr.add(0x5AE5C);    console.log(&quot;[+] Hooking sub_5AE5C at &quot; + target_addr);    Interceptor.attach(target_addr, &#123;        onEnter: function(args) &#123;            console.log(&quot;[sub_5AE5C] onEnter&quot;);            // Dump args[0] (pointer to _QWORD)            try &#123;                if (!args[0].isNull()) &#123;                    console.log(&quot;args[0] (*_QWORD at &quot; + args[0] + &quot;):&quot;);                    console.log(hexdump(args[0], &#123; length: 64, ansi: true &#125;));                &#125; else &#123;                    console.warn(&quot;args[0] is null&quot;);                &#125;            &#125; catch (e) &#123;                console.warn(&quot;Failed to hexdump args[0]: &quot; + e.message);            &#125;            // Dump args[2] (data + 8)            try &#123;                if (!args[2].isNull()) &#123;                    console.log(&quot;args[2] (data + 8 at &quot; + args[2] + &quot;):&quot;);                    console.log(hexdump(args[2], &#123; length: 64, ansi: true &#125;));                &#125; else &#123;                    console.warn(&quot;args[2] is null&quot;);                &#125;            &#125; catch (e) &#123;                console.warn(&quot;Failed to hexdump args[2]: &quot; + e.message);            &#125;            // Store pointers for comparison in onLeave            this.arg0 = args[0];            this.arg2 = args[2];        &#125;,        onLeave: function(retval) &#123;            console.log(&quot;[sub_5AE5C] onLeave, Return value: &quot; + retval);            // Dump args[0] again to check for changes            try &#123;                if (!this.arg0.isNull()) &#123;                    console.log(&quot;args[0] (*_QWORD at &quot; + this.arg0 + &quot;) after execution:&quot;);                    console.log(hexdump(this.arg0, &#123; length: 64, ansi: true &#125;));                &#125; else &#123;                    console.warn(&quot;args[0] is null in onLeave&quot;);                &#125;            &#125; catch (e) &#123;                console.warn(&quot;Failed to hexdump args[0] in onLeave: &quot; + e.message);            &#125;            // Dump args[2] again to check for changes            try &#123;                if (!this.arg2.isNull()) &#123;                    console.log(&quot;args[2] (data + 8 at &quot; + this.arg2 + &quot;) after execution:&quot;);                    console.log(hexdump(this.arg2, &#123; length: 64, ansi: true &#125;));                &#125; else &#123;                    console.warn(&quot;args[2] is null in onLeave&quot;);                &#125;            &#125; catch (e) &#123;                console.warn(&quot;Failed to hexdump args[2] in onLeave: &quot; + e.message);            &#125;        &#125;    &#125;);&#125;setImmediate(function() &#123;    console.log(&quot;[i] Script starting for &quot; + module_name + &quot;...&quot;);    hook_linker_call_constructors();&#125;);console.log(&quot;[i] Script loaded. Waiting for &quot; + module_name + &quot; to be loaded...&quot;);\n\n可以看到，after execution的args[2]中，存放的内容是一大片地址，将这些地址减去libbaiduprotect.so的基地址，可以发现这些地址都是vmp__funcs_256这个表上的地址。也就是说，经过函数sub_5ae5c，会从第一个参数中，获得到实现JNI函数所需要的的vmp指令集合列表。\n\n既然trace不了函数5ae5c，那就从sub_5ae5c的汇编代码分析吧。\n基本块1。\n\n基本块2。\n\n基本块3。\n\n基本块4。\n\n基本块5。\n\n基本块6。\n\n基本块7。\n\n\n基本块7的下一个块又是基本块4，也就是说，将上述流程写成伪代码的话，如下所示。\nfor(int index = 0; index &lt; 256; index++)&#123;\ta2 + (*(((byte*)a0) + 64 + index*4)) * 8 = *(a1 + index*8)&#125;\n\n和ida做一个对比，会发现ida的伪代码看不懂。\n\n通过这个伪代码，我们可以得知，a0是一个已知的数据源，它的64字节大小的offset偏移处，存放着解密后的vmp_code映射表，比方说，读取一个 a0 + 64 + index*4，命名为v1，然后将vmp_funcs_list的从0到255，把每一个元素，依次赋给 v1*8 + a2 的内存地址上，注意，这里的v1并不是逐增的。\n↑我把我的表述扔给gemini，哈哈哈，得到认可了，看来没分析错。\n\n我将函数sub_5ae5c命名为：from_DecodeVmpCode_map_to_SimulateSmaliCode。\n分析完它之后，不妨再分析sub_4A458，我想分析vmp_explain传入的参数的含义是什么。\nIDA的伪代码问题太大了，传入2个v19很明显没意义。\n\n\n基本块1。\n\n基本块2。\n\n基本块3，调用了sub_5cb98([[qword_BED18地址 + (vmp_method_code &amp; 0xFF0000)&gt;&gt;16]], vmp_method_code &amp; 0xFFFF)\n\n基本块4，sub_5cb98的操作如下。\n\n基本块5。\n\n\n基本块6。\n\n\n基本块7。\n\n\n基本块8。\n\n基本块9，sub_45EBC比较复杂，暂时先不分析，待会hook一下这个函数，可以不费吹灰之力获得——\n\n[[[qword_BED18地址 + (vmp_method_code &amp; 0xFF0000)&gt;&gt;16] + 0x38] + (vmp_method_code &amp; 0xFFFF)*8]\n\n[原SP-0x40]\n\nbundle数组的内容\n\nmalloc1的内容\n\nmalloc2的内容\n\n\n\n基本块10。\n\n\n基本块11。\n\n后面还要分析好多函数，暂时先分析到这。——2025&#x2F;05&#x2F;17。\n参考文章https://bbs.kanxue.com/thread-257926.htm#msg_header_h1_3\nhttps://bbs.kanxue.com/thread-257926.htm#msg_header_h1_2\n"},{"title":"批量上传typora图片到图床的脚本","url":"/2025/05/29/%E6%89%B9%E9%87%8F%E4%B8%8A%E4%BC%A0typora%E5%9B%BE%E7%89%87%E5%88%B0%E5%9B%BE%E5%BA%8A%E7%9A%84%E8%84%9A%E6%9C%AC/","content":"分享一个脚本，改一改配置项就可以用了~\nimport osimport reimport requestsimport shutilfrom pathlib import Pathimport time# --- 配置项 ---MARKDOWN_DIR = &quot;E:\\BLOG\\source\\_posts&quot;  # &lt;--- 修改这里为你的 Typora 笔记目录!PICGO_API_URL = &quot;http://127.0.0.1:36677/upload&quot;  # PicGo API 地址BACKUP_ORIGINAL_FILES = True  # 是否备份原始 Markdown 文件BACKUP_SUFFIX = &quot;.backup&quot;     # 备份文件的后缀# --- Regular Expressions ---# Standard Markdown images: ![alt text](local_path)# Excludes http/https and data: URIsIMAGE_REGEX = re.compile(r&quot;!\\[(.*?)\\]\\((?!https?://|data:)(.*?)\\)&quot;)# To find complete HTML &lt;img&gt; tagsHTML_TAG_REGEX = re.compile(r&quot;&lt;img[^&gt;]+&gt;&quot;, re.IGNORECASE)# To find &#x27;src&#x27; attribute with a local path within an HTML tag string.# - \\bsrc\\b: Ensures &#x27;src&#x27; is a whole word.# - \\s*=\\s*: Allows spaces around &#x27;=&#x27;.# - ([&quot;&#x27;]): Captures the quote character (Group 1).# - ((?!(?:https?://|data:))[^&quot;&#x27;&gt;]+?): Captures the path if it&#x27;s not an online URL or data URI (Group 2).#   - [^&quot;&#x27;&gt;]+?: Matches characters that are not quotes or &#x27;&gt;&#x27;, non-greedily.# - \\1: Matches the same quote character that opened the attribute value.SRC_ATTR_REGEX = re.compile(    r&quot;&quot;&quot;\\bsrc\\s*=\\s*([&quot;&#x27;])((?!(?:https?://|data:))[^&quot;&#x27;&gt;]+?)\\1&quot;&quot;&quot;,    re.IGNORECASE)def upload_image_to_picgo(image_path):    &quot;&quot;&quot;    使用 PicGo API 上传图片 (发送 JSON 格式的图片路径列表)。    Args:        image_path (str): 本地图片的绝对路径。    Returns:        str or None: 上传成功返回在线 URL，否则返回 None。    &quot;&quot;&quot;    try:        payload = &#123;&quot;list&quot;: [image_path]&#125;  # PicGo server expects a JSON list of absolute paths        headers = &#123;&quot;Content-Type&quot;: &quot;application/json&quot;&#125;        # print(f&quot;    Uploading to PicGo: &#123;image_path&#125; with payload: &#123;payload&#125;&quot;) # Verbose logging        response = requests.post(PICGO_API_URL, json=payload, headers=headers, timeout=30) # Added timeout        response.raise_for_status()  # Raises HTTPError for bad responses (4xx or 5xx)        result = response.json()        if result.get(&quot;success&quot;) and result.get(&quot;result&quot;):            if isinstance(result[&quot;result&quot;], list) and len(result[&quot;result&quot;]) &gt; 0:                uploaded_url = result[&quot;result&quot;][0]                # print(f&quot;    PicGo Upload OK: &#123;uploaded_url&#125;&quot;) # Verbose logging                return uploaded_url            else:                print(f&quot;    [错误] PicGo 返回的 result 格式不正确: &#123;result.get(&#x27;result&#x27;)&#125;&quot;)                return None        else:            error_message = result.get(&#x27;message&#x27;, &#x27;未知错误&#x27;)            print(f&quot;    [错误] PicGo 上传失败: &#123;error_message&#125;&quot;)            print(f&quot;    [错误] PicGo 完整响应: &#123;result&#125;&quot;)            return None    except requests.exceptions.HTTPError as http_err:        print(f&quot;    [错误] HTTP 错误发生: &#123;http_err&#125;&quot;)        if http_err.response is not None:            print(f&quot;    [错误] PicGo 服务器响应状态码: &#123;http_err.response.status_code&#125;&quot;)            try:                print(f&quot;    [错误] PicGo 服务器响应内容: &#123;http_err.response.text&#125;&quot;)            except Exception:                pass        return None    except requests.exceptions.RequestException as e: # Catches ConnectTimeout, ReadTimeout, etc.        print(f&quot;    [错误] 连接 PicGo API 失败或请求过程中出错: &#123;e&#125;&quot;)        return None    except Exception as e:        print(f&quot;    [错误] 上传图片 &#x27;&#123;image_path&#125;&#x27; 时发生未知错误: &#123;e&#125;&quot;)        return Nonedef original_full_tag_summary(tag_string, max_len=70):    &quot;&quot;&quot;Helper function to print a summary of a tag if it&#x27;s too long.&quot;&quot;&quot;    if len(tag_string) &gt; max_len:        return tag_string[:max_len-3] + &quot;...&quot;    return tag_stringdef process_markdown_file(md_file_path_str):    &quot;&quot;&quot;    处理单个 Markdown 文件，上传本地图片 (Markdown 和 HTML 格式) 并替换链接。    &quot;&quot;&quot;    print(f&quot;--- 正在处理文件: &#123;md_file_path_str&#125; ---&quot;)    md_file_path_obj = Path(md_file_path_str)    md_dir = md_file_path_obj.parent    try:        with open(md_file_path_obj, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f:            original_content = f.read()    except Exception as e:        print(f&quot;  [错误] 读取文件 &#x27;&#123;md_file_path_str&#125;&#x27; 失败: &#123;e&#125;&quot;)        return    content_being_processed = original_content    modified_in_this_file = False    # --- Pass 1: Process standard Markdown images ---    print(&quot;  Pass 1: Processing Markdown images `![alt](path)`...&quot;)    new_md_pass_content_parts = []    last_md_end = 0    markdown_images_found_count = 0    markdown_images_replaced_count = 0    for match in IMAGE_REGEX.finditer(content_being_processed):        markdown_images_found_count += 1        new_md_pass_content_parts.append(content_being_processed[last_md_end:match.start()])                alt_text = match.group(1)        local_image_path_str = match.group(2)        original_md_tag = match.group(0)        print(f&quot;    MD_IMG: Found: &#123;original_full_tag_summary(original_md_tag)&#125;&quot;)        local_image_path = Path(local_image_path_str)        if not local_image_path.is_absolute():            absolute_image_path = (md_dir / local_image_path).resolve()        else:            absolute_image_path = local_image_path.resolve()        if not absolute_image_path.exists():            print(f&quot;    [警告] MD_IMG: File not found, skipping: &#123;absolute_image_path&#125;&quot;)            new_md_pass_content_parts.append(original_md_tag)        else:            online_url = upload_image_to_picgo(str(absolute_image_path))            if online_url:                new_image_md_tag = f&quot;![&#123;alt_text&#125;](&#123;online_url&#125;)&quot;                new_md_pass_content_parts.append(new_image_md_tag)                modified_in_this_file = True                markdown_images_replaced_count += 1                print(f&quot;    MD_IMG: Replaced with: &#123;new_image_md_tag&#125;&quot;)            else:                print(f&quot;    MD_IMG: Upload failed for &#x27;&#123;local_image_path_str&#125;&#x27;, skipping replacement.&quot;)                new_md_pass_content_parts.append(original_md_tag)        last_md_end = match.end()        new_md_pass_content_parts.append(content_being_processed[last_md_end:])    content_after_md_pass = &quot;&quot;.join(new_md_pass_content_parts)    if markdown_images_found_count &gt; 0:        print(f&quot;  Pass 1 Summary: Found &#123;markdown_images_found_count&#125; MD images, Replaced &#123;markdown_images_replaced_count&#125;.&quot;)    else:        print(f&quot;  Pass 1 Summary: No Markdown images `![alt](path)` found.&quot;)    # --- Pass 2: Process HTML &lt;img&gt; tags ---    print(&quot;  Pass 2: Processing HTML images `&lt;img src=&#x27;path&#x27;&gt;`...&quot;)    content_for_html_pass = content_after_md_pass    new_html_pass_content_parts = []    last_html_end = 0    html_tags_processed_count = 0 # Counts &lt;img&gt; tags where local src was sought    html_src_replaced_count = 0    for tag_match in HTML_TAG_REGEX.finditer(content_for_html_pass):        new_html_pass_content_parts.append(content_for_html_pass[last_html_end:tag_match.start()])                original_full_tag = tag_match.group(0)        modified_tag_output = original_full_tag # Assume not modified unless src is replaced        src_attr_match = SRC_ATTR_REGEX.search(original_full_tag)        if src_attr_match:            html_tags_processed_count +=1            quote_char = src_attr_match.group(1)            local_image_path_str = src_attr_match.group(2)            original_src_attr_part = src_attr_match.group(0)            print(f&quot;    HTML_IMG: Found local src=&#x27;&#123;local_image_path_str&#125;&#x27; in tag: &#123;original_full_tag_summary(original_full_tag)&#125;&quot;)            local_image_path = Path(local_image_path_str)            if not local_image_path.is_absolute():                absolute_image_path = (md_dir / local_image_path).resolve()            else:                absolute_image_path = local_image_path.resolve()            if not absolute_image_path.exists():                print(f&quot;    [警告] HTML_IMG: File not found, skipping: &#123;absolute_image_path&#125;&quot;)            else:                online_url = upload_image_to_picgo(str(absolute_image_path))                if online_url:                    new_src_attr_part = f&#x27;src=&#123;quote_char&#125;&#123;online_url&#125;&#123;quote_char&#125;&#x27;                    modified_tag_output = original_full_tag.replace(original_src_attr_part, new_src_attr_part, 1)                    if original_full_tag != modified_tag_output:                        modified_in_this_file = True                        html_src_replaced_count +=1                        print(f&quot;    HTML_IMG: Replaced src. New tag: &#123;original_full_tag_summary(modified_tag_output)&#125;&quot;)                else:                    print(f&quot;    HTML_IMG: Upload failed for &#x27;&#123;local_image_path_str&#125;&#x27;, skipping replacement in tag.&quot;)                new_html_pass_content_parts.append(modified_tag_output)        last_html_end = tag_match.end()    new_html_pass_content_parts.append(content_for_html_pass[last_html_end:])    final_content = &quot;&quot;.join(new_html_pass_content_parts)    if html_tags_processed_count &gt; 0:        print(f&quot;  Pass 2 Summary: Processed &#123;html_tags_processed_count&#125; &lt;img&gt; tags for local &#x27;src&#x27;, Replaced &#123;html_src_replaced_count&#125; &#x27;src&#x27; attributes.&quot;)    else:        print(f&quot;  Pass 2 Summary: No HTML &lt;img&gt; tags with processable local &#x27;src&#x27; attributes found.&quot;)    # --- Save file if modified_in_this_file ---    if modified_in_this_file:        try:            if BACKUP_ORIGINAL_FILES:                backup_file_path = md_file_path_obj.with_suffix(md_file_path_obj.suffix + BACKUP_SUFFIX)                # Backup the file as it is on disk (original version for this run)                shutil.copy2(md_file_path_obj, backup_file_path)                print(f&quot;  已备份原始文件到: &#123;backup_file_path&#125;&quot;)            with open(md_file_path_obj, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f:                f.write(final_content)            print(f&quot;  文件已更新: &#123;md_file_path_str&#125;&quot;)        except Exception as e:            print(f&quot;  [错误] 写入文件或备份文件失败: &#123;e&#125;&quot;)            if BACKUP_ORIGINAL_FILES and &#x27;backup_file_path&#x27; in locals() and Path(backup_file_path).exists():                try:                    # Attempt to restore from backup if write failed                    shutil.copy2(backup_file_path, md_file_path_obj)                    print(f&quot;  [警告] 写入失败，已尝试从备份 &#123;backup_file_path&#125; 恢复。请检查文件。&quot;)                except Exception as restore_e:                    print(f&quot;  [严重错误] 写入失败且恢复备份也失败: &#123;restore_e&#125;。原始文件可能已损坏，请从手动备份中恢复。&quot;)    else:        print(f&quot;  文件 &#x27;&#123;md_file_path_str&#125;&#x27; 无需修改。&quot;)    print(&quot;-&quot; * 30)def main():    &quot;&quot;&quot;    主函数，遍历目录并处理 Markdown 文件。    &quot;&quot;&quot;    markdown_dir_path = Path(MARKDOWN_DIR)    if not markdown_dir_path.is_dir():        print(f&quot;[错误] 指定的目录不存在或不是一个目录: &#123;MARKDOWN_DIR&#125;&quot;)        return    print(f&quot;开始扫描目录: &#123;markdown_dir_path&#125;&quot;)    file_count = 0    for md_file in markdown_dir_path.rglob(&quot;*.md&quot;): # rglob 会递归查找所有子目录中的 .md 文件        if BACKUP_SUFFIX in md_file.name: # Skip backup files            print(f&quot;跳过备份文件: &#123;md_file&#125;&quot;)            continue        process_markdown_file(str(md_file))        file_count += 1        if file_count == 0:        print(&quot;在指定目录中未找到 .md 文件。&quot;)    else:        print(f&quot;所有 &#123;file_count&#125; 个 Markdown 文件处理完毕。&quot;)if __name__ == &quot;__main__&quot;:    print(&quot;*********************************************************************&quot;)    print(&quot;* Typora 图片上传脚本 (Markdown &amp; HTML)                              *&quot;)    print(&quot;*********************************************************************&quot;)    print(&quot;* 重要提示:                                                          *&quot;)    print(&quot;* 1. 请确保 PicGo 正在运行并已正确配置图床和Server。                *&quot;)    print(&quot;* 2. 脚本将修改 Markdown 文件中的本地图片链接。                     *&quot;)    print(f&quot;* 3. 配置的笔记目录: &#123;MARKDOWN_DIR&#125;                         *&quot;)    print(f&quot;* 4. PicGo API: &#123;PICGO_API_URL&#125;                                 *&quot;)    if BACKUP_ORIGINAL_FILES:        print(f&quot;* 5. 原始文件将备份为 *.md&#123;BACKUP_SUFFIX&#125;。                         *&quot;)    else:        print(&quot;* 5. 文件备份已禁用。                                               *&quot;)    print(&quot;* 6. 强烈建议在首次运行或对重要笔记操作前备份您的整个笔记目录。     *&quot;)    print(&quot;*********************************************************************\\n&quot;)    if MARKDOWN_DIR == &quot;/path/to/your/typora/notes&quot;:        print(&quot;[配置错误] 请务必修改脚本中的 `MARKDOWN_DIR`变量，指向你的 Typora 笔记目录！&quot;)        exit(1)    confirm = input(f&quot;确认开始处理目录 &#x27;&#123;MARKDOWN_DIR&#125;&#x27; 下的 Markdown 文件吗? (yes/no): &quot;).lower()    if confirm == &#x27;yes&#x27;:        print(&quot;脚本将在 3 秒后开始执行... 按 Ctrl+C 取消。&quot;)        try:            time.sleep(3)            main()        except KeyboardInterrupt:            print(&quot;\\n操作已由用户取消。&quot;)        except Exception as e:            print(f&quot;\\n[严重错误] 脚本执行过程中发生意外错误: &#123;e&#125;&quot;)    else:        print(&quot;操作已取消。&quot;)\n\n"},{"title":"初学angr与去混淆","url":"/2025/05/29/angr%E4%B8%8E%E5%8E%BB%E6%B7%B7%E6%B7%86/","content":"学习angr我打算根据https://github.com/jakespringer/angr_ctf里的解题代码进行学习。\n00_angr_findimport angrimport sysdef main(argv):  # Create an Angr project.  # If you want to be able to point to the binary from the command line, you can  # use argv[1] as the parameter. Then, you can run the script from the command  # line as follows:  # python ./scaffold00.py [binary]  # (!)  path_to_binary = ???  # :string  project = angr.Project(path_to_binary)  # Tell Angr where to start executing (should it start from the main()  # function or somewhere else?) For now, use the entry_state function  # to instruct Angr to start from the main() function.  initial_state = project.factory.entry_state()  # Create a simulation manager initialized with the starting state. It provides  # a number of useful tools to search and execute the binary.  simulation = project.factory.simgr(initial_state)  # Explore the binary to attempt to find the address that prints &quot;Good Job.&quot;  # You will have to find the address you want to find and insert it here.   # This function will keep executing until it either finds a solution or it   # has explored every possible path through the executable.  # (!)  print_good_address = ???  # :integer (probably in hexadecimal)  simulation.explore(find=print_good_address)  # Check that we have found a solution. The simulation.explore() method will  # set simulation.found to a list of the states that it could find that reach  # the instruction we asked it to search for. Remember, in Python, if a list  # is empty, it will be evaluated as false, otherwise true.  if simulation.found:    # The explore method stops after it finds a single state that arrives at the    # target address.    solution_state = simulation.found[0]    # Print the string that Angr wrote to stdin to follow solution_state. This     # is our solution.    print(solution_state.posix.dumps(sys.stdin.fileno()))  else:    # If Angr could not find a path that reaches print_good_address, throw an    # error. Perhaps you mistyped the print_good_address?    raise Exception(&#x27;Could not find the solution&#x27;)if __name__ == &#x27;__main__&#x27;:  main(sys.argv)\n\n解析创建Angr项目，angr会对二进制文件解析。\nproject = angr.Project(path_to_binary)\n\n创建一个初始状态，通常从程序的入口点开始，即文件的入口函数main。\ninitial_state = project.factory.entry_state()\n\n创建一个模拟管理器，通过这个模拟器可以使用很多工具，对二进制文件进行搜索和执行。\nsimulation = project.factory.simgr(initial_state)\n\n自动探索路径，直到找到一个到达find参数指定的地址的状态。\nsimulation.explore(find=print_good_address)\n\n这是一个列表，如果搜索成功，这个列表会包含所有可到达目标地址的状态。\nsimulation.found\n\n从成功状态中，提取标准输入的内容。\nsolution_state = simulation.found[0]solution_state.posix.dumps(sys.stdin.fileno()).decode()\n\n01_angr_avoidimport angrimport sysdef main(argv):  path_to_binary = argv[1]  project = angr.Project(path_to_binary)  initial_state = project.factory.entry_state(    add_options = &#123; angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,                    angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS&#125;  )  simulation = project.factory.simgr(initial_state)  print_good_address = 0x80485f7 # 目标成功地址（示例）  will_not_succeed_address = 0x80485bf # 需要避开的地址（示例）  # 探索时，寻找print_good_address，并避开will_not_succeed_address  simulation.explore(find=print_good_address, avoid=will_not_succeed_address)  if simulation.found:    solution_state = simulation.found[0]    print(solution_state.posix.dumps(sys.stdin.fileno()).decode())  else:    raise Exception(&#x27;Could not find the solution&#x27;)if __name__ == &#x27;__main__&#x27;:  main(sys.argv)\n\n解析这次程序中不仅有成功路径，还有一些我们不希望进入的“陷阱”路径（例如，一个会打印失败信息然后退出的路径）。我们需要找到成功路径，同时避开这些陷阱。\n在探索路径的时候，avoid参数可以避免某些状态的产生。比方说，不进入基本块A，则不会在基本块A处产生新状态，基本块A之后的基本块也不会继续通过基本块A产生新状态。\nsimulation.explore(find=find_address, avoid=avoid_address)\n\n02_angr_find_conditionimport angrimport sysdef main(argv):  path_to_binary = argv[1]  project = angr.Project(path_to_binary)  initial_state = project.factory.entry_state(    add_options = &#123; angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,                    angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS&#125;  )  simulation = project.factory.simgr(initial_state)  # 定义成功条件函数  def is_successful(state):    stdout_output = state.posix.dumps(sys.stdout.fileno()) # 获取标准输出    return b&#x27;Good Job.&#x27; in stdout_output # 检查是否包含 &quot;Good Job.&quot; (注意是字节串)  # 定义应中止路径的条件函数  def should_abort(state):    stdout_output = state.posix.dumps(sys.stdout.fileno())    return b&#x27;Try again.&#x27; in stdout_output # 检查是否包含 &quot;Try again.&quot;  simulation.explore(find=is_successful, avoid=should_abort)  if simulation.found:    solution_state = simulation.found[0]    print(solution_state.posix.dumps(sys.stdin.fileno()).decode())  else:    raise Exception(&#x27;Could not find the solution&#x27;)if __name__ == &#x27;__main__&#x27;:  main(sys.argv)\n\n解析有时候，可能不知道确切“成功”的指令地址，而是某种行为。比如说，某个基本块会标准输出“Good Job.”。\nexplore方法的find和avoid参数不仅可以接受地址，还可以接受一个函数。这个函数会以一个state对象为参数，返回True代表找到了或者应该避开，而返回False代表没找到成功状态或者不应该避开。\nAngr会在每一步执行后，用这些函数评判当前状态，如果状态是True，就代表成功了。\n# 定义成功条件函数  def is_successful(state):    stdout_output = state.posix.dumps(sys.stdout.fileno()) # 获取标准输出    return b&#x27;Good Job.&#x27; in stdout_output # 检查是否包含 &quot;Good Job.&quot; (注意是字节串)  # 定义应中止路径的条件函数  def should_abort(state):    stdout_output = state.posix.dumps(sys.stdout.fileno())    return b&#x27;Try again.&#x27; in stdout_output # 检查是否包含 &quot;Try again.&quot;\n\n03_angr_symbolic_registersimport claripy # 导入claripy用于创建符号变量import sysdef main(argv):  path_to_binary = argv[1]  project = angr.Project(path_to_binary)  # 设定一个开始地址，通常是scanf调用之后，这样我们可以手动控制输入  start_address = 0x80488c7 # 示例地址，你需要反汇编找到它  initial_state = project.factory.blank_state(    addr=start_address, # 从指定地址开始    add_options = &#123; angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,                    angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS&#125;  )  # 创建符号变量来代表密码的各个部分  # 假设程序从scanf读取3个32位整数，然后这些值被放到了eax, ebx, edx  password0_size_in_bits = 32  password0 = claripy.BVS(&#x27;password0&#x27;, password0_size_in_bits) # &#x27;password0&#x27;是名字，32是位数  password1_size_in_bits = 32  password1 = claripy.BVS(&#x27;password1&#x27;, password1_size_in_bits)  password2_size_in_bits = 32  password2 = claripy.BVS(&#x27;password2&#x27;, password2_size_in_bits)  # 将符号变量注入到相应的寄存器  initial_state.regs.eax = password0  initial_state.regs.ebx = password1  initial_state.regs.edx = password2 # 实际使用哪个寄存器取决于反汇编结果  simulation = project.factory.simgr(initial_state)  def is_successful(state):    stdout_output = state.posix.dumps(sys.stdout.fileno())    return b&#x27;Good Job.&#x27; in stdout_output  def should_abort(state):    stdout_output = state.posix.dumps(sys.stdout.fileno())    return b&#x27;Try again.&#x27; in stdout_output  simulation.explore(find=is_successful, avoid=should_abort)  if simulation.found:    solution_state = simulation.found[0]    # 从成功状态中求解出各个符号变量的具体值    solution0 = solution_state.solver.eval(password0)    solution1 = solution_state.solver.eval(password1)    solution2 = solution_state.solver.eval(password2)    # 将解格式化为程序期望的输入格式（这里假设是十六进制，空格分隔）    solution_string = &#x27; &#x27;.join(map(&#x27;&#123;:x&#125;&#x27;.format, [ solution0, solution1, solution2 ]))    print(solution_string)  else:    raise Exception(&#x27;Could not find the solution&#x27;)if __name__ == &#x27;__main__&#x27;:  main(sys.argv)\n\n解析虽然现在的Angr支持函数scanf了，但之前是不支持的，这道题目是想教会读者，可以在任意地址设置状态，并符号执行。\n在任意地址创建状态。\nproject.factory.blank_state(addr=start_address)\n\n创建符号向量，例如，一个代表32位数值的符号。\nclaripy.BVS(&#x27;name&#x27;, bit_length)\n\n将符号值赋给寄存器。\nstate.regs.REG_NAME = symbolic_value# 例如: initial_state.regs.eax = password0\n\n获取符号变量的一个具体满足约束的值。\nstate.solver.eval(symbolic_value)\n\n04_angr_symbolic_stackimport angrimport claripyimport sysdef main(argv):  path_to_binary = argv[1]  project = angr.Project(path_to_binary)  # 挑战描述 scanf(&quot;%u %u&quot;)  # 通常 scanf 的参数是：格式字符串地址、变量1地址、变量2地址...  # 这些地址本身可能在栈上（如果是局部变量的地址）  start_address = 0x80486ae # 跳过scanf的地址 (示例)  initial_state = project.factory.blank_state(    addr=start_address,    add_options = &#123; angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,                    angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS&#125;  )  # 模拟函数栈帧的建立  # mov %esp, %ebp (通常在函数开始)  # sub $0x18, %esp (为局部变量分配空间)  # 我们跳过了这些，所以需要手动设置  initial_state.regs.ebp = initial_state.regs.esp # 假设 ebp 指向当前 esp  password0 = claripy.BVS(&#x27;password0&#x27;, 32) # 第一个32位符号整数  password1 = claripy.BVS(&#x27;password1&#x27;, 32) # 第二个32位符号整数  # 根据反汇编，scanf的参数是 ebp-0xc 和 ebp-0x10  # scanf(format_string, ebp - 0xc, ebp - 0x10)  # 假设 ebp 和 esp 初始化后相等，我们需要在栈上为这两个变量腾出空间。  # 并且，由于我们跳过了scanf之前的参数压栈，栈的布局需要我们模拟。  # solve04.py 中:  # ebp -&gt;     |          padding          | (ebp 指向这里，也是初始 esp 指向这里)  # ...  # ebp - 0x0c |   password0 (符号值)    | &lt;- scanf 会写入这里 (即 initial_state.regs.ebp - 0xc)  # ...  # ebp - 0x10 |   password1 (符号值)    | &lt;- scanf 会写入这里 (即 initial_state.regs.ebp - 0x10)  # ...  # esp -&gt;     |                           | (esp 在分配完所有局部变量后指向这里)  # 为了让 scanf 操作的地址 (ebp-0xc, ebp-0x10) 包含我们的符号值，  # 我们需要在这些“模拟的”内存位置存储符号值。  # solve04.py 通过 stack_push 来实现，这暗示它认为这些 scanf 的目标缓冲区  # 就是在栈上连续分配的。  # 首先，为栈上的局部变量和 scanf 的参数指针（如果它们是通过压栈传递的话）分配空间。  # `solve04.py` 中 padding_length_in_bytes = 8，然后 esp -= padding_length_in_bytes  # 之后 stack_push(password0) 和 stack_push(password1)  # 这意味着它期望 password0 和 password1 直接作为值被程序使用，  # 并且它们位于 esp 指向的栈顶附近。  # 这需要非常小心地根据实际反汇编代码来确定栈布局。  # scanf(&quot;%u %u&quot;, &amp;var1, &amp;var2) -&gt; var1 和 var2 是栈上的局部变量  # 假设 var1 在 ebp-0xc, var2 在 ebp-0x10  # 我们需要确保在 initial_state 中，内存地址 (ebp-0xc) 处的值是 password0，(ebp-0x10) 处是 password1。  # 更直接的方法可能是:  # initial_state.memory.store(initial_state.regs.ebp - 0xc, password0, endness=project.arch.memory_endness)  # initial_state.memory.store(initial_state.regs.ebp - 0x10, password1, endness=project.arch.memory_endness)  #  # 但 solve04.py 的做法是：  padding_length_in_bytes = 8 # 这个值需要根据具体情况调整  initial_state.regs.esp -= padding_length_in_bytes  # 将符号变量压入栈。注意顺序！x86参数通常自右向左压栈。  # 但这里我们是模拟 scanf 已经执行完后，数据已在栈上变量中的情况。  # 所以这里的顺序是 password0 在较高的地址 (ebp-0xc)，password1 在较低地址 (ebp-0x10)。  # stack_push 会将值放到当前esp，然后esp相应调整。  # 为了匹配 ebp-0xc 和 ebp-0x10，可能需要先push password1，再push password0，  # 或者调整 padding 和 esp 的初始值。  # solve04.py 的顺序是：  initial_state.stack_push(password0)  initial_state.stack_push(password1)  # 这意味着 password1 在栈顶 (低地址)，password0 在其后 (高地址)。  # 这需要与程序如何从栈上读取这些值相对应。  simulation = project.factory.simgr(initial_state)  def is_successful(state):    stdout_output = state.posix.dumps(sys.stdout.fileno())    return b&#x27;Good Job.&#x27; in stdout_output  def should_abort(state):    stdout_output = state.posix.dumps(sys.stdout.fileno())    return b&#x27;Try again.&#x27; in stdout_output  simulation.explore(find=is_successful, avoid=should_abort)  if simulation.found:    solution_state = simulation.found[0]    solution0 = solution_state.solver.eval(password0)    solution1 = solution_state.solver.eval(password1)    # 格式化输出    solution_string = &#x27; &#x27;.join(map(str, [solution0, solution1])) # 假设是十进制整数，空格分隔    print(solution_string)  else:    raise Exception(&#x27;Could not find the solution&#x27;)if __name__ == &#x27;__main__&#x27;:  main(sys.argv)\n\n解析类似于Level3，但这次scanf读取的值可能直接存储于栈上的局部变量，而非像Level3一样，将值直接传递给3个寄存器。\n获得初始状态，angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY和SYMBOL_FILL_UNCONSTRAINED_REGISTERS用于设置未初始化的内存、寄存器为符号。\ninitial_state = project.factory.blank_state(  addr=start_address,  add_options = &#123; angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,                  angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS&#125;)\n\n模拟栈帧的建立，令ebp指向当前esp。\ninitial_state.regs.ebp = initial_state.regs.esp\n\n创建2个32位的符号整数。\npassword0 = claripy.BVS(&#x27;password0&#x27;, 32) # 第一个32位符号整数password1 = claripy.BVS(&#x27;password1&#x27;, 32) # 第二个32位符号整数\n\n根据反汇编，scanf的参数是 ebp-0xc 和 ebp-0x10，相当于：\nscanf(format_string, ebp - 0xc, ebp - 0x10)\n\nesp开辟8个字节的栈帧。\npadding_length_in_bytes = 8 # 这个值需要根据具体情况调整initial_state.regs.esp -= padding_length_in_bytes\n\n压栈。\ninitial_state.stack_push(password0)initial_state.stack_push(password1)\n\n创建模拟器。\nsimulation = project.factory.simgr(initial_state)\n\n解析成功状态时，符号的值。\nsolution0 = solution_state.solver.eval(password0)solution1 = solution_state.solver.eval(password1)\n\n为什么这里需要设置ebp &#x3D; esp，并且esp -&#x3D; 8？\n观察反汇编代码，发现之后调用参数的时候，都是基于ebp来调用的，因此这里ebp先设置为esp，然后让esp -&#x3D; 8，之后压栈操作又会令esp - 4，这个时候，ebp + var_10和ebp + var_C可以正确访问到栈上的符号变量了。\n\n\n05_angr_symbolic_memoryimport angrimport claripyimport sysdef main(argv):  path_to_binary = argv[1]  project = angr.Project(path_to_binary)  # 挑战描述 scanf(&quot;%8s %8s %8s %8s&quot;)  # 假设这些字符串被存储在已知的全局地址  start_address = 0x8048618 # scanf之后开始 (示例)  initial_state = project.factory.blank_state(    addr=start_address,    add_options = &#123; angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,                    angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS&#125;  )  # 创建符号字符串，每个8字节 (8*8=64位)  password0 = claripy.BVS(&#x27;password0&#x27;, 8*8)  password1 = claripy.BVS(&#x27;password1&#x27;, 8*8)  password2 = claripy.BVS(&#x27;password2&#x27;, 8*8)  password3 = claripy.BVS(&#x27;password3&#x27;, 8*8)  # 将符号字符串存储到它们在内存中的地址  # 这些地址需要通过反汇编确定  password0_address = 0xab232c0 # 示例地址  initial_state.memory.store(password0_address, password0) # 默认字节序，对于字符串通常OK  password1_address = 0xab232c8 # 示例地址  initial_state.memory.store(password1_address, password1)  password2_address = 0xab232d0 # 示例地址  initial_state.memory.store(password2_address, password2)  password3_address = 0xab232d8 # 示例地址  initial_state.memory.store(password3_address, password3)  simulation = project.factory.simgr(initial_state)  def is_successful(state):    stdout_output = state.posix.dumps(sys.stdout.fileno())    return b&#x27;Good Job.&#x27; in stdout_output  def should_abort(state):    stdout_output = state.posix.dumps(sys.stdout.fileno())    return b&#x27;Try again.&#x27; in stdout_output  simulation.explore(find=is_successful, avoid=should_abort)  if simulation.found:    solution_state = simulation.found[0]    # 求解符号字符串    solution0 = solution_state.solver.eval(password0, cast_to=bytes).decode()    solution1 = solution_state.solver.eval(password1, cast_to=bytes).decode()    solution2 = solution_state.solver.eval(password2, cast_to=bytes).decode()    solution3 = solution_state.solver.eval(password3, cast_to=bytes).decode()    # 组合成最终输入字符串，假设空格分隔    solution_string = &#x27; &#x27;.join([solution0, solution1, solution2, solution3])    print(solution_string)  else:    raise Exception(&#x27;Could not find the solution&#x27;)if __name__ == &#x27;__main__&#x27;:  main(sys.argv)\n\n解析scanf可以获得输入，这个输入在Level3中写入了寄存器，在Level4中写入了栈，在本次案例中，写入了全局变量。\n创建起始状态。\ninitial_state = project.factory.blank_state(  addr=start_address,  add_options = &#123; angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,                  angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS&#125;)\n\n创建符号变量。\n# 创建符号字符串，每个8字节 (8*8=64位)password0 = claripy.BVS(&#x27;password0&#x27;, 8*8)password1 = claripy.BVS(&#x27;password1&#x27;, 8*8)password2 = claripy.BVS(&#x27;password2&#x27;, 8*8)password3 = claripy.BVS(&#x27;password3&#x27;, 8*8)\n\n使用initial_state.memory.store，将符号值存储到已知的全局变量地址。（偏移地址）\n# 将符号字符串存储到它们在内存中的地址  # 这些地址需要通过反汇编确定  password0_address = 0xab232c0 # 示例地址  initial_state.memory.store(password0_address, password0) # 默认字节序，对于字符串通常OK  password1_address = 0xab232c8 # 示例地址  initial_state.memory.store(password1_address, password1)  password2_address = 0xab232d0 # 示例地址  initial_state.memory.store(password2_address, password2)  password3_address = 0xab232d8 # 示例地址  initial_state.memory.store(password3_address, password3)\n\n\n\n解析符号的值。\nsolution_state.solver.eval(symbolic_value, cast_to=bytes).decode()\n\n06_angr_symbolic_dynamic_memoryimport angrimport claripyimport sysdef main(argv):  path_to_binary = argv[1]  project = angr.Project(path_to_binary)  # 挑战描述 scanf(&quot;%8s %8s&quot;)，输入存储在动态分配的内存中  start_address = 0x80486af # scanf 之后 (示例)  initial_state = project.factory.blank_state(    addr=start_address,    add_options = &#123; angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,                    angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS&#125;  )  password0 = claripy.BVS(&#x27;password0&#x27;, 8*8) # 8字节字符串  password1 = claripy.BVS(&#x27;password1&#x27;, 8*8) # 注意solve06.py这里写的是password0，应为password1  # 伪造的堆地址，我们可以控制这块内存  fake_heap_address0 = 0x4444444   # 存储了 malloc返回地址 的那个指针变量的地址 (需反汇编确定)  pointer_to_malloc_memory_address0 = 0xa2def74 # 示例  # 修改程序中的指针，使其指向我们的伪造堆地址  # 对于32位程序，地址是4字节  initial_state.memory.store(pointer_to_malloc_memory_address0, fake_heap_address0, endness=project.arch.memory_endness, size=4)  fake_heap_address1 = 0x4444454 # 为第二个密码准备的伪造地址  pointer_to_malloc_memory_address1 = 0xa2def7c # 示例  initial_state.memory.store(pointer_to_malloc_memory_address1, fake_heap_address1, endness=project.arch.memory_endness, size=4)  # 在伪造的堆地址上存储我们的符号密码  initial_state.memory.store(fake_heap_address0, password0)  initial_state.memory.store(fake_heap_address1, password1)  simulation = project.factory.simgr(initial_state)  def is_successful(state):    stdout_output = state.posix.dumps(sys.stdout.fileno())    return b&#x27;Good Job.&#x27; in stdout_output  def should_abort(state):    stdout_output = state.posix.dumps(sys.stdout.fileno())    return b&#x27;Try again.&#x27; in stdout_output  simulation.explore(find=is_successful, avoid=should_abort)  if simulation.found:    solution_state = simulation.found[0]    solution0 = solution_state.solver.eval(password0, cast_to=bytes).decode()    solution1 = solution_state.solver.eval(password1, cast_to=bytes).decode() # 原为password0        solution_string = &#x27; &#x27;.join([solution0, solution1])    print(solution_string)  else:    raise Exception(&#x27;Could not find the solution&#x27;)if __name__ == &#x27;__main__&#x27;:  main(sys.argv)\n\n解析本次案例中，输入的值保存到了堆上。\n\n\n在scanf之后的地址创建初始状态。\nstart_address = 0x80486af # scanf 之后 (示例)  initial_state = project.factory.blank_state(    addr=start_address,    add_options = &#123; angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,                    angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS&#125;  )\n\n程序中会有一个指针变量（全局变量或是局部变量）用于存储malloc返回的地址，如上图的buffer0、buffer1。\n选择一个angr知道的、未被使用的“伪造堆地址”，使用下面这个语句修改存储malloc结果的指针，让它指向伪造的堆地址，这里的endness指字节序。\n # 伪造的堆地址，我们可以控制这块内存  fake_heap_address0 = 0x4444444   # 存储了 malloc返回地址 的那个指针变量的地址 (需反汇编确定)  pointer_to_malloc_memory_address0 = 0xa2def74 # 示例initial_state.memory.store(pointer_to_malloc_memory_address1, fake_heap_address1, endness=project.arch.memory_endness, size=4)\n\n在对地址上存储符号向量。\npassword0 = claripy.BVS(&#x27;password0&#x27;, 8*8)password1 = claripy.BVS(&#x27;password1&#x27;, 8*8)# 在伪造的堆地址上存储我们的符号密码initial_state.memory.store(fake_heap_address0, password0)initial_state.memory.store(fake_heap_address1, password1)\n\n探索路径。\ndef is_successful(state):  stdout_output = state.posix.dumps(sys.stdout.fileno())  return b&#x27;Good Job.&#x27; in stdout_outputdef should_abort(state):  stdout_output = state.posix.dumps(sys.stdout.fileno())  return b&#x27;Try again.&#x27; in stdout_outputsimulation.explore(find=is_successful, avoid=should_abort)\n\n解析符号。\nsolution0 = solution_state.solver.eval(password0, cast_to=bytes).decode()   solution1 = solution_state.solver.eval(password1, cast_to=bytes).decode() \n\n07_angr_syombolic_fileimport angrimport claripyimport sysdef main(argv):  path_to_binary = argv[1]  project = angr.Project(path_to_binary)  # fread(buffer, sizeof(char), 64, file) - 题目提示，但实际解法用了8字节  # 可能程序逻辑只需要前8字节，或者solve07.py中的大小是正确的。  start_address = 0x80488bc # 通常是fread调用之前或包含fread的函数入口 (示例)  initial_state = project.factory.blank_state( # 或 entry_state，取决于是否需要模拟fopen    addr=start_address,    add_options = &#123; angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,                    angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS&#125;  )  filename = &#x27;FOQVSBZB.txt&#x27; # 程序将要读取的文件名 (示例)  symbolic_file_size_bytes = 8 # 假设密码是8字节  # 创建代表文件内容的符号位向量  password_data = claripy.BVS(&#x27;password_file_content&#x27;, symbolic_file_size_bytes * 8)  # 创建一个模拟文件，其内容是我们的符号数据  # &#x27;r&#x27;表示只读模式，Angr的SimFile也接受模式参数，但content更直接  password_file = angr.storage.SimFile(filename, content=password_data)  # 将这个模拟文件插入到初始状态的文件系统中  # 当程序尝试打开并读取 &#x27;FOQVSBZB.txt&#x27; 时，它会读到 password_data  initial_state.fs.insert(filename, password_file)  simulation = project.factory.simgr(initial_state)  def is_successful(state):    stdout_output = state.posix.dumps(sys.stdout.fileno())    return b&#x27;Good Job.&#x27; in stdout_output  def should_abort(state):    stdout_output = state.posix.dumps(sys.stdout.fileno())    return b&#x27;Try again.&#x27; in stdout_output  simulation.explore(find=is_successful, avoid=should_abort)  if simulation.found:    solution_state = simulation.found[0]    # 求解文件内容    solution_bytes = solution_state.solver.eval(password_data, cast_to=bytes)    print(solution_bytes.decode()) # 假设是可打印字符  else:    raise Exception(&#x27;Could not find the solution&#x27;)if __name__ == &#x27;__main__&#x27;:  main(sys.argv)\n\n解析程序会从文件中读取密码，而不是标准的输入或命令行参数。\n解题思路：\n确定程序读取的文件名和预期的大小。\nfilename = &#x27;FOQVSBZB.txt&#x27; # 程序将要读取的文件名 (示例)symbolic_file_size_bytes = 8 # 假设密码是8字节\n\n创建符号位向量代表文件内容。\n# 创建代表文件内容的符号位向量password_data = claripy.BVS(&#x27;password_file_content&#x27;, symbolic_file_size_bytes * 8)\n\n使用angr.storage.SimFile(filename, content=symbolic_data)创建一个模拟文件，内容是我们的符号数据。将这个模拟文件插入到初始状态的文件系统中。\n# 创建一个模拟文件，其内容是我们的符号数据# &#x27;r&#x27;表示只读模式，Angr的SimFile也接受模式参数，但content更直接password_file = angr.storage.SimFile(filename, content=password_data)# 将这个模拟文件插入到初始状态的文件系统中# 当程序尝试打开并读取 &#x27;FOQVSBZB.txt&#x27; 时，它会读到 password_datainitial_state.fs.insert(filename, password_file)\n\n当程序执行 fopen, fread 等文件操作时，它会从我们提供的这个符号化文件中读取。\n08_angr_constrainsimport angrimport claripyimport sysdef main(argv):  path_to_binary = argv[1]  project = angr.Project(path_to_binary)  # 目标是找到complex_function的输入，使其输出等于硬编码的字符串  # 我们从main函数中scanf之后，complex_function执行之后，但在check_equals_调用之前开始  start_address = 0x804863c # scanf之后，complex_function之前的某个点 (示例)                           # 或者，让Angr执行scanf和complex_function  initial_state = project.factory.blank_state(    addr=start_address, # 实际上，应该让Angr执行scanf和complex_function                        # 所以可能还是entry_state()或者scanf后的地址，                        # 并将原始密码符号化。                        # solve08.py中直接从0x804863c开始，并符号化了password_address处的内存    add_options = &#123; angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,                    angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS&#125;  )    # 原始密码（complex_function的输入）是符号化的  # 假设原始密码存储在 password_address，长度16字节  password_size_bytes = 16  password = claripy.BVS(&#x27;password&#x27;, password_size_bytes * 8)  password_address = 0x804a040 # 假设这是存储原始密码的全局变量地址 (示例)  initial_state.memory.store(password_address, password) # 注入符号化的原始密码  simulation = project.factory.simgr(initial_state)  # 探索到调用 check_equals_ 函数之前的地址  address_to_check_constraint = 0x8048683 # call check_equals_... 指令的地址 (示例)  simulation.explore(find=address_to_check_constraint)  if simulation.found:    solution_state = simulation.found[0] # 到达了 call check_equals_ 的状态    # check_equals_ 的第一个参数 (char* to_check) 是 complex_function 的输出    # 这个参数的地址通常是已知的，或者可以通过分析调用前的汇编指令得到    # 在这个题目中，complex_function 的输出结果（即 to_check）覆盖了原始密码的内存区域    # 所以 constrained_parameter_address 就是 password_address    constrained_parameter_address = 0x804a040 # (示例) complex_function的输出存放地址    constrained_parameter_size_bytes = 16    # 从当前状态的内存中加载这个参数，它应该是符号化的    constrained_parameter_bitvector = solution_state.memory.load(      constrained_parameter_address,      constrained_parameter_size_bytes    )        # 我们知道 check_equals_ 期望的字符串 (通过反汇编或题目描述)    constrained_parameter_desired_value = &#x27;OSIWHBXIFOQVSBZB&#x27;.encode() # 目标字符串 (示例)    # 添加约束：要求 complex_function 的输出等于期望的字符串    solution_state.add_constraints(constrained_parameter_bitvector == constrained_parameter_desired_value)    # 现在，求解原始的符号密码 password    # Angr会找到一个 password，使得经过 complex_function 变换后，    # 其结果 (constrained_parameter_bitvector) 等于 constrained_parameter_desired_value    solution_bytes = solution_state.solver.eval(password, cast_to=bytes)    print(solution_bytes.decode())  else:    raise Exception(&#x27;Could not find the solution&#x27;)if __name__ == &#x27;__main__&#x27;:  main(sys.argv)\n\n解析程序中有一个非常复杂的检查函数（check_equals_...），它逐字节比较输入经过某个 complex_function 转换后的结果与一个硬编码的字符串。如果让Angr完整符号执行这个检查函数，由于大量的分支 (每个字节比较都是一个分支)，会导致状态爆炸，非常耗时。\n\n\n创建初始状态，假设这里的0x804863C是符号执行的起始地址。\nstart_address = 0x804863cinitial_state = project.factory.blank_state(    addr=start_address,    add_options=&#123;        angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,        angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS    &#125;)\n\n符号化密码，假设密码是16字节长，创建一个16字节的符号变量，password_address是原始密码的内存地址，\npassword_size_bytes = 16password = claripy.BVS(&#x27;password&#x27;, password_size_bytes * 8)password_address = 0x804a040initial_state.memory.store(password_address, password) # 将符号变量password写入内存地址0x804a040\n\n创建模拟管理器，探索目标地址。\nsimulation = project.factory.simgr(initial_state)address_to_check_constraint = 0x8048683simulation.explore(find=address_to_check_constraint)\n\n处理成功状态。\nif simulation.found:    solution_state = simulation.found[0]\n\n加载和约束输出。solution_state.add_constraints(…)添加约束。\nconstrained_parameter_address = 0x804a040constrained_parameter_size_bytes = 16constrained_parameter_bitvector = solution_state.memory.load(    constrained_parameter_address,    constrained_parameter_size_bytes)constrained_parameter_desired_value = &#x27;OSIWHBXIFOQVSBZB&#x27;.encode()solution_state.add_constraints(constrained_parameter_bitvector == constrained_parameter_desired_value)\n\n求解密码。\nsolution_bytes = solution_state.solver.eval(password, cast_to=bytes)print(solution_bytes.decode())\n\n09_angr_hooksimport angrimport claripyimport sysdef main(argv):  path_to_binary = argv[1]  project = angr.Project(path_to_binary)  initial_state = project.factory.entry_state( # 从程序入口开始，让Angr处理scanf    add_options = &#123; angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,                    angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS&#125;  )  check_equals_called_address = 0x80486ca # call check_equals_... 指令的地址 (示例)  instruction_to_skip_length = 5 # call指令的长度 (示例，通常是5字节: E8 XX XX XX XX)  # 定义钩子函数  @project.hook(check_equals_called_address, length=instruction_to_skip_length)  def skip_check_equals_(state):    # 假设 check_equals_ 的第一个参数 (char* to_check) 指向的地址是已知的    # 在此题中，它指向 complex_function 的输出，该输出存储在全局变量 0x804a044    user_input_buffer_address = 0x804a044 # (示例)    user_input_buffer_length = 16 # 字符串长度    # 加载这个参数（它应该是符号化的，因为它来自用户输入经过complex_function)    user_input_string_bv = state.memory.load(      user_input_buffer_address,      user_input_buffer_length # load的长度单位是字节    )        check_against_string_concrete = &#x27;OSIWHBXIFOQVSBZB&#x27;.encode() # 硬编码的目标字符串    # 构造符号化的返回值：如果匹配则为1，否则为0 (32位整数)    return_value = claripy.If(      user_input_string_bv == check_against_string_concrete, # 条件      claripy.BVV(1, 32), # 如果为真，eax = 1 (32位)      claripy.BVV(0, 32)  # 如果为假，eax = 0 (32位)    )    state.regs.eax = return_value # 将返回值放入eax  simulation = project.factory.simgr(initial_state)  def is_successful(state):    stdout_output = state.posix.dumps(sys.stdout.fileno())    return b&#x27;Good Job.&#x27; in stdout_output  def should_abort(state):    stdout_output = state.posix.dumps(sys.stdout.fileno())    return b&#x27;Try again.&#x27; in stdout_output  simulation.explore(find=is_successful, avoid=should_abort)  if simulation.found:    solution_state = simulation.found[0]    # 输入是由Angr的scanf SimProcedure处理的，所以直接从stdin dump    print(solution_state.posix.dumps(sys.stdin.fileno()).decode())  else:    raise Exception(&#x27;Could not find the solution&#x27;)if __name__ == &#x27;__main__&#x27;:  main(sys.argv)\n\n解析设置钩子。\n# 在地址0x80486ca设置钩子，替换check_equals_的调用# 当程序执行到此地址时，angr执行自定义函数skip_check_equals_# 而不会调用实际的check_equals_check_equals_called_address = 0x80486cainstruction_to_skip_length = 5@project.hook(check_equals_called_address, length=instruction_to_skip_length)def skip_check_equals_(state):# 用户输入的内容存在buffer中，buffer地址是0x804a044，长度是16    user_input_buffer_address = 0x804a044    user_input_buffer_length = 16# 加载16字节的符号变量    user_input_string_bv = state.memory.load(        user_input_buffer_address,        user_input_buffer_length    )    check_against_string_concrete = &#x27;OSIWHBXIFOQVSBZB&#x27;.encode()# 构造符号化的返回值# 成功则return_value = claripy.BVV(1,32)# 失败则return_value = claripy.BVV(0,32)    return_value = claripy.If(        user_input_string_bv == check_against_string_concrete,        claripy.BVV(1, 32),        claripy.BVV(0, 32)    )    state.regs.eax = return_value\n\n加载二进制文件：创建 angr 项目，解析程序。\n设置初始状态：从程序入口（main）开始，允许 angr 模拟 scanf 和 complex_function。\n钩子处理：\n\n在 check_equals_ 调用处（0x80486ca）设置钩子，跳过其执行。\n模拟 check_equals_ 的行为，比较 0x804a044 处的符号输出与目标字符串，设置 eax 为 1（匹配）或 0（不匹配）。\n\n符号执行：\n\n探索所有路径，寻找输出 “Good Job.” 的状态，避免输出 “Try again.” 的状态。\n\n提取输入：从成功状态的 stdin 中提取输入密码，打印结果。\n利用angr解混淆已经有大佬写过了，利用angr符号执行去除虚假控制流，思路很简单，不是活跃状态的基本块全部NOP掉。\n思路：https://bbs.kanxue.com/thread-266005.htm\n项目代码：https://github.com/bluesadi/debogus\n局限也是有的：\n\n依赖于z3约束求解，如果解不出来，则判定为非活跃状态的基本块；\n未约束导致路径爆炸。\n\n我的理解什么是状态、成功状态？在一开始，符号执行还没开始的时候，需要一个初始状态（寄存器、堆栈、内存等，它们可以被定义成符号），初始状态没有对符号的约束；\n而成功状态就是走到了目标地址或者目标行为的状态，此时的寄存器、堆栈、内存等共同构成了成功状态；\n在初始状态到成功状态的过程中，angr会为被定义为符号的变量收集约束，正是有了这些约束，程序才可以从初始状态走到成功状态；\n在成功状态时，可以调用angr相关的函数，根据约束计算出符号变量的值。\n状态的更新与分裂？每个基本块都有一个状态，每执行一条指令，状态都会对自身进行更新；而当来到条件分支的时候，会基于当前的状态，创建分裂出独立的、并行的多个状态，此时称作产生了新的状态。\nangr符号执行与基本块的关系？基本块的特点是：\n\n只有一个入口点（第一条指令）；\n只有一个出口点（最后一条指令，通常是跳转、返回、条件分支）。\n\nangr是一种符号执行框架，它通过将程序的输入（例如标准输入或参数）表示为符号变量（claripy.BVS），模拟程序的所有可能执行路径。angr 跟踪符号变量如何影响程序的状态（寄存器、内存等），并使用约束求解器（通常是 Z3）来确定哪些输入能够引导程序到达特定目标（如某个地址）。\n在 angr 的符号执行过程中，基本块是程序执行的“原子单位”，而符号执行是基于这些基本块进行路径探索的。\n\n基本块是执行的单位\n\nangr 在符号执行时，会将程序分解为基本块（通过静态分析生成 CFG 或动态执行时解析）。每个基本块代表一段连续的指令，angr 会逐块模拟执行。\n在执行一个基本块时，angr 更新当前状态的寄存器、内存等内容，并根据基本块的出口指令（例如跳转、条件分支、返回）决定下一步的执行路径。\n\n\n状态分叉与基本块的出口\n\n当基本块的最后一条指令是条件分支（例如 if 语句对应的 je、jne 等跳转指令），angr 会根据条件生成多个新的状态（state），分别对应分支的真假路径。\n\n例如，假设一个基本块以 \nif (input[0] &#x3D;&#x3D; ‘A’)\n 结束，angr 会：\n\n创建一个状态，约束 input[0] &#x3D;&#x3D; ‘A’，继续执行真分支。\n创建另一个状态，约束 input[0] !&#x3D; ‘A’，继续执行假分支。\n\n\n这些分叉点通常发生在基本块的出口，因此基本块的边界决定了状态分叉的时机。\n\n\n\n符号执行跟踪基本块的路径\n\nangr 的符号执行本质上是沿着 CFG 的路径探索，每个路径由一系列基本块组成。angr 维护一个状态池（通过 SimulationManager，即 simgr），跟踪每个状态对应的执行路径。\n每个状态在执行一个基本块后，会更新其上下文（例如寄存器、内存），并根据基本块的出口指令跳转到下一个基本块。\n\n\n约束累积与基本块\n\n在执行基本块的过程中，angr 会根据指令的逻辑为符号变量添加约束。例如，如果一个基本块包含比较指令 cmp input[0], ‘A’，angr 会在分支时为符号变量 input[0] 添加约束（如 input[0] &#x3D;&#x3D; ‘A’ 或 input[0] !&#x3D; ‘A’）。\n这些约束是符号执行的核心，用于在成功状态中求解具体输入。\n\n\n成功状态与基本块\n\n当 angr 的符号执行到达目标地址（例如 find&#x3D;print_good_address），对应的状态通常位于某个基本块的入口或内部。成功状态包含了从初始状态到目标地址的完整执行路径（即一系列基本块），以及符号输入的约束集合。\n通过 solution_state.posix.dumps(sys.stdin.fileno())，angr 求解这些约束，得到引导程序到达目标基本块的输入值。\n\n\n\n同时，angr 不会为每条指令生成新状态（而是基于原状态进行更新），而在基本块的边界（特别是条件分支）生成新状态。状态分叉发生在基本块的出口，基于分支条件。\n","tags":["angr"]},{"title":"xhs分析——shield字段","url":"/2025/06/10/xhs%E5%88%86%E6%9E%90%E2%80%94%E2%80%94shield%E5%AD%97%E6%AE%B5/","content":"1.分析目标要分析的字段：shield。\n2.抓包这个字段在很多请求中有出现，比如登录验证码。\n\n\n（ps：其实一般先抓包，然后确定分析目标，只不过在网上能找到分析shield的博客，不用孤军奋战！第一次分析大厂app，找个有资料分析的，hhhh，当然~虽然有其它人的博客，但我还是先自己分析，有不会的再看博客~）\n3.基本分析通过frida-ps获得包名。\n\n\n从Manifest文件中获取App类名。\n\n看了一下，似乎没有加壳，因为什么内容都看得见，比如IndexActivityV2。\n\n先直接在jadx中搜索，观察能否找到协议字段shield。\n\n并没有找到，但感觉有一些类名、字段名比较可疑。——先暂时放着，如果其它方法用不了再来查看这些类与字段。\n再尝试使用frida去hook hashMap，一般开发的时候，会用hashMap存储通信协议字段。\n打印的调用链有点长。\n[shield] shield[value] XYAAQAAgAAAAEAAABTAAAAUzUWEe0xG1IbD9/c+qCLOlKGmTtFa+lG434Je+FUTaRHxIzkyONuSp3/qeYJz8Mt3Jx+2fc6EAwYGGHebLP31H5m0rFOBPBvvrx/G4l575l4LPk3java.lang.Throwable        at java.util.HashMap.put(Native Method)        at qd9.h1.intercept(SourceFile:10)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:10)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:1)        at wd8.a.intercept(SourceFile:5)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:10)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:1)        at wd8.m.intercept(SourceFile:6)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:10)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:1)        at wd8.d.intercept(SourceFile:7)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:10)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:1)        at wd8.h.intercept(SourceFile:4)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:10)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:1)        at sf3.b.b(SourceFile:1)        at sf3.b.intercept(SourceFile:25)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:10)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:1)        at wd8.r.b(SourceFile:1)        at wd8.r.intercept(SourceFile:10)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:10)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:1)        at com.xingin.shield.http.XhsHttpInterceptor.intercept(Native Method)        at com.xingin.shield.http.XhsHttpInterceptor.intercept(SourceFile:8)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:10)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:1)        at ae8.b.c(SourceFile:2)        at ae8.a.intercept(SourceFile:3)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:10)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:1)        at wd8.l.intercept(SourceFile:13)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:10)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:1)        at wd8.s.intercept(SourceFile:13)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:10)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:1)        at wd8.u.intercept(SourceFile:6)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:10)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:1)        at rd9.c.intercept(SourceFile:15)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:10)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:1)        at ne7.c.intercept(SourceFile:11)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:10)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:1)        at wd8.c.intercept(SourceFile:2)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:10)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:1)        at qe7.b.intercept(SourceFile:3)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:10)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:1)        at ve9.d.intercept(SourceFile:8)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:10)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:1)        at yy8.m.intercept(SourceFile:26)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:10)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:1)        at on1.b.intercept(SourceFile:2)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:10)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:1)        at on1.a.intercept(SourceFile:2)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:10)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:1)        at jf9.c.intercept(SourceFile:1)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:10)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:1)        at qd9.k.intercept(SourceFile:3)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:10)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:1)        at yd8.a.intercept(SourceFile:1)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:10)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:1)        at qd9.p1.intercept(SourceFile:1)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:10)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:1)        at nj8.j.intercept(SourceFile:5)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:10)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:1)        at nj8.g.intercept(SourceFile:5)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:10)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:1)        at hw5.b.intercept(SourceFile:2)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:10)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:1)        at rd9.e.intercept(SourceFile:10)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:10)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:1)        at rd9.b.intercept(SourceFile:12)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:10)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:1)        at rd9.d.intercept(SourceFile:26)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:10)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:1)        at yy8.b.intercept(SourceFile:2)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:10)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:1)        at wd8.o.intercept(SourceFile:33)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:10)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:1)        at ve9.e$a.intercept(SourceFile:4)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:10)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:1)        at jf9.l.intercept(SourceFile:8)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:10)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:1)        at wd8.w.intercept(SourceFile:10)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:10)        at okhttp3.internal.http.RealInterceptorChain.proceed(SourceFile:1)        at okhttp3.RealCall.getResponseWithInterceptorChain(SourceFile:13)        at okhttp3.RealCall.execute(SourceFile:8)        at retrofit2.OkHttpCall.execute(SourceFile:8)        at wc8.b.e(SourceFile:14)        at io.reactivex.Observable.subscribe(SourceFile:14)        at wc8.a.e(Unknown Source:23)        at io.reactivex.Observable.subscribe(SourceFile:14)        at ms9.n0.e(Unknown Source:17)        at io.reactivex.Observable.subscribe(SourceFile:14)        at ms9.l3$b.run(Unknown Source:6)        at kd8.a.run(SourceFile:3)        at ud7.a.run(SourceFile:2)        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:462)        at java.util.concurrent.FutureTask.run(FutureTask.java:266)        at uh8.h.F(Unknown Source:12)        at uh8.h.run(SourceFile:9)        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)        at java.lang.Thread.run(Thread.java:920)\n\n除此之外，进程还在执行一段时间后终止了。\n\n我决定先解决反调。\n4.反调先用常规办法，看是否能解决。\n先hook库的加载，观察哪个库加载后会导致进程退出。\n下面这个结果是通过hook System.loadLibrary的结果。\n\n\n感觉不太对，就打印了一条hook记录。\n换一个方式hook，这回hook dlopen和android_dlopen_ext。\n\n在加载了libredpreload.so、libmsaoaidsec.so后，退出了。还记得bilibili和豆瓣用的也是libmsaoaidsec.so做反调。\n当时的解决方式是：hook掉检测线程或者删掉这个库（如果小红薯没额外对这个库做检查的话），考虑到重新签名太麻烦了，还是hook线程吧。\n\n\n将这3个线程的目标函数替换掉，等待了一段时间，发现进程不崩溃了。\n\n\n然后整理一个绕过检测的hook脚本模板，方便之后写其它脚本，这里就不展示了。\n5.追踪字段shield过完反调，回来继续分析shield字段。\n避开sdk的函数，先追踪qd9.h1.intercept。\n\n在函数intercept中，找到2个调用put的位置。\n\n\n这里的intercept代码可以分成2块，上面一块在拦截和修改请求（Request），下面一块在拦截和处理响应（Response）。\nhook一下函数intercept，观察原本的请求体和修改后的请求体。\n我的脚本只获得了输入参数，输出结果却打印不出来——说明hook引发了某些问题，导致调用原本的intercept的时候，陷入了死循环，导致方法stack溢出。\n\n又或者是下面这样的报错。（搜了一下，大致原因是：有不可序列化的内容在输出结果里）\n\n但不管怎么说，通过输入参数，我们发现shield已经在传入时就加密好了，说明qd9.h1.intercept并不是我们要找的加密点。\n观察了一下前面的调用栈，发现存在shield的字段，追踪过去看看。\nat com.xingin.shield.http.XhsHttpInterceptor.intercept(Native Method)at com.xingin.shield.http.XhsHttpInterceptor.intercept(SourceFile:8)\n\nhook后发现输入参数没有shield。\n\n而hook wd8.r.intercept，发现输入参数存在shield参数。\n\n说明，大概率是在com.xingin.shield.http.XshHttpInterceptor.intercept添加了字段shield。\n\n\n至此，锁定了加密点。\n6.加密分析猜测应该是根据this.cPtr生成shield，然后往chain上添加。\n\n而this.cPtr的来头有点复杂，咱们不管，直接hook JNI函数intercept，查看j10的值。\n\n多次打印，发现j10不会轻易发生改变，j10&#x3D;494045072144。\n\nhook RegisterNatives，观察动态注册的函数地址，找到intercept在libxyass.so的偏移是0x9e184。\nPS：一开始脚本写错逻辑了，我还以为是静态注册的,,ԾㅂԾ,,然后写了一个遍历文件夹下所有so的脚本，获得导出表，然后筛选我们的intercept——就当作在这里提供一个找静态注册JNI函数的思路吧。\nPPS：要找动态注册的函数，还有一个思路，根据JNI在Java的方法名，拿到ArtMethod，然后根据ArtMethod获得JNI函数在Native层的地址，然后判断这个地址在哪个模块，而偏移量则是Native层的地址 - 模块基址。\n\n用IDA打开后，修改一下参数名与类型。\n\n不知道到底在调用哪个函数，大概率是关于JNIEnv的函数。\n\n根据计算，off_AD430 + 0x753016A0 &#x3D;&#x3D; 0x6E13C，看样子是封装了CallObjectMethodV。\n问题来了，参数传递的时候，chain为什么会是a2？a2应该是jobject类型。\n\n\n而且，qword_B1740等全局变量尚未被初始化，因此，我决定dump一个so文件下来看看。\n\n然后使用工具修复dump下来的elf文件。\n\n打开IDA，来到0x9e184，可以发现qword_B1740等全局变量已经回填了。\n\n\n\n然而，这些jmethodID咱肯定是看不懂的。——这里有3个思路。\n\n将jmethodID转换成对应的函数名。（难点：先获取jmethodID，再考虑如何转换）\n\nhook JNI函数，打印JNI函数调用序列。（难点：如何筛选sub_9E184中执行的JNI函数）\n\nUnidbg的模拟执行可以打印调用的JNI函数序列。（难点：补环境）\n\n\n网上的博客都是基于Unidbg进行分析，既然别人用Unidbg，那这里我就用frida吧。——自己分析才更具挑战性嘛。\n获取JNI调用链Ⅰ.通过jmethodID获得函数名jmethodID在内存中实际上是指向ArtMethod结构的指针，也就是说，通过jmethodID可以获得ArtMethod在内存的位置。在libart中有一个函数叫PrettyMethod，往这个函数输入ArtMethod对象，可以打印出对应的函数名，而frida中就内置了这个函数的api。\n至此，还有一个问题需要解决——PrettyMethod返回函数名存储在c++的std::string对象中，要对这个string进行合理的解析，才能获得最终的函数名。\n安卓的arm64下，std::string类型一般占24字节，也就是3* pointerSize。\n需要存储小的字符串时，一般会将字符串直接存在std::string的内存空间中，最多可以存24字节；而需要存储大的字符串时，会另外开辟一处堆空间，用来专门存放字符串的内容，而std::string的原24字节，会用来存储这样的结构：\n\n一个指向堆上字符数据的指针 (char* data)。\n\n字符串的当前长度 (size_t length)。\n\n当前分配的内存容量 (size_t capacity)。\n\n\n总结一下，我们输入一个jmethodID后，把它作为参数传给PrettyMethod后，需要对返回的string进行解析，获得函数名字符串地址，然后打印。\nPS：至于如何区分小字符串存储还是大字符串存储，这里就不说咯。\n下图是一个实现效果。\n\n\n在IDA中添加注释。\n\nⅡ.hook JNI调用github上有大佬写过hook jni调用的frida脚本了，其原理是：hook上libart库中的函数——ArtMethod::Invoke。\nArtMethod::Invoke是ART中负责调用方法的核心函数，无论是Java方法还是JNI方法，最终都会通过Invoke执行。通过对这个函数的hook，可以获得整个进程的方法调用日志。\n然而日志太杂乱了，需要筛选，我们只针对libxyass.so中的方法调用，通过反射，可以获取某个类的某个方法的jmethodID，然后反射执行；因此，我们只需要打印调用栈，只要在调用栈中，某个调用的地址在libxyass.so的映射范围内，就将这条日志记录下来。\n大佬写的源代码没有过滤的代码，无过滤的、大量的console.log会导致进程卡死，无法获得我们想要的内容，于是我做了一些改动。\n\n其中地址0x6e1b4在CallObjectMethodV_函数的映射范围内。\n\n和我们第1个方法的日志结果一模一样。\n\n分析shield加密点为了获得加密函数的trace，这里有3种思路：\n\n使用IDA的trace功能；\n使用frida-stalker的实现trace；\n使用unidbg实现trace。\n\n我已经尝试过了第1、2种方式，耗时一天，无论怎么修改脚本，脚本始终跑得不稳定，最多一次trace了20w条指令，进程就崩溃了。\n在这20w条指令中，没有看到shield字段的影子，那只能使用unidbg了，麻了。\nUnidbg补环境先照着其它项目的模板，搭建基础环境。\n1.获得ShieldLogger对象跑起来后，遇到的第一个问题。\nUnidbg的JNI实现调用AbstractJni子类中的getStaticObjectField来解析此字段，但Unidbg的原生实现并不能正确解析，需要子类进行覆写，也就是在我们创建的类中进行覆写。\n\n找到getStaticOjectField的实现，然后模仿它的写法。\n@Overridepublic DvmObject&lt;?&gt; getStaticObjectField(BaseVM vm, DvmClass dvmClass, String signature) &#123;    switch (signature)&#123;        case &quot;com/xingin/shield/http/ContextHolder-&gt;sLogger:Lcom/xingin/shield/http/ShieldLogger;&quot;:            return vm.resolveClass(&quot;com/xingin/shield/http/ShieldLogger&quot;).newObject(null);    &#125;    return super.getStaticObjectField(vm, dvmClass, signature);&#125;\n\n然后JNI_OnLoad顺利执行完了。\n还记得这张图，在调用intercepte之前，需要先后执行initializeNative和initialize。\n\n通过上述这2个函数，对so中的静态变量和传入的cPtr进行初始化。\n\n因此，先要调用initializeNative和initialize。通过hook，发现initialize的参数始终是main。\n\n\n先创建3个变量。\n\n\n然后在构造函数中进行初始化。\n\n\n然后创建函数initializeNative和initialize。\n\n调用这2个函数，接着进行补环境。\n2.模拟nativeInitializeStart执行\nUnidbg 尝试调用 ShieldLogger 类中定义的原生方法 nativeInitializeStart （一个无参数的 void 方法），但该方法未在您的 AbstractJni 子类中实现或正确处理。\n\n不做处理，直接返回。\n\n3.模拟defaultCharset执行AbstractJni的函数callStaticObjectMethodV未能对java.nio.charset.Charset类上的静态方法defaultCharset()正确解析，因此需要补环境，模拟defaultCharset。\n在这里，我们直接调用Charset的defaultCharset，然后转换成DvmObject的类型传回去。\n\n4.获得sDeviceID我们需要获得设备id，然后转换成DvmObject类型传过去。\n\n通过全局搜索，查找类com.xingin.shield.http.ContextHolder。\n由于sDeviceId是一个静态变量，可以直接通过类名获取。——518dfe96-7f6f-370a-8e80-f94f8838e6de\n\n然后覆盖AbstractJni的getStaticObjectField。\n对于常用的java内置的数据结构，unidbg封装了特别的函数，比如StringObject，就不需要dvmClass.newObject来转换。\n\n5.获得sAppId\n与第4个补环境的流程一样。——sAppId &#x3D; -319115519\n\n覆写。\n\n\n6.模拟nativeInitializeEnd执行\n同样不做处理，直接返回。\n\n\n7.模拟initializeStart()执行\n\n8.获得SharedPreferences对象\n根据报错提示，我们要返回构造好一个SharedPreferences对象。\nSharedPreferences 是 Android 提供的一种轻量级的数据存储机制。它允许应用程序以键值对 (key-value pairs) 的形式持久化存储一些简单的数据类型（如布尔值、浮点数、整数、长整数和字符串）。每个 Android 应用都可以有自己的 SharedPreferences 文件。这些文件存储在应用的私有目录（shared_prefs目录）下，默认情况下其他应用无法访问。它是一个接口 (Interface)。这意味着它定义了一套操作规范（比如如何读取数据 getString(), getInt()，如何写入数据 edit().putString().commit() 等），但具体的实现则由 Android 系统提供。\nContext.getSharedPreferences(name, mode) 是获取或创建特定名称的 SharedPreferences 实例的标准途径。你调用这个方法，传入你想要操作的配置文件的名字，然后系统会返回一个实现了 SharedPreferences 接口的对象，你可以通过这个对象来读写数据。\n补环境的代码如下。\n\n注意，这里的newObject(getSharedPreferences_arg0)并不是调用构造函数，含义如下图所示。\n\n\n9.实现函数SharedPreferences-&gt;getString()\n上一步中，获得了SharedPreferences对象，这里需要通过getString获得value。\n通过unidbg，可以打印arg0的值，是“s”。\n\n因此，我们去看看xhs私有目录下有没有名为s的文件。——这些文件在原apk中没有，属于服务器下发给客户端的。\n\n\nandroid&#x2F;content&#x2F;SharedPreferences-&gt;getString(Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;String;的逻辑是这样的：输入2个字符串arg0、v2，输出1个字符串v1；这个函数会获取键arg0对应的值，如果没有，默认返回v2，如果找到了建arg0的值，返回v1。\n先通过unidbg获取访问了哪些键。\n\n已知main是不存在，s.xml里就放了一个main_hmac，所以可以这么写。\n\n为了方便观察，我把返回的结果也打印了。\n\n10.模拟Base64Helper-&gt;decode()执行\n需要返回解码后的字节数组。\n可以调用Base64类进行解码，然后通过unidbg对Byte数组的封装函数，返回回去。\n\n11.模拟initializedEnd()执行一样对initializedEnd()不做处理。\n\n12.至此，完成了对initializeNative()和initialize()的调用，接下来对intercepte进行主动调用\n13.构造一个空的chain对象添加chain。\n\n\n调用get_shield()。\n\n14.模拟com&#x2F;xingin&#x2F;shield&#x2F;http&#x2F;ShieldLogger-&gt;buildSourceStart()执行\n补环境。\n\n\n15.下载okhttp3框架，模拟okhttp3&#x2F;Interceptor$Chain-&gt;request()执行遇到报错。\n\n在pom.xml中，添加okhttp3的包，注意缩进。\n&lt;dependency&gt;    &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt;    &lt;artifactId&gt;okhttp&lt;/artifactId&gt;    &lt;version&gt;4.12.0&lt;/version&gt; &lt;/dependency&gt;\n\n保存，并构造request对象。\n\n补环境。这里的request是一种标记,可以通过DvmObject.getValue()取出来request的值。\n\n16.模拟okhttp3&#x2F;Interceptor$Chain-&gt;request()执行\n这里的request.url也是一种标记，可以通过DvmObject.getValue()取出来request.url()的值。\n\n17.模拟执行okhttp3&#x2F;HttpUrl-&gt;encodedPath()\n需要通过getValue取出具体的值，然后调用okhttp3.HttpUrl的encodedQuery()，将返回值转换为DvmObject类型返回去，由于这里是返回字符串，有专门的封装函数StringObject。\n\n\n18.模拟执行okhttp3&#x2F;HttpUrl-&gt;encodedPath()\n一样的原理。\n\n19.空字符串异常\n根据提示，这里的httpUrlObj_encodedQuery.encodedQuery()返回的是空字符串，即null。\n\n方法encodedQuery是用来返回url请求?后面参数用的，而我们的url没有添加?。\n\n20.模拟执行okhttp3&#x2F;Request-&gt;body()\n复杂对象都用newObject打上标记即可。\ncase &quot;okhttp3/Request-&gt;body()Lokhttp3/RequestBody;&quot;:\treturn vm.resolveClass(&quot;okhttp3/RequestBody&quot;).newObject(request.body());\n\n21.模拟执行okhttp3&#x2F;Request-&gt;headers()\ncase &quot;okhttp3/Request-&gt;headers()Lokhttp3/Headers;&quot;:                return vm.resolveClass(&quot;okhttp3/Headers&quot;).newObject(request.headers());\n\n22.模拟构造函数okio&#x2F;Buffer-&gt;&lt;init&gt;()\n\n在AbstractJni.newObjectV中，实现了很多构造函数。\n现在需要往里面添加okio.Buffer类的构造函数。\n观察原有的构造函数实现，其实是往newObject里面存放构造函数后的初始值。\n\n\n而okio&#x2F;Buffer-&gt;&lt;init&gt;()是无参构造函数，所以代码应该这么写。\n\n\n23.模拟okio&#x2F;Buffer-&gt;writeString(Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;nio&#x2F;charset&#x2F;Charset;)Lokio&#x2F;Buffer;\n函数writeString的返回值是Lokio&#x2F;Buffer，也就是说，我们可以取出Buffer实例，取出2个参数，然后调用writeString，最后将结果转换成DvmObject类型。\n\n\n24.模拟okhttp3&#x2F;Headers-&gt;size()I\n补环境。\n\n25.模拟执行okhttp3&#x2F;Headers-&gt;name(I)Ljava&#x2F;lang&#x2F;String;\n已经熟练补环境了。\n\n\n26.模拟执行okhttp3&#x2F;Headers-&gt;value(I)Ljava&#x2F;lang&#x2F;String;\n补环境。\n\n\n27.模拟执行okhttp3&#x2F;RequestBody-&gt;writeTo(Lokio&#x2F;BufferedSink;)V\n这里不能像以前一样直接返回return了，得先完成目标操作，再return。\n\n28.模拟执行com&#x2F;xingin&#x2F;shield&#x2F;http&#x2F;ShieldLogger-&gt;buildSourceEnd()V\n补环境。\n\n29.模拟执行com&#x2F;xingin&#x2F;shield&#x2F;http&#x2F;ShieldLogger-&gt;calculateStart()V\n补环境。\n\n30.模拟执行okio&#x2F;Buffer-&gt;clone()Lokio&#x2F;Buffer;\n补环境。\n\n31.模拟执行okio&#x2F;Buffer-&gt;read([B)I\n补环境。\n\n\n32.模拟执行com&#x2F;xingin&#x2F;shield&#x2F;http&#x2F;ShieldLogger-&gt;calculateEnd()V\n补环境的代码如下。\n\n33.模拟执行okhttp3&#x2F;Request-&gt;newBuilder()Lokhttp3&#x2F;Request$Builder;\n补环境的代码如下。\ncase &quot;okhttp3/Request$Builder-&gt;header(Ljava/lang/String;Ljava/lang/String;)Lokhttp3/Request$Builder;&quot;:    Request.Builder builderObj_header = (Request.Builder) dvmObject.getValue();    String header_arg0 = vaList.getObjectArg(0).getValue().toString();    String header_arg1 = (String)vaList.getObjectArg(1).getValue();    builderObj_header.header(header_arg0,header_arg1);    return dvmObject;\n\n34.模拟执行okhttp3&#x2F;Request-&gt;newBuilder()Lokhttp3&#x2F;Request$Builder;\n补环境的代码如下。\ncase &quot;okhttp3/Request-&gt;newBuilder()Lokhttp3/Request$Builder;&quot;:    Request requestObj_newBuilder = (Request) dvmObject.getValue();    return vm.resolveClass(&quot;okhttp3/Request$Builder&quot;).newObject(requestObj_newBuilder.newBuilder());\n\n35.模拟执行okhttp3&#x2F;Request$Builder-&gt;build()Lokhttp3&#x2F;Request;\n补环境的代码如下。\n\n36.模拟执行okhttp3&#x2F;Interceptor$Chain-&gt;proceed(Lokhttp3&#x2F;Request;)Lokhttp3&#x2F;Response;\n这里不需要模拟proceed的执行，因为proceed用于发送请求，说明字段shield已经添加好了，我们不关注发包，只关注shield是如何加密的。\n\n37.模拟状态码\n直接返回200。\n\n\n至此，总算是模拟完成了——37个要补充的地方，快累死了。\n38.获得shield\n\n然后打印的是null。\n注意到，之前我们在模拟环境的时候，总会使用newObject创建一个新的Request对象返回去，request的值其实始终没改变，因此，我们需要知道，最后一次返回Request类型的对象是哪个函数。\n\n\n来到这个代码的地方，添加一句为request赋值的语句，更新request的值。\n\n再次查看shield，这回有结果了。\n\n全部代码如下：\npackage com.xhs;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.Module;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.*;import com.github.unidbg.linux.android.dvm.api.Binder;import com.github.unidbg.linux.android.dvm.api.Bundle;import com.github.unidbg.linux.android.dvm.api.ServiceManager;import com.github.unidbg.linux.android.dvm.api.Signature;import com.github.unidbg.linux.android.dvm.array.ByteArray;import com.github.unidbg.linux.android.dvm.wrapper.DvmBoolean;import com.github.unidbg.linux.android.dvm.wrapper.DvmInteger;import com.github.unidbg.memory.Memory;import okhttp3.*;import okio.Buffer;import okio.BufferedSink;import org.apache.commons.codec.binary.Base64;import javax.crypto.Cipher;import javax.crypto.NoSuchPaddingException;import javax.crypto.spec.SecretKeySpec;import java.io.ByteArrayInputStream;import java.io.File;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.nio.charset.Charset;import java.security.*;import java.security.cert.CertificateException;import java.security.cert.CertificateFactory;import java.util.List;import java.util.Locale;import java.util.Map;import java.util.UUID;public class XHS_shield extends AbstractJni &#123;    public static AndroidEmulator emulator; // 静态属性，以后对象和类都可以直接使用    public static Memory memory; // 内存    public static VM vm; // 虚拟机    public static Module module; // 要加载的模块    public static DvmClass XhsInterceptor = null;    public static DvmObject XhsInterceptorObject;    public static long cPtr;    public static DvmObject chain = null;    private String url;    public Request request;    public XHS_shield()&#123;        // 64位虚拟设备，进程名为XHS        emulator = AndroidEmulatorBuilder.for64Bit().setProcessName(&quot;XHS&quot;).build();        // 获得内存对象        memory = emulator.getMemory();        // 设置安卓sdk版本        memory.setLibraryResolver(new AndroidResolver(23));        // 创建虚拟机        vm = emulator.createDalvikVM(new File(&quot;unidbg-android/src/test/resources/xhs_pack/xhs.apk&quot;));        // 开启JNI互动        vm.setJni(this); // 后期补环境会用，把要补的环境写到当前类中，执行这个代码即可，但是必须要继承AbstractJni        // 加载目标so        DalvikModule dm = vm.loadLibrary(&quot;xyass&quot;, true);        // 调用jni_onload        dm.callJNI_OnLoad(emulator);        module = dm.getModule(); // 把so加载到内存后，可以获得基地址、偏移量，该变量代指so文件        // 解析XhsInterceptor        XhsInterceptor = vm.resolveClass(&quot;com/xingin/shield/http/XhsHttpInterceptor&quot;);        // 获得一个空chain//        chain = vm.resolveClass(&quot;okhttp3/Interceptor$Chain&quot;).newObject(null);        // 构造url和request        url = &quot;https://edith.xiaohongshu.com/api/sns/v4/user/login/password?&quot;;        request = new Request.Builder()                .url(url)                .addHeader(&quot;xy-direction&quot;,&quot;88&quot;)                .addHeader(&quot;X-B3-TraceId&quot;,&quot;4b4bdb48881d080f&quot;)                .addHeader(&quot;x-xray-traceid&quot;,&quot;cb1441a76a4a081ecd469a26f3706ad0&quot;)                .addHeader(&quot;xy-scene&quot;,&quot;fs=0&amp;point=1932&quot;)                .addHeader(&quot;x-legacy-did&quot;,&quot;f10f91f68-7db7-3a36-80c9-703abad8fee2&quot;)                .addHeader(&quot;x-legacy-fid&quot;,&quot;17442981081013d20c9158a0a9b29abbcbb1ed726f5b&quot;)                .addHeader(&quot;x-legacy-sid&quot;,&quot;session.1744300626655701629150&quot;)                .addHeader(&quot;x-mini-gid&quot;,&quot;7c0d68e8647a5438a2394bbad364c2bdf31b98794735944077bbfc55&quot;)                .addHeader(&quot;x-mini-s1&quot;,&quot;ABsAAAABKjIUDN/qnVyFrjdjCBjTNhmOGE0SjnzqstjuHWyj5wVhUjSgHTzsuqoPKuiiOhD4JesIeK1AX8w=&quot;)                .addHeader(&quot;x-mini-sig&quot;,&quot;a619346fd57b0f2494eb8e197cf8fe6bb33cd62241a67e03343700de0ab8b8ff&quot;)                .addHeader(&quot;x-mini-mua&quot;,&quot;eyJhIjoiRUNGQUFGMDEiLCJjIjo0MSwiayI6ImQzNjkxYjYzMGJhODNmODljZTM0M2Q5NDlmODU2NTcyNzY5NTg2YTA5YzhmNTJhMjgzNWNiYjhjZjYxZTAwMTciLCJwIjoiYSIsInMiOiJkZmQ0OTI4ZWZlNTA5NDg1MTg5ZmJjOGEwMGRmMmMwYyIsInQiOnsiYyI6NDgsImQiOjQsImYiOjAsInMiOjQwOTgsInQiOjE3NDY3MTQwLCJ0dCI6WzFdfSwidSI6IjAwMDAwMDAwMmMwOGQwYWI0ZDdlNjExMjM4NmU2YmEyOTljZjAzNzIiLCJ2IjoiMi44LjUifQ.r2k40ztxFkHb9YD9W-r8ktVwWcyCuRLf0MmPFBWxV-9voigXNb_Bkvc3Vf8X3qs2wwcX2CpuPWIpylpfB9dwGR_CB3GAZrG1NpfKMjoDZh3Q6VAtuROrlVc7eAi-SqcGE-Z7GoU5tDth4LC9Fg0lbTIa6w6T6WTD_7QUlGroY8huQKkU26M7Whhv7nIFZQtkleznZtw276pAfbuvqyM9zMJb6TN4vqSrPeRRBBIn-7vgTNYF5pS7sF3yeshHP9BbS5QgFACF2I5iBo-z2dSMJkPeyPltMlabkqqJcf4fAjbqECYOCZusmkHXTfFk7-bwTYTW2TzeFFOBYMXNwBWKeOXe4aRqCcqbkjQQzPnJ3EHL-rzXCnKPv7Uf63MfEVxq9LqG398kwYNbUfkRdiGeM_X3OrwBLQ54cmA9jQa25L5jNzUo_2s1dS4Heg1EsEkLtNhAD9zDYDmjRpY6lbe94i_5oWLux8USIomK6_-TbvoEm1w3A51MwcJMVtiop-klqFRHEkazDUQA-76XS1Ogptxo9JpFSSYQt-S6Wet8nvg344UHUuhmXx7bb-gPYepYR6CQOt6EuCNOmLUIDLo0GgniHf2VJNQieSDxuYUIO3EGOXiwzxxB4Lv0TeSRTdqc8U7bLOb-GPeh49my4YWFHVcWEsqRO55EawZF0MSL4aekkiC5ZMm1SpoaJ60XKKVhNfG7sYf7LmIs6kMd3tNFFjvs3CFNlFgu58falTh13_W-sGsMZS3e-Cvlh6PKHic4l36rF2NH1xa2XmbY_VJzQyPm6tlD57IX89HocmwL1emORGPUx6EkhEkgbU-ZiXKcXmEC4W3njsliIc4HY18MurQmn2szKA4Kyl0Yo05igx5DlpJedTiALaaczSuaPr9Ko5xbcrSeFzFPc682BPkwZ1z8H-Hb5ljHDi2wqdvHepBVf8f96SbPEobd52wRjKh4hgdwxuUrKiM4JD3fxlCheGkLvMByCEXL3pP3oMMk7Bjblf-a_qw8cPdjzj_XOzrlcr-gWq1y79AyoyIF3CEri04uJEvnauaNNqLYOjWUYidJiuHdfpj0hQ3o-tEv19hiA4Qx_Bn_qG8BQEpVgksCTu9iwrIaeCjCZ486-waE09M.&quot;)                .addHeader(&quot;xy-common-params&quot;,&quot;fid=17442981081013d20c9158a0a9b29abbcbb1ed726f5b&amp;gid=7c0d68e8647a5438a2394bbad364c2bdf31b98794735944077bbfc55&amp;device_model=phone&amp;tz=Asia%2FShanghai&amp;channel=Vivo&amp;versionName=8.77.0&amp;deviceId=10f91f68-7db7-3a36-80c9-703abad8fee2&amp;platform=android&amp;sid=session.1744300626655701629150&amp;identifier_flag=4&amp;project_id=ECFAAF&amp;x_trace_page_current=login_full_screen_pwd_page&amp;lang=zh-Hans&amp;app_id=ECFAAF01&amp;uis=light&amp;teenager=0&amp;active_ctry=CN&amp;cpu_name=Qualcomm+Technologies%2C+Inc+SM8150&amp;dlang=zh&amp;launch_id=1744436392&amp;overseas_channel=0&amp;mlanguage=zh_cn&amp;folder_type=none&amp;auto_trans=0&amp;t=1744436385&amp;build=8770299&amp;holder_ctry=CN&amp;did=2d351bbef1db838c5fcd6b67a4aa1db5&quot;)                .addHeader(&quot;User-Agent&quot;,&quot;Dalvik/2.1.0 (Linux; U; Android 13; Pixel 4 XL Build/TP1A.221005.002.B2) Resolution/1440*3040 Version/8.77.0 Build/8770299 Device/(Google;Pixel 4 XL) discover/8.77.0 NetType/WiFi&quot;)                .addHeader(&quot;Referer&quot;,&quot;https://app.xhs.cn/&quot;)                .build();    &#125;    @Override    public DvmObject&lt;?&gt; getStaticObjectField(BaseVM vm, DvmClass dvmClass, String signature) &#123;        switch (signature)&#123;            case &quot;com/xingin/shield/http/ContextHolder-&gt;sLogger:Lcom/xingin/shield/http/ShieldLogger;&quot;:                return vm.resolveClass(&quot;com/xingin/shield/http/ShieldLogger&quot;).newObject(null);            case &quot;com/xingin/shield/http/ContextHolder-&gt;sDeviceId:Ljava/lang/String;&quot;:                return new StringObject(vm, &quot;518dfe96-7f6f-370a-8e80-f94f8838e6de&quot;);        &#125;        return super.getStaticObjectField(vm, dvmClass, signature);    &#125;    @Override    public void callVoidMethodV(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VaList vaList) &#123;        if(&quot;com/xingin/shield/http/ShieldLogger-&gt;nativeInitializeStart()V&quot;.equals(signature))&#123;            System.out.println(&quot;nativeInitializeStart() trap!&quot;);            return;        &#125;        if(&quot;com/xingin/shield/http/ShieldLogger-&gt;nativeInitializeEnd()V&quot;.equals(signature))&#123;            System.out.println(&quot;nativeInitializeEnd() trap&quot;);            return;        &#125;        if(&quot;com/xingin/shield/http/ShieldLogger-&gt;initializeStart()V&quot;.equals(signature))&#123;            System.out.println(&quot;initializeStart() trap&quot;);            return;        &#125;        if(&quot;com/xingin/shield/http/ShieldLogger-&gt;initializedEnd()V&quot;.equals(signature))&#123;            System.out.println(&quot;initializedEnd() trap&quot;);            return;        &#125;        if(&quot;com/xingin/shield/http/ShieldLogger-&gt;buildSourceStart()V&quot;.equals(signature))&#123;            System.out.println(&quot;buildSourceStart trap&quot;);            return;        &#125;        if(&quot;okhttp3/RequestBody-&gt;writeTo(Lokio/BufferedSink;)V&quot;.equals(signature))&#123;            System.out.println(&quot;writeTo trap&quot;);            RequestBody requestBody = (RequestBody) dvmObject.getValue();            BufferedSink bufferedSink = (BufferedSink) vaList.getObjectArg(0).getValue();            if(requestBody == null)&#123;                return;            &#125;            try &#123;                requestBody.writeTo(bufferedSink);            &#125; catch (IOException e) &#123;                throw new RuntimeException(e);            &#125;            return;        &#125;        if(&quot;com/xingin/shield/http/ShieldLogger-&gt;buildSourceEnd()V&quot;.equals(signature))&#123;            return;        &#125;        if(&quot;com/xingin/shield/http/ShieldLogger-&gt;calculateStart()V&quot;.equals(signature))&#123;            return;        &#125;        if(&quot;com/xingin/shield/http/ShieldLogger-&gt;calculateEnd()V&quot;.equals(signature))&#123;            return;        &#125;        super.callVoidMethodV(vm, dvmObject, signature, vaList);    &#125;    @Override    public DvmObject&lt;?&gt; callStaticObjectMethodV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) &#123;        switch(signature)&#123;            case &quot;java/nio/charset/Charset-&gt;defaultCharset()Ljava/nio/charset/Charset;&quot;: &#123;                return dvmClass.newObject(Charset.defaultCharset());            &#125;            case &quot;com/xingin/shield/http/Base64Helper-&gt;decode(Ljava/lang/String;)[B&quot;:&#123;                String getString_arg0 = vaList.getObjectArg(0).getValue().toString();                System.out.println(&quot;Base64Helper arg0: &quot; + getString_arg0);                return new ByteArray(vm, Base64.decodeBase64(getString_arg0));            &#125;        &#125;        return super.callStaticObjectMethodV(vm, dvmClass, signature, vaList);    &#125;    @Override    public int getStaticIntField(BaseVM vm, DvmClass dvmClass, String signature) &#123;        if(&quot;com/xingin/shield/http/ContextHolder-&gt;sAppId:I&quot;.equals(signature))&#123;            return -319115519;        &#125;        return super.getStaticIntField(vm, dvmClass, signature);    &#125;    @Override    public DvmObject&lt;?&gt; callObjectMethodV(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VaList vaList)&#123;        switch (signature)&#123;            case &quot;android/content/Context-&gt;getSharedPreferences(Ljava/lang/String;I)Landroid/content/SharedPreferences;&quot;:&#123;                String getSharedPreferences_arg0 = vaList.getObjectArg(0).getValue().toString();                System.out.println(&quot;arg0 = &quot; + getSharedPreferences_arg0);                return vm.resolveClass(&quot;android/content/SharedPreferences&quot;).newObject(getSharedPreferences_arg0);            &#125;            case &quot;android/content/SharedPreferences-&gt;getString(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;&quot;:&#123;                if(dvmObject.getValue().toString().equals(&quot;s&quot;))&#123;  // 获取getSharedPreferences_arg0                    String getString_arg0 = vaList.getObjectArg(0).getValue().toString(); // 获取键                    String getString_arg1 = vaList.getObjectArg(1).getValue().toString(); // 获得默认值                    System.out.println(&quot;key: &quot; + getString_arg0);                    System.out.println(&quot;default_value: &quot; + getString_arg1);                    if (getString_arg0.equals(&quot;main_hmac&quot;)) &#123;                        System.out.println(&quot;SharedPreferences -&gt; getString(): &quot; + &quot;Msm7d4eAmQVoQie97ci+UCY3fL6YKxBwT2qSuID0IOxYqWkpyRFdN6bM2LvQTlPzdQ5qkkJx/T2QMa8V/z+zkKAqh1mZevC+GYm8UJDPuZKbSI/ROWnKwlTiCvIMHEyY&quot;);                        return new StringObject(vm,&quot;Msm7d4eAmQVoQie97ci+UCY3fL6YKxBwT2qSuID0IOxYqWkpyRFdN6bM2LvQTlPzdQ5qkkJx/T2QMa8V/z+zkKAqh1mZevC+GYm8UJDPuZKbSI/ROWnKwlTiCvIMHEyY&quot;);                    &#125;else&#123;                        System.out.println(&quot;SharedPreferences -&gt; getString(): &quot; + getString_arg1);                        return new StringObject(vm, getString_arg1);                    &#125;                &#125;            &#125;            case &quot;okhttp3/Interceptor$Chain-&gt;request()Lokhttp3/Request;&quot;:                return vm.resolveClass(&quot;okhttp3/Request&quot;).newObject(request);            case &quot;okhttp3/Request-&gt;url()Lokhttp3/HttpUrl;&quot;:                return vm.resolveClass(&quot;okhttp3/HttpUrl&quot;).newObject(request.url());            case &quot;okhttp3/HttpUrl-&gt;encodedQuery()Ljava/lang/String;&quot;:&#123;                HttpUrl httpUrlObj_encodedQuery = (HttpUrl) dvmObject.getValue();                return new StringObject(vm, httpUrlObj_encodedQuery.encodedQuery());            &#125;            case &quot;okhttp3/HttpUrl-&gt;encodedPath()Ljava/lang/String;&quot;:&#123;                HttpUrl httpUrl = (HttpUrl) dvmObject.getValue();                return new StringObject(vm, httpUrl.encodedPath());            &#125;            case &quot;okhttp3/Request-&gt;body()Lokhttp3/RequestBody;&quot;:                return vm.resolveClass(&quot;okhttp3/RequestBody&quot;).newObject(request.body());            case &quot;okhttp3/Request-&gt;headers()Lokhttp3/Headers;&quot;:                return vm.resolveClass(&quot;okhttp3/Headers&quot;).newObject(request.headers());            case &quot;okio/Buffer-&gt;writeString(Ljava/lang/String;Ljava/nio/charset/Charset;)Lokio/Buffer;&quot;:&#123;                Buffer buffer = (Buffer) dvmObject.getValue(); // 取出实例                // 取出参数                String arg0 = vaList.getObjectArg(0).getValue().toString();                Charset arg1 = (Charset) vaList.getObjectArg(1).getValue();                // 调用writeString                return vm.resolveClass(&quot;okio/Buffer&quot;).newObject(buffer.writeString(arg0, arg1));            &#125;            case &quot;okhttp3/Headers-&gt;name(I)Ljava/lang/String;&quot;:&#123;                int arg0 = vaList.getIntArg(0);                return new StringObject(vm, ((Headers)dvmObject.getValue()).name(arg0));            &#125;            case &quot;okhttp3/Headers-&gt;value(I)Ljava/lang/String;&quot;:&#123;                int arg0 = vaList.getIntArg(0);                return new StringObject(vm, ((Headers)dvmObject.getValue()).value(arg0));            &#125;            case &quot;okio/Buffer-&gt;clone()Lokio/Buffer;&quot;:&#123;                return vm.resolveClass(&quot;okio/Buffer&quot;).newObject(((Buffer)dvmObject.getValue()).clone());            &#125;            case &quot;okhttp3/Request$Builder-&gt;header(Ljava/lang/String;Ljava/lang/String;)Lokhttp3/Request$Builder;&quot;:&#123;                Request.Builder builderObj_header = (Request.Builder) dvmObject.getValue();                String header_arg0 = vaList.getObjectArg(0).getValue().toString();                String header_arg1 = (String)vaList.getObjectArg(1).getValue();                builderObj_header.header(header_arg0,header_arg1);                return dvmObject;            &#125;            case &quot;okhttp3/Request-&gt;newBuilder()Lokhttp3/Request$Builder;&quot;:&#123;                Request requestObj_newBuilder = (Request) dvmObject.getValue();                return vm.resolveClass(&quot;okhttp3/Request$Builder&quot;).newObject(requestObj_newBuilder.newBuilder());            &#125;            case &quot;okhttp3/Request$Builder-&gt;build()Lokhttp3/Request;&quot;:&#123;                Request.Builder builderObj_build= (Request.Builder) dvmObject.getValue();                Request requestObj_build = builderObj_build.build();                request = requestObj_build;                return vm.resolveClass(&quot;okhttp3/Request&quot;).newObject(requestObj_build);            &#125;            case &quot;okhttp3/Interceptor$Chain-&gt;proceed(Lokhttp3/Request;)Lokhttp3/Response;&quot;:                return vm.resolveClass(&quot;okhttp3/Response&quot;).newObject(null);        &#125;        return super.callObjectMethodV(vm, dvmObject, signature, vaList);    &#125;    @Override    public DvmObject&lt;?&gt; newObjectV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) &#123;        switch (signature)&#123;            case &quot;okio/Buffer-&gt;&lt;init&gt;()V&quot;:&#123;                return dvmClass.newObject(new Buffer());            &#125;        &#125;        return super.newObjectV(vm, dvmClass, signature, vaList);    &#125;    @Override    public int callIntMethodV(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VaList vaList) &#123;        switch (signature)&#123;            case &quot;okhttp3/Headers-&gt;size()I&quot;:&#123;                return ((Headers) dvmObject.getValue()).size();            &#125;            case &quot;okio/Buffer-&gt;read([B)I&quot;:&#123;                Buffer buffer = (Buffer) dvmObject.getValue();                byte[] bytes = (byte[]) vaList.getObjectArg(0).getValue();                return buffer.read(bytes);            &#125;            case &quot;okhttp3/Response-&gt;code()I&quot;:&#123;                return 200;            &#125;        &#125;        return super.callIntMethodV(vm, dvmObject, signature, vaList);    &#125;    // 调用initialNative    public void initializeNative()&#123;        XhsInterceptor.callStaticJniMethod(emulator, &quot;initializeNative()V&quot;);    &#125;    // 调用initialize    public void initialize()&#123;        XhsInterceptorObject = XhsInterceptor.newObject(null);        cPtr = XhsInterceptorObject.callJniMethodLong(emulator, &quot;initialize(Ljava/lang/String;)J&quot;, &quot;main&quot;);        System.out.println(&quot;cPtr = &quot; + cPtr);    &#125;    // 调用intercept    public void get_shield()&#123;        chain = vm.resolveClass(&quot;okhttp3/Interceptor$Chain&quot;).newObject(null);        DvmObject&lt;?&gt; response = XhsInterceptorObject.callJniMethodObject(emulator, &quot;intercept(Lokhttp3/Interceptor$Chain;J)Lokhttp3/Response;&quot;, chain, cPtr);        System.out.println(&quot;response = &quot; + response);    &#125;    public static void main(String[] args) &#123;        XHS_shield shield = new XHS_shield();        shield.initializeNative();        shield.initialize();        shield.get_shield();        System.out.println(&quot;shield = &quot; + shield.request.headers().get(&quot;shield&quot;));    &#125;&#125;\n\n\n\n补环境补了好久，幸好有大佬们的博客，在补环境的过程中，我也逐渐学会了各式各样的unidbg补环境的方法，今天先歇一歇，明天开始trace指令流，分析加密点。——2025.6.2，晚上20:36。\nUnidbg trace获得日志代码如下：\nstatic void traceCode()&#123;    String traceFile = &quot;unidbg-android/src/test/java/com/xhs/traceCode.log&quot;; // 输出的路径    PrintStream traceStream = null; // 打印流    try &#123;        traceStream = new PrintStream(new FileOutputStream(traceFile), true);    &#125; catch (FileNotFoundException e) &#123;        throw new RuntimeException(e);    &#125;    // traceCode 对代码进行监控    emulator.traceCode(module.base, module.base + module.size).setRedirect(traceStream);&#125;\n\n然后从JNI_OnLoad开始trace的话，日志存了120w条指令；而从sub_9E184开始trace，只有1700多行，我们主要关注的是sub_9E184的逻辑。\n\n注意到，这里把寄存器变化的值打印出来了，假如某寄存器存放着字符串的地址，这里也只是打印地址，而不会打印字符串，这样的日志不便于观察。\n因此，我们需要修改traceCode的逻辑。\n修改Unidbg，获得带有字符串信息的日志注意到，日志会出现符号“&#x3D;&gt;”，于是在整个项目中搜索这个符号。然后发现，文件RegAccessPrinter.java就是我要们要修改的文件。\n我在这里设定，每次读取寄存器的内容，当初字符串地址进行访问，如果读取后发现了连续3个可视字符，就当成字符串进行处理，打印整个字符串。\n在Unidbg中，读取指定内存区域的字节又该怎么做呢？——我记得Unidbg动调可以访问内存地址，指令是“m”，于是在整个项目搜索“m”，然后发现是用Pointer类型进行访问，于是代码如下。\n// Method to check if the register value points to a readable string and print it    private void checkAndPrintString(long address, StringBuilder builder) &#123;        try &#123;            // 获取指向指定地址的 Pointer 对象            Pointer pointer = UnidbgPointer.pointer(emulator, address);            if (pointer == null) &#123;                return; // 地址无效，直接返回            &#125;            // 从地址读取 256 字节的数据            byte[] bytes = pointer.getByteArray(0, 256);            // 检查是否为可打印字符串并提取            if (isPrintableString(bytes)) &#123;                String str = extractString(bytes);                builder.append(&quot; (string: \\&quot;&quot;).append(str).append(&quot;\\&quot;)&quot;);            &#125;        &#125; catch (Exception e) &#123;            // 忽略内存不可读或无效的情况        &#125;    &#125;    // Check if the first 3 bytes are printable ASCII characters    private boolean isPrintableString(byte[] bytes) &#123;        if (bytes.length &lt; 3) return false;        for (int i = 0; i &lt; 3; i++) &#123;            if (bytes[i] &lt; 32 || bytes[i] &gt; 126) &#123;                return false;            &#125;        &#125;        return true;    &#125;    // Extract the full string until a non-printable character or null terminator    private String extractString(byte[] bytes) &#123;        StringBuilder sb = new StringBuilder();        for (byte b : bytes) &#123;            if (b &gt;= 32 &amp;&amp; b &lt;= 126) &#123;                sb.append((char) b);            &#125; else &#123;                break; // Stop at first non-printable character            &#125;        &#125;        return sb.toString();    &#125;\n\n将checkAndPrintString移动到函数print内部。\n\n\n同时，由于调用UnidbgPointer.Pointer需要Emulator对象，所以还得往类RegAccessPrinter添加成员变量。\n\n既然改了构造函数，还需要在调用构造函数的地方，把Emulator对象传进去。\n\n重新运行，程序能正常跑了。\n日志中出现了我们想看到的字符串。\n\n寻找加密点通过带有字符串信息的日志可以知道：\n\nshield最早出现在哪条指令；\nshield的缓冲区地址在哪。\n\n于是，有2个思路去寻找加密点：\n\n根据shield最早出现的指令，朝着之前的指令进行溯源；\n在shield的缓冲区地址设置读写断点。\n\n怎么看都是第2种方式更简单。\n找到缓冲区地址：0x1240c000。——因为是unidbg模拟的缓冲区，所以缓冲区地址不会变。\n\n我们的shield长度是134个字节，内容为：\nXYAAQAAgAAAAEAAABTAAAAUzUWEe0xG1IbD9&#x2F;c+qCLOlKGmTtFa+lG434Je+FUTaRHxIzkyONuSp3&#x2F;qeYJz8Mt3Jx+2fc6EAwYGGHebLP31H5m0rHnmtyNNSyC55+4O2fp4TDk\nunidbg提供了api，可以对写操作进行监控。——traceWrite。\n\n可以发现，偏移0x4b024处在将正确的值写回去了。\n分析加密算法先在IDA中，来到0x4b024看看。\n\n用frida hook一下，查看memcpy复制的内容，发现与最后的shield相差了2个字节，有2个字节（XY）不见了。\n\n\n根据之前traceWrite日志，可以发现0x4af74单独对0x1240c000前2个字节进行了修改。\n\n根据观察，0x4af70对前2个字节做了赋值，而0x4b020对132个字节进行了赋值。\n\n\n而且，对a1进行交叉引用，发现没有任何修改a1的地方；查看a1被传入的地方，只发现了简单的加解密，也就是说，前2个字节是固定的，根据直接的traceWrtie日志，固定为XY，因此我们分析的重点在v16。\n\n而v16似乎涉及加密。\n\n\n在Unidbg中，对v16涉及的memcpy下断点，查看源地址是什么。（已知目的地址是0x1240c002）\n\n可以看到，源地址是0x1240c0a0，于是在0x1240c0a0下写断点。\n发现，0x1240c0a0在libxyass.so偏移0x82890的地方被写入数据。\n\n注意到，shield有点像是base64编码后的结果，而且0x82890的代码又是每轮取出v136的3个字节，然后赋给v138的4个字节，这是base64编码的特征。\n\n\n在IDA中，来到汇编层，X10应该是：指向未经过base64编码的数据的地址。\n\n在Unidbg中下个断点，然后查看这里的值。\n\n\n对这里的内容进行base64编码，跟我们最终的shield后134字节一模一样，坐实了这里是base64编码。\n\n注意到，这个数据的地址是0x12411000，对这里下一个写断点。（编码前是99字节）\n\n\n注意到，99个字节的前16个字节的LR指向libxyass.so偏移0x49da0的位置，而后面83个字节来自偏移0x49db4的位置。\n\n\n来到IDA中。\n\n\n先后查看两个memcpy的源地址（下断点），然后对源地址下写断点。\n先看前16字节的memcpy的x1在哪，由于我hook的地址是0x49D9C，有些数据不是我们想要的，我们只需要前16个字节是00 04 00 02…的源地址。\n\n第4次进入该函数后，终于找到前16个字节的源地址是0xe4ffefd9。\n\n\n再来找后83个字节的x1在哪。——找到后83个字节在0x123dc060。\n\n\n0x10个字节（I）通过IDA的伪代码分析，v15是前16个字节，它来自于a1+1或者a1+16的位置。\n\n\nhook函数sub_49CE4，查看a1内容。\n\n\n确定v15来自a1+1。\n\n\n查看交叉引用，从哪一个过来的呢。\n\n\n根据trace日志，可以发现是从0x4a2e0跳转过来的。\n\n地址0x4a2e0属于函数sub_4a278，hook一下函数的入参，可以发现x0和x1分别指向16字节和83字节，而x2代表x1的长度。\n这里继续观察 16个字节，16个字节位于栈0xe4ffefd8上。\n\n\n因此对0xe4ffefd8下一个写断点，注意到0x8271C、0x8272C等地址会往里写目标字节。\n\n来到0x8271C，位于函数sub_81F00的范围内。\n下图，我对17个字节进行了分析（第0个字节是0x20，0x20并不在目标16字节内，它另有作用）。\n第0、3-4、5-8、9-12字节分析v124用来描述v127（53个字节）的长度，所以v124是0x53，经过bswap32后变成0x53 00 00 00。\n\n\n\n因此，这17个字节的格式是这样的：\n20 ?? ?? ?? ?? 00 00 00 01 53 00 00 00 ?? ?? ?? ?? \n再来判断第1-4个字节是如何来的。\n\n假设v155是0xAB CD EF GH，左移16位后，0xEF GH 00 00，或上一个2后，0xEF GH 00 02，然后swap32交换次序，0x02 00 GH EF，也就是说，有2个字节是固定的，GH EF相当于原来的v155的低2个字节做了交换。\n当前的v157是这样的：\n20 ?? ?? 00 02 00 00 00 01 53 00 00 00 ?? ?? ?? ??\n第13-16字节分析暂时先不分析第1-2字节，这个难度有点高，先来看最后4个字节。\n\n对v161进行交叉引用，发现v161 &#x3D; v35。\n\n\n阅读下图，v161获得了sub_4A278的返回值，我们上面的图中，也出现了sub_4A278。\n\n\n对sub_4A278进行分析，发现它是一个类似memcpy的函数。\n\n不同的是，target是std::string类型，而src是char数组。\n\n\nstring类型是24个字节，之前提到过string类型会对短字符串做sso优化，存储短字符串和长字符串时，string采用的结构不同。\nv3 &amp; 1，即target的最低位与1做&amp;，如果（v3&amp;1 !&#x3D; 0）为true，则说明当前当前的string存储着长字符串，采用__long结构；而反之为false，则采用__short结构。\n当遇到一个string类型，先判断第0位是否为1，如果是1，则采取__long结构，不用担心第0位的1会影响__cap_的值，__cap_被规定需要2字节对齐，所以第0位单纯是flag；而如果第0位是0，则采取__short结构，该结构会使用高7位表示data的大小，舍弃掉flag的1位，因为data就23个字节，最后一个字节还要存\\x00，所以data的实际存储空间大小就22字节，用7位足够表示了。\n+--------+----------------+----------+|address |    __short     | __long   |+--------+----------------+----------+|   0    | __size_ / __lx |          |+--------+----------------+          ||   1    |                |          ||   2    |                |          ||   3    |                | __cap_   ||   4    |                |          ||   5    |                |          ||   6    |                |          ||   7    |                |          |+--------|                |----------+|   8    |                |          ||   9    |                |          ||   10   |                |          ||   11   |   __data_      | __size_  ||   12   |                |          ||   13   |                |          ||   14   |                |          ||   15   |                |          |+--------|                |----------+|   16   |                |          ||   17   |                |          ||   18   |                |          ||   19   |                | __data_  ||   20   |                |          ||   21   |                |          ||   22   |                |          ||   23   |                |          |+--------+----------------+----------+\n\n注意到，在函数sub_81F00中，一共调用了4次sub_4A278，而v34 &#x3D; sub_4A278是第3次调用，也就是说，v34里面累积存放了4个字符串——原本有1个，再通过sub_4A278追加了3个。\n\n在Unidbg中模拟执行，对函数sub_4A278进行hook，可以发现：一共就调用了4次sub_81F00，所以基本可以确认，这4次调用都来自于sub_81F00。\n第一次调用sub_4A278。\nx0指向string类型对象，x1指向char数组，x2是char数组的长度。\n\n第1个字节是0x21，它最低位是1，说明是__long类型；\n第1个8字节是0x21，由于对齐，算作0x20，也就是说有32个字节的缓冲区；\n第2个8字节说明缓冲区已经用了0x18个字节，也就是用掉了24个字节；\n第3个8字节是缓冲区（堆）的地址。\n\n\n查看堆里面存放的内容，正好24个字节。\n\n\n待添加的字符串存在x1指向的地址中。\n\n\n第二次调用sub_4A278。\nx0指向string类型对象，x1指向char数组，x2是char数组的长度。\n\n查看x0的内容。\n第1个8字节是0x21，由于对齐，算作0x20，也就是说有32个字节的缓冲区。——因为之前32个字节，原本的字符串长度是24个字节，第一次调用时需要添加了7个字节，而缓冲区剩下的8个字节足够容纳，不需要重新申请空间。\n第2个8字节由于添加了7个字节，由0x18 + 0x7变成了0x1F。\n第3个8字节由于不用重新申请空间，所以空间地址和第一次调用时的堆地址一样，没变。\nz\n查看堆里面存放的内容，可以看到已经添加上8770299了。\n\n第三次调用sub_4A278。\n\n第一个字节是0x51，说明是__long类型。\n第1个8字节，0x51视作0x50，说明新申请的缓冲区有80字节的大小。\n第2个8字节，0x43表示已经使用了0x43个字节。\n第3个8字节，0x12407000是新缓冲区的地址。\n\n\n18dfe96-7f6f-370a-8e80-f94f8838e6de已经被复制到缓冲区里了。\n\n\nsub_4A278的返回值是string对象的地址，也就是说，v161指向这4个字符串。\n\n再也就是说，这里的v123实际上是在获得长度，而4个字符串的长度分别是0x18 + 0x7 + 0x24 + 0x10，和为0x53。\n\n所以16字节的第9-12和13-16都是53 00 00 00，都代表着v127的长度。\n为什么v156是17字节，而非16个字节，第0个字节为什么是0x20？很明显了，0x20说明是短字符串存储，经过sso优化，直接存储在对象内部，不用开辟堆空间。\n砍去一个0不用，剩下的7位表示data部分使用的字节数，0x0010000就是是十进制16，也就是目标16个字节的长度。\n\n言归正传，前17个字节的格式是这样的。\n20 ?? ?? 00 02 00 00 00 01 53 00 00 00 53 00 00 00\n只剩下第1-2字节未解决了。\n第1-2字节分析第1-2字节与v154有关。\n\n\n而v154与a4有关。\n\n\n查看函数0x81F00的引用，来到sub_6EFF0。\n\nv5与a3相关。\n\n函数sub_6EFF0有2个引用。\n\n先不着急追踪引用，先在Unidbg中hook函数sub_6EFF0。\n发现*a3 &#x3D; 0x4。\n\n搜索trace记录，判断函数sub_6EFF0来自于哪个函数调用。\n跳转到0x9ef04。\n\nv134是传入的a3。\n\n在0x9ef04下断点，查看x2，因为v134是一个指针，所以用mx2查看里面的内容。\n\n\nv134与v13有关，v13通过多个调用获得初始化。\n\n我之前实现过：通过jmethodID获得函数名，因此可以识别这里调用了什么。\n\n经过判断，调用了类的初始化函数okio.Buffer.&lt;init&gt;，还调用了writeString。\n尝试分析，这里究竟写入了什么。这里我hook上了0x6E13C，0x6E13C封装了CallObjectMethodV，同时根据args[2]（jmethodID）筛选调用的函数，打印写入的字符串。\nfunction getStr()&#123;    var module = Process.getModuleByName(&quot;libxyass.so&quot;);    Interceptor.attach(module.base.add(0x6E13C), &#123;        onEnter: function(args)&#123;            if(prettyMethod(args[2], 0) == (&quot;okio.Buffer.writeString&quot;))&#123;                var va1 = args[3];                var env = Java.vm.getEnv();                console.log(&quot;[str]&quot;, ptr(env.getStringUtfChars(va1)).readCString());            &#125;        &#125;    &#125;);&#125;\n\n写了很多东西。\n\n用Unidbg也可以实现类似的效果，写的时候打印一下即可。\n\n然后下个断点，判断执行前后能否打印字符串。\n成功打印字符串“&#x2F;api&#x2F;sns&#x2F;v4&#x2F;user&#x2F;login&#x2F;password”，但发现了点小问题。\n\n观察我补的环境，发现这里传入了一个新的dvmObject，可能是因为这个原因。\n\n\n改成这样子。\n\n\n然后再跑一次，这回jobject的值一致了。\n\n\n最后v134应该指向栈上地址：0xe4fff640，但没找到v134被修改的地方。\n只能说，只看伪代码果然不行，接下来看汇编了，前面的内容供读者图一乐，错误经验也是经验，主要是展示我个人的分析流程。\n往栈地址0xe4fff640下一个写断点，发现是0x9eddc往0xe4fff640里写了0x4。\n\n在0x9eddc下一个断点，判断一下Q3、Q2哪个存放了0x4。\n\nq3存放0x4。\n\n而Q3 &#x3D; [X24 + 252]，往0x9EDC4下断点，查看X24+252和是多少，然后给X24+252下一个写断点。\n\nx24 &#x3D; 0x123df000，因此在0x123df0fc下一个写断点。\n\n下了断点后，发现是0x920AC的指令再往0x123df0fc里写0x4。\n而w8的值由LDR w8,[x8]得来的。\n\n\n而x8的值是0x123dc060。\n\n再在0x123dc060下一个写断点，找是谁往0x123dc060里写入的0x4。\n地址0x9aab8的指令往0x123dc060里写0x4。\n\n分析一波，如图所示。\n\n可以下个断点在0x9AAA4，查看每次取的16字节来自于哪里。\n\n\nQ1的16字节来自栈上基址（且x19指向的）0xe4fff200、Q0的16字节来自栈上基址（且x22指向的）0xe4fff148。\nQ1和Q0只有低字节不一样，Q1是0x31，Q0是0x35。\n\n\n\n\n先为0xe4fff200下一个写断点，判断这16个字节（31 01 32…17 66 39）是什么时候写入的。\n\n发现是0x92830的指令在往里面写，跳转过去看看。\nQ0 &#x3D; [x8 + x10]，在0x92820下一个断点，查看x8与x10的值。\n\n\n得出0x12019A30。\n\n\nUnidbg的映射基地址是0x1200000，所以这里的偏移指向so文件的0x19A30。\n发现这里是.rodata节的内容，也就是说，Q1的16字节，来自于文件中硬编码的16字节。\n\n再追踪Q0的16字节从何而来，对0xe4fff148下一个写断点。\n注意到，似乎对每个字节赋值的地址不同。\n\n这里先追踪Q0最低字节，因为Q1和Q0只在这里有所不同。\n来到0x9A064。\n\n对这一块代码进行还原，发现有点复杂啊。\n\n借鉴了一下其它人的分析，Q0的16个字节来自于变种AES加密，因此这里先放一放，先去分析另外53个字节。\n0x53个字节前面提到，0x53个字节其实是分为4块，每块的字节数分别是0x18、0x7、0x24、0x10，\n通过hook函数sub_4A278便可获得这4块内容。\n下图是第3次调用sub_4A278的位置，可以在这边下一个断点，观察4个字符串未加密前是什么。\n\n这是加密前的内容，位于0x1240c000。\n\n在对第四次调用sub_4A278的位置下断点，这个时候里面的内容虽然也是0x53个字节，但已经加密了。\n\n\n加密点应该在第3次调用与第四次调用之间。\n在0x123dc060下写断点，指令0x8235C处往里面写了0x35，0x8235C位于函数sub_81F00内。\n\n跳转到0x8235C，看不出加密算法。\n\n\n慢慢分析。\n先对sub_81F00进行hook，打印入参。\n\n\n\n（x0）a1 &#x3D; 1。（疑似固定值）\n\n\n（x1）a2是个字符数组，代表build，如下。\n0xE表示sso存储，占用了7个字节。\n\n\n\n\n\n（x2）a3来自于AppId。\n\n\n\n\n（x3）a4为0x4；——之前q1、q2异或的0x4。\n（x4）a5是个string类型；\n\n存放了device_id。\n\n（x5）a6&#x3D;0xe4fff521，似乎存放了16个字节。\n\n\n（x6）a7 &#x3D; 0x10，似乎代表a6的大小。\n\n（x7）a8&#x3D;0x38663439662d3038，存放了8个字符“80-f94f8”。\n\n似乎是device_id的一部分。\n\n\n改一下变量名。\n\n\n结合入参进行改名。\n\n\n插入一个结构体，方便分析。\n\n\n接着往下分析。\n\n点进xmmword_19AA0，0x21说明了是长字符串存储，缓冲区大小是0x20个字节，已经占用了0x18个字节。（v157的前16个字节来自于xmmword_19AA0，缓冲区的地址并不是通过v157&#x3D;xmmword_19AA0得到的）\n\nv157指向红色框中的这18个字节。\n\n接着往下分析。\n\n观察变量“ptr_18bytes_AND_build_id_AND_device_id_b”的值，它的值其实在之前就清空了，这里应该是复用了，因为不知道它在加密部分是什么含义，暂时没改变量名。\nhook上0x821B0的位置，访问x9所指向的内存地址，查看内容有什么变化。（根据计算，有32次循环，记作0-31）\n\n第0次循环。\n\n\n\n在执行了几次循环后，如下图所示。\n从第8个字节开始，0x0、0x1…依次递增，一次循环可以初始化8个4字节，而执行32次，也就是说，从0一直到(32*8 - 1)，也就是0x0到0xff。\n\n而！RC4流密码中，在初始化状态向量时，SBox就是这么得来的，SBox的初始化的伪代码如下。\n一般的RC4中，SBox是字节数组，而这里是4字节为单位的数组。\nfor (int i = 0; i &lt; 256; i++) &#123;    S[i] = i;&#125;\n\n如果猜想是对的话，待会应该还有一段用密钥对S盒进行置换的过程，暂时先将“ptr_18bytes_AND_build_id_AND_device_id_b”重命名为“SBox”。\n继续往下分析。\n\n待会再去hook获得密钥，先来看看这个S盒置换算法。\n下面这段代码基本可以说明，就是RC4算法，而且密钥长度为13——0到12。\n\n循环64次，说明每次循环交换4次。\n\n\nhook一下，得到密钥看看。\n\nx8&#x3D;0x1201b48d，说明密钥在文件偏移0x1b48d的位置。\n试图用字符串“std::abort();”作掩护，hhhh。\n\n\n拿去试一下，发现是个非常标准的rc4加密。\n\n至此，0x53个字节分析完了。\n0x10个字节（Ⅱ）还记得，在**16个字节（Ⅰ）**中，我们分析得出，16个字节的格式如下：\n20 ?? ?? 00 02 00 00 00 01 53 00 00 00 53 00 00 00\n当时最大的问题是：?? ??的值由Q1与Q0异或得来，Q1是硬编码在文件中的，而Q0的值，当时只追踪了最低字节。\n当时为了得出Q0的最低字节从何而来，我逆了一下算法，但涉及到的缓冲区有点多。\n\n所以在这一小节，我们的目标之一是还原Q0，还有一个目标是分析绿色框里的16个字节从何而来。\n（我好像没解释过红色框，红色框的前4个字节是函数sub_81F00传入的a1，是固定值；再4个字节是app_id，0x2是根据传Q1与Q0异或的0x4判断得到的；0x7代表build的大小，0x24代表device_id的大小，0x10代表未知的16个字节）\n\nHMAC-MD5这16个字节是函数sub_81F00的入参a6，对应的缓冲区地址是0xe4fff521。\n\n\n在0xe4fff521下一个写断点。\n\n地址0x6f768处的指令对0xe4fff521进行了写。\n0xe4fff521的值由Q0得到，Q0的值由[X29,#-0x18]得到，所以在0x6F758下断点（或者看日志）。\n\nx29&#x3D;0xe4fff470，所以X29 - 0x18是0xE4FFF458。\n\n在0xE4FFF458下写断点，发现是0x92fd8。\n\n地址0x92fd8位于函数sub_92F2C范围内。\n\n\n我们需要的16字节存储在a2中，a2由v2赋值。\n\nw8是上图的a2，a2的值地址0x92FCC获得，所以在0x92FCC下一个断点，查看X20的值。\n\nx20的值是0x123df480。\n\n在x20下写断点。\n可以看到，偏移0x93f74对0x123df480进行了写操作。\n\n来到0x93f74。\n\n对应于汇编的伪代码。\n\n现在0x93F74下个断点，发现这个函数执行了很多次，迟迟等不到我们要看的内容，于是统计一下这个函数执行的次数。\n\n同时，分析算法，发现一个很有意思的点。\n假设HIDWORD(v4) &#x3D; R，那么LODWORD(v4)也等于R，也就是说64位的高32位和低32位是一样的，都为R。\n而v4 &gt;&gt; 17可以写成(R &lt;&lt; 32 | R) &gt;&gt; 17，进一步可以写成((R &lt;&lt; 32) &gt;&gt; 17) | R &gt;&gt; 17。\n(R &lt;&lt; 32) &gt;&gt; 17的结果是 R 左移（32 - 17 &#x3D; 15）位，并占据了结果的高位部分。\nR &gt;&gt; 17的结果是 R 右移17位，占据了结果的低位部分。\nv5是一个32位的数据类型，所以当上述的两者通过或组合在一块，就相当于将R循环右移了17位。\n而循环右移17位，等同于循环左移15位。\n（注意这里的&lt;&lt;都是逻辑左移和逻辑右移，而不是循环左移和循环右移）\n\nmd5算法有4轮运算：F、G、H、I，每一轮运算要执行16次（因为有16个子分组），在I运算中，涉及循环左移6、10、15、21位；除此之外，I运算涉及异或、取反、或等操作。\n\n\n\n\n而在sub_93F14中，发现了循环左移15位，还有循环左移21位，同时发现了一些异或、取反的操作，又考虑到这个函数执行了16次，这大概率是md5算法的II运算。\n\n还发现了md5的魔数，按常理来说，II运算是第4轮运算，魔数ABCD早被修改了，但编译器似乎没对寄存器x0进行操作，魔数一直存在x0中。\n\n\n更加坐实了这是一个魔改的md5算法。——为什么说是魔改，之后会说。\n\n\n分析trace日志中，0x93F74出现的地方，对应上调用了16次函数sub_93F14。\n\n\n在第16次的时候，w28出现了未知16字节中的4个字节。\n\n在第16次调用的trace记录，w27是魔数，w28的值来自于[0xe4fff2c0 - 0x34]，即[0xE4FFF28C]。\n要同时追踪w27和w28吗？其实不用。\n\n下图是第1次调用的trace记录，w27是一个魔数，所以只追踪w28。\n\n第三轮运算最终的a、b、c、d的第四轮运算的初始a、b、c、d。\n\n\n在0xe4fff1f0-0x34处下一个写断点，观察里面的值来自于哪，大概率是md5的HH轮运算传过来的。\n\n偏移0x94534位于函数sub_944A8内，符合md5的特征，看样子还是II运算。\n\n\n结合上图和下图，有点像是MD5的第60、61、62、63、64轮运算。\n\n\n结合标准的md5算法，md5的63、64轮明显被魔改了。\n\n有一个疑惑，既然这里是md5的第63、64轮加密，为什么函数sub_93F14调用了16次？我原本以为，这里魔改的II运算，结果似乎只涉及63、64轮加密，前面的分析有些误打误撞，不过确认了，使用的加密算法是md5，涉及一些变异。\n回到函数sub_92F2C，对函数进行hook，判断v2是从什么变成16个字节。\n\n\n发现要加密的内容是16个字节。\n\n\n对函数sub_92F2C进行分析，静态分析下，可能会调用了2次sub_93390，第1次调用是为了处理空间不足的情况，因为md5的每个分组是512位，要留出最后64位记录信息长度，所以实际能用来存储的空间只有56字节。\n\n创建结构体，对变量进行修改。\n0x80是填充值，数据长度要小于等于55，因为至少有1个字节是填充值。\n\n\n接下来，分析函数sub_93390，它大概率是在进行md5加密，根据统计，一共执行了5次sub_93390。——这也无法解释为什么调用了sub_93F14共计16次，再放一会吧。\n\n而我hook函数sub_92F2C，这个函数执行了2次，而且每一次数据的量都没有超过55字节，说明还有其它3处地方调用了sub_93390，进行md5加密。\n搜索trace记录，从第1次调用开始看起。\n\n第一次调用来自于0x92eec。\n\n这里的sub_93390没有看到参数列表。\n\n\n根据汇编，大概有3个参数，因此可以修改函数签名。\n\n而且这里的v3，一看就是之前分析的那个结构，修改变量类型。\n\n\nhook函数sub_93390，看看返回值和入参。——返回值可以通过入参a1的前16字节获得。\n根据大量的0x36，可以判断这是一个hmac-md5算法。\n\n\n整理一下，5次调用sub_93390的入参、返回值。\n// 第1次调用// x00000: 76 54 32 10 FE DC BA 98 89 AB CD EF 01 23 45 67    vT2..........#Eg// x1（key与0x36的结果）0000: 6A 3E 23 D6 BC E6 B7 B9 C6 D2 4B D7 6C 78 02 D9    j&gt;#.......K.lx..0010: 72 84 55 82 03 93 5F 6E 20 B3 32 87 75 82 F9 8D    r.U..._n .2.u...0020: 38 43 90 71 D4 5C B9 1A 8D 63 39 3D F7 94 59 C7    8C.q.\\...c9=..Y.0030: 7C 27 5A FD 1D 68 77 A5 BE 4D 91 14 E5 8D 0E 51    |&#x27;Z..hw..M.....Q// x20x1// 返回值0000: 39 0A 80 0F EC FE 50 43 EE 54 1F 5B 06 9C 47 8B    9.....PC.T.[..G.// 第2次调用// x00000: 76 54 32 10 FE DC BA 98 89 AB CD EF 01 23 45 67    vT2..........#Eg// x1（key与0x5C的结果）0000: 00 54 49 BC D6 8C DD D3 AC B8 21 BD 06 12 68 B3    .TI.......!...h.0010: 18 EE 3F E8 69 F9 35 04 4A D9 58 ED 1F E8 93 E7    ..?.i.5.J.X.....0020: 52 29 FA 1B BE 36 D3 70 E7 09 53 57 9D FE 33 AD    R)...6.p..SW..3.0030: 16 4D 30 97 77 02 1D CF D4 27 FB 7E 8F E7 64 3B    .M0.w....&#x27;.~..d;// x20x1// 返回值0000: 29 9A 8E 4B 77 48 EA 98 E3 E3 DF 8C C7 D2 4B 4A    )..KwH........KJ// 第3次调用// x00000: 39 0A 80 0F EC FE 50 43 EE 54 1F 5B 06 9C 47 8B    9.....PC.T.[..G.// x10000: 2F 61 70 69 2F 73 6E 73 2F 76 34 2F 75 73 65 72    /api/sns/v4/user0010: 2F 6C 6F 67 69 6E 2F 70 61 73 73 77 6F 72 64 66    /login/passwordf0020: 69 64 3D 31 37 34 34 32 39 38 31 30 38 31 30 31    id=17442981081010030: 33 64 32 30 63 39 31 35 38 61 30 61 39 62 32 39    3d20c9158a0a9b290040: 61 62 62 63 62 62 31 65 64 37 32 36 66 35 62 26    abbcbb1ed726f5b&amp;0050: 67 69 64 3D 37 63 30 64 36 38 65 38 36 34 37 61    gid=7c0d68e8647a0060: 35 34 33 38 61 32 33 39 34 62 62 61 64 33 36 34    5438a2394bbad3640070: 63 32 62 64 66 33 31 62 39 38 37 39 34 37 33 35    c2bdf31b987947350080: 39 34 34 30 37 37 62 62 66 63 35 35 26 64 65 76    944077bbfc55&amp;dev0090: 69 63 65 5F 6D 6F 64 65 6C 3D 70 68 6F 6E 65 26    ice_model=phone&amp;00A0: 74 7A 3D 41 73 69 61 25 32 46 53 68 61 6E 67 68    tz=Asia%2FShangh00B0: 61 69 26 63 68 61 6E 6E 65 6C 3D 56 69 76 6F 26    ai&amp;channel=Vivo&amp;00C0: 76 65 72 73 69 6F 6E 4E 61 6D 65 3D 38 2E 37 37    versionName=8.7700D0: 2E 30 26 64 65 76 69 63 65 49 64 3D 31 30 66 39    .0&amp;deviceId=10f900E0: 31 66 36 38 2D 37 64 62 37 2D 33 61 33 36 2D 38    1f68-7db7-3a36-800F0: 30 63 39 2D 37 30 33 61 62 61 64 38 66 65 65 32    0c9-703abad8fee20100: 26 70 6C 61 74 66 6F 72 6D 3D 61 6E 64 72 6F 69    &amp;platform=androi0110: 64 26 73 69 64 3D 73 65 73 73 69 6F 6E 2E 31 37    d&amp;sid=session.170120: 34 34 33 30 30 36 32 36 36 35 35 37 30 31 36 32    44300626655701620130: 39 31 35 30 26 69 64 65 6E 74 69 66 69 65 72 5F    9150&amp;identifier_0140: 66 6C 61 67 3D 34 26 70 72 6F 6A 65 63 74 5F 69    flag=4&amp;project_i0150: 64 3D 45 43 46 41 41 46 26 78 5F 74 72 61 63 65    d=ECFAAF&amp;x_trace0160: 5F 70 61 67 65 5F 63 75 72 72 65 6E 74 3D 6C 6F    _page_current=lo0170: 67 69 6E 5F 66 75 6C 6C 5F 73 63 72 65 65 6E 5F    gin_full_screen_0180: 70 77 64 5F 70 61 67 65 26 6C 61 6E 67 3D 7A 68    pwd_page&amp;lang=zh0190: 2D 48 61 6E 73 26 61 70 70 5F 69 64 3D 45 43 46    -Hans&amp;app_id=ECF01A0: 41 41 46 30 31 26 75 69 73 3D 6C 69 67 68 74 26    AAF01&amp;uis=light&amp;01B0: 74 65 65 6E 61 67 65 72 3D 30 26 61 63 74 69 76    teenager=0&amp;activ01C0: 65 5F 63 74 72 79 3D 43 4E 26 63 70 75 5F 6E 61    e_ctry=CN&amp;cpu_na01D0: 6D 65 3D 51 75 61 6C 63 6F 6D 6D 2B 54 65 63 68    me=Qualcomm+Tech01E0: 6E 6F 6C 6F 67 69 65 73 25 32 43 2B 49 6E 63 2B    nologies%2C+Inc+01F0: 53 4D 38 31 35 30 26 64 6C 61 6E 67 3D 7A 68 26    SM8150&amp;dlang=zh&amp;0200: 6C 61 75 6E 63 68 5F 69 64 3D 31 37 34 34 34 33    launch_id=1744430210: 36 33 39 32 26 6F 76 65 72 73 65 61 73 5F 63 68    6392&amp;overseas_ch0220: 61 6E 6E 65 6C 3D 30 26 6D 6C 61 6E 67 75 61 67    annel=0&amp;mlanguag0230: 65 3D 7A 68 5F 63 6E 26 66 6F 6C 64 65 72 5F 74    e=zh_cn&amp;folder_t0240: 79 70 65 3D 6E 6F 6E 65 26 61 75 74 6F 5F 74 72    ype=none&amp;auto_tr0250: 61 6E 73 3D 30 26 74 3D 31 37 34 34 34 33 36 33    ans=0&amp;t=174443630260: 38 35 26 62 75 69 6C 64 3D 38 37 37 30 32 39 39    85&amp;build=87702990270: 26 68 6F 6C 64 65 72 5F 63 74 72 79 3D 43 4E 26    &amp;holder_ctry=CN&amp;0280: 64 69 64 3D 32 64 33 35 31 62 62 65 66 31 64 62    did=2d351bbef1db0290: 38 33 38 63 35 66 63 64 36 62 36 37 61 34 61 61    838c5fcd6b67a4aa02A0: 31 64 62 35 38 38 70 6C 61 74 66 6F 72 6D 3D 61    1db588platform=a02B0: 6E 64 72 6F 69 64 26 62 75 69 6C 64 3D 38 37 37    ndroid&amp;build=87702C0: 30 32 39 39 26 64 65 76 69 63 65 49 64 3D 35 31    0299&amp;deviceId=5102D0: 38 64 66 65 39 36 2D 37 66 36 66 2D 33 37 30 61    8dfe96-7f6f-370a02E0: 2D 38 65 38 30 2D 66 39 34 66 38 38 33 38 65 36    -8e80-f94f8838e602F0: 64 65 66 73 3D 30 26 70 6F 69 6E 74 3D 31 39 33    defs=0&amp;point=1930300: 32 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    2...............// x20xc// 返回值0000: 81 97 7E 83 36 B7 43 2D 01 34 A6 A4 34 6C 32 06    ..~.6.C-.4..4l2.// 第4次调用// x00000: 81 97 7E 83 36 B7 43 2D 01 34 A6 A4 34 6C 32 06    ..~.6.C-.4..4l2.// x10000: 32 80 00 00 00 00 00 00 00 00 00 00 00 00 00 00    2...............0010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................0020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................0030: 00 00 00 00 00 00 00 00 08 1A 00 00 00 00 00 00    ................// x20x1// 返回值0000: 8D 67 06 8C 91 18 85 7B FB 78 DB 01 59 F2 09 69    .g.....&#123;.x..Y..i// 第5次调用// x00000: 29 9A 8E 4B 77 48 EA 98 E3 E3 DF 8C C7 D2 4B 4A    )..KwH........KJ// x10000: 8D 67 06 8C 91 18 85 7B FB 78 DB 01 59 F2 09 69    .g.....&#123;.x..Y..i0010: 80 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................0020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................0030: 00 00 00 00 00 00 00 00 80 02 00 00 00 00 00 00    ................// x20x1// 返回值0000: 72 4B A0 52 97 97 13 0E 0B C3 00 2F BF C2 C7 5F    rK.R......./..._\n\n注意到，第5次调用sub_93390的返回值正是我们需要的16字节。\n同时发现：\n\n第1次调用的返回值，是第3次加密的魔数值——0x36与key异或作为输入，魔数是标准md5魔数；\n第2次调用的返回值，是第5次加密的魔数值——0x5C与key异或作为输入，魔数是标准md5魔数；\n第3次调用的返回值，是第4次加密的魔数值——明文url + xy-common-params + xy-direction + platform + build + deviceId + xy-scene作为输入，魔数是第1次调用的返回值；\n第4次调用的返回值，是第5次加密的输入——第4次调用的输入是第3次加密中，末尾不足64字节的部分；如果第3次调用刚好满足每组都是64字节，第4次调用的输入将是0x80开头，然后在最后的8个字节中，会描述前面的所有块的大小。\n第5次加密就是将第4次的16字节进行了填充得到最终的16字节。\n\n单独看每次调用，其实每次调用都是魔改MD5算法，而将5次魔改MD5的调用合在一起，就是一个HMAC-MD5调用，整个流程应该这样子理解：\n第1次调用魔改MD5，是对**（密钥 ^ 0x36）的结果进行的魔改MD5运算，这一次调用的目的是获得用作第3次调用的魔数（16字节），这16字节并非是用来作为K’**，再次说明：密钥是64字节，不需要经过MD5运算获得16字节，再填充至64字节，这里进行MD5仅仅是为了获得第3次调用的魔数，因为第3次调用是第1次调用的延续。\n\n暂时不管第2次调用。\n第3次调用魔改MD5，是对明文进行计算MD5的值，明文长度为0x301字节，魔数是第1次调用的结果（16字节）。\n\n按照HMAC-MD5计算方式，K’是密钥，ipad是64个字节的0x36，两者异或后还是64字节，然后拼接上明文，再进行魔改的MD5运算，这时候，输入MD5运算的长度是0x301+0x40，即0x341字节。\n\n而MD5运算，一次处理64字节，如果最后一组不满64字节，则填充448位，最后8字节用来表示这一次输入MD5运算的位数是多少。0x341个字节，即输入了0x1A08位数据。\n\n\n第4次调用，单独处理1个字节，因为0x341个字节，可以分为13个64字节分组和单独1个字节，第4次调用就是处理这个字节的，注意下图，0x32后填充了一个0x80（即后面填充一个1和“无数”个0），而最后8字节是0x1A08，代表着处理的位数。\n\n\n将第1、3、4次调用放在一块看，最后获得了HMAC-MD5这一步的结果。↓\n\n第2次调用是获得（K’ ^ 0x5C）的MD5运算后的结果（16字节），用来作为第5次调用的魔数（因为在附加连接的时候，是K’在前面，说白了，魔数代表着前面几次MD5运算的结果）。\n\n\n第5次调用，是计算H(K’ ^ 0x5C || H(K’ ^ 0x36 || 明文)) ，输入是（K’ ^ 0x5C）|| （第1、3、4次调用的结果），已知（K’ ^ 0x5C）是64字节，而（第1、3、4次调用的结果）肯定是16字节，所以一共是80字节。\n下图中0x80是填充，最后8字节是0x280，即80字节。\n\n到这里，也能理解之前为什么调用了16次sub_93F14。因为第1-5次调用sub_93390，分别执行了1、1、12、1、1次魔改MD5运算。\n之所以说这是魔改MD5，是因为在个别轮次的运算，不是标准MD5的FF、GG、HH、II。\n点开sub_93390。\n\n\n根据日志，对sub_93390调用链进行分析，MD5一共64轮运算，将每轮运算依次与标准MD5进行对比。\n\n\n在日志中，追踪BR跳转，sub_94970是第1个较为“完整”的函数。（这里的完整指的是：有些函数的伪代码在IDA的分析下，显示为直接BR跳转；而这个函数会先执行一些操作再跳转）\n根据动调，发现前4行代码加载了魔数，第5行代码加载了待加密数据的地址，具体内容写在注释上了…函数sub_94970似乎在为MD5的第一轮运算做准备。\n\n接下来，来到函数sub_95080，这应该是md5的第一轮加密。循环左移7位变成了6位。\n\nhook了一下v7+132的位置应该是T盒，但并不是标准的T盒。\n\n函数sub_95654，为明文的第2、3个字做准备。\n\n函数sub_93DD8中，MD5第二轮加密。循环左移12位变成了循环左移13位。\n\n具体的不在这里一一分析，做个总结。\n魔改左移操作数第43轮的左移操作数被改，在地址0x93AC8处，原操作数为 16，被改为 11\n第42轮的左移操作数被改，在地址0x93A90处，原操作数为11 ，被改为 16\n第41轮的左移操作数被改，在地址0x93A78处，原操作数为 4，被改为 23\n第40轮的左移操作数被改，在地址0x94368处，原操作数为 23，被改为 4\n第14轮的左移操作数被改，在地址0x9480C处，原操作数为 12，被改为 13\n第11轮的左移操作数被改，在地址0x94E00处，原操作数为 17，被改为 16\n第8轮的左移操作数被改，在地址0x93888处，原操作数为 22，被改为 20\n第4轮的左移操作数被改，在地址0x952E4处，原操作数为 22，被改为 21\n第2轮的左移操作数被改，在地址0x93E28处，原操作数为 12，被改为 13\n第1轮的左移操作数被改，在地址0x950F0处，所属函数sub_95080，原操作数为 7 ，被改为 6\n魔改T值标准MD5的T值是：\nconst unsigned int t[] = &#123;      0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,      0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be, 0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,      0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa, 0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,      0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,      0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,      0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,      0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,      0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1, 0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391&#125;;\n\n而魔改的T值是：\n0000: 56 B7 C9 E9 79 A4 1B D7 DB 81 10 24 D9 88 10 68    V...y......$...h0010: AF F7 14 9B B1 5B 1F FF BE D7 1C 88 22 61 66 66    .....[......&quot;aff0020: 93 61 66 F6 9E 63 19 A6 21 09 14 49 EE CE 1D C1    .af..c..!..I....0030: AF 0F 1C F5 2A C6 17 47 13 46 10 A9 01 95 16 FD    ....*..G.F......0040: 00 25 00 F6 53 14 74 02 91 E6 21 D2 C9 11 00 E2    .%..S.t...!.....0050: E6 CD 61 22 97 0D D5 F2 ED 14 5A 42 05 E9 77 A2    ..a&quot;......ZB..w.0060: F9 A3 77 F2 D9 12 6F 62 9A 4C 2A 92 48 F2 39 12    ..w...ob.L*.H.9.0070: 00 00 00 00 40 B3 40 C0 51 5A 5E 26 00 00 10 E9    ....@.@.QZ^&amp;....0080: 5D 10 3F D6 D6 07 57 C3 42 39 FC FF 91 D6 7C 97    ].?...W.B9....|.0090: 44 EA BC A4 A9 CF DC 4B 70 BC BC BE C6 7E 8C 28    D......Kp....~.(00A0: 60 4B CC F6 95 10 EC D4 FA 27 AC EA E5 88 DC E6    `K.......&#x27;......00B0: 39 D0 DC D9 05 1D 8C 04 F9 7C A2 1F 90 F2 39 12    9........|....9.00C0: 00 00 00 00 22 61 9D 6D 65 56 AC C4 1C 39 E5 FD    ....&quot;a.meV...9..00D0: 44 22 29 F4 A7 23 94 AB 39 A0 93 F5 C3 59 5B 65    D&quot;)..#..9....Y[e00E0: 97 FF 2A 45 7D 24 EF F5 D1 5D 84 85 92 CC 0C 85    ..*E&#125;$...]......00F0: E0 26 99 F9 C0 F2 39 12 00 00 00 00 D6 A9 97 EF    .&amp;....9.........0100: 4F 7E 99 F9 14 43 99 A9 82 7E 53 C5 A1 11 08 45    O~...C...~S....E0110: A6 11 08 45 35 F2 3A BD 91 D3 86 EB\n\n为什么魔改后的T表比标准T表大呢？——多了7个4字节。\n在函数sub_93BA4中，执行了第26、27、28轮运算，v0[59]是第27轮的t，v0[62]是第28轮的t，中间跳过了v0[60]、v0[61]，也就是2个4字节。\n\n在函数sub_951A8中，执行了第45、46、47轮运算。\n\n\n而在函数sub_93A4C中，执行了第42、43、44轮运算，第45轮的t是v1[79]。\n\n\nv1和v5基址一样，v1[79]到v5[82]，跳过了2个4字节，也就是8字节。\n在函数sub_93CB4中，执行了第56、57、58轮运算，又跳过了3个4字节。\n\n总共跳过了2 + 2 + 3个4字节，共计7个4字节，因此魔改后的T表多了7个4字节。\n入参顺序修改假设HH的签名是HH（A，B，C，D，Mi，s，Ti）。\n40轮：37轮结果对应为A位置，36轮结果对应B，38-39分别对应C-D，明文块取下标13\n41轮：36轮结果对应为A位置，39轮结果对应B，38-40分别对应C-D，明文块取下标10\n42轮：39轮结果对应为A位置，38轮结果对应B，40-41分别对应C-D，明文块取下标3\n43轮：38轮结果对应为A位置，40轮结果对应B，41-42分别对应C-D，明文块取下标0\n以第40轮的入参为例子。\n标准MD5的情况下，原本第40轮的bcda分别来自于第36、39、38、37轮。\n\n\n在函数sub_957D4中，v1-200存放着第36轮的结果b。\n\n在函数sub_936C0中：\nv2-196存放着第37轮的结果a。\nv2-192存放着第38轮的结果d。\nv2-188存放着第39轮的结果c。\n\n正常的第40轮，应该是：HH(v-200, v-188, v-192, v-196，M10，23，tj)，展开后应该是这样子：\na &#x3D; (v-188) + (((v-200) + H(v-188, v-192, v-196) + M10 + tj) &lt;&lt;23)。\n在函数sub_94344中是：HH(v-196, v-200, v-192, v-188, M13, 4, tj)。\n\n\n同时发现，如果对第40轮取的明文进行打印，对应的M是第13块（下标），而非第10块，这里不过多赘述了。\n\n魔改AES，还原Q0现在只剩下最后2个问题：\n一是之前Q0与Q1异或的结果是0x4，Q1是硬编码在文件中的，而Q0则涉及很多内容，对栈、堆下断点，一点一点追踪Q0的内容十分困难。\n\n二是HMAC-MD5的密钥是哪里来的？\n根据后来的结果，只要解决问题二，问题一就顺带解决了。\nx1指向的内容，是密钥与0x36异或的结果。\n// 第1次调用// x00000: 76 54 32 10 FE DC BA 98 89 AB CD EF 01 23 45 67    vT2..........#Eg// x1（key与0x36的结果）0000: 6A 3E 23 D6 BC E6 B7 B9 C6 D2 4B D7 6C 78 02 D9    j&gt;#.......K.lx..0010: 72 84 55 82 03 93 5F 6E 20 B3 32 87 75 82 F9 8D    r.U..._n .2.u...0020: 38 43 90 71 D4 5C B9 1A 8D 63 39 3D F7 94 59 C7    8C.q.\\...c9=..Y.0030: 7C 27 5A FD 1D 68 77 A5 BE 4D 91 14 E5 8D 0E 51    |&#x27;Z..hw..M.....Q// x20x1// 返回值0000: 39 0A 80 0F EC FE 50 43 EE 54 1F 5B 06 9C 47 8B    9.....PC.T.[..G.\n\n再次异或0x36，获得key。\n5c 08 15 e0 8a d0 81 8f f0 e4 7d e1 5a 4e 34 ef 44 b2 63 b4 35 a5 69 58 16 85 04 b1 43 b4 cf bb 0e 75 a6 47 e2 6a 8f 2c bb 55 0f 0b c1 a2 6f f1 4a 11 6c cb 2b 5e 41 93 88 7b a7 22 d3 bb 38 67\n\n存放（密钥^0x36）的栈地址是0xe4fff320，在这里下一个写断点。\n\n\n偏移0x91708的位置。\n\n说明密钥来自于[x25, #0x24]往后的64个字节。\n\n地址是0x123e7024。\n\n对0x123e7024下一个写断点。\n\n\n偏移0x916d0。\n\n在0x926B8下断点，获得X24的值。\n\n再对0x123e2000下一个写断点。\n\n这里的偏移是0x911c8，0x1c1f8是libc的偏移，所以这里看LR寄存器。\n\nhook 0x911C4，获取源地址。\n\n再在0xe4fff644下写断点，看看哪里往里写。\n\n偏移0x9eddc。\n\n在0x9edc4下断点，查看x24和x8.\n\n在0x123df100下写断点。\n\n\n偏移0x91c84。\n\n在0x91C80下断点，查看src。\n\n在0x123dc070下个写断点。\n\n偏移0x9aab8，之前分析第1-2字节的时候，遇到过这个偏移。\n\n密钥来源于Q1、Q0的16字节异或的结果。\n\n在0x9AAB4下断点，查看Q0、Q1的值。\n\n\n一共经历了6次地址0x9AAB4。\n第1轮异或的结果是0x4，是我们之前想探究的2个字节的来源。\n第2、3、4、5轮异或的结果合在一块，是密钥的64字节。\n第6轮异或的结果像是PKCS7填充方式。\n// 1q0=0x3966170766667a666108020434320135q1=0x3966170766667a666108020434320131// 结果q0=0x4// 2q0=0xbf8a86b75c5aa6988a18500d97aec16eq1=0x50bec8edbd2742680599808777bbc932// 结果q0=0xef344e5ae17de4f08f81d08ae015085c// 3q0=0x57ef40c30996ef5928798ead0a1f8562q1=0xec20f480b8926a4f70102b98be7c3726// 结果q0=0xbbcfb443b10485165869a535b463b244// 4q0=0x23cec11b0d7991d1bd27b2b6ecfdc56q1=0xf3534ed0bbd8cca6375d11c92969a958// 结果q0=0xf16fa2c10b0f55bb2c8f6ae247a6750e// 5q0=0xf78b842c37084a18aebc2f6959061f3fq1=0x90b33fff15af31903dfd7142926a0e75// 结果q0=0x6738bbd322a77b8893415e2bcb6c114a// 6q0=0x82a9df8040ac9909aee06a8949973ab0q1=0x92b9cf9050bc8919bef07a9959872aa0// 结果q0=0x10101010101010101010101010101010\n\n注意到，x19里面的地址，都是从x24里面取出来的。\n\nx24指向的内容如下。\n\n监控一下0x120b4000。\n\n发现监控不到。。。\n在IDA的伪代码中进行追踪。\n\n\n\n打印一下result。\n\n\n\n\n后面发现，这里的x24源于hmac_main的值，hmac_main进行base64解码后的内容和它一模一样。\n\n前面0x40字节在异或后是hmac-md5的密钥，而0x40-&gt;0x50字节抑或后是pkcs7填充的内容。\n再对x22指向的0xe4fff148进行监控。（Q0）\n之前追踪过0x9a064，找不到结果，这回追踪LR。\n\n写的操作都发生在sub_994AC中，sub_994AC累积执行了6次。\n\n偏移0x9a9cc位于函数sub_9A728，对这个函数分析，发现这个函数实现了一个对称分组密码的加密和解密操作，使用模式是CBC。\nif(a6)分支实现了CBC加密模式。\n\n\nif(a3)分支实现了CBC解密模式。\n\n\n根据分析，a5是IV，即初始化向量（盐），这是之前Q1的值。\n\n\n\nhook函数sub_994AC，查看它的入参。\n注意到，第1次执行，对“32 C9 BB 77 87 80 99 05 68 42 27 BD ED C8 BE 50”解密，获得了“35 01 32 34 04 02 08 61 66 7A 66 66 07 17 66 39”，而“35 01 32 34 04 02 08 61 66 7A 66 66 07 17 66 39”正是0x9AAB4第一轮异或的Q0！\n第1次执行X032 C9 BB 77 87 80 99 05 68 42 27 BD ED C8 BE 50X158 97 27 12 0A 00 00 00 00 00 00 00 00 00 00 00返回值（第2次执行时的X1）35 01 32 34 04 02 08 61 66 7A 66 66 07 17 66 39第2次执行X026 37 7C BE 98 2B 10 70 4F 6A 92 B8 80 F4 20 ECX135 01 32 34 04 02 08 61 66 7A 66 66 07 17 66 39返回值（第3次执行时的X1）6E C1 AE 97 0D 50 18 8A 98 A6 5A 5C B7 86 8A BF第3次执行X058 A9 69 29 C9 11 5D 37 A6 CC D8 BB D0 4E 53 F3X16E C1 AE 97 0D 50 18 8A 98 A6 5A 5C B7 86 8A BF返回值（第4次执行时的X1）62 85 1F 0A AD 8E 79 28 59 EF 96 09 C3 40 EF 57第4次执行X075 0E 6A 92 42 71 FD 3D 90 31 AF 15 FF 3F B3 90X162 85 1F 0A AD 8E 79 28 59 EF 96 09 C3 40 EF 57返回值（第5次执行时的X1）第5次执行X0A0 2A 87 59 99 7A F0 BE 19 89 BC 50 90 CF B9 92X156 DC CF 6E 2B 7B D2 1B 1D 99 D7 B0 11 EC 3C 02返回值（第6次执行时的X1）3F 1F 06 59 69 2F BC AE 18 4A 08 37 2C 84 8B F7第6次执行X09B 48 8F D1 39 69 CA C2 54 E2 0A F2 0C 1C 4C 98X13F 1F 06 59 69 2F BC AE 18 4A 08 37 2C 84 8B F7返回值b0 3a 97 49 89 6a3 e0 ae 09 99 ac 40 80 df a9 82\n\nsub_9A728采用了CBC模式，而函数sub_994AC每次处理又是16字节，这大概率是一个AES加解密。sub_994AC的第一个参数的待解密的16字节，第二个参数存放结果，第三个参数是轮密钥。\ns.xml文件里存放的是密文。\n\n第1个16字节作为密文0，在AES解密后生成中间值[0]，中间值[0]就是35 01 32 34 04 02 08 61 66 7A 66 66 07 17 66 39，中间值[0]再与盐IV “31 01 32 34 04 02 08 61 66 7A 66 66 07 17 66 39”进行异或，生成明文[0]——0x4。\n所以说，这里的明文0x4是固定的。\n\n第2个16字节作为密文1，在AES解密后生成中间值[1]，中间值1就是6E C1 AE 97 0D 50 18 8A 98 A6 5A 5C B7 86 8A BF，中间值[1]再与密文0（32 C9 BB 77 87 80 99 05 68 42 27 BD ED C8 BE 50）进行异或，生成明文[1]——0xef344e5ae17de4f08f81d08ae015085c。\n\n…以此类推，最后获得的内容是：\n// 明文[0]，固定字节q0=0x4// 明文[1-4]，用作HMAC-MD5的密钥q0=0xef344e5ae17de4f08f81d08ae015085cq0=0xbbcfb443b10485165869a535b463b244q0=0xf16fa2c10b0f55bb2c8f6ae247a6750eq0=0x6738bbd322a77b8893415e2bcb6c114a// PKCS7填充q0=0x10101010101010101010101010101010\n\n也就是说，xhs服务器那边发来的xml文件，其实藏了0x4和MD5的密钥。\n接下来还有2个疑惑AES是否魔改？密钥是什么？\n为了解答疑惑，需要追踪函数sub_994AC，这个函数专门负责AES解密，难点在于，这个函数与魔改MD5一样，频繁通过BR跳转到别的函数，代码片段零零散散。\n\n根据分析，每一次执行sub_994AC，最终都会调用下面这些函数。\n0-3次循环都一样，第4次循环出现变化；\n994AC9a260\t\t\t\t// 0-3字节：轮密钥加99e6c\t\t\t\t// 4-7字节：轮密钥加9a40c\t\t\t\t// 8-11字节：轮密钥加9a574\t\t\t\t// 12-15字节：轮密钥加995e899c40&lt;----循环0996d8\t\t\t\t// 查表优化9a620\t\t\t\t// 查表优化99a7c995649a6ac9a2cc9991c&lt;&gt;9a0a09a364998989978c9a16099ee099f749969c99c40&lt;----循环1996d89a62099a7c995649a6ac9a2cc9991c&lt;&gt;9a0a09a364998989978c9a16099ee099f749969c99c40&lt;----循环2996d89a62099a7c995649a6ac9a2cc9991c&lt;&gt;9a0a09a364998989978c9a16099ee099f749969c99c40&lt;----循环3996d89a62099a7c995649a6ac9a2cc9991c&lt;&gt;9a0a09a364998989978c9a16099ee099f749969c99c40&lt;----循环4996d89a62099a7c995649a6ac9a2cc9991c&lt;&gt;9a4a0&lt;差异点&gt;9984c9a00c\n\n同时，之前提到的0x9a064位于函数sub_9A00C内部，0x9a064会在每次循环中，会修改下图的X22寄存器指向的地址，这间接改变了Q0的内容，而Q0指向解密后的中间值（之所以称作中间值，是因为CBC模式下，中间值还要和上一轮密文进行异或，才能得到最后的明文），这说明了执行到sub_9A00C的时候，已经完成了AES解密。\n\n开始分析上述函数——从sub_9A260开始。\nhook函数sub_994AC的时候，第3个参数是轮密钥。\n\n\nhook函数sub_9A260，发现下面的情况。\n\n这说明sub_9A260在对密文进行“轮密钥加”。\n\n初始密钥加密与解密的流程是反过来的，既然a3是轮密钥，可以倒推回初始密钥。\n\n在0xE4FFF398下一个写断点，观察到偏移0x981b4。\n\n\n在偏移0x981A0处下一个断点，观察x2+x8。\n\n往0xe4fff2f8下一个写断点。\n\n偏移0x96a44，位于函数sub_96A14中。\n\nhook一下函数sub_96A14，打印a1，a1是device_id的前16字节。\n\n因此，aes密钥的种子是device_id。\n解密——Td表（未改动）稍微分析了一下，AES解密采取的方式是查T表，查表的话AES的解密速率会快很多，但没有一般的特征了（行位移、字节替换等），所以不好分析。\n\n\n来到函数sub_996d8，0x6a5fcc9b是标准Td[0]表的4个字节，打印一下T表。\n\n和标准的Td[0]表一模一样。\n\n\n另外3个表会基于Td[0]进行生成，简单来说就是对基础表中的每一个32位数值执行字节的循环右移，因此可以根据Td[0]生成另外3个T表。经过对比，4个T表都是标准的。\n密钥扩展这里，我们为了追踪密钥扩展的函数，可以追踪初始密钥。\n追踪sub_96A14的执行流，寻找对device_id进行处理加密，最终获得初始密钥的位置。\n根据分析，在函数sub_96A14、sub_95A3C、sub_97100、sub_960F8中，完成了对初始密钥的构建。\n\n已知，初始密钥是W[3:0]，是根据device_id异或4个固定的4字节生成的；（0-3轮密钥）\n而接下来的第4-39轮密钥是根据查表的方式生成的。\n\n\n\n在日志中，发现了一个规律——最左边框框里面的轮密钥，统一由函数sub_980ac查表获得；左2的框框统一由函数sub_97490查表获得，左3的框框统一由函数sub_97980获得、左4的框框统一由sub_973a8查表获得。\n\n\n\n\n这4个函数都只执行9次，生成了W[39:4]，此时，还未知W[43:40]的生成方式，但应该是正常的标准扩展方式。\n正常的密钥扩展如下图所示。\n\n\n我们在日志中搜索W[43:40]的轮密钥——比如：搜索0x1070c115，然后来到第1次出现的地方。注意到，eor的w9和w12中并没有出现0xf0106B39，如果是标准的扩展算法，应该会出现0xf0106B39的。\n\n\n\n\n可以看到，T函数明显被修改了，除此之外，W[43:40]的结果本来是两个轮密钥异或的结果，但在上图中，由一个轮密钥和一个未知的4字节异或得到的。\n密钥扩展中最后4轮密钥是如何生成的？涉及到查S盒、字节替换、Rcon等——需要交叉引用96b08、96d5c。\n这里简单过一下，具体算法还原先不做，快秋招了，得做点其它的事情，补充一下开发能力QwQ，害，怎么感觉这么难呢，我好菜。\n以W[40]为例，W[40] &#x3D; *(_DWORD *)(a1 + 60) = *(_DWORD *)(a1 + 52) ^ *(_DWORD *)(a1 + 56);\n\n\n需要hook一下，获得a1+52、a1+44、a1+48等值。\n\n它们的值又来源于sub_97230。\n\n然后又来源于sub_97100。\n\n又可以追回到sub_96A14。\n\n大概意思是，W[43-40]与初始密钥相关，涉及S盒、字节交换、rcon。\n具体关于逆T表的工作，等到以后吧，算法还原耗时但一定能解开，hhhhh。\n总结2025&#x2F;0610&#x2F;22:23，脑子有点晕，希望能早点找到工作。\n参考jidong大佬的公众号。\n","tags":["心累"]},{"title":"某梆企业壳--过frida检测","url":"/2025/06/12/%E6%9F%90%E6%A2%86%E4%BC%81%E4%B8%9A%E5%A3%B3-%E8%BF%87frida%E6%A3%80%E6%B5%8B/","content":"某汽车app查壳github:https://github.com/moyuwa/ApkCheckPack\n使用查壳工具简单看一看。\n\nroot检测打开app直接闪退。\n使用magisk，把app加入排除列表中。\n\n\n能正常打开了，说明对root的检测比较常规。\nfrida检测使用frida进行注入，等了一会后，进程退出。\n\n试试使用老方法——hook pthread_create。\n\n\nso文件是加密的，可以从内存中dump下来，然后修复了再看。\n\n但这里先不dump，先试试在libDexHelper加载的第一时刻，直接将sub_4f884替换掉。\n\n为什么会报红呢，因为在加载libDexHelper.so的时候，函数sub_4f884尚未解密，所以frida没hook上。\n因此，需要在解密函数执行完后，再对函数sub_4f884进行hook。\n在把libDexHelper.so dump下来以后，用sofix进行修复。\n一般都是在init_array和JNI_OnLoad中进行解密。\n\n\n假设libDexHelper.so通过pthread_create创建了一个线程，这个线程要执行start_routine——sub_4f884，那么，我可以选择这样一个hook时机。\n检查函数pthread_create的第3个参数start_routine是否指向libDexHelper.so的sub_4f884，如果指向，则在onEnter回调中，替换sub_4f884。——执行前，应该已经完成了解密。\n然而，在将start_routine指向的函数替换后，进程还是会退出，说明除了sub_4f884，仍有检测frida的地方\n如果想要一个进程反复检测frida的存在，那就需要创建子线程或子进程，一般来说都是创建子线程。\n而创建线程的方法有系统调用（svc）、pthread_create（库调用）、clone（库调用）。\n之所以要写这篇博客，其实就是想讲讲clone、pthread_create、fork的区别。\nfork和pthread_create都是依靠clone创建的，根据传递不同的参数给clone，以区别创建的是进程还是线程。\n\n我hook库函数pthread_create，发现libDexHelper仅仅只创建了1个线程（sub_4f884）。\npthread_create在libc是这样子的，也就是说，clone的第4个参数v30，再加上96的偏移就是pthread_create的a3（start_routine）。\n__int64 __fastcall pthread_create(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4)&#123;    ...    *(_QWORD *)(v30 + 96) = a3;        ...    v32 = clone(__pthread_start, v18, 4001536LL, v30, v30 + 16, v22 + 8, v30 + 16);&#125;\n\n之后只要将下面的函数给hook掉，frida就能正常用了。\n\n不过我挺好奇是如何调用的clone？——got劫持，还是说其他的方法。\n","tags":["ez"]},{"title":"某旅游app分析（1）","url":"/2025/06/20/%E6%9F%90%E6%97%85%E6%B8%B8app%E5%88%86%E6%9E%90%EF%BC%881%EF%BC%89/","content":"sotp该厂不许发布针对他们app的分析博客，好多博客都被厂商要求下架了，所以这里只是简单提几句。\n一，利用查壳工具对apk做检测，并没有找到壳的特征，没加壳，dex文件都清晰可见。\n二，root检测似乎不会导致app闪退与正常使用。\n三，使用酒店搜索功能时，通过“花瓶”抓不到酒店的包，只能获得酒店的预览图，但具体价格、位置等信息都看不到，根据分析，使用了sotp协议。\n接下来的分析关于酒店搜索功能。\n接收分析了接收报文时的调用栈：\n报文的前8个字节代表payload长度。\npayload要是为6个字节，则是心跳包；反之是常规业务数据包，业务数据包的前6个字节有特殊用处，前4个字节是DataHandleType，后2个字节是Version，根据这2个值分别选择解密方式和解压缩方式（AES、Xor、Gzip、Zstandard），最好进行反序列化。\n对AES进行了分析，并没有魔改，IV和密钥都很好获得。\n发送再分析了发送报文时的调用栈：\n对RequestBody先进行序列化，再进行压缩、加密。\n有意思的是，RequestBody的结构是protobuf，费了一些心思，一开始用blackboxprotobuf逐步还原请求体，后来在apk中找到了关于TAG的定义，整理成proto文件，对body部分进行还原。\n然后发现被这个字段开盒了hhhh。\n\n下一篇博客应该是对该app的某个加密字段进行分析。\n最后，如果这个博客不允许发，可以联系我&#x2F;(ㄒoㄒ)&#x2F;~~（2050365997@qq.com）\n","tags":["sotp"]},{"title":"某旅游app分析（2）","url":"/2025/06/23/%E6%9F%90%E6%97%85%E6%B8%B8app%E5%88%86%E6%9E%90%EF%BC%882%EF%BC%89/","content":"某个字段分析在前一篇博客中提到，酒店搜索列表请求报文的请求体是protobuf结构。\n根据分析，在这个protobuf结构中，有一个编码对应的字段是head，而head也是一个protobuf结构，head里面有一个字段是clientToken，这在protobuf结构中，属于内层嵌套。\n本次的分析目标就是clientToken，同样是简略介绍（怕被投诉）。\nclientToken来源于服务器，客户端发送clientID，服务端返回clientToken。\n追踪到某个so文件里，发现clientToken与md5有关，而且md5是魔改的——具体怎么魔改的就不说了，也不难。\n\n复现了魔改的md5，得到了一模一样的值。\n\n其实最难的地方（也不难）就在于魔改md5，其它的都是一些验证方面的设置——构造特定的clientID数值，才能拿到clientToken。\n","tags":["协议字段分析"]},{"title":"ks/sig3分析","url":"/2025/07/01/ks-sig3%E5%88%86%E6%9E%90/","content":"分析字段：__NS_sig3\n初步分析查壳&#x2F;查反调等利用工具，对apk进行一个初步判断。\n似乎没有壳，那就不用脱壳了。\n\n即便不做什么处理，我root后的手机，还是可以正常打开快手。\n\n\n定位__NS_sig3的生成函数先在jadx中搜索，看看能否直接找到__NS_sig3的相关代码；如果不行，再试试hook HaspMap的put。\n直接搜到了，那就直接再jadx中追踪了。\n\n从这段代码中，可以知道__NS_sig3的长度是32字节。\n\nhook函数m160592a，获得request。\n\n下面这些请求路径不需要字段__NS_sig3。\n&quot;/rest/system/startup&quot;, &quot;/rest/n/system/abtest/config&quot;, &quot;/rest/system/keyconfig&quot;, &quot;/rest/n/system/realtime/startup&quot;, &quot;/rest/n/live/config/startup&quot;, &quot;/rest/n/feed/hotFast&quot;, &quot;/rest/n/feed/selectionFast&quot;, &quot;/rest/n/encourage/startup&quot;, &quot;/rest/zt/share/system/startup&quot;, &quot;/rest/system/startup&quot;, &quot;/rest/im/wd/user/startup/push&quot;;\n\n在分析__NS_sig3的加密流程之前，注意到，加密函数m160594c的输入是encodePath + str，encodePath不必多说，而这里的str是一个长度为32的字符串（相当于16字节，大概率是md5），接下来分析它是从哪里来的。\nsig下列图表示我的追踪“轨迹”。\n\n\n\n\n\n\n假如要使用Sig3，需要清空bodyParam。\n\n\n用IDA打开getClock对应的libcore。\n函数sub_1908出现了md5魔数。——md5_init。\n\n\n\n\n函数sub_1934是md5_update，函数sub_1A4C是md5_transform。\n\n\n函数sub_19C0是md5_final。\n\n\n所以，sig就是urlParams、bodyParams、sdk_version等数据经过md5处理的结果，这里就不去验证是不是标准md5了。\n函数m160599c下列图为追踪顺序。\n\n\n\n\n\n\n追踪函数m33365b。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n在函数doCommandNative处hook，打印调用栈。\n\nhook一下函数doCommandNative的参数，看看是什么。\nString str2 = (String) this.f46796k.mo33427a().mo33476a(    10418,     new String[]&#123;new String(abstractC16338n.mo33447e()).trim()&#125;, // strEncodePath + str    C16278b.m33236i().m33242j().mo33327a(),     -1,     Boolean.FALSE,     C16278b.m33236i().m33242j().mo33328c(),     null,     Boolean.valueOf(abstractC16338n.mo33448f()),     abstractC16338n.mo33455m()); // 空字符串\n\n\n定位生成函数位于的so（&amp;&amp; 去除花指令）跑一下脚本，看看doCommandNative在哪个so里。\n\n[RegisterNatives] java_class: com.kuaishou.android.security.internal.dispatch.JNICLibrary name: doCommandNative sig: (I[Ljava/lang/Object;)Ljava/lang/Object; fnPtr: 0xa3cd0435  fnOffset: 0xa3cd0435 libkwsgmain.so!0x46435  callee: 0xa3cd77fb libkwsgmain.so!0x4d7fb\n\n位于libkwsgmain.so，偏移0x46435。\n好像存在一些加密代码？试一下从内存中dump下来，然后修补。\n\n\ndump。\n\n修复。\n\n突然想起来，偏移0x46435，说明是thumb指令，应该从0x46434开始算起。\n上来就是BL跳转。\n\n在sub_B764中，LR &#x3D; 0x46448，而R0是未知的，需要回到0x46434查找。\n\n\nR0 &#x3D; 0x1fa。\n\nR1 &#x3D; [0x46c30]\n\n\n而0x46448 + 0x5C60 &#x3D;&#x3D; 0x4C0A8，PC &#x3D; 0x4C0A8。\n然而，0x4C0A8处也没有函数定义，这样不好分析。\n\n然而，在最新版本的快手中，不是这个样子的方式跳转的。\n重新跑了1次hook RegisterNatives的脚本。\n[RegisterNatives] java_class: com.kuaishou.android.security.internal.dispatch.JNICLibrary name: doCommandNative sig: (I[Ljava/lang/Object;)Ljava/lang/Object; fnPtr: 0x7bb8184cd4  fnOffset: 0x7bb8184cd4 libkwsgmain.so!0x40cd4  callee: 0x7bb818a164 libkwsgmain.so!0x46164\n\nBR混淆。\n\n\n\n上述的计算，可以整理成：\nX0, X1放入栈中; 下面计算X9的值STP X2, X30, [SP + 0x10]\t;[SP+0x18] = X30ADR\tX1, dword_40cfc\t\t\t;X1 = 0x40cfcX1 = X1 - 0x4X0 = X1X0 = X0 + 0x14[SP+0x18] = X0LDP X2, X9, [SP + 0x10]X0, X1 = 原来的内容BR X9\n\n只要我们知道X30的值，就可以利用keypatch将BR X9改成B xxxx。\nJNI_OnLoad也是这样的混淆。\n\n直接用一个IDA脚本，遍历so文件。——获得3个操作数，然后在BR X9处进行修改。\nimport keystonefrom keystone import *import ida_bytesimport idaapiimport idcdef pattern_search(pattern):    match_list = []    addr = 0    while True:        addr = ida_bytes.bin_search(addr, idc.BADADDR, bytes.fromhex(pattern), None,                                 idaapi.BIN_SEARCH_FORWARD, idaapi.BIN_SEARCH_NOCASE)        if addr == idc.BADADDR:            break        else:            match_list.append(addr)            addr = addr + 1    return match_listdef get_jumpout_addr(addr):    data1 = idc.get_operand_value(addr + 8, 1)    data2 = idc.get_operand_value(addr + 12, 2)    data3 = idc.get_operand_value(addr + 20, 2)    return data1 - data2 + data3    def generate_asm(code, addr):    ks = Ks(keystone.KS_ARCH_ARM64, keystone.KS_MODE_LITTLE_ENDIAN)    encode, count = ks.asm(code, addr)    return encodedef main():    match_list = pattern_search(&quot;E0 07 BE A9 E2 7B 01 A9&quot;)    print(len(match_list))    for i in range(len(match_list)):        encode_b = generate_asm(&quot;B &quot; + str(hex(get_jumpout_addr(match_list[i]))), match_list[i])        encode_nop = generate_asm(&quot;nop&quot;, 0)        ida_bytes.patch_bytes(match_list[i], bytes(encode_b))        ida_bytes.patch_bytes(match_list[i] + 4, bytes(encode_nop) * 9)if __name__ == &quot;__main__&quot;:    main()\n\n执行完后是这样的。\n\nUnidbg补环境先搭最基本的架子。\npackage com.ks;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.Module;import com.github.unidbg.arm.backend.Unicorn2Factory;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.*;import com.github.unidbg.linux.android.dvm.array.ArrayObject;import com.github.unidbg.linux.android.dvm.wrapper.DvmBoolean;import com.github.unidbg.linux.android.dvm.wrapper.DvmInteger;import com.github.unidbg.memory.Memory;import com.github.unidbg.virtualmodule.android.AndroidModule;import com.github.unidbg.virtualmodule.android.JniGraphics;import java.io.File;public class sig3 extends AbstractJni &#123;    private final AndroidEmulator emulator;    private final VM vm;    private final Module module;    private final Memory memory;    sig3()&#123;        emulator = AndroidEmulatorBuilder.for64Bit()                .setProcessName(&quot;com.smile.gifmaker&quot;)                .addBackendFactory(new Unicorn2Factory(true))  // 处理器类型                .build();        // 设置执行多少条指令切换一次线程        emulator.getBackend().registerEmuCountHook(10000);        // 开启日志        emulator.getSyscallHandler().setVerbose(true);        // 开启线程调度器        emulator.getSyscallHandler().setEnableThreadDispatcher(true);        memory = emulator.getMemory(); // 模拟器的内存操作接口        memory.setLibraryResolver(new AndroidResolver(23)); // 设置系统类库解        //创建虚拟机并指定APK文件        vm = emulator.createDalvikVM(new File(&quot;unidbg-android/src/test/resources/ks_pack/ks.apk&quot;));        // 设置是否打印Jni调用细节        vm.setVerbose(true);        // 补jni方法        vm.setJni(this);        // 加载so        DalvikModule dm = vm.loadLibrary(&quot;kwsgmain&quot;, true);        // 加载好的libkwsgmain.so对应为一个模块        module = dm.getModule();        // 手动执行JNI_OnLoad函数        dm.callJNI_OnLoad(emulator);    &#125;    public static void main(String[] args) &#123;        sig3 _sig3 = new sig3();    &#125;&#125;\n\n对照着之前的调用参数，添加调用doCommandNative的代码。\n\nvoid get_Sig3()&#123;    DvmClass JNICLibrary = vm.resolveClass(&quot;com.kuaishou.android.security.internal.dispatch.JNICLibrary&quot;);    StringObject urlObj = new StringObject(vm, &quot;xianyu&quot;);    StringObject appkey = new StringObject(vm, &quot;d7b7d042-d4f2-4012-be60-d97ff2429c17&quot;);    DvmInteger intergetobj = DvmInteger.valueOf(vm, -1);    DvmBoolean boolobj = DvmBoolean.valueOf(vm, false);    DvmObject&lt;?&gt; context = vm.resolveClass(&quot;com/yxcorp/gifshow/App&quot;).newObject(null); // context    StringObject appkey2 = new StringObject(vm, &quot;&quot;);    ArrayObject arg2 = new ArrayObject(new ArrayObject(urlObj), appkey, intergetobj, boolobj, context, null, boolobj, appkey2);    String result = JNICLibrary.callStaticJniMethodObject(emulator,&quot;doCommandNative(I[Ljava/lang/Object;)Ljava/lang/Object;&quot;,10418,arg2).getValue().toString();    System.out.println(result);&#125;\n\n报错如下，提示返回值是null。\n一般这种情况，都是调用so接口的时候，没有初始化导致的。\nException in thread &quot;main&quot; java.lang.NullPointerException: Cannot invoke &quot;com.github.unidbg.linux.android.dvm.DvmObject.getValue()&quot; because the return value of &quot;com.github.unidbg.linux.android.dvm.DvmClass.callStaticJniMethodObject(com.github.unidbg.Emulator, String, Object[])&quot; is null\tat com.ks.sig3.get_Sig3(sig3.java:63)\tat com.ks.sig3.main(sig3.java:69)\n\nlibkwsgmain.so里面，一共注册了5个函数，把它们hook起来，不过似乎并没有什么关联。\n[RegisterNatives] java_class: com.kuaishou.android.security.internal.dispatch.JNICLibrary name: doCommandNative sig: (I[Ljava/lang/Object;)Ljava/lang/Object; fnPtr: 0x7bb8184cd4  fnOffset: 0x7bb8184cd4 libkwsgmain.so!0x40cd4  callee: 0x7bb818a164 libkwsgmain.so!0x46164[RegisterNatives] java_class: com.kuaishou.android.security.internal.dispatch.JNICLibrary name: gDBF sig: ()J fnPtr: 0x7bb81848a4  fnOffset: 0x7bb81848a4 libkwsgmain.so!0x408a4  callee: 0x7bb818a164 libkwsgmain.so!0x46164[RegisterNatives] java_class: com.kuaishou.android.security.internal.dispatch.JNICLibrary name: dCaBk sig: (ILjava/lang/String;[BI)V fnPtr: 0x7bb8184948  fnOffset: 0x7bb8184948 libkwsgmain.so!0x40948  callee: 0x7bb818a164 libkwsgmain.so!0x46164[RegisterNatives] java_class: com.kuaishou.android.security.internal.dispatch.JNICLibrary name: gDGI sig: ()[Ljava/lang/String; fnPtr: 0x7bb81843bc  fnOffset: 0x7bb81843bc libkwsgmain.so!0x403bc  callee: 0x7bb818a164 libkwsgmain.so!0x46164[RegisterNatives] java_class: com.kuaishou.android.security.internal.dispatch.JNICLibrary name: gKSF sig: ()J fnPtr: 0x7bb81847f0  fnOffset: 0x7bb81847f0 libkwsgmain.so!0x407f0  callee: 0x7bb818a164 libkwsgmain.so!0x46164\n\n同时，注意到Command ID也是有不同的，打印一下args[2]。\n\n可以发现，在第一时间内只会调用1次command ID &#x3D; 0x28ac，这大概率是初始化的一部分。\n\n\n所以，加一个执行10412的函数。\nvoid moduleInit()&#123;    DvmClass JNICLibrary = vm.resolveClass(&quot;com.kuaishou.android.security.internal.dispatch.JNICLibrary&quot;);    StringObject appkey = new StringObject(vm, &quot;d7b7d042-d4f2-4012-be60-d97ff2429c17&quot;);    DvmObject&lt;?&gt; context = vm.resolveClass(&quot;com/yxcorp/gifshow/App&quot;).newObject(null); // context    ArrayObject arg2 = new ArrayObject(null, appkey, null, null, context, null, null);    JNICLibrary.callStaticJniMethodObject(emulator,&quot;doCommandNative(I[Ljava/lang/Object;)Ljava/lang/Object;&quot;,10412,arg2);&#125;\n\n之后遇到缺少类的错误。\npublic void callStaticVoidMethodV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) &#123;    switch (signature) &#123;        case &quot;com/kuaishou/android/security/internal/common/ExceptionProxy-&gt;nativeReport(ILjava/lang/String;)V&quot;:            return;    &#125;&#125;@Overridepublic DvmObject&lt;?&gt; callStaticObjectMethodV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) &#123;    switch (signature) &#123;        case &quot;com/kuaishou/android/security/internal/common/ExceptionProxy-&gt;getProcessName(Landroid/content/Context;)Ljava/lang/String;&quot;:            return new StringObject(vm, &quot;com.smile.gifmaker&quot;);    &#125;    return super.callStaticObjectMethodV(vm, dvmClass, signature, vaList);&#125;@Overridepublic DvmObject&lt;?&gt; callObjectMethodV(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VaList vaList) &#123;    switch (signature) &#123;        case &quot;com/yxcorp/gifshow/App-&gt;getPackageCodePath()Ljava/lang/String;&quot;: &#123;            return new StringObject(vm, &quot;/data/app/com.smile.gifmaker-VZhzinzcefoqqzJZ47EE0A==/base.apk&quot;);        &#125;        case &quot;com/yxcorp/gifshow/App-&gt;getPackageName()Ljava/lang/String;&quot;: &#123;            return new StringObject(vm, &quot;com.smile.gifmaker&quot;);        &#125;        case &quot;com/yxcorp/gifshow/App-&gt;getAssets()Landroid/content/res/AssetManager;&quot;: &#123;            return new AssetManager(vm, signature);        &#125;        case &quot;com/yxcorp/gifshow/App-&gt;getPackageManager()Landroid/content/pm/PackageManager;&quot;: &#123;            return vm.resolveClass(&quot;android.content.pm.PackageManager&quot;).newObject(signature);        &#125;    &#125;    return super.callObjectMethodV(vm, dvmObject, signature, vaList);&#125;\n\n仍然报错空指针，对比了一些和其它人博客的区别。\n补了一句↓，这样就可以正常跑出结果了。\nnew AndroidModule(emulator, vm).register(memory);\n\n\n每跑一次，都会有一个新结果，为了固定结果，需要将时间戳、随机数导致的，修改下面这个文件的currentTimeMillis()。\nsrc/main/java/com/github/unidbg/unix/UnixSyscallHandler.java\n\n固定一下，时间固定成1751095318144。\n\n结果固定为c4d5a086d88864b88c8c8f8ef7c6668e830cc8fe919d9385。\n\ntrace指令流。\nvoid traceCode()&#123;    String traceFile = &quot;unidbg-android/src/test/java/com/ks/traceCode.log&quot;; // 输出的路径    PrintStream traceStream = null; // 打印流    try &#123;        traceStream = new PrintStream(new FileOutputStream(traceFile), true);    &#125; catch (FileNotFoundException e) &#123;        throw new RuntimeException(e);    &#125;    // traceCode 对代码进行监控    emulator.traceCode(module.base, module.base + module.size).setRedirect(traceStream);&#125;\n\n分析在文件traceCode.log中，追踪结果“c4d5a086d88864b88c8c8f8ef7c6668e830cc8fe919d9385”。——这里的字符串是之前分析小红书的时候，修改Unidbg得到的。\n第一次出现的地址在：0x13b9c，位于函数sub_13b54内。\n\n函数sub_13B54将result中的结果提取到a2中，a2是一个string类型（从sso优化看出来的）。\n\n\n观察trace日志，结果位于[x0+0x28]的位置，而x0是调用sub_13b54传入的入参。\n\n在函数sub_3CC28内调用了sub_13B54，对这个函数进行分析，发现a1是v9的来源，因此hook函数sub_3cc28。\n\n\n\n查看sub_3cc28的引用。\n\n\n根据日志，发现是从0x44c8c跳转过来的。\n\n0x44c8c不在定义的函数内，于是我在日志中，划分了一个函数。\n\n\n这个函数的栈不平衡，但勉强可以用来分析，总比纯看汇编方便。\n\n观察v98，注意到，循环次数是23次，但最后的结果是24字节。\n\n对着地址0x44c04下断点。\n\n下图是第一次执行到0x44c04的结果，会发现，最后一个字节已经赋了正确的值。\n\n\n最后一个字节是单独赋值的，可以关注一下这里的v101。\t\nv101的高8位是：v48的低8位 | v49的高8位，v48源于前23个字节累加然后取负。\n\n\n而v49来自一个略微复杂的计算。\nv49 = ((unsigned __int64)qword_70910 &gt;&gt; 53) &amp; 0x10 | ((unsigned __int64)qword_70910 &gt;&gt; 54) &amp; 0x20 | ((unsigned __int64)qword_70910 &gt;&gt; 44) &amp; 0x40 | v46 | 0xD00;\n\n对红色框里的v98进行hook，查看24个字节在异或之前是什么样的。\n\n41 51 27 00 59 08 e7 3a 01 00 00 00 7e 4e ed 04 16 98 5f 68 00 0d 00 85\n\n\n改变输入有3个可以改变的输入，url、appkey、时间戳，观察改变输入后，内容有什么不同。\nurlObj输入：”xianyu” -&gt; “x14nuy”。\nv49的值未变，0xd00 -&gt; 0xd00。\nv98的12-15字节发生了变化，最后1个字节之所以变了，是因为前23字节存在变化。\n41 51 27 00 59 08 e7 3a 01 00 00 00 |7e 4e ed 04| 16 98 5f 68 00 0d 00 85↓↓↓41 51 27 00 59 08 e7 3a 01 00 00 00 |7f 7c 00 53| 16 98 5f 68 00 0d 00 f4\n\nappkey输入：”d7b7d042-d4f2-4012-be60-d97ff2429c17” -&gt; “d7b7d042-d4f2-4012-60be-d97ff2429c17”。\n不能改，改了就报错。\n时间戳输入：”1751095318144L” -&gt; “1751095318145L”。\nv49的值未变，0xd00 -&gt; 0xd00。\nv98的值未变，可能是时间戳改动太小了？\n41 51 27 00 59 08 e7 3a 01 00 00 00 7e 4e ed 04 16 98 5f 68 00 0d 00 85↓↓↓41 51 27 00 59 08 e7 3a 01 00 00 00 7e 4e ed 04 16 98 5f 68 00 0d 00 85\n\n输入：”1751095318144L” -&gt; “1751105319144L”。\nv49的值未变，0xd00 -&gt; 0xd00。\nv98的4-7和16-17字节发生了变化，最后1个字节之所以变了，是因为前23字节存在变化。\n41 51 27 00 |59 08 e7 3a| 01 00 00 00 7e 4e ed 04 |16 98| 5f 68 00 0d 00 85↓↓↓41 51 27 00 |b6 ca a0 0e| 01 00 00 00 7e 4e ed 04 |27 bf| 5f 68 00 0d 00 a1\n\n如果输入改成”1111111111111L”。\nv49的值未变，0xd00 -&gt; 0xd00。\nv98的4-7和16-19字节发生了变化，最后1个字节之所以变了，是因为前23字节存在变化。\n41 51 27 00 |59 08 e7 3a| 01 00 00 00 7e 4e ed 04 |16 98 5f 68| 00 0d 00 8541 51 27 00 |7c 75 c0 79| 01 00 00 00 7e 4e ed 04 |c7 35 3a 42| 00 0d 00 da\n\nurlObj和时间戳输入：”xianyu” -&gt; “x14nuy”。\n输入：”1751095318144L” -&gt; “1111111111111L”。\nv49的值未变，0xd00 -&gt; 0xd00。\nv98的4-7、12-15、16-19字节发生了变化\n41 51 27 00 |59 08 e7 3a| 01 00 00 00 |7e 4e ed 04| |16 98 5f 68| 00 0d 00 85↓↓↓41 51 27 00 |7c 75 c0 79| 01 00 00 00 |7f 7c 00 53| |c7 35 3a 42| 00 0d 00 49\n\n16-19字节注意到，参与计算的时间戳是以s为单位。\n\n1751095318144L是微秒，换算成秒的话，值为1751095318L，即0x68 5f 98 16，对应于v98的第16-19字节。\n\n\n20-23字节前面分析了，v49的值恒定为0xd00，不管输入的urlObjc和时间戳如何变化，都为这个值。\nv49 = ((unsigned __int64)qword_70910 &gt;&gt; 53) &amp; 0x10 | ((unsigned __int64)qword_70910 &gt;&gt; 54) &amp; 0x20 | ((unsigned __int64)qword_70910 &gt;&gt; 44) &amp; 0x40 | v46 | 0xD00;\n\n((unsigned __int64)qword_70910 &gt;&gt; 53) &amp; 0x10实际取了qword_70910第57位，作为v49的第4位（从0开始）。\n((unsigned __int64)qword_70910 &gt;&gt; 54) &amp; 0x20实际取了qword_70910第59位，作为v49的第5位。\n((unsigned __int64)qword_70910 &gt;&gt; 44) &amp; 0x40实际取了qword_70910第50位，作为v49的第6位。\nhook了一下，查看qword_70910和v46的值。\nqword_70910 &#x3D; x8 &#x3D; 0xc001000000000000，所以20-22字节固定为0x000D00。\n而最后8位（第23字节）为前面数的总和（超过255取负）。\n\n我怀疑这里的dword_70910是混淆，干扰计算用的。\n\n\n12-15字节修改urlObj，可以使得12-15字节发生变化。\n\n在函数sub_120D8处进行hook，\n\nx0应该是我们传入的数据，但不知道被做了什么处理。\n\n\nx2指向的内容也不是明文。\n\n\nCRC32经过搜索，x2指向的内容是crc32的魔数，B71DC104是标准crc32算法的查找表中预计算好的一个魔数，说明函数sub_120d8跟crc32算法相关。——并且是标准的crc32算法。\n\nAES那么，x0的48字节是什么呢？往地址0x124ff000下写断点。\n\n再hook，打印源地址。\n\n再下写断点。\n\n\n\n\n存在花指令，导致地址0x1E7FC不在定义的函数内。\n\n\nIDA识别后，把0x1E7FC也算入函数sub_1E32C的范围内了。\n追踪src。\n\n\nhook函数sub_1E07C。\n\n等函数sub_1E07C执行完，再打印x3、x4的内容。\nsub_1E07C执行完后，出现了目标48字节。\n大概率是传入的第0、1个参数，它们与这48字节的生成相关。\n\n\n看看第0、1个参数，x1的内容有点像加密后的字符串。\n\n\n进入函数sub_1E07C，关注函数sub_26024。\n\n\n根据hook的结果，sub_26024只执行了1次。\n\n\n\na4指向v18\n\n\nv17指向一块堆内存，v18通过赋值，也指向这块内存。\n\n\n其中，v24是从0开始取，每次自增1，换算过来，v25每次移动16字节。\n\n根据分析，锁定了sub_25980。（sub_251F4没执行，它代表着AES解密，相反，sub_25980代表着加密；函数sub_2640C用来设置执行加密还是解密）\n\n\n下面是hook函数sub_25980所得到的参数。\nx1指向待加密的数据，这里的数据大小是0x30，本来是0x20，多了0x10的填充。\nx2指向加密结束的堆内存，起始地址是0x124d3330。\n\n执行完3次sub_25980后，v25指向的区域是这样的，这是我们目标的48个字节。\n\n用了什么加密呢？大概率是白盒AES，因为通过插件FindCrypt，找到了AES。\n\n回到函数sub_26024，将输入改成2个一样的内容。——判断CBC还是EBC。\ndebugger.addBreakPoint(module.base + 0x1E224, new BreakPointCallback() &#123;    @Override    public boolean onHit(Emulator&lt;?&gt; emulator, long address) &#123;        // 2个16字节        String hexString = &quot;xianyuxianyuismexianyuxianyuisme&quot;; // 十六进制字符串        byte[] bytes = hexString.getBytes();        MemoryBlock newInput = emulator.getMemory().malloc(hexString.length(), true);        newInput.getPointer().write(bytes);        // 将x1指向我们的待加密字符串        emulator.getBackend().reg_write(Arm64Const.UC_ARM64_REG_X1, newInput.getPointer().peer);        return false;    &#125;&#125;);\n\n函数执行前，x1已经指向xianyuxianyuisme的内容。\n\n执行后，发现结果一模一样，说明采用EBC模式。（无IV）\n\n\n之前hook函数sub_25980时，填充值是0x10，符合PKCS#7的填充方式。\n在下面else的代码块内，下了1个断点，发现每当执行1次函数sub_25980，这个代码块会执行36次。\n\n为什么是36次呢？标准的AES-128有10轮运算，前9轮完全一样，每1轮需要对每列进行列变换，而共有4列，因此前9轮共有36轮列变化，刚好对应else内的代码块执行了36次。\n为了更方便分析函数sub_259B8，用d810去除一下控制流平坦化。\n过于清晰了。\n\n为了得到密钥，需要使用DFA攻击，在第8轮列混淆之后，第9轮列混淆之前，改变1个字节。\n状态矩阵在a1。\n\n而sub_24f78是行位移操作，第9次行位移执行时，正是差分攻击的好时机。\n编写脚本，进行差分攻击。\n\n\n获得第10轮密钥。\n\n得到初始密钥。\n\n试验一下，操作没问题，和之前的hook的结果一样。\n\nHMAC-SHA256进入AES加密之前，“xianyu”作为输入，会生成下面这32字节。\n现在追踪这32字节哪里来的。\n\n\n早在函数sub_26024的时候，x1就指向了这32字节。\n\n往回溯源，又可以找到，a2源于函数\n\nhook函数sub_1DEC0，会发现encrypt_data还不是目标32字节。\n\n\n而a4里面，存放着的是明文xianyu。\n点入函数sub_1DEC0进行分析，在函数217D8找到了SHA256的字眼。\n\n交给大模型进行分析，分析这个是一个HMAC-SHA256函数，a5、a6是opad、ipad也确认了这一点，下图异或的密钥反了，但结果一致也说明是opad&#x2F;ipad。\n\n\n用到了HMAC-SHA256，密钥如下，但不知道有没有魔改。\n\n经过判断是标准的HMAC-SHA256。\n\n总结做个小总结，输入“xianyu”经过HMAC-SHA256，变成32字节，又经过AES变成48字节（填充也有16字节），最后经过CRC32变成4字节。\n4-7字节第4-7字节和时间戳有关，而赋值的地方在这里。\n\n交叉引用，大概率是在JNI_OnLoad里执行写的。\n\n在JNI_OnLoad可以看到，随机种子是time(0)，被固定了，所以随机数也被固定了，至此分析结束。\n\n","tags":["慢脚"]},{"title":"某站分析","url":"/2025/07/06/%E6%9F%90%E7%AB%99%E5%88%86%E6%9E%90/","content":"查壳\n在jadx中，基本什么都看得到，应该没有加整体壳。\n\n\n抓包（&#x2F;x&#x2F;resource&#x2F;fingerprint）url抓的包，访问链接如下。——指纹接口。\nhttps://app.bilibili.com/x/resource/fingerprint?appkey=1d8b6e7d45233436&amp;build=8480300&amp;c_locale=zh_CN&amp;channel=vivo&amp;disable_rcmd=0&amp;mobi_app=android&amp;platform=android&amp;s_locale=zh_CN&amp;statistics=%7B%22appId%22%3A1%2C%22platform%22%3A3%2C%22version%22%3A%228.48.0%22%2C%22abtest%22%3A%22%22%7D&amp;ts=1751439861&amp;sign=9168aa232e8a21024f1276dabbd6682a\n\n参数参数如下。\nappkey一般是一个app固定的东西；\nbuild是版本号；\nstatistics记录了一些基本信息。\nsign是一个签名。\n\n\n对一些参数进行删减，发现只要留下platform和sign便能获得正确的响应。\n\n请求头请求头如下。\nfp_local是本地指纹；\nbuvid似乎也是指纹。\n两者有什么区别呢：\n一个形象的比喻，假设进入一个高级俱乐部需要验证身份：    buvid 就像是你的会员卡。这张卡一旦办好，上面的会员号是固定不变的。你每次来，出示这张卡，俱乐部就知道你是谁，你过往的消费记录是怎样的。    fp_local 就像是门口的人脸识别+安检。你每次进门时，系统会实时扫描你的脸、你的穿着打扮、你有没有带危险品（即你当前的设备环境）。这个扫描结果就是你的fp_local。\n\n\n\n请求头全撤了，也能得到正确响应。（这样可能会触发风控，毕竟请求头太奇怪了）\n\n请求体请求体包含2个部分，key和content，稍微动1个字节都会引发错误。\n&#123;  &quot;key&quot;: &quot;B5592D6C3EC9EDB4A217370C2502098C71296E7A91A922F90F01F1AD1C4FFD9D7A140879D503DB12E153E4AB41051B413E95C7C5F6AC4681EA65FF7EA8055F0B336EA750E31980F70DAD33448607D3A8CAFA3D149D106758296B8EA448498C967452D58EF5E01694CBE128686C6ECCC98593895E01981CC33AE043288BDFE520&quot;,  &quot;content&quot;: &quot;7F85A3076EFCDB1CE8B2951DD3976F7994BFF8A62D51EC62D8F6F5773E3AE4DAB9DCE2F6BE8BC149C6C7F26B635430E23B7E005AC9A241A530BD0D2A73A9BDA6CF126CCBB2CB1EEE3805A2E96D617E9B48D3569E697DD28B377A4459B24FE7CA7BDEB77B433C91C968937ABB2F6E561AEB0AD07335CF7F40B4A8C3B48B65B59DBFB57358DA9D0541064C852A6FC8F455062276BAA8496DA656A9DF365D444EBB3DC3711AC44D248F05DE6DAE34101AF8FA3E179E87F86F3AA001DD28CBF21F852B39E8D7C98B7ECBBC85AFB3C52C8C7ED9E01279F7D650E39BBBD821DC556C40F83669785AA90C024B73EADFD8F28D2B9C1C2608B22B3684AD9116E4BC4163DB60C058F23BF3F1E7D56A481C6F4BB9373EE771D61608295ADB1B3F205C0DD2E8EC24A693C2B9C555C35E537F5B19D6C9F5B71CC111858E2D321ACDFB269003EA45D191FB9C56D359386F79B245C1697F145976F05E43195968A54423C041CFC7990FF7E8B632138F699F473DADA2CB8280225A96D311574B89337BFCE30DFF16A42D19324D9244E1714DDB6B36A7F46B21168F41E9CD3FBF380EEC915A7C12EECEC3973F38343192862009A85B182AD1233AEBC1434EA2C4770A636F6DF093003B96F0A017E04DB157D5228DE72246BC5FC90D222B217794F94D5EC8CF5BDAF4C95B34F89AEABD8A7979403BBC48329B6FB23D72A54DF3882D758D7AB68E25DA76FE94A140458BAF4CC3530854BCC5A231D5D941CA579EE94E83A89F1792A4595EC405E291A55A060EE0DEE5014CC9A1CC1CF7AB9987FE3E52F88FBD1A043679D0A7DEC997789F2136253BA806C744DDB9E9A0422AAF564D8E7F58F28D086D74CE430E6FAF084982BC12339A7CE6EBE94A96555FC7CCDEBC69E3E7F481BC224617384D0F4F5D2470A2BCB5944B22DEB878EAA2C2844F8ABE7F12592664BB37ECA47509B84D77716B0BAC584B7FBB150E6820BF4D423FB618A74B2CC7719D728B9D8D39D029C5B45396736F10618CB21CAA14355FB0B42D464774AEE05F7AEEDBFFE910DEC069FA9E32617CCEDBEDA4708D9FA1D9BC96753F8017969A5EBEB1D8B933D3C50D8574DD2A84DA2AE71D48761A1AF265770A8EE49F551A10C41BD0552048438834EE2EEBCA62458DB2C2836DEFFD1ECA41B344A0C03166FCA7E4CE8BB52967B686B9DF6CD8AB879945547A7C2FE627B3302AE5CE1AA65C68668D6784124BA0713F55D4BEC45E5E5DFD5B691DC8D36ABD821C5E2E24A3EB06B0D8F14E124BA0713F55D4BEC45E5E5DFD5B691DAC207D15F7A1AF2B8A0E5A4580582A33F32CBC20343B9E708171A98B4159E62BBA6A7C8038EB3AA26812372744A1C4C2F5F5EACAC455F30E53BCF52EAA140EADFB4E5CCB01971968A245974EA19BC7F0669AB681037B4BB8F903260124AC0FB504E9C87229D636431329E8F205CFCA0D7A80E08DA78061F0EB9D1AF16DB730C1AE0E80DDB2DFB3156B18D334618CCDDE233AEBC1434EA2C4770A636F6DF09300E2F550F90EEADBE814F221EBE00164664F0A34D5FF8B32C09E5A24D40D6D45B3612B17C41FBA51ABB86251E3B1CB357A299E8879C6D8BCAD98733D71A38C2B8EEFFD1ECA41B344A0C03166FCA7E4CE8BD9DAC74C881D6B1CFC5BA3746DDB48C4F1ED8C56135C4984CBE8209E1F60449C708C783AB8959B30CBF3F77BE5AAE7FB097BF936EC59600DF4FC8DCF6FC9DB82309AB89A1644437A65F55E12FEA82784AE0E80DDB2DFB3156B18D334618CCDDE967DAC2FD4C167D08163840E5071E353350E14A04FC182249A7A3C8060EBDFB0645F65777CD5A68D3281CB8488B99F22CF6985310DE6D2BBDAF8362F58130FE561693D7C8015E047220EC786D06B26238B6EB3084D301EF70BE8082D0D3FBE15EB30475F9A7B6876B8447B9A911D7749F5F5EACAC455F30E53BCF52EAA140EAD99E5E18A77E0D7BB1E62CC846D9CC80D8B6EB3084D301EF70BE8082D0D3FBE15EB30475F9A7B6876B8447B9A911D7749F5F5EACAC455F30E53BCF52EAA140EAD99E5E18A77E0D7BB1E62CC846D9CC80DABC395E3E9307A63EBA8450C10F4AAAD967328FA7CA7638A2C066A0336736A3D13A5240B265E5581E245783309027F6372F0C59E74017138EE33D195BCAD06FAE32B80709A8CE080116413E53F5A326A5AE85FAF47F6FA5FE444EAF448D3C1B04F35288C7D045CD2D8C79F021E365359651EF28CA3616A16F9FFD4D56C3EA514218CE945CD85C054B8AD8C3ECE3C4CB4C183C48A12686422A696335A261FB96F8CCE36CFCE08EA98F0F32ECEEFB22FF23B6CA3D801D9DDEFE2DF37463FB28488EE0061406C2FC4346E5DEB30040D1712C76B625C4A680653FACD92931ED78474459AF115761AD515AB0499B8F50C06D44CE11766B8779712E014BD49ADD1D5306C3BD2CB4671C9CE2B1AB77F13F80163A3ADD2E4B89D09C03B6AFF1F428B5AEDB410689D8777D91B22A5B46C4C9005D112A1CFF7A854B4964364C5BCD5485D0D2A9C65DFB61D444D52E79B71BC74DA4416ECEAEAFEEB6F5328FD4757CD5C0C42F6D5BBE3EE085F8ED98281DC8BEB62E9DEE934628A9142DB00121DCACAB5A0365B84200CD99B9E8ED6FE2FC27702C73831A2E70EE2301EB5305FE37D30AA20757F77C9878833E7A412AA0FFDD4C5A2651926698143B617115960874EDEC9634C625EC3C20E342278C8B37F348AD6B1FD610F2835414B2C3113048D20A3D02146B9BF3B60128731ABCA77639B0DA6337314C3F3ACC92F338429B0AEE68ACC0E13B4B78572B43C0B92A24DE330684131ABDF26CEF3BC27CD978E29570E1E0690DA8F6648384F435659F89E4F0FA04A38A78C9E532B0C5307F2306A46497F37BBCA703923C03B8ECD34B958BF0804181B0776B284248B199FAD99CF1BD3773FC9DA6FDA6B0B3FEDAE5ECB0C95A66E0D79020A198887E43EF87328073071BE14575470E41E8CBA4D151F3F9B0E454431A9684EA68D7DC4A1942ED3D09A8C0006FD04B4C2A0F899B3C09B054D6A3405145A74958B3FF19FE13E48C4F679E09D490FCA261BAFDBD972BCA0056FD9B41C8F4D141678018968B450DEA5C6694FE97C93EACFFD79AFD23FB1D690ECD5A62D55645D636B6A87E3C8339390B8B52E36CF07179848B079E6CB4E39AA7E7B98F172020068B6DCD9E83E8ACE3B07099394EEB82BCC7899413C8A7B549A539D58906DA39F2E837088AFA0DD81D838216DD32178F13B901968946AE5C6190D509FF9A353AC5AD8E5AD03B7F44A705B925B43EF5866217CE62D5550C1D6107F525A965901FF90615E64155E218DFF821A2D8B51DDF2F402B5C63A8E67D125945165D9FEC3235DFCDE63C1B40D8816B7F3E517F0430EEB9C28F75EAAE9A06DB745ECC8868931B6A989620AEBACBD5B98DA2453895961F01116D824F062C0AD3AC7EDC14DA06579B8FDF57A93D49349CE9481532B5CABD8690FEDAC8BFBBCA039A1F602C49DB8D0AF0BBAFC185EEE22F78EE10C73257C050A6EDF181DDEEBAA0C37552CAAC0F8672ABF5DFE7767C70C5A44EF6D5827F820EF44B5D693D086629675A2047B6B422DE2CA91F7C16F48FCDC542DBDC64B47442519DABE3841B6136BFEEB6B32D1207FDF8752833CFDF1D407A1C16E777D6A3AD4A49F54F87408A5E69A83DBB852DB9F19A665512CA75BCA1EF9050D18BF152882409AEC92D05BFD5F35FEE6C9BF62056EC7AD830A00CC10BF8270621BC04CCE5D2018569A86E00A99C4D60020A8F3E56756F83168C01918C1AF35941DC2EAC18BE904F19650D8231CE8B30C9E2BB2BDB77A57BA980F3601D4D50C1D52997D65B99622AC53E5D5DD7258F72B1EA2DEEE40E1B3CAAD1EF087C7024E30E6266200600A39CDC7B065CDDB6D206797D5F2AA5F263A3D8B1ED0A077283607CFEF32412EFB7B6E6C59AFB4FA0BEF1D257FA2EB57AB611B4ACFCCB6DED51F207B3E328A7DDE85FED7C98058F0E5E6D8E493FB3DD2C59DB9F1F5E8621702B843DF8E52F5A00894FAA0363BFC77AB70D6B57995F39684DE8F61EA2BB96A642F4B545B17984C653106FEBC7610E0B7F451ADC97CF36A9A668D617521AF056A5C5EEF07B603054FC4D1412F54129CBE4BBCD7A8142114D8A27F35DCFDC8095A56AC245691A8B783D594EC52015261A2E95724988B5A3A3647059A289B614511CD0DB44080E39D1C0EACDD65BCCC2B68C6B8938FCDE02E2A725263F4C321938AE9BFB886D9291C06790124113BAB08659A4BC2268875396FE8F63661CB977A05652A31C91CA27D2C4072424907DAB05DB6A6E9F3518F78A8172B6C9D1611C3463A38786FCFCC2363AA37CF8D34F93A944C40D463CD4A6C6F2698E41AAF48F362D4591F9B4BBE667B8EA4A1A211DF167585E7ACE6E8B2CB35D1C43B236C70C92A8DB47DDC869603C60ADFD523B5BB08F0B765F9B91DA7D05097E7109F540C05DEC099864D773DF8E5D7D3A187826747581587B3D22D6210F47FC719F94E1E98824A210B0E7AB543EBFC745C102B36B9EA78D64CF2B379C6A63A8E0B302CEF681192AB859DD8911D25AAAA248896ED60D58E041E799D4F0E9DBD97D1D3A6B63D40F009EA23523AA7C708AB2087F5C48EB54DFECB021B11D6B8BE54F43B47ECDC4B9D4383EC9AFA1A32B3731DEDFF782092F5964D8D0437ADB689383099E66F2A0AC8BA89E5A5CBF1FCA8538680197F192760786EAF620B7F985F4729FB5AEAF2BAF379F5312EAC0D871F92FB804D1E4E1F14DB95D30A93D31A59586B74359A8A6A29065D13BB52F79C76E455478813A64B90DD8B934690F216C4507D52B831B446ACA320A868F7BA56AC36A4BA7B214139F87833CC05402D9935318D0365C7385B8DB1BD6CA8903FC5FE4F5308282325AD9687DBCBFF90F216C4507D52B831B446ACA320A868F7BA56AC36A4BA7B214139F87833CC058697B471918C0617C7D803FDFA858C591E248919900FA678E012FC5506487500803904EA509B6FD8C2929B0D7877714B5FB09985B271C74B23190BD05C3A456FAAA0AA148DD944A260602CA2AACA921CE5D96574541C128C2020FAC184F77BCD7FFE6BCD1D64CC81231BFCDBD7CE287B4082823E00E2444CC849241D5C39B7D3255947FC810018EE959BF8394E3FCCFB65130A34669E46EAD066732074E79747D431D002AF22CBF26A841E1C7FAB86177D21C5EE6A1AFA900D5456093D4B3FF52F763A23EA1989D19972264B3F4A062C1D7677D67F39D6B88AAE8EE0CD4287C0F38B3C8E3D1775833F9B7626FA29635F2A841A307BBE3B0F41DB1337C0DBAD90264D07B0895F15E0D6E7DBEE9DE1C4158EB801501463144F5ADA11F92E11D49F1116FA7B7B8CB23A627F386F190D188E79BEA5D1198624C95D1D57E3FA7D161B93B005CD7DAD5DF83F3511B661037E0D64047B878719F91D79ABA3AF7F648852D431D002AF22CBF26A841E1C7FAB8617C025D907EE2B4EB63ACA4A09ABFF63AAE56434A3F4B817C8A777516C0E36DAC28F27C6849012F2C9076CEB858703B65B5BC400A5A8A69ACFD306E6F03EECE46A9B1758FADB344B3D04BA2CAF3154B7817D559BB2F4804197B6D4E1D07822BEDE60A17CBFE9472AABE53C26EB59255E20BF13763A8506CABCEBB1935BAADF8D85A54668E34F90CDF76CF9CC847FE13BD2049A1160D1C4233BC169FF56CCEAEA98FB062EEB196D72C00789C1C285C2CF276A462822E7C6687A008C146EC5AAA5038691173224E333FE75EB0048E7845E10200FA230DB98527DAA52653A6268505FA47213686A10BEF7161E9E87E2081BDBD6E90FFB5A08EFFAFF503C920D1BBFB2AFF95ED457151A079FF72FFFC5B31726DACD78F6977E058A22994BCA11A0B3AD670585D20C78C2073A330ED0CB887169DCC5D8D86217F7942281B090229E95B552F79C76E455478813A64B90DD8B934690F216C4507D52B831B446ACA320A868F7BA56AC36A4BA7B214139F87833CC0512B2F35E34DE7B5206536BBE032D1E9EF66ED808D2D49E56A1AA95516E1891D854DBD0AC494B97BA69A58764F7F23C61BEBC9B79C6CCAF16394826FE821E51FF6CC43B9CE055C233C1C99D2C1CA1087D5093182C53F3D02845FCE5EC25C181C10C4824278D939141214CF5FA7ECDA61564798BD8BFD35FD13E2B32A19BB2F956AFF95ED457151A079FF72FFFC5B31726DACD78F6977E058A22994BCA11A0B3AD670585D20C78C2073A330ED0CB8871692E78FA6D57EABFB67D8E1E686105F86B2F763A23EA1989D19972264B3F4A062C1D7677D67F39D6B88AAE8EE0CD4287C0F7576A8B19E3BF43D3A2971BF442011509B3BD74082A0FCF146D6A78EA24C8AC9BBF2DFD10FD15A52C99A6156E07477358D88A8B98601F48DA57C00D965683974820AE18C30361DABD484814725D375AB3F94B005A2C5D1B8A366D5B0BC72534BA59C741098827EC5EB9E97A2BA7D1907451D0DD902ECBACE0B517378CA336A422DFB7584EAD89DE11AB8BFA8892D4B0592DCBC99532291CCE62C371CF04097AED4A731185D1DA84B09DC80A36063D1FB2F75C3E35BFDF632E0F744FC375DE5654B994472D4672609FFC89F42C8BD54802B6C3EF67BA8151E7D1FDAA652713E47DAC46EB2E104C6DBE00B610124ABED49312F05F9DEFB3CF615B041EEBC9B17A8592A2BB61CEE4D414379A5002817539946EF55B0A3FBE6AE3335F59885F854D1116FA7B7B8CB23A627F386F190D188E79BEA5D1198624C95D1D57E3FA7D161B93B005CD7DAD5DF83F3511B661037E0DB578A5B853194C93102747A93880CDB7330EDFAB19CB0F4D236C719F16B3A1E4C88E0A5D9079F543BBBA77F1C6F46121A47F9C6C3A9FB8D2841551694B63B959E5E7A6F9B89952712A70BF4D076AD5A35F110FC835C3C50A651AB561D1A4A54C048D963DEEADFEA593E31105A3BB946B68C3FC15C250D8AF21CF2A84A21838C6193C67A66273137919E7EB826D2DA9B0F30525856B9B541B8A59086F6F010B0CEA9565E9E3D343A0C1D60FA90D86D90A8BAB40D3DFDEDED112AF81B12646346242C0B2BDFA0FC9BF7F80E00469C7F05D9796FBBBEE3EFD9A6A3B7F41949415F58F7AE7408FE60D6C1EA948F29676A338764FDC0784D7C4BD44E750327DC42B3732854E85030BE75BC38517038A6D7D5E37850C04060E9F762BA59458B529D0B5BE6E19E3B28925ABDDF0B44CE193643233F204B702C98BD59E95D5CC7958E212A3CBE0388F4CE165E85A4E7817446CCE64B3D43347E44253B3E8ECC56F5C540FC275E018BBD4F18C0C8B35D66E03E897CA1962A1BFBCC8E56B9E4E080F0BE1A02B02AB2EBE47C79D412953E521546FDBC0DA8794806032FB02D08BF362A0031E5E893F4E76E0F31B0B722C488AC6AA4704E76670F962A076569018B432957613F1918D983CBD8A9442FD18ADDBC875C63EF572F8B71CEDAA3EB89AA867D9404D2CDB3404FF7D7B5ED1687BE040A545B26075E1AD333A83817D6B637AC29089FF2F475E08BB441316B070F26E2C704545C774337BB11ABB9FBCEA5367F16D1F94DCBF9A73909FD721B80E34CEEBA05C4F2315FCC1DEF4D42BCBD11F3657FE3ABF49B60AB75656F420F4DFBBD1938D5B574C86F0EB7489560AB14360B4CB6486F80BF32A0F12D5C8A01C6932790B9CDE5C2D1DAFED1BED9D2BA68260CA7EF276B202BB6B07463B9BC1E742E21469C0AB854BEC04B9591404D3F735329D0790952EFDDEC1A39B258225A07160D07A408DC048D9FABE95ED977F5118061FD04047CB8A4E74EA59E63C26410DBA0E1A823FBC4987C78DFFF74DCB200F80A18BFE9D6A3D4F8D56ABC56E5DCB42EE66781D27B812943CE033B30047097F09E4B321C6AA5069D0D8DC4E26E6D95D8412B21942C88CB0630CEF9F085706B735DE23811DD58282667AC678CD05A1A305BAC6C3D537C49F9238596FF288B714F6C72BA8EE52969541AA2854BB10C475262B70468F34F0ED0760126FD6F393F270AE2A989BE79796FBBBEE3EFD9A6A3B7F41949415F58F7AE7408FE60D6C1EA948F29676A338764FDC0784D7C4BD44E750327DC42B3732854E85030BE75BC38517038A6D7D5EE1920129351D7A87A3568292B97634C7F76F507C7B60E2DF46A6640C042A0007FD1C0CB373F1AE9B1639B73EE1AA52D090C163B806800272CFCBB01448ECBBEF4DB053CD6ED476771DCA2EDF38DA9C7A434656F2162366371B3B339E410F5933872DA250E1BBE272DCB9E64E558DD6C350EF72C5A6D32D2757DA895688753EBC98914B0DD995B2F6E9F710848701D53162E8D7D3A9E37E81A7A8085B1C3A888CB1AF1CFD34A576586755B75E9212E0CA7DBC31904EC4F642DEDA26591F3930D530CB5DFCBE8A372502F078B4DD362DBAC42F2A6934867CC4826C01053F889ADC8B65A0A5BD8D73DED629BB31A0FB7E356BEC8457DE280DE526245B300A531FA5AC0D871F92FB804D1E4E1F14DB95D30ADEB8EA1819B7776C2CD72B34FFF9E58651C80573692057C11B36665040911EA76BEC8457DE280DE526245B300A531FA5AC0D871F92FB804D1E4E1F14DB95D30AAD8DC62CBF41603C2D14927A6ED34748DDD1C9FDE82A77596C5A53A47ECAABEFA47213686A10BEF7161E9E87E2081BDBA1D2C1A759A48D0E980FA2A94596483AD0F2223FB34863E18C8D645F65939FEAE56434A3F4B817C8A777516C0E36DAC28F27C6849012F2C9076CEB858703B65B7EC0B3C3CDCFE853BD0E30057DE415F81980E7CDA20DBC456C9CB91651BF56968CDAFDBFF0BF245545C414379631F58190F216C4507D52B831B446ACA320A868F7BA56AC36A4BA7B214139F87833CC0512B2F35E34DE7B5206536BBE032D1E9EF66ED808D2D49E56A1AA95516E1891D854DBD0AC494B97BA69A58764F7F23C61830C92C5CE40223E5304364425E45B438C21A6ACCD12E1AFD6FBE2F1520C1E03E3FB0BEB7F296E67E5079FD5981B1022AFB31669008C97E0E6A02851A0F1EA9AD431D002AF22CBF26A841E1C7FAB8617C025D907EE2B4EB63ACA4A09ABFF63AAE56434A3F4B817C8A777516C0E36DAC28F27C6849012F2C9076CEB858703B65B0E0DC728B6E62B8D88D3339B4D21B1AE52F79C76E455478813A64B90DD8B934690F216C4507D52B831B446ACA320A868F7BA56AC36A4BA7B214139F87833CC05F5B9A999A0DBE02758EA72ED13696CBBF286017310041599A883D4DABE274A77A4DCAD501F455B12681AEC9849DB184D289C29C29C4278476469E9CD6D8B3624EEC8C18B684CC96D8C88AB8B643064615BEFF17663ACCAF9D14B5D184DD5174488F595F6C272C3B79BF618E35F94A431D5A9F27BA257FF0A87E5ED254BC3776F52E128F15820BD2811002A0C966401FEA91407BDF5AB44130504AB47D185817C01CF0C8D6A03692C1AA0823130C645722C5C692D4E83607E89934A9B0F6EE62452F79C76E455478813A64B90DD8B934690F216C4507D52B831B446ACA320A868F7BA56AC36A4BA7B214139F87833CC0512B2F35E34DE7B5206536BBE032D1E9EF66ED808D2D49E56A1AA95516E1891D854DBD0AC494B97BA69A58764F7F23C61BEBC9B79C6CCAF16394826FE821E51FF6CC43B9CE055C233C1C99D2C1CA1087D5093182C53F3D02845FCE5EC25C181C10C4824278D939141214CF5FA7ECDA6152FCEB8E9B4F2679507AB8F6EE8C8649B011AC4357EAB4AB809E47204D530CF25DACD78F6977E058A22994BCA11A0B3AD670585D20C78C2073A330ED0CB887169FC5F8563B42D8073925BDCD46662B2B4E56434A3F4B817C8A777516C0E36DAC28F27C6849012F2C9076CEB858703B65BC42F2A6934867CC4826C01053F889ADC8B65A0A5BD8D73DED629BB31A0FB7E356BEC8457DE280DE526245B300A531FA5AC0D871F92FB804D1E4E1F14DB95D30ADF7C6268E7333C414E1392B824F7FAC8F66ED808D2D49E56A1AA95516E1891D854DBD0AC494B97BA69A58764F7F23C61830C92C5CE40223E5304364425E45B438C21A6ACCD12E1AFD6FBE2F1520C1E03E3FB0BEB7F296E67E5079FD5981B1022A8B1E0BA166D2A6BC4C6B072328FF8D284B97E0DDB4E80788AA697C39738BCFE64494B3F07CB23980E07D4FCC9420D3F152B7B018EC814374E39E35BF8DE5DA494F8D3FC222859AFDD74A2F85BE3F51A0CD09A2E1593CC720A54847078F4B9F8D4EA2E3C326E3C0CF04072BE12E8F31E7AA3E24A3EC3297965C7411F12047C63B97C6AD81218F8FEB6A9B6915DB00F4427C9BE44C90DCEEB22C78C937DD8CA8089F1ED2BBEC0EC1D1BFD38B6D19A235C7C694B533072FF10DA6EA3331ED033738087B0C0D85274D237CDF89692978ADB1A5EB84649B7429EF1208903DAE675EB3F2E7DB4B4FF8825E88B52696CF3292895DB9341B69677D13461AEA83D226C55869A332CAE9864C9B229E92A699E026C95262993FBE69FAED08C91A5690A7135C749CCD38B9195491ED06A976C483FD6955A64914DACB7185D2BB0896A7064C55AA752A2AA265147D595BE7B9748F6CDC464C679F1A4A262DCE5D69EDD327513009157CA19CABC43DA6E60C96C6B1B953E81060F3914E65611575656F8F2749CBD92D9B888F16FEE47B23CE4316E2811D5A35D01A55990BA69CBF8EF84CFC89D910007F5A865008E54112B24EAAE4D6F990FF7E8B632138F699F473DADA2CB8280225A96D311574B89337BFCE30DFF16515FF2B9A9E1AC75D9B6F91815342A7B34C6C223EF4598C95E72CBCF67B2FEE0F007C666F86B4B1CF4C603F45BEEFF6226B862E138BF6B55CF6B158AC27667BAE89DF3F79A55F503341377934F5E21F70A23207A28F73CF9533FBB68D79B63F2669EE99C2000C303C42652222C2FA5B44EE38CFD95E15D74FAA06E436D7440573E563BE3CFEC54820627A81723A9728608131F51FBCCC1644342E3D0CD6ECCED0429A869421B4EA013898819B95F25093C049A8127762F7123B898CE94D25B863E563BE3CFEC54820627A81723A97286C7F1A1AC18B6E21AFA00B26C8CA6208485F99FE3E7D7EA97C8C29AEFFB290144B3D007675DF82A1CB9A17858002F128F41C609545EDDA2F5C35AA94A0E357A2A70F2BEB5AF1F9F03C5EA20050470C68EC749ED4DDDC698261434B427A25F779B350E14A04FC182249A7A3C8060EBDFB00426904FCBBCD599C1C103DEE57EB3E2C4A771A6DE8A67164CDD0CEDD817B1768934785E1DC8B65BD041CECE58833229A1081B01B60850C082EA8E4A0DAF5E0ECD480D0B5A44499A54F068DD9FEF62C7A13DC7453679EEC3D34A92D623B79C1695837A08BB0A70AF44EB26157E245810B3B504D38D01887E7504DB48C50DE25743E370CC84795AC30462BB98D52389DEC3D886D7708C85A695C4948151F750BC3B5F329B53BCDCC6B2955FCE3D085A9BEB8A9F633D835F1683CDE65D1D7ED96DE900EFAB99920C130890A8BD1BC32AB24834AF46B416425960290B1DAE5AD342990C4CFA73024DB060D102953BE7754160DFED9F3FBFB8AD2634D947BE5A2277CFF6FBABDB7BF5625F4D118DE8831567ACCDF7E99711816A7FBBE3F64E3D7539B4A910155CC09ED3C446EFC943791E750FEBE34B70120440DA4D943A292FCCE6AAC66FF9453D8A93B27A6AA1C9BA22E8EDCBE8B7EB1D13F23BF126735484AAF78F87CBE64E42597605496F171F271D499466F0E4FA8C35A512898CA691ECAD8712161855BAA8048238C3C5F6071699892D64FDA860F3DB3B06FFA4D531A8550154C05CDAF670729893520B353997F4F21F0EBE2ACF8B6DBD4D119349F1C2B55822CFADA906DF04C7C4634F23BDE01248219D2040CD9A023E76337F3E9A7F6D80C40A7CF35D401794CB67D20DC8B4FA0476B69083C49488F84F4A3EEB4A055655ADBDDA111E057860AFD9E1783FB60598B84E7C1E476EC6162845FACDD40EB4F81F44D272D220B1D1C32955B83BA2B570DB7CD9781F24F0FC9BE8263ED8F25AC2280A32C9E98EC2815567781B354B9FC41F2317E4408F4BBD21873702B8EEE20255A377E556EE8957654F9B844B89939F198B03EE20713E0087FED15C18209B07FD867520B219D7E9FE363DE8BF0AC52F299E8879C6D8BCAD98733D71A38C2B8E513A1263E66577B119DC9FFAAE6D71DEF33E9C205139F616CEAD1B5103265AF8D21887509E4F4AAD0EC33363B0E7BEC0A13536F30BA922B5E69DBE82B26C57C0FA06EC07C3D189D1669A012DB69AADCF01B3538E97B92717A50A155AD6969ACFD1270330C8F13CB8C2101CF0D1A565BE22AC93F289EF8A9F361C74F044E7F9A069F6E36F599EE92C075127436F47BAFF6FA5D3B0202070FF8D2DD28394FA90D74CCDFBC68B9CD373AFBAF2C4222D7A47F7BF867B2CDC7AC061B1043CA97943C37A94E7B48ED6CD54393029AB13D4552E43B74082368D126191B6BC65349A5CCE3F745B985260B09EDACA9F4FF73E12EB0ED09B1C8B9ED97C89A96260108FB5DE218014E9B2BB56209DC6F81794D441C11113C302D5ACB1841A2587E5451EF6DC5A37FAF69B16D5D3106F910530B125CD04D570485800C141CA0472465E8A133399132AC5010580B9BB12ED9BD806782EE252906AF40328C78AA796A1694B024FAB3A7233D6867E8C596BB4A0F1FBF12B40DD890CF0C6F341CB7671DF45121D8A6E13342262CE2F1F4316BA5C048B5F8ED4D6886003A8D7064A20D8514F236A4BADF428FBA859FFDD73E76A375E5A14682853503ACDEB68E94B1C205D866A79683526681FF6D1716CA1F4546F79942BD4FF67F8EF442A12BBA5469D5346116720055ED4C1EA045E8197FB19A2DB29094CE2B55C82F6F0579445795A789FB0ECFBB977DF9ACB0E47C1F74DAF91B5067EF4CE5802614939937D810C499A52B09961FBD05FD9A037FE1EC198D0B3B11896BABB33EFFD1DE1A90EAC55627692ABBF51A298A525E781E21F968152A4C099699693782A99AAAF1E0EF532BA1267F77B841379317DA46003B0290662DAE14E0932A03EE4CC7C683E5C87F9E39F5D6179FFECF9C829FA4E367612C92E83AA9553175B8524031F9603605341A123352FD0C24902B576C941A52284231B6444E07466E4B1A7E9902C025A5F09B0A393EA5B4D438AAD2543EBF16A0E6259BBB8074B1CC43C8AE82F612E9F90B42682C66CA629BE45193CAA1C03BC5D7F7081C22303DFD97F175E39CD61024DAFBBDBA4F583B10F0B369E7E5F2108F158337F27ACBFD3B97445886BDE144247E126412C83E5D10DB679C5825791F5D8741516DE7A4F23FD9ACDAE467C777BFE5B92723C727AE450D171FA7767796FE2507220B556DDE1513A1263E66577B119DC9FFAAE6D71DEF35D6F5D790F8EB8D9C19B28A02CE8DAD19A5E6FC3FB1CE43CAE1EF463E5732140CA6675B54613959F3F94B4BADFCE7C6CC18404F876E19058CEF811397E3B127B94616943EE56F7D3C441B8B1118F8C1558C05C805833404B1842F874A78FD7ABCF40EB9BCBCE04F3699B9EDF76AD2AF1BC07AD6433D6E87E184F597DA6EECB1FFE259DA6E1F55A79015F277739E9383720114437DE6FEC41A7E947A2DD75ADD635029FB2A171CD19E89309E855100E1F6705214B1948DB9DC0552296FCA1C71341861323D969940606D8946A8AEC0EFDF9AB76C3267E23D6C67632B1F166997EF5133CD0CAC7FE675026AD18B8433973ACC2B9BC3C32B826FF1C4BD38CC43E04FE07014A6436EFC7C61C74D80E6A6BF9B8B7A2EC01E12A96033058EE0DC66B31BFF59C2EECEB10CF1CB1825FC5A0F77EA7DC0D5776A89784D964FF5EFE53362CDC3E3B5B98D35D19BD36E8D405CCF342B5B629559D043D226FD75CEA9CCB67841419D5FFA5B83BF998AD247F6575B66E9E955F896AF9EC883F25924916995C604C960EA1A5A00111478FE0DF5EF4EF59CFD49350F21945908EF8F6E7CCD0697EF5133CD0CAC7FE675026AD18B843394C800E525DE5CE0E129177076FDF3317FC6ADA0E175617915D442315995597F4E08D005B7465081D9E2559846F86570AADF428FBA859FFDD73E76A375E5A14682853503ACDEB68E94B1C205D866A7968E11B47C293D302BD46CE11FFF86F221F50EFBBA289DB3536202CE84D28CDE4777D0B9E358D1FE70EE8A1E0ACE9FDD52819387497C9D2E481EFA38D5BF94DF5CA028BA2CF09F373A68F982CCE730C90EDBB43B1C640894A29120832C002D080C6A930D729459493D0C90DCA8FCA05AB4FF9BA6D9DB62860033799C36C66EF82CFEDD02FCC183036E7A4A06482561103F7A7A049BE0A2FF7CBD64D9C670454E00EC1CADD682476355376E4829629CE5CFAA3DADDE2932EAA9440712C917271EBB524E1E42ECD79B3C4AD4BD42200896EBB12161855BAA8048238C3C5F607169989B9E355AB5A185958D3FB2E683036B892A6649FEB89991CDD04E674796F1694255413DC21014288390831A2A804766D0867ED42CF0F205640EBAD43213654A11577B80A3A85C3A035EA09E76BF9928AF900C33A09ADD2E29B122863651E3CC19E156F47DB9439FC26C94140C7F695C625BB6A9E6EACB868A60295AD65112AA6F3C1D0DCA16A145D2E86F60F76885532B044B4E0C44004CB3E4580EC09685D41650F1AD22B10496957D32F785528E9DAD95EDD17EBC44F8D6AA844FC042F20E392184BC74C2C961C0954DD803BC478C4C231F254B1E4475AC320AF4CA704CB7C56C384856016A9ED9802FB123FE742312B2C3F10BF6248EE16FCC3DDC2FE9D5D8ECB61196820452F596F86B102FD6B32D7633299BAA63E6D86D191BEC72EBE01A21796D1F0D05ACC88731A7CBA22ACA4B0D022C3CE3B90375A77E165C5DD8F9B26C5227CD2E2F8F230A73E1B81716322DB1946D7E308D0037C3D62CEA2AF8A44483475895B06E94FB432ED3D3116585321B8F8BECB205BF98180DC7E65B10911A6F2ED58EF4CB672D467F9A65539C3B66E59C4C1FC28B02EC7663B38E5FF372FE58ED6E24D389D200232F8AAADD040D3BB181AD5F3195254B3DF0C3D54951155114E0D8B990A65D2A08696E611C4F14ECA0DE32C2CE98E05254D60DBCEF66241B27761E6BA22E1BAB346E8B8779B4786B18A2E38C4D6ED6476045B2BADBFD4F00FEA66A0A35F738D8DDF8168BADB8B8004CC0D11759C1AA2CF6AB35D9CD4703F85E9CA8E80D45D6224B8CD8407293EC7BA2450B9A8DB75C7884D772295E0DF56669453E6B95C6B0D6499D16CA077AE924E725513DAEE088A327D23EF0ED6C7701EADE8616851F5EDEA0DD8D9F6E2E66065C3879181AFCD0ABFB6D5563BF4107EB7B8607E32EDB07D2D750C6B0C6A9830B1A6409EBECC53AF3000AA5203E562B9BB5506B9CFD7F29F8C7ECEEECE41C84189AD7863335A06E42D630D58E7BE7DCB3045859143B070AE4E2BF3C8366837964380D7F62651E7969A66C46DFABC7976F25787EBC6B0318C9A399566D2BB9119BA048AB3E35693C129AF6A90241E99AA2E8CD95B8EB308A49DDB98582AC10CE1ADC59C7E5664DA8C1920087C974615E11E793346968C73FC6286F157682E62ADEB48EDAC158A2126E50FED5A7B4D0B0E34&quot;&#125;\n\n\n\n分析sign定位常规操作，在jadx中搜索”sign”，观察能否直接定位到目标代码。\n根据包名，这几个出现”sign”的地方，似乎都不是为sign写入加密数据的地方。\n\n那就使用frida，hook函数java.util.Map。\n然鹅，遇到了frida检测。\n绕过了反调后，依旧没有打印内容，说明不是使用java.util.Map存储键值对的。\n\n\n还有两个办法。\n一是抓包，打印调用栈，对着调用栈分析sign的加密点；\n二是在jadx中搜索关于sign的其它字符串，因为之前搜索的是&quot;sign&quot;，如果去掉双引号，得到的结果会更多。——有可能用的是字符串拼接的方式。\n由于分析调用栈太麻烦，这里先尝试搜索sign=。\n\n发现结果相比搜索&quot;sign&quot;多了许多，从上图的结果来看，大概率使用的就是字符串拼接，进一步缩小范围：&amp;sign=。\n\n有两处比较像加密点。\n一个是：\n\n\nhook了这个函数，结果如下。\n\n根据比对，这个sign大概率是访问&#x2F;x&#x2F;push&#x2F;token时的签名，而不是访问&#x2F;x&#x2F;resource&#x2F;fingerprint时的签名。\n\n另一个是：\n\n\n对它进行hook。\nactionKey=appkey&amp;appkey=1d8b6e7d45233436&amp;build=8480300&amp;c_locale=zh_CN&amp;channel=vivo&amp;device=android&amp;disable_rcmd=0&amp;mobi_app=android&amp;platform=android&amp;s_locale=zh_CN&amp;statistics=%7B%22appId%22%3A1%2C%22platform%22%3A3%2C%22version%22%3A%228.48.0%22%2C%22abtest%22%3A%22%22%7D&amp;ts=1751452489&amp;version=8.48.0&amp;sign=f7f2223690261f5c1c79da1725187a14\n\n可以发现，大部分内容基本一致，基本可以确认，这里的this.sign就是目标sign。\n\n\n根据交叉引用，this.sign的赋值来自SignedQuery的构造函数。\n\n而构造函数在java层无任何引用，大概率是在native层创建的实例。\n\n\n根据追踪，signQuery会返回一个SignedQuery实例，\n\n\n\n对应的库名是libbili.so。\n\n\n如何定位函数s在native层的动态绑定地址呢？\n方法1：\n如果要hook RegisterNatives，由于存在反调试，在处理完反调试之前，是不能hook RegisterNatives的——反调不是在第一时间就能hook绕过的；如果在处理完反调之后，再hook RegisterNatives，又会错过一些JNI函数的注册。这个hook的时机不好把握。\n方法2：\n又或者用Unidbg模拟执行libbili.so，但只是为了看注册地址就去补环境，有点杀鸡用牛刀的感觉。\n方法3：\n这里有一个点子。\n每一个Java函数都对应着C&#x2F;C++的一个ArtMethod结构体实例，可以遍历类的所有函数，然后拿到它们的handle句柄（ArtMethod地址），然后通过偏移，在ArtMethod的成员变量中找到绑定的Native地址，然后根据这个地址，判断位于哪个模块，函数的实际地址再减去模块基址，就可以得到文件内偏移地址了。\n这个方式相对于前面2种方式，优点在于：可以任意时机获得偏移地址（也就是说，可以绕过反调再获得）；而且不用大费周章补环境。\n实现效果如下，还不错。\n[+] Java Method: com.bilibili.nativelibrary.LibBili.s(java.util.SortedMap)  |-- Method Handle: 0x9f149638  |-- Native Address: 0x797cf0a050  `-- Symbol Details: 0x9050 (offset: 0x9050 in libbili.so)\n\n\n\n解密字符串.datadiv_decodexxxxx是ollvm对字符串加密的特征。\n\n\n在dump完并且修复后，字符串基本都解密完了，多了300多个字符串 。\n\n\n分析来到sub_9050。\n\n\n进入sub_162A8，从return倒推。\n\nv21和v7应该对应于str、str2。\n\n\n倒推，分析sub_18FF0。\n\n\n一路往里找加密算法，最后来到sub_106C4。\n各种位移、异或、与、非操作，大概率是md5。\n注意到，第248行有一个-680876936，转换成十六进制，相当于0xD76AA478，这正是MD5的T盒中的常数之一。\n\n同时，注意到存在(v5 &gt;&gt; 3) &amp; 63的操作，在md5中，这一般是获得字节数的操作。\n\n\n同时，在函数sub_FFAC发现了魔数赋值的地方。\n\n\n上述种种说明，这是一个md5运算，就是不知道有没有魔改。\n输入：\t\t\t 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF7b4fb95310  61 63 63 65 73 73 5f 6b 65 79 3d 26 61 70 70 6b  access_key=&amp;appk7b4fb95320  65 79 3d 31 64 38 62 36 65 37 64 34 35 32 33 33  ey=1d8b6e7d452337b4fb95330  34 33 36 26 62 72 61 6e 64 3d 4f 6e 65 50 6c 75  436&amp;brand=OnePlu7b4fb95340  73 26 62 75 69 6c 64 3d 38 34 38 30 33 30 30 26  s&amp;build=8480300&amp;7b4fb95350  63 5f 6c 6f 63 61 6c 65 3d 7a 68 5f 43 4e 26 63  c_locale=zh_CN&amp;c7b4fb95360  68 61 6e 6e 65 6c 3d 76 69 76 6f 26 64 69 73 61  hannel=vivo&amp;disa7b4fb95370  62 6c 65 5f 72 63 6d 64 3d 30 26 6d 56 65 72 73  ble_rcmd=0&amp;mVers7b4fb95380  69 6f 6e 3d 33 30 39 26 6d 61 6c 6c 56 65 72 73  ion=309&amp;mallVers7b4fb95390  69 6f 6e 3d 38 34 38 30 33 30 30 26 6d 6f 62 69  ion=8480300&amp;mobi7b4fb953a0  5f 61 70 70 3d 61 6e 64 72 6f 69 64 26 70 6c 61  _app=android&amp;pla7b4fb953b0  74 66 6f 72 6d 3d 61 6e 64 72 6f 69 64 26 73 5f  tform=android&amp;s_7b4fb953c0  6c 6f 63 61 6c 65 3d 7a 68 5f 43 4e 26 73 74 61  locale=zh_CN&amp;sta7b4fb953d0  74 69 73 74 69 63 73 3d 25 37 42 25 32 32 61 70  tistics=%7B%22ap7b4fb953e0  70 49 64 25 32 32 25 33 41 31 25 32 43 25 32 32  pId%22%3A1%2C%227b4fb953f0  70 6c 61 74 66 6f 72 6d 25 32 32 25 33 41 33 25  platform%22%3A3%7b4fb95400  32 43 25 32 32 76 65 72 73 69 6f 6e 25 32 32 25  2C%22version%22%7b4fb95410  33 41 25 32 32 38 2e 34 38 2e 30 25 32 32 25 32  3A%228.48.0%22%27b4fb95420  43 25 32 32 61 62 74 65 73 74 25 32 32 25 33 41  C%22abtest%22%3A7b4fb95430  25 32 32 25 32 32 25 37 44 26 74 72 69 62 65 56  %22%22%7D&amp;tribeV7b4fb95440  65 72 73 69 6f 6e 3d 30 26 74 73 3d 31 37 35 31  ersion=0&amp;ts=17517b4fb95450  35 32 37 36 37 33                                527673输出：             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF7991c96590  31 35 31 30 66 39 39 39 62 33 62 39 38 38 31 37  1510f999b3b988177991c965a0  39 39 61 30 33 34 33 64 32 64 38 62 38 63 64 62  99a0343d2d8b8cdb\n\n与标准的MD5结果不同，说明魔改了？（后来发现并没有）\n\n魔数和M盒赋值并没有魔改。\nv202 = *a1;  v2 = a1[1];  v3 = a1[2];  v4 = a1[3];                                   // 魔数，状态矩阵  v5 = 0;  v6 = 0;  v203 = v4;  while ( v5 &lt; 0x40 )                           // M盒赋值  &#123;    for ( i = 0x180DFC9C; i != 0x94D2D6E7; i = 0x94D2D6E7 )    &#123;      *(&amp;v207 + v6) = (*(unsigned __int8 *)(a2 + v5 + 3) &lt;&lt; 24) | (*(unsigned __int8 *)(a2 + v5 + 1) &lt;&lt; 8) ^ 0xF91793FF ^ ~*(unsigned __int8 *)(a2 + v5) &amp; 0xF91793FF | (*(unsigned __int8 *)(a2 + v5 + 2) &lt;&lt; 16);      v205 = v6 + 1;      v206 = v5 + 4;    &#125;    v6 = v205;    v5 = v206;  &#125;\n\n根据分析，在1-64轮中：第11轮的|变成了^；\n第16轮的|变成了^；\n第19轮的|变成了^；\n第25轮不是魔改，因为位移后，使用^或者|，效果都一样，图中是我弄错了。\n第31轮的|变成了^；\n至于11、16、19、31轮，经过试验，发现^和|的效果是一样的，也就是说，编译器和混淆的结果，并不是魔改。\n所以，sub_1046C是标准的MD5 transform，基本可以判定MD5是标准的。\n\n分析了函数sub_18ff0后，发现是加了IV，所以导致结果不同。\n\n\nIV如下。\n\n\n验证，这回对上了。\n\n\nbuvid定位 &amp;&amp; 分析先定位到getBuvid。\n\n\nthis.f136924d.m467330e()会得到buvid_remote。\n\n\n如果没有buvid_remote，就调用this.f136923c.m467322e()。\n\n\nthis.f403543a.get_buvid()会获得存储的buvid。\n\n如果没存储，再调用m467316f()，获得buvid_compat。\n\n如果没存储，再调用m467317g()，获得buvid_local。\n\n如果上述哪个buvid是存储了的，会将它存放在buvid字段里。\n\n\nbuvid_remote是服务器发的官方buvid；buvid_compat是兼容旧版的buvid；buvid_local是设备本身生成的临时buvid；而buvid是当前有效的buvid。\n这里主要去分析buvid_local是如何生成的。\n追踪下面这个函数。\n\n\n\n\n存在3个引用。\n\n这里追踪第1个，如果找不到加密点，再追踪第2个。\n\n\n查看引用。\n\n\n其中，String strM467289e = this.f403533a instanceof AbstractC140824n.c ? this.f403534b.m467289e() : &quot;&quot;;这一行代码是在获得存储的buvid2，我们的目标是计算获得buvid，所以这里继续追踪strM467289e = this.f403537e.mo367721a();。\n\n\nthis.f403537e是一个接口实例，它的赋值来自于这。\n\n\n而InterfaceC107263b.f281975a.m367723a会返回一个类C109665c的实例。\n\n\n这个实例覆写了函数a、b，并且调用了interfaceC107265d接口对象中的函数。\n\n\ninterfaceC107265d接口是如何实现的呢？追踪函数C140819i。\n\n再查看this.f403544b的赋值。\n\n\n查看C140822l的引用。\n\n\n实现interfaceC107265d接口的对象是new C134862b(null, 1, null)。\n\n\n接下来读代码，分析函数mo367721a()。\n获得实现接口实例的函数a。\nInterfaceC107262a interfaceC107262aMo367726a = this._interface.mo367726a();\n\n而函数a返回了一个接口实例对象。\n\n\n只有类C109664b实现了这个接口，在new的时候，并没有对这个接口进行初始化，所以这里interfaceC107262aMo367726a只会得到null。\n\n继续往下看，这回进行初始化了，传的接口是getLogger。\nif (interfaceC107262aMo367726a == null) &#123;    interfaceC107262aMo367726a = new C109664b(this._interface.getLogger());&#125;\n\n\n\n而getLogger的返回值是this.f378652a。\n\n所以相当于调用了new C109664b(null)。\n\n继续往下看，获得了一个迭代器，根据当前的sdk版本，获得不同的接口列表。\nIterator&lt;InterfaceC107264c&gt; it = this._interface.mo367728c().iterator();\n\n\n我手机的版本是32，之后分析listListOf的接口列表。\n\n接着分析下面的代码。\nIterator&lt;InterfaceC107264c&gt; it = this._interface.mo367728c().iterator();        while (it.hasNext()) &#123;            String strMo367720a = interfaceC107262aMo367726a.mo367720a(it.next());            if (strMo367720a.length() != 0) &#123;                if (!this._interface.mo367727b().contains(strMo367720a)) &#123;                    return strMo367720a;                &#125;                Function1&lt;String, Unit&gt; logger = this._interface.getLogger();                if (logger != null) &#123;                    logger.invoke(Intrinsics.stringPlus(strMo367720a, &quot; is bad buvid&quot;));                &#125;            &#125;        &#125;\n\n上述代码中，只有下面2条关键语句——获得当前设备的buvid，如果不在黑名单中，便返回，作为buvid_local。\nString strMo367720a = interfaceC107262aMo367726a.mo367720a(it.next());：获得接口函数处理后的字符串。\nthis._interface.mo367727b()：获得黑名单buvid。\n来看看是如何生成str的，由3部分组成。\n\n以其中1个接口为例。\n前缀是XU，调用mo367725d可以获得drmID。\n\n来看看String strM375856c = C109666d.m375856c(strMo367725d，这是一个标准的MD5算法。\n\n再看看C109666d.m375857d(strM375856c)，取出md5结果的第2、12、22字节。\n\n最终结果是：”&lt;前缀&gt; + &lt;md5的2&#x2F;12&#x2F;22字节&gt; + &lt;md5结果&gt;”。\n最后，看看除了drmId，其它接口返回的是什么内容。\n\n\n\n\n\n\n\n\n\n\nfp_local定位 &amp;&amp; 分析搜出来的结果很少，可以一个一个看。由于大部分都是getXXX，这里直接可以锁定这一行。\n\n函数m199614l中出现的字符串说明，fp_local与buvid有关。追踪C144128a.m475557a。\n\n函数C144128a.m475557a长这个样子。\n\n再看m475561e，是一个md5加密，对“buvid + 设备型号 + 基带版本信息”字符串进行md5运算。\n\n而C105446f.m362260e是将hex字符串转换成字节数组。\n\n函数m475563g返回了一个时间。\n\n函数m475562f返回了随机的8个字节。\n\n这就是本地指纹（fingerprint）的生成方式。\n请求体分析（protobuf）分析关于/x/resource/fingerprint的请求体。\n\n定位 &amp;&amp; 分析搜索/x/resource/fingerprint。\n\n对接口交叉引用，来到如下图所示的位置。\n\n逐步分析。\nServiceGenerator.createService(InterfaceC9422e.class)：创建一个网络请求服务的实例，ServiceGenrator是一个工厂类，用于生成实现了InterfaceC9422e接口的代理对象。\n.fingerprint(str, ...)：对应一个具体的api，str是请求参数，而另一个参数是http请求体，我们要分析的就是请求体。\n这里的fingerprint并不涉及实现，只是告诉retrofit设置str作为查询参数到url中；设置requestBody作为POST请求的主体等。\nRequestBody.create(MediaType.parse(&quot;application/json&quot;), str2)：创建了一个http请求体。\n据上面的分析，可以知道str是请求参数字符串，str2是处理后的请求体，因此，下一步交叉引用m34466b，查看str2的来源。\n\n\nthis.f29694a和this.f29695b来自于RunnableC9421d，继续查询引用。\n\nnew PostBodyModel(str2, str3).toJsonString()是请求体。\n\n继续追踪m34467c的引用，请求体和入参的str、data有关，继续追踪m27200a。\n\nstr来自于m199614l()，而data来自于C145722b.m479556b(Source.INIT)。\n\nstr取值为fp_local，至于fp_local的计算方式，之前分析过。\n\n\n直接看return的内容，尝试获得main、property、sys数据。\nreturn new Data(    setEmptySet.contains(&quot;main&quot;) ? MapsKt.emptyMap() : m479558d(setEmptySet, source),    setEmptySet.contains(&quot;property&quot;) ? MapsKt.emptyMap() : C147370e.m483853a(),    setEmptySet.contains(&quot;system&quot;) ? MapsKt.emptyMap() : C147367b.m483842f());\n\n\nmain的数据如下。\n\n\nproperty的数据在native层获得。\n\n\n\nsys的数据如下。\n\n可以将main、property、sys都视作设备指纹。\n查看函数C98559a.m342912b(local_fp, data)做了什么。\n\n\n函数m342911a长这个样子，点入任意一个c55998aNewBuilder的函数中，会发现跳转到了类com.bilibili.datacenter.hakase.protobuf.AndroidDeviceInfo$DeviceInfo。\n这一步是将明文指纹转换成 protobuf编码。\n\n再来看函数C101015b.m349014a，它将protobuf编码的字节数组进行了加密。\nRSA.loadPublicKey(BiliContext.application().getAssets().open(&quot;rsa_public_key.pem&quot;));：获得rsa公钥。\n\nC101014a.m349012e()：获得随机的128位数据，作为AES密钥。\n\n\nRSA.encryptByPublicKey(strM349012e, rSAPublicKeyLoadPublicKey)：用rsa公钥对aes密钥进行加密。\nC101014a.m349009b(bArr, strM349012e)：对protobuf编码的字节数组，进行aes加密。\nnew Pair&lt;&gt;(strEncryptByPublicKey, strM349009b：返回rsa加密的aes密钥和aes加密的protobuf数组。\n之后就没什么好分析的了，将key和content转换成json格式传到服务器。\n\n\n\n伪造指纹先用frida hook关键点，得到protobuf数据。\n再使用blackboxprotobuf对protobuf数据进行解析，修改字段值，修改后转回protobuf。\n然后生成aes密钥，对protobuf内容加密。\n用assets文件夹下的rsa公钥，对生成的aes密钥进行加密。\n最后，将构造好的内容，替换掉正常包的请求体。\n学习点1.blackboxprotobuf的使用，定义proto文件。\n2.mitmproxy可以抓取并解析protobuf报文。\n3.reqable可以抓包、修改字段、发包、导出发包代码（python等语言）等。\n4.如何定位关键字段的生成代码。\n","tags":["抓包 字段分析 protobuf"]},{"title":"emo云爬取评论(day1)","url":"/2025/07/07/emo%E4%BA%91%E7%88%AC%E5%8F%96%E8%AF%84%E8%AE%BA-day1/","content":"学习爬虫的第一天，目标：获得网易云音乐的评论信息。\n定位查看网页和框架的源代码，发现源代码中并没有评论信息，评论信息大概率是通过js后续加载的。\n\n\n浏览器在渲染了html文件后，会执行其中的js文件，这些js代码会向特定的api接口发送请求，比如下图，发送请求评论的请求。\n\n请求头是这样的。\n\n\n负载是这样的。\n\n如果要爬取评论，需要完成下面3件事情。\n\n找到未加密的参数来源。\n对参数进行加密（符合网易的加密逻辑），充当负载部分。\n发送请求，获得评论。\n\n参数来源在浏览器的开发工具中，启动器可以查看发出这个请求之前，执行了哪些js脚本。\n\n点开了最后一个执行的js文件，下断点。\n\n\n\n一路跳过不匹配的包，直到匹配目标url。\n\n\n我发现js的调用堆栈有个好处，记录了调用时的值。\n一路翻看调用堆栈，直到翻到data处于明文的时候。\n\n发现处于下面这个匿名调用时，Ce2x的内容尚未加密，说明加密点在t6n.be6Y。\n\n在be6Y中下了一个断点，发现：当执行完window.asrsea(JSON.stringify(i6c), bsC7v([&quot;流泪&quot;, &quot;强&quot;]), bsC7v(BA1x.md), bsC7v([&quot;爱心&quot;, &quot;女孩&quot;, &quot;惊恐&quot;, &quot;大笑&quot;]));后，数据就加密完了，这个window.asrsea就是加密点。\n\n\n\n将明文导出来。\ndata = &#123;    &quot;rid&quot;: &quot;R_SO_4_2722391361&quot;,    &quot;threadId&quot;: &quot;R_SO_4_2722391361&quot;,    &quot;pageNo&quot;: &quot;1&quot;,    &quot;pageSize&quot;: &quot;20&quot;,    &quot;cursor&quot;: &quot;-1&quot;,    &quot;offset&quot;: &quot;0&quot;,    &quot;orderType&quot;: &quot;1&quot;,    &quot;csrf_token&quot;: &quot;fb96f04e2bf711be4bf31bba80bf766a&quot;&#125;\n\n加密算法差一个加密流程，就可以构造报文发包了。\n加密函数是window.asrsea，搜索一下。\n\n\n对下面的内容进行分析，获得加密方式。\n函数a：获得长度为a的字符串。\n函数b：AES对称加密，数据是a、密钥是b。\n函数c：利用服务器的公钥b和c对数据a进行RSA加密，b是公钥、c是模数。\n函数d：负责调用函数a&#x2F;b&#x2F;c，得到结果。\nfunction a(a) &#123;    var d, e, b = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;, c = &quot;&quot;;    for (d = 0; a &gt; d; d += 1)        e = Math.random() * b.length,        e = Math.floor(e),        c += b.charAt(e);    return c&#125;function b(a, b) &#123;    var c = CryptoJS.enc.Utf8.parse(b)      , d = CryptoJS.enc.Utf8.parse(&quot;0102030405060708&quot;)      , e = CryptoJS.enc.Utf8.parse(a)      , f = CryptoJS.AES.encrypt(e, c, &#123;        iv: d,        mode: CryptoJS.mode.CBC    &#125;);    return f.toString()&#125;function c(a, b, c) &#123;    var d, e;    return setMaxDigits(131),    d = new RSAKeyPair(b,&quot;&quot;,c),    e = encryptedString(d, a)&#125;function d(d, e, f, g) &#123;    var h = &#123;&#125;      , i = a(16);    return h.encText = b(d, g),    h.encText = b(h.encText, i),    h.encSecKey = c(i, e, f),    h&#125;function e(a, b, d, e) &#123;    var f = &#123;&#125;;    return f.encText = c(a + e, b, d),    f&#125;window.asrsea = d,window.ecnonasr = e\n\n这个加密流程调用了函数d，函数d的4个参数有3个是固定值。\n\n将上述流程转换成python代码。\nimport base64import jsonimport randomimport stringfrom Crypto.Cipher import AES# 核心加密类class NeteaseEncrypt:    &quot;&quot;&quot;    这个类封装了网易云音乐API请求加密所需的所有方法。    - 对应JS函数a: _create_random_key    - 对应JS函数b: _aes_encrypt    - 对应JS函数c: _rsa_encrypt    - 对应JS函数d (asrsea): encrypt    &quot;&quot;&quot;    def __init__(self):        # 这些是网易云音乐API中硬编码的、固定的值        self.MODULUS = &quot;00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7&quot;        self.NONCE = &quot;010001&quot;        self.PUBKEY = &quot;0CoJUm6Qyw8W8jud&quot;  # 预设的AES密钥 (JS函数d里的g)        self.IV = &quot;0102030405060708&quot;      # AES加密的初始化向量 (JS函数b里的d)    def _create_random_key(self, size: int) -&gt; str:        &quot;&quot;&quot;        对应JavaScript函数 a: 生成指定长度的随机字符串        &quot;&quot;&quot;        char_set = string.ascii_letters + string.digits        return &quot;&quot;.join(random.choices(char_set, k=size))    def _aes_encrypt(self, text: str, key: str) -&gt; str:        &quot;&quot;&quot;        对应JavaScript函数 b: 进行AES加密        &quot;&quot;&quot;        key_bytes = key.encode(&quot;utf-8&quot;)        iv_bytes = self.IV.encode(&quot;utf-8&quot;)        # PKCS7填充：确保数据长度是16字节的倍数        pad = 16 - len(text) % 16        text_padded = text + pad * chr(pad)        text_padded_bytes = text_padded.encode(&quot;utf-8&quot;)                # 创建AES加密器        cipher = AES.new(key_bytes, AES.MODE_CBC, iv_bytes)        # 加密并进行Base64编码        encrypted_bytes = cipher.encrypt(text_padded_bytes)        return base64.b64encode(encrypted_bytes).decode(&quot;utf-8&quot;)    def _rsa_encrypt(self, text: str) -&gt; str:        &quot;&quot;&quot;        对应JavaScript函数 c: 进行RSA加密        &quot;&quot;&quot;        # RSA加密过程的核心是模幂运算: (plaintext ^ exponent) % modulus                # 1. 将随机密钥反转并转为十六进制字节        text_bytes = text.encode(&#x27;utf-8&#x27;)        reversed_text_hex = text_bytes[::-1].hex()        # 2. 将十六进制字符串、公钥、模数都转换为大整数        plaintext_int = int(reversed_text_hex, 16)        pubkey_int = int(self.NONCE, 16)        modulus_int = int(self.MODULUS, 16)        # 3. 执行模幂运算        encrypted_int = pow(plaintext_int, pubkey_int, modulus_int)        # 4. 将结果转为十六进制字符串，并补足256位        return format(encrypted_int, &#x27;x&#x27;).zfill(256)    def encrypt(self, data: dict) -&gt; dict:        &quot;&quot;&quot;        对应JavaScript函数 d (asrsea): 执行完整的混合加密流程        &quot;&quot;&quot;        # 将Python字典转换为JSON字符串        data_json = json.dumps(data)                # 1. 生成16位随机密钥 (对应JS函数i = a(16))        random_key = self._create_random_key(16)        # 2. 第一次AES加密: 使用预设密钥(PUBKEY)加密业务数据        enc_text_part1 = self._aes_encrypt(data_json, self.PUBKEY)                # 3. 第二次AES加密: 使用随机密钥加密第一次的结果        enc_text = self._aes_encrypt(enc_text_part1, random_key)                # 4. RSA加密: 加密随机密钥        enc_sec_key = self._rsa_encrypt(random_key)                # 返回最终的两个加密参数        return &#123;            &quot;params&quot;: enc_text,            &quot;encSecKey&quot;: enc_sec_key        &#125;\n\n爬取评论跑脚本。\n\n发现不需要”csrf_token”也可以获得返回值。\n之后修改了一下代码，爬取结果变好看了。\n\n","tags":["爬虫 js逆向"]},{"title":"壁纸多线程+协程爬取(day2)","url":"/2025/07/08/%E5%A3%81%E7%BA%B8%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%8D%8F%E7%A8%8B%E7%88%AC%E5%8F%96-day2/","content":"协程简单来说，协程可以把同步操作变成异步操作。\n比方说，在写爬虫时，发送请求和等待回应会触发IO堵塞，如果是同步操作，线程就会一直等；而如果是异步操作，线程会切换到其它任务执行，而不是“闲等”。\n常见的requests.get是同步操作，如果想切换成异步，需要安装aiohttp。\npip install aiohttp\n\n除此之外，关于一些其它的io操作也可以用协程，如：读写文件。\npip install aiofile\n\n关于python的asyncio的实现，其实就是使用select、poll、epoll等机制，监控文件描述符的状态，避免线程堵塞。\n自Java21起，虚拟线程就是Java的协程实现。\n协程可以极大的提高爬取的速率。\n爬取壁纸我在网上找了一个壁纸网站。\nhttps://haowallpaper.com\n尝试用多线程、协程的方式，去爬取壁纸。\n\n单线程的爬取流程如下：\n\n解析每一页中，所有图片所在的子链接；\n获取子链接中，图片的下载链接；\n下载图片。\n\n在单线程的代码基础上把代码改成多线程，再将子链接分配给了具有4个线程的线程池，90张图片，花了将近160s。\n\n\n# 使用ThreadPoolExecutor来管理线程       with concurrent.futures.ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:           # 将下载任务提交给线程池           # executor.submit会立即返回一个future对象，代表这个未完成的操作           future_to_url = &#123;executor.submit(download_image, link): link for link in all_links&#125;                      for future in concurrent.futures.as_completed(future_to_url):               url = future_to_url[future]               try:                   result = future.result()               except Exception as exc:                   print(f&quot;链接 &#123;url&#125; 的任务执行时产生了一个异常: &#123;exc&#125;&quot;)\n\n之所以如此之慢，因为每个线程在下载一个图片时，线程会等待I&#x2F;O设备接收完图片，再进行下一步处理。（I&#x2F;O堵塞）。\n可以把协程视作I&#x2F;O多路复用的高级实现，每一个被async修饰的地方，相当于一个被监听描述符。\n在I&#x2F;O堵塞时，使用协程的方式编程，线程便可以去做别的事情。比如：在下载图片时，线程能够切换任务，去发送另一个图片下载请求，这样一来，在同一时间内，这些图片同时下载，便可以节约大量时间。\n在python中，要使用协程，在定义函数时、异步资源请求要使用async，而等待结果用await。\n下面的代码仅供参考。\nasyncio.gather：可以接收1个或多个对象，然后放入事件循环中运行。\nasync def download_image_async(session: aiohttp.ClientSession, sub_link: str):    &quot;&quot;&quot;    (异步) 工作协程，用于从给定的子链接下载单张图片。    Args:        session (aiohttp.ClientSession): aiohttp的会话对象.        sub_link (str): 壁纸详情页的相对路径.    &quot;&quot;&quot;    try:        filename = sub_link.split(&#x27;/&#x27;)[-1] + &quot;.jpg&quot;        filepath = os.path.join(OUTPUT_DIR, filename)        if os.path.exists(filepath):            return f&quot;已存在: &#123;filename&#125;&quot;        full_url = BASE_URL + sub_link                # 异步请求壁纸详情页        async with session.get(full_url, timeout=15) as response:            response.raise_for_status()            html_content = await response.text()        soup = BeautifulSoup(html_content, &#x27;html.parser&#x27;)        meta_tag = soup.find(&#x27;meta&#x27;, attrs=&#123;&quot;property&quot;: &quot;og:image&quot;&#125;)                if not meta_tag or not meta_tag.get(&#x27;content&#x27;):            return f&quot;未找到链接: &#123;sub_link&#125;&quot;        img_url = meta_tag.get(&#x27;content&#x27;)                # 异步请求并下载真实的图片文件        async with session.get(img_url, timeout=30) as img_response:            img_response.raise_for_status()            image_data = await img_response.read()        # 使用 aiofiles 异步写入文件        async with aiofiles.open(filepath, &quot;wb&quot;) as f:            await f.write(image_data)                return f&quot;成功: &#123;filename&#125;&quot;    except asyncio.TimeoutError:        return f&quot;超时错误: &#123;sub_link&#125;&quot;    except aiohttp.ClientError as e:        return f&quot;网络错误: &#123;sub_link&#125; - &#123;e&#125;&quot;    except Exception as e:        return f&quot;未知错误: &#123;sub_link&#125; - &#123;e&#125;&quot;async def download_batch_async(links_batch: List[str]):    &quot;&quot;&quot;    (异步) 创建一个 aiohttp 会话并并发执行一批下载任务。    &quot;&quot;&quot;    async with aiohttp.ClientSession(headers=HEADERS) as session:        tasks = [download_image_async(session, link) for link in links_batch]        results = await asyncio.gather(*tasks, return_exceptions=True)                # 打印结果用于调试        success_count = sum(1 for r in results if isinstance(r, str) and r.startswith(&quot;成功&quot;))        exist_count = sum(1 for r in results if isinstance(r, str) and r.startswith(&quot;已存在&quot;))        fail_count = len(results) - success_count - exist_count        print(f&quot;本批次处理完成 - 成功: &#123;success_count&#125;, 已存在: &#123;exist_count&#125;, 失败: &#123;fail_count&#125;&quot;)def run_thread_worker(links_batch: List[str]):    &quot;&quot;&quot;    (同步) 每个线程的入口函数。    它会创建一个新的 asyncio 事件循环来运行分配给它的那批下载任务。    &quot;&quot;&quot;    # 在新线程中创建并设置新的事件循环    loop = asyncio.new_event_loop()    asyncio.set_event_loop(loop)    # 运行异步任务直到完成    loop.run_until_complete(download_batch_async(links_batch))    loop.close()\n\n在加了协程后，任务会完成得非常快。\n\n\n我还做了个小实验，用“纯多线程”和“多线程 &amp; 单一协程”两种结构进行爬取，在这样的设置下，哪个下载速度会更快？（这里的后者含义是：每个线程只有一个协程）\n答案是后者，来看看大模型给出的理由。\n大致意思是：由于图片很小，本来一下子就能下载完，但普通的多线程下载涉及到I&#x2F;O堵塞，线程&#x2F;进程会被操作系统加入到堵塞线程队列中，然后操作系统会去执行其它的线程&#x2F;进程，等待I&#x2F;O设备的唤醒和操作系统的下一次调度；而在“多线程 &amp; 单一协程”的模式中，线程并没有被堵塞，而是会去执行事件循环，等到操作系统的通知——监听的事件是否完成，如果完成则立即处理。\n\n最后，看看壁纸！\n\n","tags":["多线程 协程 爬虫"]},{"title":"某网站视频爬取(day3)","url":"/2025/07/09/%E6%9F%90%E7%BD%91%E7%AB%99%E8%A7%86%E9%A2%91%E7%88%AC%E5%8F%96-day3/","content":"视频网站的工作原理用用户上传一个视频，并不会被一次性保存，而是经过下面这几步。\n**编码：**编码成不同质量级别、分辨率的多个版本。\n**分块：**每个版本的视频都会被分割成连续的小视频片段，通常只有几秒钟，这些小片段通常采用.ts格式，也就是MPEG传输流。\n**创建清单文件：**网站会创建一个“播放列表”文件作为索引，清单文件会告知视频播放器.ts数据块的顺序，一般使用的是M3U8文件作为清单文件。\n**通过 CDN 分发：**所有这些 .ts 数据块和 .m3u8 播放列表都会上传到内容分发网络 (CDN)，该网络的服务器遍布全球。这确保了无论用户身在何处，都能快速交付。\n抓取流程分析\n找到m3u8文件。\n通过m3u8下载所有ts文件。\n合并ts文件。\n\n爬取手工测试我选了一个视频网站进行爬取。——https://www.ssrfun.com\n\n先不写脚本，看看能不能找到.ts文件的下载链接。\n通过XHR过滤和抓包，能找到index.m3u8和mixed.m3u8。\n\n先下载index.m3u8，存放了mixed.m3u8的地址。\n\n再下载mixed.m3u8，这回可以找到视频的.ts文件了。\n\n\n下载其中一个.ts，得到的是视频的一个片段。\n\n脚本爬取分析一下脚本流程：\n\n获得视频链接，在返回的html中，存在m3u8文件的链接。\n获得m3u8文件（A），读取并下载另一个m3u8文件（B）。\n获得文件B，并解析获得ts文件的链接。\n下载并合并所有ts文件。\n\n没有反爬、没有风控，还是很简单的。\n\n之后使用ffmpeg进行合并。\n\n顺带补了一下asyncio.run和asyncio的事件循环的关系。\n在python3.7之前，需要手动创建事件循环并运行一个协程。\nimport asyncioasync def main():    print(&quot;Hello&quot;)    await asyncio.sleep(1)    print(&quot;World&quot;)# --- 手动挡操作 ---# 1. 获取（或创建）一个事件循环loop = asyncio.get_event_loop()try:    # 2. 命令循环运行一个任务直到它完成    loop.run_until_complete(main())finally:    # 3. 手动关闭事件循环    loop.close()\n\n而async.run相当于自动挡，封装好了步骤。\n\n它会自动创建一个新的事件循环。\n\n它会自动调用 loop.run_until_complete() 来运行你指定的协程。\n\n它会自动处理所有后续的清理工作。\n\n最后，它会自动关闭事件循环。\n\n\n","tags":["爬虫 视频爬取"]},{"title":"xhs去水印","url":"/2025/07/10/xhs%E5%8E%BB%E6%B0%B4%E5%8D%B0/","content":"跟着朋友的博客，复现了一下，找回了学安卓逆向的一点快乐&#x2F;(ㄒoㄒ)&#x2F;~~\nhttps://www.52pojie.cn/thread-2044329-1-1.html\n简单来说，为图片添加水印用到了下面几个api。\n1、Bitmap.compress：保存图片到磁盘时调用2、FileOutputStream.write：底层文件写3、Canvas.drawText：画布上写文字4、Canvas.drawBitmap：画布上绘制bitmap图像\n之后对这几个函数进行hook，将水印图片进行绕过。\n若要持久化，把脚本改写成xposed模块即可。（下图无水印了）\n\n","tags":["图片去水印"]}]